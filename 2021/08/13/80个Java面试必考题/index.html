<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="b站视频,Java,编程,面试题," />










<meta name="description" content="网址： https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1aM4y1T7PY?p&#x3D;3&amp;spm_id_from&#x3D;pageDriver">
<meta property="og:type" content="article">
<meta property="og:title" content="80个Java面试必考题">
<meta property="og:url" content="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/index.html">
<meta property="og:site_name" content="伶仃浩瀚">
<meta property="og:description" content="网址： https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1aM4y1T7PY?p&#x3D;3&amp;spm_id_from&#x3D;pageDriver">
<meta property="og:image" content="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/17.png">
<meta property="og:image" content="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/25-1.png">
<meta property="og:image" content="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/25-2.png">
<meta property="og:image" content="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/30.png">
<meta property="og:image" content="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/58.png">
<meta property="og:image" content="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/60.png">
<meta property="article:published_time" content="2021-08-13T06:52:39.000Z">
<meta property="article:modified_time" content="2021-08-14T13:05:29.919Z">
<meta property="article:author" content="潇 卟 甸">
<meta property="article:tag" content="b站视频">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/17.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/13/80个Java面试必考题/"/>







<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>

  <title>80个Java面试必考题 | 伶仃浩瀚</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://xbd224694.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">伶仃浩瀚</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="潇 卟 甸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/picture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伶仃浩瀚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">80个Java面试必考题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建时间" itemprop="dateCreated datePublished" datetime="2021-08-13T14:52:39+08:00">
                2021-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Monkey/" itemprop="url" rel="index">
                    <span itemprop="name">Monkey</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/" class="leancloud_visitors" data-flag-title="80个Java面试必考题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度 </span>
               
                 <span class="leancloud-visitors-count"></span>
	 <span> ℃ </span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  63 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>网址：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1aM4y1T7PY?p=3&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1aM4y1T7PY?p=3&amp;spm_id_from=pageDriver</a></p>
<a id="more"></a>
<h1 id="1、看以下代码回答问题（一）"><a class="header-anchor" href="#1、看以下代码回答问题（一）">¶</a>1、看以下代码回答问题（一）</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        <span class="comment">//在这中间可以添加N行代码，但必须保证s引用的指向不变，最终将输出变成abcd</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这中间可以添加N行代码，但必须保证s引用的指向不变，最终将输出变成abcd</span></span><br><span class="line">        Field value = s.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        value.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        value.set(s,<span class="string">"abcd"</span>.toCharArray());</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2、看以下代码回答问题（二）"><a class="header-anchor" href="#2、看以下代码回答问题（二）">¶</a>2、看以下代码回答问题（二）</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">//s1 == s2?</span></span><br><span class="line">        String s3 = s1.intern();</span><br><span class="line">        <span class="comment">//s2 == s3?</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>答案：</p>
<pre><code>1. s1 == s2 为false
2. s2 == s3 为true
</code></pre>
<p>String对象的intern方法，首先会检查字符串常量池中是否存在“abc”，如果存在则返回该字符串引用，如果不存在，则把“abc”添加到字符串常量池中。并返回该字符串的引用。</p>
<h1 id="3、看以下代码回答问题（三）"><a class="header-anchor" href="#3、看以下代码回答问题（三）">¶</a>3、看以下代码回答问题（三）</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// i1 == i2?</span></span><br><span class="line"></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line">        <span class="comment">// i1 == i2?</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>答案：</p>
<p>​	1、 i1 == i2为true</p>
<p>​	2、 i3 == i4为false</p>
<p>在Integer类中，存在一个静态内部类IntegerCache，该类中存在一个Integer cache[]，并且存在一个static块，会在加载类的时候执行，会将-128至127这些数字提前生成Integer对象，并缓存在cache数组中，当我们在定义Integer数字时，会调用Integer的valueOf方法，valueOf方法会判断所定义的数字是否在-128至127之间，如果存在则直接从cache数组中获取Integer对象，如果超过，则生成一个新的Integer对象。</p>
<h1 id="4、String、StringBuffer、StringBuilder的区别"><a class="header-anchor" href="#4、String、StringBuffer、StringBuilder的区别">¶</a>4、String、StringBuffer、StringBuilder的区别</h1>
<p>1、String是不可变的，如果尝试去修改，会新生成一个字符串对象，StringBuffer和StringBuilder是可变的</p>
<p>2、StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更高</p>
<h1 id="5、ArrayList和LinkedList有哪些区别"><a class="header-anchor" href="#5、ArrayList和LinkedList有哪些区别">¶</a>5、ArrayList和LinkedList有哪些区别</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 数组</span></span><br><span class="line">        arrayList.add(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 链表</span></span><br><span class="line">        linkedList.add(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1、首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的</p>
<p>2、由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同</p>
<p>3、另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做队列来使用</p>
<h1 id="6、CopyOnWriteArrayList的底层原理是怎样的"><a class="header-anchor" href="#6、CopyOnWriteArrayList的底层原理是怎样的">¶</a>6、CopyOnWriteArrayList的底层原理是怎样的</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">"zhouwu"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"xbd"</span>);</span><br><span class="line"></span><br><span class="line">        CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"zhouwu"</span>);</span><br><span class="line">        String s = list.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1、首先CopyOnWriteArrayList内部也是用数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上进行</p>
<p>2、并且，写操作会加锁，防止出现并发写入丢失数据的问题</p>
<p>3、写操作结束之后会把原数组指向新数组</p>
<p>4、CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很高的场景。</p>
<h1 id="7、HashMap的扩容机制原理"><a class="header-anchor" href="#7、HashMap的扩容机制原理">¶</a>7、HashMap的扩容机制原理</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">"xbd"</span>,<span class="string">"zy"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1.7版本</p>
<p>​	1、先生成新数组</p>
<p>​	2、遍历老数组中的每个位置上的链表上的每个元素</p>
<p>​	3、取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标</p>
<p>​	4、将元素添加到新数组中去</p>
<p>​	5、所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</p>
<p>1.8版本</p>
<p>​	1、先生成新数组</p>
<p>​	2、遍历老数组中的每个位置上的链表或红黑树</p>
<p>​	3、如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去</p>
<p>​	4、如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置</p>
<p>​			a、统计每个下标位置的元素个数</p>
<p>​			b、如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置</p>
<p>​			c、如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置</p>
<p>​	5、所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</p>
<h1 id="8、ConcurrentHashMap的扩容机制"><a class="header-anchor" href="#8、ConcurrentHashMap的扩容机制">¶</a>8、ConcurrentHashMap的扩容机制</h1>
<p>1.7版本</p>
<p>​	1、1.7版本的ConcurrentHashMap是基于Segment分段实现的</p>
<p>​	2、每个Segment相当于一个小型的HashMap</p>
<p>​	3、每个Segment内部会进行扩容，和HashMap的扩容逻辑类似</p>
<p>​	4、先生成新的数组，然后转移元素到新数组中</p>
<p>​	5、扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值</p>
<p>1.8版本</p>
<p>​	1、1.8版本的ConcurrentHashMap不再基于Segment实现</p>
<p>​	2、当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容，那么该线程一起进行扩容</p>
<p>​	3、如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容</p>
<p>​	4、ConcurrentHashMap是支持多个线程同时扩容的</p>
<p>​	5、扩容之前也先生成一个新的数组</p>
<p>​	6、在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作</p>
<h1 id="9、ThreadLocal的底层原理"><a class="header-anchor" href="#9、ThreadLocal的底层原理">¶</a>9、ThreadLocal的底层原理</h1>
<p>1.ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据<br>
2.ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象(注意不是ThreadLocal对象)中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值<br>
3.如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key ， value，也就是Enty对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清楚Entry对象<br>
4.ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接)</p>
<h1 id="10、如何理解volatile关键字"><a class="header-anchor" href="#10、如何理解volatile关键字">¶</a>10、如何理解volatile关键字</h1>
<p>在并发领域中，存在三大特性:原子性、有序性、可见性。volatile关键字用来修饰对象的属性，在并发环境下可以保证这个属性的可见性，对于加了volatile关键字的属性，在对这个属性进行修改时，会直接将CPU高级缓存中的数据写回到主内存，对这个变量的读取也会直接从主内存中读取，从而保证了可见性，底层是通过操作系统的内存屏障来实现的，由于使用了内存屏障，所以会禁止指令重排，所以同时也就保证了有序性，在很多并发场景下，如果用好volatile关键字可以很好的提高执行效率。</p>
<h1 id="11、ReentrantLock中的公平锁和非公平锁的底层实现"><a class="header-anchor" href="#11、ReentrantLock中的公平锁和非公平锁的底层实现">¶</a>11、ReentrantLock中的公平锁和非公平锁的底层实现</h1>
<p>首先不管是公平锁和非公平锁，它们的底层实现都会使用AQS来进行排队，它们的区别在于:线程在使用lock()方法加锁时，如果是公平锁，会先检查AQs队列中是否存在线程在排队，如果有线程在排队，则当前线程也进行排队，如果是非公平锁，则不会去检查是否有线程在排队，而是直接竞争锁。</p>
<p>不管是公平锁还是非公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非平锁只是体现在了线程加锁阶段，而没有体现在线程被唤醒阶段。</p>
<p>另外，ReentrantLock是可重入锁，不管是公平锁还是非公平锁都是可重入的。</p>
<h1 id="12、ReentrantLock中tryLock-和lock-方法的区别"><a class="header-anchor" href="#12、ReentrantLock中tryLock-和lock-方法的区别">¶</a>12、ReentrantLock中tryLock()和lock()方法的区别</h1>
<ol>
<li>tryLock()表示尝试加锁，可能加到，也可能加不到，该方法不会阻塞线程，如果加到锁则返回true，没有加到则返回false</li>
<li>lock()表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值</li>
</ol>
<h1 id="13、CountDownLatch和Semaphore的区别和底层原理"><a class="header-anchor" href="#13、CountDownLatch和Semaphore的区别和底层原理">¶</a>13、CountDownLatch和Semaphore的区别和底层原理</h1>
<p>CountDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用CountDownLatch的await()将会阻塞，其他线程可以调用CountDownLatch的countDown()方法来对CountDownLatch中的数字减一，当数字被减成0后，所有await的线程都将被唤醒。<br>
对应的底层原理就是，调用await()方法的线程会利用AQS排队，一旦数字被减为0，则会将AQS中排队的线程依次唤醒。</p>
<p>Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过acquire()来获取许可，如果没有许可可用则线程阻塞，并通过AQS来排队，可以通过release()方法来释放许可，当某个线程释放了某个许可后，会从AQ5中正在排队的第一个线程开始依次唤醒，直到没有空闲许可。</p>
<h1 id="14、Sychronized的偏向锁、轻量级锁、重量级锁"><a class="header-anchor" href="#14、Sychronized的偏向锁、轻量级锁、重量级锁">¶</a>14、Sychronized的偏向锁、轻量级锁、重量级锁</h1>
<p>1.偏向锁:在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接获取到了<br>
⒉轻量级锁:由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争锁，偏向锁就会升级为轻量级锁,之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程<br>
3.如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞<br>
4.自旋锁:自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。</p>
<h1 id="15、Sychronized和ReentrantLock的区别"><a class="header-anchor" href="#15、Sychronized和ReentrantLock的区别">¶</a>15、Sychronized和ReentrantLock的区别</h1>
<ol>
<li>
<p>sychronized是一个关键字，ReentrantLock是一个类</p>
</li>
<li>
<p>sychronized会自动的加锁与释放锁，ReentrantLock需要程序员手动加锁与释放锁</p>
</li>
<li>
<p>sychronized的底层是JVM层面的锁，ReentrantLock是API层面的锁</p>
</li>
<li>
<p>sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁</p>
</li>
<li>
<p>sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识来标识锁的状态</p>
</li>
<li>
<p>sychronized底层有一个锁升级的过程</p>
</li>
</ol>
<h1 id="16、线程池的底层工作原理"><a class="header-anchor" href="#16、线程池的底层工作原理">¶</a>16、线程池的底层工作原理</h1>
<p>线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时:<br>
1.如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</p>
<p>⒉如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。</p>
<p>3.如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</p>
<p>4.如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。</p>
<p>5.当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</p>
<h1 id="17、JVM中哪些是线程共享区"><a class="header-anchor" href="#17、JVM中哪些是线程共享区">¶</a>17、JVM中哪些是线程共享区</h1>
<p>堆区和方法区是所有线程共享的，栈、本地方法栈、程序计数器是每个线程独有的</p>
<p><img src="/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/17.png" alt></p>
<h1 id="18、JVM中哪些可以作为gc-root"><a class="header-anchor" href="#18、JVM中哪些可以作为gc-root">¶</a>18、JVM中哪些可以作为gc root</h1>
<p>什么是gc root，JVM在进行垃圾回收时，需要找到“垃圾”对象，也就是没有被引用的对象，但是直接找“垃圾”对象是比较耗时的，所以反过来，先找“非垃圾”对象，也就是正常对象，那么就需要从某些“根”开始去找，根据这些“根”的引用路径找到正常对象，而这些“根”有一个特征，就是它只会引用其他对象，而不会被其他对象引用，例如:栈中的本地变量、方法区中的静态变量、本地方法栈中的变量、正在运行的线程等可以作为gc root。</p>
<h1 id="19、你们项目如何排查JVM问题"><a class="header-anchor" href="#19、你们项目如何排查JVM问题">¶</a>19、你们项目如何排查JVM问题</h1>
<p>对于还在正常运行的系统:<br>
1.可以使用jmap来查看JⅣM中各个区域的使用情况<br>
2.可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁<br>
3.可以通过jstat命令来查看垃圾回收的情况，特别是fullgc，如果发现fullgc比较频繁，那么就得进行调优了</p>
<p>4.通过各个命令的结果，或者jvisualvm等工具来进行分析<br>
5.首先，初步猜测频繁发送fullgc的原因，如果频繁发生fuliac但是又一直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入到老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大,导致年轻代放不下，直接进入到了老年代，尝试加大年轻代的大小，如果改完之后，fullgc减少，则证明修改有效<br>
6.同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存</p>
<p>对于已经发生了OOM的系统:<br>
1.一般生产系统中都会设置当系统发生了OOM时，生成当时的dump文件(-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base)<br>
2我们可以利用jsisualvm等工具来分析dump文件<br>
3.根据dump文件找到异常的实例对象，和异常的线程（占用CPU高)，定位到具体的代码</p>
<p>4.然后再进行详细的分析和调试</p>
<p>总之，调优不是一蹴而就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题</p>
<h1 id="20、说说类加载器双亲委派模型"><a class="header-anchor" href="#20、说说类加载器双亲委派模型">¶</a>20、说说类加载器双亲委派模型</h1>
<p>JVM中存在三个默认的类加载器:|<br>
1.BootstrapClassLoader<br>
2.ExtClassLoader<br>
3.AppClassLoader</p>
<p>AppClassLoader的父加载器是ExtClassLoader，ExtClassLoader的父加载器是BootstrapClassLoader。</p>
<p>NVM在加载一个类时，会调用AppClassloader的loadClass方法来加载这个类，不过在这个方法中，会先使用ExtClassLoader的loadClass方法来加载类，同样ExtClassloader的oadClass方法中会先使用BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功，如果BootstrapClassLoader没有加载到，那么ExtClassLoader就会自己尝试加载该类，如果没有加载到，那么则会由AppClassLoader来加载这个类</p>
<p>所以，双亲委派指得是，VM在加载类时，会委派给Ext和Bootstrap进行加载，如果没加载到才由自己进行加载。</p>
<h1 id="21、Tomcat中为什么要使用自定义类加载器"><a class="header-anchor" href="#21、Tomcat中为什么要使用自定义类加载器">¶</a>21、Tomcat中为什么要使用自定义类加载器</h1>
<p>一个Tomcat中可以部署多个应用，而每个应用中都存在很多类，并且各个应用中的类是独立的，全类名是可以相同的，比如一个订单系统中可能存在comzhouyuUser类，一个库存系统中可能也存在comzhouyuUser类，一个Tomcat，不管内部部署了多少应用，Tomcat启动之后就是一个ava进程，也就是一个NM，所以如果Tomcat中只存在一个类加载器，比如默认的AppClassLoader，那么就只能加载一个comzhouyuUser类，这是有问题的，而在Tomcat中，会为部署的每个应用都生成一个类加载器实例，名字叫做WebAppClassloader，这样Tomcat中每个应用就可以使用自己的类加载器去加载自己的类，从而达到应用之间的类隔离，不出现冲突。另外Tomcat还利用自定义加载器实现了热加载功能。</p>
<p>WebAppClassLoader1类加载实例+A类名修改时间重新的去创建一个WebAppClassLoader1</p>
<h1 id="22、Tomcat如何进行优化"><a class="header-anchor" href="#22、Tomcat如何进行优化">¶</a>22、Tomcat如何进行优化?</h1>
<p>对于Tomcat调优，可以从两个方面来进行调整:内存和线程。<br>
首先启动Tomcat，实际上就是启动了一个JVM，所以可以按JVM调优的方式来进行调整，从而达到Tomcat优化的目的。另外Tomcat中设计了一些缓存区，比如appReadBufSize、bufferPoolSize等缓存区来提高吞吐量。<br>
还可以调整Tomcat的线程，比如调整minSpareThreads参数来改变Tomcat空闲时的线程数，调整maxThreads参数来设置Tomcat处理连接的最大线程数.并且还可以调整IO模型，比如使用NIO、APR这种相比于BIO更加高效的IO模型。</p>
<h1 id="23、浏览器发出一个请求到收到响应经历了哪些步骤"><a class="header-anchor" href="#23、浏览器发出一个请求到收到响应经历了哪些步骤">¶</a>23、浏览器发出一个请求到收到响应经历了哪些步骤?</h1>
<p>1.浏览器解析用户输入的URL，生成一个HTTP格式的请求<br>
⒉先根据URL域名从本地hosts文件查找是否有映射P，如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址</p>
<p>3.浏览器通过操作系统将请求通过四层网络协议发送出去<br>
4.途中可能会经过各种路由器、交换机，最终到达服务器<br>
5.服务器收到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了</p>
<p>6.tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet<br>
7.然后servlet来处理这个请求，如果是SpringMVC中的DispatcherServlet，那么则会找到对应的Controller中的方法，并执行该方法得到结果</p>
<p>8.Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过网络发送给浏览器所在的服务器<br>
9.浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染</p>
<h1 id="24、跨域请求是什么-有什么问题-怎么解决"><a class="header-anchor" href="#24、跨域请求是什么-有什么问题-怎么解决">¶</a>24、跨域请求是什么?有什么问题?怎么解决?</h1>
<p>跨域是指浏览器在发起网络请求时，会检查该请求所对应的协议、域名、端口和当前网页是否一致，如果不一致则浏览器会进行限制，比如在www.baidu.com的某个网页中，如果使用ajax去访问www.jd.com是不行的，但是如果是img、iframe、script等标签的src属性去访问则是可以的<br>
之<br>
所以浏览器要做这层限制，是为了用户信息安全。但是如果开发者想要绕过这层限制也是可以的:<br>
1.response添加header，比如resp.setHeader(“Access-Control-Allow-Origin”,&quot;*&quot;)表示可以访问所有网站，不受是否同源的限制</p>
<p>2.jsonp的方式，该技术底层就是基于script标签来实现的，因为script标签是可以跨域的<br>
3.后台自己控制，先访问同域名下的接口，然后在接口中再去使用HTTPClient等工具去调用目标接口</p>
<p>4.网关，和第三种方式类似，都是交给后台服务来进行跨域访问</p>
<h1 id="25、Spring中的Bean创建的生命周期有哪些步骤"><a class="header-anchor" href="#25、Spring中的Bean创建的生命周期有哪些步骤">¶</a>25、Spring中的Bean创建的生命周期有哪些步骤</h1>
<p>Spring中一个Bean的创建大概分为以下几个步骤:<br>
1.推断构造方法<br>
2.实例化<br>
3.填充属性，也就是依赖注入</p>
<p>4.处理Aware回调<br>
5.初始化前，处理@PostConstruct注解</p>
<p>6.初始化，处理lnitializingBean接口</p>
<p>7.初始化后，进行AOP</p>
<p>当然其实真正的步骤更加细致，可以看下面的流程图</p>
<p><img src="/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/25-1.png" alt="25-1"></p>
<p><img src="/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/25-2.png" alt></p>
<h1 id="26、Spring中Bean是线程安全的吗"><a class="header-anchor" href="#26、Spring中Bean是线程安全的吗">¶</a>26、Spring中Bean是线程安全的吗</h1>
<p>Spring本身并没有针对Bean做线程安全的处理，所以:</p>
<p>1.如果Bean是无状态的，那么Bean则是线程安全的</p>
<p>⒉如果Bean是有状态的，那么Bean则不是线程安全的</p>
<p>另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。</p>
<h1 id="27、ApplicationContext和BeanFactory有什么区别"><a class="header-anchor" href="#27、ApplicationContext和BeanFactory有什么区别">¶</a>27、ApplicationContext和BeanFactory有什么区别</h1>
<p>BeanFactory是Spring中非常核心的组件，表示Bean工厂，可以生成Bean，维护Bean，而ApplicationContext继承了BeanFactory ，所以ApplicationContext拥有BeanFactory所有的特点，也是一个Bean工厂，但是ApplicationContext除开继承了BeanFactory之外，还继承了诸如<br>
EnvironmentCapable、MessageSource、ApplicationEventPublisher等接口，从而ApplicationContext还有获取系统环境变量、国际化、事件发布等功能，这是BeanFactory所不具备的</p>
<h1 id="28、Spring中的事务是如何实现的"><a class="header-anchor" href="#28、Spring中的事务是如何实现的">¶</a>28、Spring中的事务是如何实现的</h1>
<p>1.Spring事务底层是基于数据库事务和AOP机制的<br>
⒉首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean</p>
<p>3.当调用代理对象的方法时，会先判断该方法上是否加了@Transactional注解<br>
4.如果加了，那么则利用事务管理器创建一个数据库连接<br>
5.并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步</p>
<p>6.然后执行当前方法，方法中会执行sql<br>
7.执行完当前方法后，如果没有出现异常就直接提交事务<br>
8.如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务</p>
<p>9.Spring事务的隔离级别对应的就是数据库的隔离级别<br>
10.Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的<br>
11.Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建个数据库连接，在此新数据库连接上执行sql</p>
<h1 id="29、Spring中什么时候-Transactional会失效"><a class="header-anchor" href="#29、Spring中什么时候-Transactional会失效">¶</a>29、Spring中什么时候@Transactional会失效</h1>
<p>因为Spring事务是基于代理来实现的，所以某个加了@ Transactional的方法只有是被代理对象调用时，那么这个注解才会生效，所以如果是被代理对象来调用这个方法，那么@Transactional是不会失效的。</p>
<p>同时如果某个方法是private的，那么@Transactional也会失效，因为底层cglib是基于父子类来实现的，子类是不能重载父类的private方法的，所以无法很好的利用代理，也会导致@Transactianal失效</p>
<h1 id="30、Spring容器启动流程是怎样的"><a class="header-anchor" href="#30、Spring容器启动流程是怎样的">¶</a>30、Spring容器启动流程是怎样的</h1>
<p>1.在创建Spring容器，也就是启动Spring时:<br>
⒉首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中<br>
3然后筛选出非懒加载的单例BeanDefition进行创建Bean，对于多例Bean不需要在启动过程中去进行创建，对于多例Bean会在每次获取Bean时利用BeanDefinition去创建<br>
4.利用BeanDefinition创建Bean就是Bean的创建生命周期，这期间包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发生在初始化后这一步骤中<br>
5.单例Bean创建完了之后，Spring会发布一个容器启动事件<br>
6.Spring启动结束<br>
7.在源码中会更复杂，比如源码中会提供一些模板方法，让子类来实现，比如源码中还涉及到一些BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过BenaFactoryPostProcessor来实现的，依赖注入就是通过BeanPostprocessor来实现的<br>
8.在Spring启动过程中还会去处理@Import等注解</p>
<h1 id="31、Spring用到了哪些设计模式"><a class="header-anchor" href="#31、Spring用到了哪些设计模式">¶</a>31、Spring用到了哪些设计模式</h1>
<p><img src="/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/30.png" alt></p>
<h1 id="32、SpringMVC的底层工作流程"><a class="header-anchor" href="#32、SpringMVC的底层工作流程">¶</a>32、SpringMVC的底层工作流程</h1>
<p>1.用户发送请求至前端控制器DispatcherServlet。<br>
2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>
3.处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。<br>
4.DispatcherServlet 调用HandlerAdapter处理器适配器。<br>
5.HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)</p>
<p>6.Controller执行完成返回ModelAndView。<br>
7.HandlerAdapter将controller 执行结果ModelAndView返回给 DispatcherServlet。</p>
<p>8.DispatcherServlet将 ModelAndView传给ViewReslover视图解析器。<br>
9.ViewReslover解析后返回具体View。<br>
10.DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)。</p>
<p>11.DispatcherServlet响应用户。</p>
<h1 id="33、SpringBoot中常用注解及其底层实现"><a class="header-anchor" href="#33、SpringBoot中常用注解及其底层实现">¶</a>33、SpringBoot中常用注解及其底层实现</h1>
<p>1.@SpringBootApplication注解:这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，这三个注解是:<br>
a.@SpringBootConfiguration:这个注解实际就是一个@Configuration，表示启动类也是一个配置类<br>
b.@EnableAutoConfiguration:向Spring容器中导入了一个Selector，用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean<br>
c.@ComponentScan:标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录<br>
2.@Bean注解:用来定义Bean，类似于XML中的&lt;bean&gt;标签，Spring在启动时，会对加了@Bean注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象<br>
3.@Controller、@Service、@ResponseBody、@Autowired都可以说</p>
<h1 id="34、SpringBoot是如何启动Tomcat的"><a class="header-anchor" href="#34、SpringBoot是如何启动Tomcat的">¶</a>34、SpringBoot是如何启动Tomcat的</h1>
<p>1.首先，SpringBoot在启动时会先创建一个Spring容器<br>
⒉在创建Spring容器过程中，会利用@ConditionalOnClass技术来判断当前classpath中是否存在Tomcat依赖，如果存在则会生成一个启动Tomcat的Bean<br>
3.Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端口等，然后启动Tomcat</p>
<h1 id="35、SpringBoot中配置文件的加载顺序是怎样的"><a class="header-anchor" href="#35、SpringBoot中配置文件的加载顺序是怎样的">¶</a>35、SpringBoot中配置文件的加载顺序是怎样的?</h1>
<p>优先级从高到低，高优先级的配置覆盖低优先级的配置，所有配置会形成互补配置。</p>
<p>1.命令行参数。所有的配置都可以在命令行上进行指定;<br>
2.Java系统属性(System.getProperties0) ;<br>
3.操作系统环境变量;<br>
4.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件<br>
5.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件再来加载不带profile</p>
<p>6.jar包外部的application.properties或application.yml(不带spring.profile)配置文件<br>
7.jar包内部的application.properties或application.yml(不带spring.profile)配置文件8.@Configuration注解类上的@PropertySource</p>
<h1 id="36、Mybatis存在哪些优点和缺点优点"><a class="header-anchor" href="#36、Mybatis存在哪些优点和缺点优点">¶</a>36、Mybatis存在哪些优点和缺点优点:</h1>
<p>1.基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL单独写，解除sql与程序代码的耦合，便于统一管理。<br>
2.与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接;<br>
3.很好的与各种数据库兼容（因为MyBatis 使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持)。</p>
<p>4.能够与Spring 很好的集成;<br>
5.提供映射标签，支持对象与数据库的ORM字段关系映射;提供对象关系映射标签，支持对象关系组件维护。</p>
<p>缺点:<br>
1.SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>2.SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</p>
<h1 id="37、Mybatis中-和-的区别是什么"><a class="header-anchor" href="#37、Mybatis中-和-的区别是什么">¶</a>37、Mybatis中#{}和${}的区别是什么?</h1>
<p>1.#{}是预编译处理、是占位符，${}是字符串替换、是拼接符<br>
2.Mybatis在处理#{}时，会将sql中的#却替换为?号，调用PreparedStatement来赋值</p>
<p>3.Mybatis在处理${}时，就是把$替换成变量的值，调用Statement来赋值<br>
4.使用#{}可以有效的防止SQL注入，提高系统安全性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--假设</span><br><span class="line">name&#x3D;&quot;zhouyu&quot;</span><br><span class="line">password&#x3D;&quot;1 or 1&#x3D;1&quot;</span><br><span class="line"></span><br><span class="line">select * from user where name &#x3D; #&#123;name&#125; and password &#x3D; #&#123;password&#125;将转为</span><br><span class="line">select * from user where name &#x3D; &#39;zhouyu&#39; and password &#x3D; &#39;1 or 1&#x3D;1&#39;</span><br><span class="line">select * from user where name &#x3D; $&#123;name&#125; and password &#x3D; $&#123;password&#125;将转为</span><br><span class="line">select * from user where name &#x3D; zhouyu and password &#x3D; 1 or 1&#x3D;1</span><br></pre></td></tr></table></figure>
<h1 id="38、什么是CAP理论"><a class="header-anchor" href="#38、什么是CAP理论">¶</a>38、什么是CAP理论</h1>
<p>CAP理论是分布式领域中非常重要的一个指导理论，c (Consistency)表示强一致性，A(Availablity)表示可用性，P(Parition Tolerance)表示分区容错性，CAP理论指出在目前的硬件条件下，一个分布式系统是必须要保证分区容错性的，而在这个前提下，分布式系统要么保证CP，要么保证AP，无法同时保证CAP。</p>
<p>分区容错性表示，一个系统虽然是分布式的，但是对外看上去应该是一个整体，不能由于分布式系统内部的某个结点挂点，或网络出现了故障而导致系统对外出现异常。所以，对于分布式系统而言是一定要保证分区容错性的。</p>
<p>强一致性表示，一个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提供服务的，不然就会造成数据不一致，所以强一致性和可用性是不能同时满足的。</p>
<p>可用性表示，一个分布式系统对外要保证可用。</p>
<h1 id="39、什么是BASE理论"><a class="header-anchor" href="#39、什么是BASE理论">¶</a>39、什么是BASE理论</h1>
<p>由于不能同时满足CAP，所以出现了BASE理论:<br>
<a href="http://1.BA" target="_blank" rel="noopener">1.BA</a>: Basically Availble，表示基本可用，表示可以允许一定程度的不可用，比如由于系统故障，请求时间变长，或者由于系统故障导致部分非核心功能不可用，都是允许的<br>
2.S: Soft state:表示分布式系统可以处于一种中间状态，比如数据正在同步<br>
3.E: Eventually consistent，表示最终一致性，不要求分布式系统数据实时达到一致，允许在经过一段时间后再达到一致，在达到一致过程中，系统也是可用的</p>
<h1 id="40、什么是RPC"><a class="header-anchor" href="#40、什么是RPC">¶</a>40、什么是RPC</h1>
<p>RPC，表示远程过程调用，对于Java这种面试对象语言，也可以理解为远程方法调用，RPC调用和HTTP调用是有区别的，RPC表示的是一种调用远程方法的方式，可以使用HTTP协议、或直接基于TCP协议来实现RPC，在Java中，我们可以通过直接使用某个服务接口的代理对象来执行方法，而底层则通过构造HTTP请求来调用远端的方法，所以，有一种说法是RPC协议是HTTP协议之上的一种协议，也是可以理解的。</p>
<h1 id="41、分布式ID是什么-有哪些解决方案"><a class="header-anchor" href="#41、分布式ID是什么-有哪些解决方案">¶</a>41、分布式ID是什么?有哪些解决方案?</h1>
<p>在开发中，我们通常会需要一个唯一ID来标识数据，如果是单体架构，我们可以通过数据库的主键，或直接在内存中维护一个自增数字来作为ID都是可以的，但对于一个分布式系统，就会有可能会出现ID冲突，此时有以下解决方案:</p>
<ol>
<li>uuid，这种方案复杂度最低，但是会影响存储空间和性能</li>
<li>利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较之uuid更短，但是受到单机数据库性能的限制，并发量大的时候,此方案也不是最优方案</li>
<li>利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库(mysql)相比，性能有所提高，可以适当选用</li>
<li>雪花算法，一切问题如果能直接用算法解决，那就是最合适的，利用雪花算法也可以生成分布式ID，底层原理就是通过某台机器在某一毫秒内对某一个数字自增，这种方案也能保证分布式架构中的系统id唯一，但是只能保证趋势递增。业界存在tinyid、leaf等开源中间件实现了雪花算法.</li>
</ol>
<h1 id="42、分布式锁的使用场景是什么-有哪些实现方案"><a class="header-anchor" href="#42、分布式锁的使用场景是什么-有哪些实现方案">¶</a>42、分布式锁的使用场景是什么?有哪些实现方案?</h1>
<p>在单体架构中，多个线程都是属于同一个进程的，所以在线程并发执行时，遇到资源竞争时，可以利用ReentrantLock、synchronized等技术来作为锁，来控制共享资源的使用。</p>
<p>而在分布式架构中，多个线程是可能处于不同进程中的，而这些线程并发执行遇到资源竞争时，利用ReentrantLock、 synchronized等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思就是，需要一个分布式锁生成器，分布式系统中的应用程序都可以来使用这个生成器所提供的锁，从而达到多个进程中的线程使用同一把锁。|</p>
<p>目前主流的分布式锁的实现方案有两种:</p>
<p>1.zookeeper:利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱</p>
<p>2.redis:利用redis的setnx、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是高可用，因为redis保证的是AP，所以由它实现的分布式锁可能不可靠，不稳定(一旦redis中的数据出现了不一致)，可能会出现多个客户端同时加到锁的情况</p>
<h1 id="43、什么是分布式事务-有哪些实现方案"><a class="header-anchor" href="#43、什么是分布式事务-有哪些实现方案">¶</a>43、什么是分布式事务?有哪些实现方案?</h1>
<p>在分布式系统中，一次业务处理可能需要多个应用来实现，比如用户发送一次下单请求，就涉及到订单系统创建订单、库存系统减库存，而对于一次下单，订单创建与减库存应该是要同时成功或同时失败的，但在分布式系统中，如果不做处理，就很有可能出现订单创建成功，但是减库存失败，那么解决这类问题，就需要用到分布式事务。常用解决方案有:</p>
<p>1.本地消息表:创建订单时，将减库存消息加入在本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统，如果调用成功则修改本地消息状态为成功，如果调用库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调用库存系统</p>
<p>2消息队列:目前RocketMQ中支持事务消息，它的工作原理是:<br>
a.生产者订单系统先发送一条half消息到Broker,，half消息对消费者而言是不可见的</p>
<p>​	b.再创建订单，根据创建订单成功与否，向Broker发送commit或rollback<br>
​	c并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功<br>
​	d.一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束</p>
<p>​	e.如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理</p>
<p>3.Seata:阿里开源的分布式事务框架，支持AT、TCC等多种模式，底层都是基于两阶段提交理论来实现的</p>
<h1 id="44、什么是ZAB协议"><a class="header-anchor" href="#44、什么是ZAB协议">¶</a>44、什么是ZAB协议</h1>
<p>ZAB协议是Zookeeper用来实现一致性的原子广播协议，该协议描述了Zookeeper是如何实现一致性的，分为三个阶段:</p>
<p>1.领导者选举阶段:从Zookeeper集群中选出一个节点作为Leader，所有的写请求都会由Leader节点来处理<br>
⒉数据同步阶段:集群中所有节点中的数据要和Leader节点保持一致，如果不一致则要进行同步<br>
3.请求广播阶段:当Leader节点接收到写请求时，会利用两阶段提交来广播该写请求，使得写请求像事务一样在其他节点上执行，达到节点上的数据实时一致</p>
<p>但值得注意的是，Zookeeper只是尽量的在达到强一致性，实际上仍然只是最终一致性的。</p>
<h1 id="45、为什么Zookeeper可以用来作为注册中心"><a class="header-anchor" href="#45、为什么Zookeeper可以用来作为注册中心">¶</a>45、为什么Zookeeper可以用来作为注册中心</h1>
<p>可以利用Zookeeper的临时节点和watch机制来实现注册中心的自动注册和发现，另外Zookeeper中的数据都是存在内存中的，并且Zookeeper底层采用了nio，多线程模型，所以Zookeeper的性能也是比较高的，所以可以用来作为注册中心，但是如果考虑到注册中心应该是注册可用性的话，那么Zookeeper则不太合适，因为Zookeeper是CP的，它注重的是一致性，所以集群数据不一致时，集群将不可用，所以用Redis、Eureka、Nacos来作为注册中心将更合适。</p>
<h1 id="46、Zookeeper中的领导者选举的流程是怎样的"><a class="header-anchor" href="#46、Zookeeper中的领导者选举的流程是怎样的">¶</a>46、Zookeeper中的领导者选举的流程是怎样的?</h1>
<p>对于Zookeeper集群，整个集群需要从集群节点中选出一个节点作为Leader，大体流程如下:</p>
<p>1.集群中各个节点首先都是观望状态(LOOKING)，一开始都会投票给自己，认为自己比较适合作为leader<br>
2．然后相互交互投票，每个节点会收到其他节点发过来的选票，然后pk，先比较zxid，zxid大者获胜，zxid如果相等则比较myid,myid大者获胜<br>
3.一个节点收到其他节点发过来的选票，经过PK后，如果PK输了，则改票，此节点就会投给zid或myid更大的节点，并将选票放入自己的投票箱中，并将新的选票发送给其他节点<br>
4．如果pk是平局则将接收到的选票放入自己的投票箱中</p>
<p>5．如果pk赢了，则忽略所接收到的选票<br>
6．当然一个节点将一张选票放入到自己的投票箱之后，就会从投票箱中统计票数，看是否超过一半的节点都和自己所投的节点是一样的，如果超过半数，那么则认为当前自己所投的节点是leader<br>
7.集群中每个节点都会经过同样的流程，pk的规则也是一样的，一旦改票就会告诉给其他服务器，所以最终各个节点中的投票箱中的选票也将是一样的，所以各个节点最终选出来的leader也是一样的，这样集群的leader就选举出来了</p>
<h1 id="47、zookeeper集群中节点之间数据是如何同步的"><a class="header-anchor" href="#47、zookeeper集群中节点之间数据是如何同步的">¶</a>47、zookeeper集群中节点之间数据是如何同步的</h1>
<p>1．首先集群启动时，会先进行领导者选举，确定哪个节点是Leader，哪些节点是Follower和Observer</p>
<p>2．然后Leader会和其他节点进行数据同步，采用发送快照和发送Diff日志的方式<br>
3．集群在工作过程中，所有的写请求都会交给Leader节点来进行处理，从节点只能处理读请求4. Leader节点收到一个写请求时，会通过两阶段机制来处理<br>
5.Leader节点会将该写请求对应的日志发送给其他Follower节点，并等待Follower节点持久化日志成功</p>
<p>6.Follower节点收到日志后会进行持久化，如果持久化成功则发送一个Ack给Leader节点<br>
7．当Leader节点收到半数以上的Ack后，就会开始提交，先更新Leader节点本地的内存数据<br>
8．然后发送commit命令给Follower节点，Follower节点收到commit命令后就会更新各自本地内存数据<br>
9.同时Leader节点还是将当前写请求直接发送给Observer节点，Observer节点收到Leader发过来的写请求后直接执行更新本地内存数据<br>
10．最后Leader节点返回客户端写请求响应成功<br>
11．通过同步机制和两阶段提交机制来达到集群中节点数据一致</p>
<h1 id="48、Dubbo支持哪些负载均衡策略"><a class="header-anchor" href="#48、Dubbo支持哪些负载均衡策略">¶</a>48、Dubbo支持哪些负载均衡策略</h1>
<p>1．随机:从多个服务提供者随机选择一个来处理本次请求，调用量越大则分布越均匀，并支持按权重设置随机概率</p>
<p>2．轮询:依次选择服务提供者来处理请求，并支持按权重进行轮询，底层采用的是平滑加权轮询算法<br>
3.最小活跃调用数:统计服务提供者当前正在处理的请求，下次请求过来则交给活跃数最小的服务器来处理</p>
<p>4．一致性哈希:相同参数的请求总是发到同一个服务提供者</p>
<h1 id="49、Dubbo是如何完成服务导出的"><a class="header-anchor" href="#49、Dubbo是如何完成服务导出的">¶</a>49、Dubbo是如何完成服务导出的?</h1>
<p>1．首先Dubbo会将程序员所使用的@DubboService注解或@Service注解进行解析得到程序员所定义的服务参数，包括定义的服务名、服务接口、服务超时时间、服务协议等等，得到一个ServiceBean。<br>
2．然后调用serviceBean的export方法进行服务导出<br>
3．然后将服务信息注册到注册中心，如果有多个协议，多个注册中心，那就将服务按单个协议，单个注册中心进行注册</p>
<p>4．将服务信息注册到注册中心后，还会绑定一些监听器，监听动态配置中心的变更<br>
5．还会根据服务协议启动对应的Web服务器或网络框架，比如Tomcat、Netty等</p>
<h1 id="50、Dubbo是如何完成服务引入的"><a class="header-anchor" href="#50、Dubbo是如何完成服务引入的">¶</a>50、Dubbo是如何完成服务引入的?</h1>
<p>1.当程序员使用@Reference注解来引入一个服务时，Dubbo会将注解和服务的信息解析出来，得到当前所引用的服务名、服务接口是什么<br>
2．然后从注册中心进行查询服务信息，得到服务的提供者信息，并存在消费端的服务目录中3．并绑定一些监听器用来监听动态配置中心的变更<br>
4．然后根据查询得到的服务提供者信息生成一个服务接口的代理对象，并放入Spring容器中作为Bean</p>
<h1 id="51、Dubbo的架构设计是怎样的"><a class="header-anchor" href="#51、Dubbo的架构设计是怎样的">¶</a>51、Dubbo的架构设计是怎样的?</h1>
<p>Dubbo中的架构设计是非常优秀的，分为了很多层次，并且每层都是可以扩展的，比如:</p>
<ol>
<li>
<p>Proxy服务代理层，支持JDK动态代理、javassist等代理机制</p>
</li>
<li>
<p>Registry注册中心层，支持Zookeeper、Redis等作为注册中心</p>
</li>
<li>
<p>Protocol远程调用层，支持Dubbo、Http等调用协议</p>
</li>
<li>
<p>Transport网络传输层，支持netty、mina等网络传输框架</p>
</li>
<li>
<p>Serialize数据序列化层，支持JSON、Hessian等序列化机制</p>
</li>
</ol>
<p><strong>各层说明</strong><br>
**config配置层:**对外配置接口，以ServiceConfig, ReferenceConfig为中心，可以直接初始化配置类，也可以通过spring解析配置生成配置类<br>
**proxy服务代理层:**服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton,以ServiceProxy为中心，扩展接口为ProxyFactory<br>
**registry 注册中心层:**封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory,Registry,RegistryService<br>
**cluster路由层:**封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster , Directory ,Router , LoadBalance<br>
<strong>monitor监控层:</strong> RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为 MonitorFactory , Nonitor)，MonitorService<br>
**protocol远程调用层:**封装RPC调用，以Invocation,Result为中心，扩展接口为 Protocol,Invoker，Exporter<br>
**exchange 信息交换层:**封装请求响应模式，同步转异步，以Request,Response为中心，扩展接口为Exchanger，ExchangeChannel , Exchangeclient , ExchangeServer<br>
**transport网络传输层:**抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel , Transporter,client , Server , Codec<br>
**serialize数据序列化层:**可复用的一些工具，扩展接口为Serialization, objectInput , ObjectOutput,ThreadPool</p>
<p><strong>关系说明</strong><br>
在RPC中，Protocol是核心层，也就是只要有Protocol + Invoker + Exporter就可以完成非透明的RPC调用，然后在lnvoker的主过程上Filter 拦截点。<br>
图中的Consumer和Provider是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用Client和Server的原因是Dubbo在很多场景下都使用 Provider, Consumer, Registry, Monitor划分逻辑拓普节点，保持统一概念。<br>
而Cluster是外围概念，所以Cluster的目的是将多个Invoker伪装成一个Invoker，这样其它人只要关注Protocol层Invoker即可，加上Cluster或者去掉Cluster对其它层都不会造成影响，因为只有一个提供者时，是不需要Cluster的。<br>
Proxy层封装了所有接口的透明化代理，而在其它层都以Invoker为中心，只有到了暴露给用户使用时，才用 Proxy将Invoker转成接口，或将接口实现转成Invoker，也就是去掉 Proxy层RPC是可以Run的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。<br>
而Remoting实现是Dubbo协议的实现，如果你选择RMI协议，整个Remoting都不会用上，Remoting 内部再划为Transport传输层和Exchange信息交换层，Transport层只负责单向消息传输，是对Mina, Netty, Grizzly的抽象，它也可以扩展UDP传输，而Exchange层是在传输层之上封装了Request-Response语义。<br>
Registry和Monitor实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</p>
<h1 id="52、Spring-Cloud有哪些常用组件，作用是什么"><a class="header-anchor" href="#52、Spring-Cloud有哪些常用组件，作用是什么">¶</a>52、Spring Cloud有哪些常用组件，作用是什么?</h1>
<ol>
<li>
<p>Eureka:注册中心</p>
</li>
<li>
<p>Nacos:注册中心、配置中心</p>
</li>
<li>
<p>Consul:注册中心、配置中心</p>
</li>
<li>
<p>Spring Cloud Config:配置中心</p>
</li>
<li>
<p>Feign/OpenFeign: RPC调用</p>
</li>
<li>
<p>Kong:服务网关</p>
</li>
<li>
<p>Zuul:服务网关</p>
</li>
<li>
<p>Spring Cloud Gateway:服务网关</p>
</li>
<li>
<p>Ribbon:负载均衡</p>
</li>
<li>
<p>Spring CLoud Sleuth:链路追踪</p>
</li>
<li>
<p>Zipkin:链路追踪</p>
</li>
<li>
<p>Seata:分布式事务</p>
</li>
<li>
<p>Dubbo: RPC调用</p>
</li>
<li>
<p>Sentinel:服务熔断</p>
</li>
<li>
<p>Hystrix:服务熔断</p>
</li>
</ol>
<h1 id="53、Spring-Cloud和Dubbo有哪些区别"><a class="header-anchor" href="#53、Spring-Cloud和Dubbo有哪些区别">¶</a>53、Spring Cloud和Dubbo有哪些区别?</h1>
<p>Spring Cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用间的问题，Spring Cloud是一个大而全的框架，Dubbo则更侧重于服务调用，所以Dubbo所提供的功能没有SpringCloud全面，但是Dubbo的服务调用性能比Spring Cloud高，不过Spring Cloud和Dubbo并不是对立的，是可以结合起来一起使用的。</p>
<h1 id="54、什么是服务雪崩-什么是服务限流"><a class="header-anchor" href="#54、什么是服务雪崩-什么是服务限流">¶</a>54、什么是服务雪崩?什么是服务限流?</h1>
<p>1.当服务A调用服务B，服务B调用C，此时大量请求突然请求服务A，假如服务A本身能抗住这些请求，但是如果服务C抗不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。<br>
2.服务限流是指在高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。</p>
<h1 id="55、什么是服务熔断-什么是服务降级-区别是什么"><a class="header-anchor" href="#55、什么是服务熔断-什么是服务降级-区别是什么">¶</a>55、什么是服务熔断?什么是服务降级?区别是什么?</h1>
<p>1．服务熔断是指，当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，从而不再调用服务B，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复。<br>
2．服务降级是指，当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压力，这就是服务降级。</p>
<p>相同点:<br>
1．都是为了防止系统崩溃<br>
2．都让用户体验到某些功能暂时不可用</p>
<p>不同点:熔断是下游服务故障触发的，降级是为了降低系统负载</p>
<h1 id="56、SOA、分布式、微服务之间有什么关系和区别"><a class="header-anchor" href="#56、SOA、分布式、微服务之间有什么关系和区别">¶</a>56、SOA、分布式、微服务之间有什么关系和区别?</h1>
<p>1.分布式架构是指将单体架构中的各个部分拆分，然后部署不同的机器或进程中去，SOA和微服务基本上都是分布式架构的<br>
2.SOA是一种面向服务的架构，系统的所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用</p>
<p>3.微服务是一种更彻底的面向服务的架构，将系统中各个功能个体抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构</p>
<h1 id="57、BIO、NIO、AIO分别是什么"><a class="header-anchor" href="#57、BIO、NIO、AIO分别是什么">¶</a>57、BIO、NIO、AIO分别是什么</h1>
<p>1.BIO:同步阻塞IO，使用BIO读取数据时，线程会阻塞住，并且需要线程主动去查询是否有数据可读，并且需要处理完一个Socket之后才能处理下一个Socket<br>
2.NIO:同步非阻塞lO，使用NIO读取数据时，线程不会阻塞，但需要线程主动的去查询是否有Io事件<br>
3.AlO:也叫做NIO 2.0，异步非阻塞lO，使用AIO读取数据时，线程不会阻塞，并且当有数据可读时会通知给线程，不需要线程主动去查询</p>
<h1 id="58、零拷贝是什么"><a class="header-anchor" href="#58、零拷贝是什么">¶</a>58、零拷贝是什么</h1>
<p>零拷贝指的是，应用程序在需要把内核中的一块区域数据转移到另外一块内核区域去时，不需要经过先复制到用户空间，再转移到目标内核区域去了，而直接实现转移。</p>
<p><img src="/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/58.png" alt></p>
<h1 id="59、Netty是什么-和Tomcat有什么区别-特点是什么"><a class="header-anchor" href="#59、Netty是什么-和Tomcat有什么区别-特点是什么">¶</a>59、Netty是什么?和Tomcat有什么区别?特点是什么?</h1>
<p>Netty是一个基于NlO的异步网络通信框架，性能高，封装了原生NIO编码的复杂度，开发者可以直接使用Netty来开发高效率的各种网络服务器，并且编码简单。<br>
Tomcat是一个Web服务器，是一个Servlet容器，基本上Tomcat内部只会运行Servlet程序，并处理HTTP请求，而Netty封装的是底层IO模型，关注的是网络数据的传输，而不关心具体的协议，可定制性更高。</p>
<p>Netty的特点:<br>
1．异步、NIO的网络通信框架</p>
<p>2．高性能<br>
3．高扩展，高定制性</p>
<p>4．易用性</p>
<h1 id="60、Netty的线程模型是怎么样的"><a class="header-anchor" href="#60、Netty的线程模型是怎么样的">¶</a>60、Netty的线程模型是怎么样的</h1>
<p>Netty同时支持Reactor单线程模型、Reactor多线程模型和Reactor主从多线程模型，用户可根据启动参数配置在这三种模型之间切换。</p>
<p><img src="/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/60.png" alt></p>
<p>服务端启动时，通常会创建两个NioEventLoopGroup实例，对应了两个独立的Reactor线程池, bossGroup负责处理客户端的连接请求，workerGroup负责处理I/O相关的操作，执行系统Task、定时任务Task等。用户可根据服务端引导类<br>
ServerBootstrap配置参数选择Reactor线程模型，进而最大限度地满足用户的定制化需求。</p>
<h1 id="61、Netty的高性能体现在哪些方面"><a class="header-anchor" href="#61、Netty的高性能体现在哪些方面">¶</a>61、Netty的高性能体现在哪些方面</h1>
<p>1.NIO模型，用最少的资源做更多的事情。<br>
2．内存零拷贝，尽量减少不必要的内存拷贝，实现了更高效率的传输。<br>
3.内存池设计，申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。<br>
4．串行化处理读写∶避免使用锁带来的性能开销。即消息的处理尽可能再同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队里-多个工作线程模型性能更优。<br>
5．高性能序列化协议︰支持protobuf等高性能序列化协议。<br>
6．高效并发编程的体现:volatile的大量、正确使用;CAS和原子类的广泛使用;线程安全容器的使用;通过读写锁提升并发性能。</p>
<h1 id="62、Redis有哪些数据结构-分别有哪些典型的应用场景"><a class="header-anchor" href="#62、Redis有哪些数据结构-分别有哪些典型的应用场景">¶</a>62、Redis有哪些数据结构?分别有哪些典型的应用场景?</h1>
<p>Redis的数据结构有:<br>
1.字符串:可以用来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID<br>
2．哈希表:可以用来存储一些key-value对，更适合用来存储对象<br>
3.列表: Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据<br>
4．集合:和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似,我和某人共同关注的人、朋友圈点赞等功能<br>
5．有序集合:集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能</p>
<h1 id="63、Redis分布式锁底层是如何实现的"><a class="header-anchor" href="#63、Redis分布式锁底层是如何实现的">¶</a>63、Redis分布式锁底层是如何实现的?</h1>
<p>1.首先利用setnx来保证:如果key不存在才能获取到锁，如果key存在，则获取不到锁</p>
<p>2．然后还要利用lua脚本来保证多个redis操作的原子性<br>
3.同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约<br>
4，同时还要考虑到redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到</p>
<h1 id="64、Redis主从复制的核心原理"><a class="header-anchor" href="#64、Redis主从复制的核心原理">¶</a>64、Redis主从复制的核心原理</h1>
<p>Redis的主从复制是提高Redis的可靠性的有效措施，主从复制的流程如下:</p>
<p>1．集群启动时，主从库间会先建立连接，为全量复制做准备<br>
2．主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照RDB<br>
3，在主库将数据同步给从库的过程中，主库不会阻塞，仍然可以正常接收请求。否则，redis的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的RDB文件中。为了保证主从库的数据一致性，主库会在内存中用专门的replication buffer，记录RDB文件生成收到的所有写操作。<br>
4.最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成RDB文件发送后，就会把此时replocation buffer中修改操作发送给从库，从库再执行这些操作。这样一来，主从库就实现同步了<br>
5，后续主库和从库都可以处理客户端读操作，写操作只能交给主库处理，主库接收到写操作后，还会将写操作发送给从库，实现增量同步</p>
<h1 id="65、缓存穿透、缓存击穿、缓存雪崩分别是什么"><a class="header-anchor" href="#65、缓存穿透、缓存击穿、缓存雪崩分别是什么">¶</a>65、缓存穿透、缓存击穿、缓存雪崩分别是什么</h1>
<p>缓存中存放的大多都是热点数据，目的就是防止请求可以直接从缓存中获取到数据，而不用访问Mysql,<br>
1．缓存雪崩:如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问Mysql了，解决办法就是在过期时间上增加一点随机值，另外如果搭建一个高可用的Redis集群也是防止缓存雪崩的有效手段<br>
2．缓存击穿:和缓存雪崩类似，缓存雪崩是大批热点数据失效，而缓存击穿是指某一个热点key突然失效，也导致了大量请求直接访问Mysql数据库，这就是缓存击穿，解决方案就是考虑这个热点key不设过期时间<br>
3．缓存穿透:假如某一时刻访问redis的大量key都在redis中不存在(比如黑客故意伪造一些乱七八糟的key)，那么也会给数据造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加一层布隆过滤器来拦截不存在的key</p>
<h1 id="66、Redis和Mysql如何保证数据一致"><a class="header-anchor" href="#66、Redis和Mysql如何保证数据一致">¶</a>66、Redis和Mysql如何保证数据一致</h1>
<p>1．先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致<br>
2．先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新Mysql，此时另外一个查询再查询，那么就会把Mysql中老数据又查到Redis中<br>
3，延时双删，步骤是:先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致</p>
<h1 id="67、Explain语句结果中各个字段分表表示什么"><a class="header-anchor" href="#67、Explain语句结果中各个字段分表表示什么">¶</a>67、Explain语句结果中各个字段分表表示什么</h1>
<table>
<thead>
<tr>
<th style="text-align:center">列名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td style="text-align:center">查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值，某些子查询会被优化为join查询，那么出现的id会一样</td>
</tr>
<tr>
<td style="text-align:center">select_type</td>
<td style="text-align:center">SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">表名</td>
</tr>
<tr>
<td style="text-align:center">partitions</td>
<td style="text-align:center">匹配的分区信息</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">针对单表的查询方式(全表扫描、索引)</td>
</tr>
<tr>
<td style="text-align:center">possible_keys</td>
<td style="text-align:center">可能用到的索引</td>
</tr>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">实际上使用的索引</td>
</tr>
<tr>
<td style="text-align:center">key_len</td>
<td style="text-align:center">实际使用到的索引长度</td>
</tr>
<tr>
<td style="text-align:center">ref</td>
<td style="text-align:center">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td style="text-align:center">rows</td>
<td style="text-align:center">预估的需要读取的记录条数</td>
</tr>
<tr>
<td style="text-align:center">filtered</td>
<td style="text-align:center">某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td style="text-align:center">Extra</td>
<td style="text-align:center">一些额外的信息，比如排序等</td>
</tr>
</tbody>
</table>
<h1 id="68、索引覆盖是什么"><a class="header-anchor" href="#68、索引覆盖是什么">¶</a>68、索引覆盖是什么</h1>
<p>索引覆盖就是一个SQL在执行时，可以利用索引来快速查找，并且此SQL所要查询的字段在当前索引对应的字段中都包含了，那么就表示此SQL走完索引后不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了</p>
<h1 id="69、最左前缀原则是什么"><a class="header-anchor" href="#69、最左前缀原则是什么">¶</a>69、最左前缀原则是什么</h1>
<p>当一个SQL想要利用索引时，就一定要提供该索引所对应的字段中最左边的字段，也就是排在最前面的字段，比如针对a,b.c三个字段建立了一个联合索引，那么在写一个sql时就一定要提供a字段的条件，这样才能用到联合索引，这是由于在建立a,b,c三个字段的联合索引时，底层的B+树是按照a,b.c三个字段从左往右去比较大小进行排序的，所以如果想要利用B+树进行快速查找也得符合这个规则</p>
<h1 id="70、lnnodb是如何实现事务的"><a class="header-anchor" href="#70、lnnodb是如何实现事务的">¶</a>70、lnnodb是如何实现事务的</h1>
<p>Innodb通过Buffer Pool，LogBuffer，Redo Log,Undo Log来实现事务，以一个update语句为例:<br>
1.Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中</p>
<p>2．执行update语句，修改Buffer Pool中的数据，也就是内存中的数据<br>
3．针对update语句生成一个RedoLog对象，并存入LogBuffer中<br>
4．针对update语句生成undolog日志，用于事务回滚<br>
5．如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中</p>
<p>6．如果事务回滚，则利用undolog日志进行回滚</p>
<h1 id="71、B树和B-树的区别，为什么Mysql使用B-树"><a class="header-anchor" href="#71、B树和B-树的区别，为什么Mysql使用B-树">¶</a>71、B树和B+树的区别，为什么Mysql使用B+树</h1>
<p>B树的特点:<br>
1．节点排序<br>
2．一个节点了可以存多个元素，多个元素也排序了<br>
B+树的特点:<br>
1．拥有B树的特点<br>
2．叶子节点之间有指针<br>
3．非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序</p>
<p>Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个Innodb页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。</p>
<h1 id="72、Mysql锁有哪些，如何理解"><a class="header-anchor" href="#72、Mysql锁有哪些，如何理解">¶</a>72、Mysql锁有哪些，如何理解</h1>
<p>按锁粒度分类:<br>
1．行锁:锁某行数据，锁粒度最小，并发度高</p>
<p>2．表锁:锁整张表，锁粒度最大，并发度低</p>
<p>3．间隙锁:锁的是一个区间</p>
<p>还可以分为:<br>
1.共享锁:也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写</p>
<p>2.排它锁:也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写</p>
<p>还可以分为:<br>
1．乐观锁:并不会真正的去锁某行记录，而是通过一个版本号来实现的</p>
<p>2．悲观锁:上面所的行锁、表锁等都是悲观锁</p>
<p>在事务的隔离级别实现中，就需要利用所来解决幻读</p>
<h1 id="73、Mysql慢查询该如何优化"><a class="header-anchor" href="#73、Mysql慢查询该如何优化">¶</a>73、Mysql慢查询该如何优化?</h1>
<p>1．检查是否走了索引，如果没有则优化SQL利用索引</p>
<p>2．检查所利用的索引，是否是最优索引<br>
3．检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据</p>
<p>4．检查表中数据是否过多，是否应该进行分库分表了<br>
5．检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源</p>
<h1 id="74、消息队列有哪些作用"><a class="header-anchor" href="#74、消息队列有哪些作用">¶</a>74、消息队列有哪些作用</h1>
<p>1．解耦:使用消息队列来作为两个系统直接的通讯方式，两个系统不需要相互依赖了</p>
<p>2．异步:系统A给消费队列发送完消息之后，就可以继续做其他事情了<br>
3．流量削峰:如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，由消费者自己控制消费速度</p>
<h1 id="75、死信队列是什么-延时队列是什么"><a class="header-anchor" href="#75、死信队列是什么-延时队列是什么">¶</a>75、死信队列是什么?延时队列是什么?</h1>
<p>1．死信队列也是一个消息队列，它是用来存放那些没有成功消费的消息的，通常可以用来作为消息重试<br>
2．延时队列就是用来存放需要在指定时间被处理的元素的队列，通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付则取消订单</p>
<h1 id="76、Kafka为什么比RocketMQ的吞吐量要高"><a class="header-anchor" href="#76、Kafka为什么比RocketMQ的吞吐量要高">¶</a>76、Kafka为什么比RocketMQ的吞吐量要高</h1>
<p>Kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息并没有发送到Broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送给Broker。这种做法减少了网络io，从而提高了消息发送的吞吐量，但是如果消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用此机制提高了性能却降低了可靠性。</p>
<h1 id="77、Kafka的Pull和Push分别有什么优缺点"><a class="header-anchor" href="#77、Kafka的Pull和Push分别有什么优缺点">¶</a>77、Kafka的Pull和Push分别有什么优缺点</h1>
<ol>
<li>pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者自己控制，根据自己的消息处理能力来进行控制，但是消费者不能及时知道是否有消息，可能会拉到的消息为空</li>
<li>push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就得消费多少消息，所以可能会造成网络堵塞，消费者压力大等问题</li>
</ol>
<h1 id="78、RocketMQ的底层实现原理"><a class="header-anchor" href="#78、RocketMQ的底层实现原理">¶</a>78、RocketMQ的底层实现原理</h1>
<p>RocketMQ由NameServer集群、Producer集群、Consumer集群、Broker集群组成，消息生产和消费的大致原理如下:</p>
<ol>
<li>Broker在启动的时候向所有的Nameserver注册，并保持长连接，每30s发送一次心跳</li>
<li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</li>
<li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li>
</ol>
<h1 id="79、消息队列如何保证消息可靠传输"><a class="header-anchor" href="#79、消息队列如何保证消息可靠传输">¶</a>79、消息队列如何保证消息可靠传输</h1>
<p>消息可靠传输代表了两层意思，既不能多也不能少。</p>
<p>1.为了保证消息不多，也就是消息不能重复，也就是生产者不能重复生产消息，或者消费者不能重复消费消息<br>
2．首先要确保消息不多发，这个不常出现，也比较难控制，因为如果出现了多发，很大的原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制<br>
3．要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题<br>
4．消息不能少，意思就是消息不能丢失，生产者发送的消息，消费者一定要能消费到，对于这个问题，就要考虑两个方面</p>
<p>5．生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ的confirm机制，Kafka的ack机制都可以保证生产者能正确的将消息发送给broker</p>
<p>6．broker要等待消费者真正确认消费到了消息时才删除掉消息，这里通常就是消费端ack机制，消费者接收到─条消息后，如果确认没问题了，就可以给broker发送一个ack,broker接收到ack后才会删除消息</p>
<h1 id="80、TCP的三次握手和四次挥手"><a class="header-anchor" href="#80、TCP的三次握手和四次挥手">¶</a>80、TCP的三次握手和四次挥手</h1>
<p>TCP协议是7层网络协议中的传输层协议，负责数据的可靠传输。在建立TCP连接时，需要通过三次握手来建立，过程是:<br>
1．客户端向服务端发送一个SYN<br>
2．服务端接收到SYN后，给客户端发送一个SYN_ACK</p>
<p>3．客户端接收到SYN_ACK后，再给服务端发送一个ACK</p>
<p>在断开TCP连接时，需要通过四次挥手来断开，过程是:</p>
<p>1．客户端向服务端发送FIN<br>
2．服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理<br>
3．服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接</p>
<p>4．客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了</p>

      
    </div>
    
    
    

    <div>
     
         <div>
 
  <div style="text-align:center;color:#bfbfbf;font-size:16px;">
   <span>-------- 本文结束 </span>
   <i class="fa fa-paw"></i>
   <span> 感谢阅读 --------</span>
  </div>
 
</div>
     
    </div>

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="潇 卟 甸 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="潇 卟 甸 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <!-- JS库 clipboard 拷贝内容到粘贴板-->
<script src="https://cdn.bootcss.com/clipboard.js/2.0.1/clipboard.min.js"></script>

<!-- JS库 sweetalert 显示提示信息-->
<script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>

<ul class="post-copyright">
<!-- 本文标题 -->
<li>
  <strong>本文标题： </strong>
  80个Java面试必考题
</li>

<!-- 本文作者 -->
<li class="post-copyright-author">
  <strong>本文作者： </strong>
  
</li>

<!-- 创建时间 -->
<li>
  <strong>创建时间： </strong>
  2021年08月13日 - 14时08分
</li>

<!-- 修改时间 -->
<li>
  <strong>修改时间： </strong>
  2021年08月14日 - 21时08分
</li>

<!-- 引用链接 -->
<li class="post-copyright-link">
  <strong>本文链接：</strong>
  <a href="http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/" title="80个Java面试必考题"
    >http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/</a
  >
  <span class="copy-path" title="点击复制引用链接"
    ><i
      style="cursor: pointer"
      class="fa fa-clipboard"
      data-clipboard-text="['s Blog | 80个Java面试必考题](http://yoursite.com/2021/08/13/80%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/)"
      aria-label="复制成功"
    ></i
  ></span>
</li>

<!-- 版权声明 -->
<li class="post-copyright-license">
  <strong
    >版权声明：
  </strong>
  本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
</li>
</ul>

<script>
var clipboard = new ClipboardJS(".fa-clipboard");
clipboard.on("success", function(target) {
  var message = document.createElement("div");
  message.innerHTML =
    '<i class="fa fa-check-circle message-icon"></i><span class="message-content">' +
    target.trigger.getAttribute("aria-label") +
    "</span>";
  swal({
    content: message,
    className: "copy-success-message",
    timer: 1000,
    button: false
  });
});
</script>
      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/b%E7%AB%99%E8%A7%86%E9%A2%91/" rel="tag"><i class="fa fa-tag"></i> b站视频</a>
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          
            <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 编程</a>
          
            <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 面试题</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/10/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E7%AC%AC3%E5%AD%A3%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90Java%E5%AD%A6%E7%A7%91%E3%80%91/" rel="next" title="尚硅谷-第3季面试题【Java学科】">
                <i class="fa fa-chevron-left"></i> 尚硅谷-第3季面试题【Java学科】
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/15/Java%E9%9D%A2%E8%AF%95300%E9%A2%98%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="prev" title="Java面试300题（上）">
                Java面试300题（上） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <a href="/">
              <img class="site-author-image" itemprop="image"
                src="/uploads/picture.jpg"
                alt="潇 卟 甸" />
              </a>
            
              <p class="site-author-name" itemprop="name">潇 卟 甸</p>
              <p class="site-description motion-element" itemprop="description">总结自己一些知识，一些事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">88</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

			
				<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
				<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
				<div class="widget-wrap">
					<div id="myCanvasContainer" class="widget tagcloud">
						<canvas width="250" height="250" id="resCanvas" style="width=100%">
							<ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">62</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%AE%9E%E8%B7%B5/" rel="tag">Java实践</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/b%E7%AB%99%E8%A7%86%E9%A2%91/" rel="tag">b站视频</a><span class="tag-list-count">45</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E7%BA%A7/" rel="tag">中级</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85/" rel="tag">喜马拉雅</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a><span class="tag-list-count">40</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E8%AF%AD/" rel="tag">日语</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/" rel="tag">源代码</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/" rel="tag">电子书</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a><span class="tag-list-count">76</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BE%8E%E5%8C%96/" rel="tag">美化</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E6%8E%A8%E8%8D%90/" rel="tag">读书推荐</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E9%98%B6/" rel="tag">进阶</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a><span class="tag-list-count">7</span></li></ul>
						</canvas>
					</div>
				</div>
			

          </nav>

          

          
		  
		  <!-- 添加近期文章 -->
			
				<div class="links-of-blogroll motion-element links-of-blogroll-block">
				<div class="links-of-blogroll-title">
				<!-- modify icon to fire by szw -->
				<i class="fa fa-history fa-" aria-hidden="true"></i>
				近期文章
				</div>
				<ul class="links-of-blogroll-list">
				
				
					<li>
					<a href="/2021/09/14/%E5%B0%9A%E7%A1%85%E8%B0%B7-Web%E5%89%8D%E7%AB%AFES6%E6%95%99%E7%A8%8B/" title="尚硅谷-Web前端ES6教程" target="_blank">尚硅谷-Web前端ES6教程</a>
					</li>
				
					<li>
					<a href="/2021/08/31/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%99%E7%A8%8B/" title="尚硅谷-密码学教程" target="_blank">尚硅谷-密码学教程</a>
					</li>
				
					<li>
					<a href="/2021/08/31/%E5%B0%9A%E7%A1%85%E8%B0%B7-Elasticsearch%E6%95%99%E7%A8%8B/" title="尚硅谷-Elasticsearch教程" target="_blank">尚硅谷-Elasticsearch教程</a>
					</li>
				
					<li>
					<a href="/2021/08/26/Java%E9%9D%A2%E8%AF%95300%E9%A2%98%EF%BC%88%E4%B8%8B%EF%BC%89/" title="Java面试300题（下）" target="_blank">Java面试300题（下）</a>
					</li>
				
					<li>
					<a href="/2021/08/26/Java%E9%9D%A2%E8%AF%95300%E9%A2%98%EF%BC%88%E4%B8%AD%EF%BC%89/" title="Java面试300题（中）" target="_blank">Java面试300题（中）</a>
					</li>
				
				</ul>
			</div>
			

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://sushan102.top/posts/1410804403/" title="博客搭建" target="_blank">博客搭建</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://how2j.cn?p=154642" title="HOW2J" target="_blank">HOW2J</a>
                  </li>
                
              </ul>
            </div>
          
		  
		  
			
		  
		  <div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>


        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、看以下代码回答问题（一）"><span class="nav-text">1、看以下代码回答问题（一）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、看以下代码回答问题（二）"><span class="nav-text">2、看以下代码回答问题（二）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、看以下代码回答问题（三）"><span class="nav-text">3、看以下代码回答问题（三）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、String、StringBuffer、StringBuilder的区别"><span class="nav-text">4、String、StringBuffer、StringBuilder的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、ArrayList和LinkedList有哪些区别"><span class="nav-text">5、ArrayList和LinkedList有哪些区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、CopyOnWriteArrayList的底层原理是怎样的"><span class="nav-text">6、CopyOnWriteArrayList的底层原理是怎样的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7、HashMap的扩容机制原理"><span class="nav-text">7、HashMap的扩容机制原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8、ConcurrentHashMap的扩容机制"><span class="nav-text">8、ConcurrentHashMap的扩容机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9、ThreadLocal的底层原理"><span class="nav-text">9、ThreadLocal的底层原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10、如何理解volatile关键字"><span class="nav-text">10、如何理解volatile关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11、ReentrantLock中的公平锁和非公平锁的底层实现"><span class="nav-text">11、ReentrantLock中的公平锁和非公平锁的底层实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12、ReentrantLock中tryLock-和lock-方法的区别"><span class="nav-text">12、ReentrantLock中tryLock()和lock()方法的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13、CountDownLatch和Semaphore的区别和底层原理"><span class="nav-text">13、CountDownLatch和Semaphore的区别和底层原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14、Sychronized的偏向锁、轻量级锁、重量级锁"><span class="nav-text">14、Sychronized的偏向锁、轻量级锁、重量级锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15、Sychronized和ReentrantLock的区别"><span class="nav-text">15、Sychronized和ReentrantLock的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16、线程池的底层工作原理"><span class="nav-text">16、线程池的底层工作原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17、JVM中哪些是线程共享区"><span class="nav-text">17、JVM中哪些是线程共享区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18、JVM中哪些可以作为gc-root"><span class="nav-text">18、JVM中哪些可以作为gc root</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19、你们项目如何排查JVM问题"><span class="nav-text">19、你们项目如何排查JVM问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20、说说类加载器双亲委派模型"><span class="nav-text">20、说说类加载器双亲委派模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21、Tomcat中为什么要使用自定义类加载器"><span class="nav-text">21、Tomcat中为什么要使用自定义类加载器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22、Tomcat如何进行优化"><span class="nav-text">22、Tomcat如何进行优化?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23、浏览器发出一个请求到收到响应经历了哪些步骤"><span class="nav-text">23、浏览器发出一个请求到收到响应经历了哪些步骤?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24、跨域请求是什么-有什么问题-怎么解决"><span class="nav-text">24、跨域请求是什么?有什么问题?怎么解决?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25、Spring中的Bean创建的生命周期有哪些步骤"><span class="nav-text">25、Spring中的Bean创建的生命周期有哪些步骤</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26、Spring中Bean是线程安全的吗"><span class="nav-text">26、Spring中Bean是线程安全的吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27、ApplicationContext和BeanFactory有什么区别"><span class="nav-text">27、ApplicationContext和BeanFactory有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28、Spring中的事务是如何实现的"><span class="nav-text">28、Spring中的事务是如何实现的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29、Spring中什么时候-Transactional会失效"><span class="nav-text">29、Spring中什么时候@Transactional会失效</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30、Spring容器启动流程是怎样的"><span class="nav-text">30、Spring容器启动流程是怎样的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31、Spring用到了哪些设计模式"><span class="nav-text">31、Spring用到了哪些设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32、SpringMVC的底层工作流程"><span class="nav-text">32、SpringMVC的底层工作流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33、SpringBoot中常用注解及其底层实现"><span class="nav-text">33、SpringBoot中常用注解及其底层实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34、SpringBoot是如何启动Tomcat的"><span class="nav-text">34、SpringBoot是如何启动Tomcat的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35、SpringBoot中配置文件的加载顺序是怎样的"><span class="nav-text">35、SpringBoot中配置文件的加载顺序是怎样的?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36、Mybatis存在哪些优点和缺点优点"><span class="nav-text">36、Mybatis存在哪些优点和缺点优点:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37、Mybatis中-和-的区别是什么"><span class="nav-text">37、Mybatis中#{}和${}的区别是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38、什么是CAP理论"><span class="nav-text">38、什么是CAP理论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39、什么是BASE理论"><span class="nav-text">39、什么是BASE理论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40、什么是RPC"><span class="nav-text">40、什么是RPC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41、分布式ID是什么-有哪些解决方案"><span class="nav-text">41、分布式ID是什么?有哪些解决方案?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42、分布式锁的使用场景是什么-有哪些实现方案"><span class="nav-text">42、分布式锁的使用场景是什么?有哪些实现方案?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43、什么是分布式事务-有哪些实现方案"><span class="nav-text">43、什么是分布式事务?有哪些实现方案?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44、什么是ZAB协议"><span class="nav-text">44、什么是ZAB协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45、为什么Zookeeper可以用来作为注册中心"><span class="nav-text">45、为什么Zookeeper可以用来作为注册中心</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46、Zookeeper中的领导者选举的流程是怎样的"><span class="nav-text">46、Zookeeper中的领导者选举的流程是怎样的?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47、zookeeper集群中节点之间数据是如何同步的"><span class="nav-text">47、zookeeper集群中节点之间数据是如何同步的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48、Dubbo支持哪些负载均衡策略"><span class="nav-text">48、Dubbo支持哪些负载均衡策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49、Dubbo是如何完成服务导出的"><span class="nav-text">49、Dubbo是如何完成服务导出的?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50、Dubbo是如何完成服务引入的"><span class="nav-text">50、Dubbo是如何完成服务引入的?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#51、Dubbo的架构设计是怎样的"><span class="nav-text">51、Dubbo的架构设计是怎样的?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#52、Spring-Cloud有哪些常用组件，作用是什么"><span class="nav-text">52、Spring Cloud有哪些常用组件，作用是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53、Spring-Cloud和Dubbo有哪些区别"><span class="nav-text">53、Spring Cloud和Dubbo有哪些区别?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54、什么是服务雪崩-什么是服务限流"><span class="nav-text">54、什么是服务雪崩?什么是服务限流?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55、什么是服务熔断-什么是服务降级-区别是什么"><span class="nav-text">55、什么是服务熔断?什么是服务降级?区别是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56、SOA、分布式、微服务之间有什么关系和区别"><span class="nav-text">56、SOA、分布式、微服务之间有什么关系和区别?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57、BIO、NIO、AIO分别是什么"><span class="nav-text">57、BIO、NIO、AIO分别是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58、零拷贝是什么"><span class="nav-text">58、零拷贝是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#59、Netty是什么-和Tomcat有什么区别-特点是什么"><span class="nav-text">59、Netty是什么?和Tomcat有什么区别?特点是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#60、Netty的线程模型是怎么样的"><span class="nav-text">60、Netty的线程模型是怎么样的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61、Netty的高性能体现在哪些方面"><span class="nav-text">61、Netty的高性能体现在哪些方面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62、Redis有哪些数据结构-分别有哪些典型的应用场景"><span class="nav-text">62、Redis有哪些数据结构?分别有哪些典型的应用场景?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#63、Redis分布式锁底层是如何实现的"><span class="nav-text">63、Redis分布式锁底层是如何实现的?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#64、Redis主从复制的核心原理"><span class="nav-text">64、Redis主从复制的核心原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#65、缓存穿透、缓存击穿、缓存雪崩分别是什么"><span class="nav-text">65、缓存穿透、缓存击穿、缓存雪崩分别是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66、Redis和Mysql如何保证数据一致"><span class="nav-text">66、Redis和Mysql如何保证数据一致</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#67、Explain语句结果中各个字段分表表示什么"><span class="nav-text">67、Explain语句结果中各个字段分表表示什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#68、索引覆盖是什么"><span class="nav-text">68、索引覆盖是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#69、最左前缀原则是什么"><span class="nav-text">69、最左前缀原则是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#70、lnnodb是如何实现事务的"><span class="nav-text">70、lnnodb是如何实现事务的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#71、B树和B-树的区别，为什么Mysql使用B-树"><span class="nav-text">71、B树和B+树的区别，为什么Mysql使用B+树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#72、Mysql锁有哪些，如何理解"><span class="nav-text">72、Mysql锁有哪些，如何理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#73、Mysql慢查询该如何优化"><span class="nav-text">73、Mysql慢查询该如何优化?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#74、消息队列有哪些作用"><span class="nav-text">74、消息队列有哪些作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#75、死信队列是什么-延时队列是什么"><span class="nav-text">75、死信队列是什么?延时队列是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#76、Kafka为什么比RocketMQ的吞吐量要高"><span class="nav-text">76、Kafka为什么比RocketMQ的吞吐量要高</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#77、Kafka的Pull和Push分别有什么优缺点"><span class="nav-text">77、Kafka的Pull和Push分别有什么优缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#78、RocketMQ的底层实现原理"><span class="nav-text">78、RocketMQ的底层实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#79、消息队列如何保证消息可靠传输"><span class="nav-text">79、消息队列如何保证消息可靠传输</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#80、TCP的三次握手和四次挥手"><span class="nav-text">80、TCP的三次握手和四次挥手</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script
  async
  src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"
></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">潇 卟 甸</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>

-->



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
     我的第 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 位朋友，
    </span>
  

  
    <span class="site-pv">
     历经 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次回眸才与你相遇
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'w1mVK8MFY7n2fWIKlq2t9EJn-gzGzoHsz',
        appKey: 'NMGzUaGqmpzSiSItkHBQGUaA',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("w1mVK8MFY7n2fWIKlq2t9EJn-gzGzoHsz", "NMGzUaGqmpzSiSItkHBQGUaA");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  

  

  


  

 <script src="/js/src/activate-power-mode.js"></script>
 <script>
   POWERMODE.colorful = true;
   POWERMODE.shake = false;
   document.body.addEventListener('input', POWERMODE);
 </script>




<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script>
<script>
  function timer() {
    var ages = moment.preciseDiff(moment(),moment(20200610,"YYYYMMDD"));
    ages = ages.replace(/years?/, "年");
    ages = ages.replace(/months?/, "月");
    ages = ages.replace(/days?/, "天");
    ages = ages.replace(/hours?/, "小时");
    ages = ages.replace(/minutes?/, "分");
    ages = ages.replace(/seconds?/, "秒");
    ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
    div.innerHTML = `我已在此等候你 ${ages}`;
  }
  var div = document.createElement("div");
  //插入到copyright之后
  var copyright = document.querySelector(".copyright");
  document.querySelector(".footer-inner").insertBefore(div, copyright.nextSibling);
  timer();
  setInterval("timer()",1000)
</script>




<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>


  
</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard.min.js"></script>  
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
