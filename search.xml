<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java学习笔记【求知课堂】（三）</title>
    <url>/2020/06/15/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>网址：<a href="https://www.bilibili.com/video/av76235341" target="_blank" rel="noopener">https://www.bilibili.com/video/av76235341</a></strong></p>
<p>【P39-45】</p>
<p>【P46-55】</p>
<p>【P56-65】</p>
<p>【P66-72】</p>
<p>【P73-81】</p>
<p>【P82-89】</p>
<p>【P90-96】</p>
<p>【P97-104】</p>
<p>【P105-111】</p>
<p>【P112-121】</p>
<p>【P122-131】</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>求知课堂</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>b站视频</tag>
      </tags>
  </entry>
  <entry>
    <title>10分钟速成课：学习技能</title>
    <url>/2020/06/15/10%E5%88%86%E9%92%9F%E9%80%9F%E6%88%90%E8%AF%BE%EF%BC%9A%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>【合集】10分钟速成课：学习技能【预告+全10集】【720P高清双语】</p>
<p><strong><a href="https://www.bilibili.com/video/av16785517" target="_blank" rel="noopener">https://www.bilibili.com/video/av16785517</a></strong></p>
<a id="more"></a>
<iframe src="//player.bilibili.com/player.html?aid=16785517&bvid=BV1bW411a7oM&cid=27425615&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<h1 id="一、记笔记"><a class="header-anchor" href="#一、记笔记">¶</a>一、记笔记</h1>
<p>1.选择工具：<br>
纸张 最推荐：自我控制→关注意义而非语法<br>
电脑<br>
胳膊<br>
2.记录内容：<br>
记录所需信息，并去掉无关信息<br>
3.大致指导<br>
预习；教学大纲；学习指南、已有资料；已有知识；重要思想：总结、回顾、结论；列表；术语、意义；例子<br>
4.怎么记<br>
（1）大纲法<br>
条理清晰 死板<br>
改进：格式技巧<br>
（2）康奈尔法<br>
图（3）思维导图法<br>
表示单个概念和事实之间的关系</p>
<p>其他：输入与输出同样重要、记笔记体系</p>
<h1 id="二、阅读材料"><a class="header-anchor" href="#二、阅读材料">¶</a>二、阅读材料</h1>
<p>1.法一：甄别与优先级<br>
（1）甄别，分为两类<br>
主要教材、补充阅读（选择）<br>
（2）优先级<br>
论述＞描述＞背景<br>
2.法二：读得更快<br>
——速读，不推荐<br>
3.法三：孰能生巧<br>
经常阅读、广泛阅读、确认难度适中<br>
tips：发呆，为每一章设置时间限制<br>
4.法四：摩斯密码法<br>
· 观点<br>
- 例子<br>
5.法五：主动阅读<br>
SQ3R：Survey、Question、Read、Recite、Review<br>
浏览 提问 阅读 复述 复习</p>
<p>其他：中央凹、眼跳、注视、工作记忆的限制<br>
快速序列视觉加工<br>
伪略读<br>
记忆的两种方式：再认、回忆</p>
<h1 id="三、记忆"><a class="header-anchor" href="#三、记忆">¶</a>三、记忆</h1>
<p>原理以及如何记得更好</p>
<p>1.原理<br>
（1）从信息到记忆<br>
感觉记忆→大部分遗忘，留下的进入短时记忆→长时记忆<br>
（2）遗忘<br>
原因：大脑没有平等的编码信息<br>
2.记忆强度<br>
（1）储存强度：放入就不再拿走的书<br>
（2）提取强度：寻找这本书<br>
3.记住技巧<br>
（1）有形的、视觉的、不寻常的信息<br>
（2）记忆链接越多（不同场景），越牢固<br>
4.记牢方法<br>
（1）间隔重复法：稳定增加每次学习的间隔时间<br>
表格<br>
（2）莱特纳系统<br>
表格<br>
tips：灵活项目（如运动）不适用死板方法，但原理类似</p>
<p>其他：开发记忆术（零碎信息→更容易记住的形式）<br>
艾宾浩斯遗忘曲线<br>
间隔效应、适度困难原则、零界点<br>
重视回忆（recall）</p>
<h1 id="四、计划与整理"><a class="header-anchor" href="#四、计划与整理">¶</a>四、计划与整理</h1>
<p>1.管理系统<br>
存储灵感、信息、资源的可靠方式<br>
（1）凑齐系统<br>
任务管理器：记录需要做的事情（任务要求+截止日期），并查看即将到来的事情<br>
日历：即将到来的事件<br>
记笔记体系<br>
纸质文件的物理保存方式<br>
（2）设计方案（指规则）<br>
推荐树状的文件夹结构<br>
（3）建立项目（把相同的任务归纳在一起）<br>
（4）确保自己会使用管理系统<br>
快速捕捉（在正确的位置记录）<br>
①先正确位置，再记录<br>
②先记录，再整理（每日笔记）<br>
2.做计划<br>
（1）每周<br>
长期计划<br>
回顾总结：找到计划与结果的差距，及原因；修改任务管理器，日历<br>
（2）每天<br>
tips：可以整合每日琐碎的任务</p>
<p>其他：学生都有的两种模式：计划模式（设定程序）、机器模式（做程序指定的工作）<br>
熵：宇宙中一切区域无序和混乱的任务<br>
通过规律的整理防止一切变得太混乱</p>
<h1 id="五、注意力"><a class="header-anchor" href="#五、注意力">¶</a>五、注意力</h1>
<p>1.定义<br>
把认知资源集中于特定刺激或信息源<br>
2.两种形式<br>
（1）自上而下<br>
源于“任务要求”<br>
抑制机制，可变化，环境、寻求新鲜感得倾向、兴趣、大脑状态、已注意时长<br>
（2）自下而上<br>
源于“环境刺激”<br>
3.强化注意力（外在强化）<br>
（1）停止同时进行多项任务<br>
（2）简化环境<br>
·环境选择<br>
·分解当前任务，对特定任务必要的环境工具<br>
-写论文：头脑风暴、研究、起草、编辑，其中只有研究才需要互联网<br>
·预防潜在干扰<br>
4.提升注意力（内在提升）<br>
做法：抵抗对新鲜感的渴望（渴望的强度，源于屈服的频率）<br>
具体而言，承认渴望，刻意无视<br>
5.注意休息，劳逸结合<br>
推荐：番茄工作法</p>
<p>其他：定向注意疲劳<br>
认知转换惩罚、注意残留<br>
环境的力量是强大的<br>
完美的工作地点，是没有标准答案的<br>
昼夜节律<br>
高质量的工作=时间×注意力强度</p>
<h1 id="六、拖延症"><a class="header-anchor" href="#六、拖延症">¶</a>六、拖延症</h1>
<p>1.原因——当前动机理论（Temporal Motivation Theory）<br>
·动机=（期望×价值）/（冲动×迟延）<br>
Motivation=（Expectancy×Value）/（Impulsiveness×Delay）<br>
-期望：相信自己完成任务的能力<br>
-价值：过程的快乐与最后的奖励<br>
-冲动：做其他事的倾向<br>
-迟延：目前到任务完成的时间（最难控制）<br>
·四方面→动机↑→拖延↓<br>
2.改善拖延的方法<br>
（1）提高期望<br>
·分解任务<br>
-写论文：查资料、草稿（引言、论证、结论）、编辑<br>
·寻求帮助<br>
-找导师，结成学习小组<br>
（2）提升价值<br>
·提高完成的奖励（选择适当的工作）<br>
·提升过程的体验（喜欢的地点、音乐、朋友）<br>
·给子任务增加奖励（小奖励、工作游戏化）<br>
（3）消除冲动<br>
·允许自己享受高密度娱乐<br>
-低密度娱乐（容易花更长时间）；高密度娱乐（产生集中精力做正事的期待）<br>
·强化、提升注意力（上节课内容）<br>
（4）运用意志力<br>
从最困难的着手（好像不太适用于我）<br>
（5）番茄工作法<br>
分解阻力，增加外部动力</p>
<p>其他：《拖延方程》，皮尔斯·斯蒂尔<br>
短期奖励，长期奖励<br>
自我损耗：随着并非最省力决定的做出，意志力消逝</p>
<h1 id="七、备考"><a class="header-anchor" href="#七、备考">¶</a>七、备考</h1>
<p>1.原理<br>
大脑不会自发备考，需要构建外部结构，即学习计划<br>
2.清楚考试时间地点，加入日历<br>
3.学习场景尽可能模拟考试场景<br>
（1）获得考试信息<br>
问老师、教学大纲；内容、时间、题量、题型、允许携带的东西<br>
（2）做练习、真题<br>
4.有效求助<br>
·自己不明白的究竟是什么<br>
·写下尝试过的方案<br>
5.快速巩固知识<br>
小抄练习<br>
6.劳逸结合</p>
<p>其他：小黄鸭调试法</p>
<h1 id="八、考试焦虑"><a class="header-anchor" href="#八、考试焦虑">¶</a>八、考试焦虑</h1>
<p>1.原因<br>
（1）重复过去失败的恐惧<br>
（2）对未知的恐惧<br>
（3）对风险的恐惧<br>
2.通用策略——写下真正导致焦虑的原因<br>
3.重复过去失败的恐惧<br>
（1）意识到自己不由过去的成败定义<br>
（2）分析过去的错误<br>
具体知识点的错误；错误的原因（准备，时长，考试时间分配，考试状态）<br>
4.对未知的恐惧<br>
·越了解，越心安<br>
-学习时模拟考试场景（知识点上、习题上、利用笔记编题目、时间、环境）<br>
5.对风险的恐惧<br>
·风险没想象那么大，逆风也可翻盘<br>
·当成一次学习机会而非审判，失败了就吸取教训</p>
<p>其他：恐惧不会被消灭<br>
焦虑暗示着，正在做的事很重要<br>
消极偏见</p>
<h1 id="九、论文与文章——写作流程"><a class="header-anchor" href="#九、论文与文章——写作流程">¶</a>九、论文与文章——写作流程</h1>
<p>1.前写作阶段<br>
（1）方法：大脑清空（脑袋里相关的东西都倒出来）<br>
（2）好处：想到大量问题和相关论点；更加集中地查资料<br>
2.查资料<br>
（1）找到资源<br>
（2）对资料进行注释<br>
相关观点、细节<br>
（3）有意识地问自己是够足够<br>
参考：主要观点至少2个来源；次要观点，间接观点至少一个来源<br>
3.写初稿<br>
放飞自我，不加审核、限制<br>
tips：初稿写在不同位置上（不同文件，不同软件）<br>
4.编辑<br>
（1）内容编辑<br>
·从整体把握文章<br>
-逻辑是否通顺<br>
-论证是否都支持论点<br>
-论证是否有资料、论证支持<br>
-有没有可以删除的<br>
（2）技术编辑<br>
①方针：识别字、句错误<br>
-字、语法错误<br>
-语句不通，意思的表达程度<br>
-结构错误<br>
②方法<br>
-打印出来，手动改<br>
-出声阅读<br>
-获得别人地反馈</p>
<p>其他：资料递归症候群<br>
写作最痛苦地问题之一——完美主义<br>
“醉着写稿，醒着编辑”</p>
<h1 id="十、锻炼身体——原因与建议"><a class="header-anchor" href="#十、锻炼身体——原因与建议">¶</a>十、锻炼身体——原因与建议</h1>
<p>1.原因：<br>
·不仅保持健康，还有利于学习<br>
（1）优化神经递质的水平<br>
（2）刺激海马体的神经干细胞产生新的神经元<br>
（3）提高神经元相互连接的能力<br>
（4）其他：提高专注和屏蔽干扰的能力；减轻压力；控制情绪<br>
2.建议<br>
（1）不要在剧烈运动过程中进行知识学习，建议在运动后后学习<br>
（2）结合起来运动<br>
-本身就有结合性，如高强度瑜伽、滑冰<br>
-先有氧，再无氧（低强度低技巧性）<br>
（3）最重要的，开始运动</p>
<p>其他：运动有各种形式与内容，找到提高自己心率的运动<br>
大脑的学习能力，随着运动一起进化<br>
海鞘（qiao，四声）吃掉自己的脑子<br>
“我们所称的“思考”是进化对运动的内化”<br>
用进废退<br>
BDNF——脑源性神经营养因子、长时程增强的过程</p>
]]></content>
      <categories>
        <category>十分钟速成课</category>
      </categories>
      <tags>
        <tag>b站视频</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实践-DIYTomcat</title>
    <url>/2020/06/23/Java%E5%AE%9E%E8%B7%B5-DIYTomcat/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>源代码</tag>
        <tag>Java实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记【求知课堂】（一）</title>
    <url>/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>网址：<a href="https://www.bilibili.com/video/av76235341" target="_blank" rel="noopener">https://www.bilibili.com/video/av76235341</a></strong></p>
<p>【P1-P12】</p>
<a id="more"></a>
<h1 id="零、入门"><a class="header-anchor" href="#零、入门">¶</a>零、入门</h1>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/1.png" alt></p>
<h1 id="一、Java语言概述"><a class="header-anchor" href="#一、Java语言概述">¶</a>一、Java语言概述</h1>
<h2 id="1-1基础常识"><a class="header-anchor" href="#1-1基础常识">¶</a>1.1基础常识</h2>
<h3 id="软件开发"><a class="header-anchor" href="#软件开发">¶</a>软件开发</h3>
<p>​        软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有<strong>系统软件</strong>和<strong>应用软件</strong>之分。</p>
<h3 id="人机交互方式"><a class="header-anchor" href="#人机交互方式">¶</a>人机交互方式</h3>
<p>​        图形化界面(Graphical User Interface GUI)这种方式简单直观，使用者易于接受，容易上手操作。<br>
​        命令行方式(Command Line Interface CLI)：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。</p>
<h3 id="常用的DOS命令"><a class="header-anchor" href="#常用的DOS命令">¶</a>常用的DOS命令</h3>
<p><strong>打开DOS界面：按win+R，输入cmd，回车即可进入</strong></p>
<p>注意:在输入dos命令时，要使用英文输入，所有标点都有是英文<br>
d:<br>
这冒号是英文</p>
<p><code>dir</code> :    列出当前目录下的文件以及文件夹<br>
<code>md</code> :   创建目录<br>
<code>rd</code> :     删除目录<br>
<code>cd</code> :    进入指定目录<br>
<code>cd..</code> :  退回到上一级目录<br>
<code>cd\</code>:    退回到根目录<br>
<code>del</code> :    删除文件<br>
<code>exit</code> :   退出 dos 命令行</p>
<h2 id="1-2-Java语言概述"><a class="header-anchor" href="#1-2-Java语言概述">¶</a>1.2 Java语言概述</h2>
<h3 id="什么是计算机语言"><a class="header-anchor" href="#什么是计算机语言">¶</a>什么是计算机语言</h3>
<p>​        语言：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，英国人要学习中文。<br>
<strong>计算机语言：人与计算机交流的方式。</strong><br>
​     如果人要与计算机交流，那么就要学习计算机语言。<br>
​     计算机语言有很多种，如：C，C++，Java，python，PHP等。</p>
<p><strong>第一代语言</strong><br>
打孔机——纯机器语言<br>
<strong>第二代语言</strong><br>
汇编<br>
<strong>第三代语言</strong><br>
C、Pascal、Fortran面向过程的语言<br>
C++面向过程/面向对象<br>
Java跨平台的纯面向对象的语言<br>
.NET跨语言的平台</p>
<h3 id="Java技术体系平台"><a class="header-anchor" href="#Java技术体系平台">¶</a>Java技术体系平台</h3>
<table>
<thead>
<tr>
<th><strong>Java</strong> <strong>SE</strong>(Java Standard Edition)标准版</th>
</tr>
</thead>
<tbody>
<tr>
<td>支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为<strong>J2SE</strong></td>
</tr>
<tr>
<td><strong>Java</strong> <strong>EE(Java Enterprise Edition)企业版</strong></td>
</tr>
<tr>
<td>是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为<strong>J2EE</strong></td>
</tr>
<tr>
<td><strong>Java</strong> <strong>ME(Java Micro Edition)小型版</strong></td>
</tr>
<tr>
<td>支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为<strong>J2ME</strong></td>
</tr>
<tr>
<td><strong>Java Card</strong></td>
</tr>
<tr>
<td>支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台</td>
</tr>
</tbody>
</table>
<h2 id="1-3-Java语言运行机制及运行过程"><a class="header-anchor" href="#1-3-Java语言运行机制及运行过程">¶</a>1.3  Java语言运行机制及运行过程</h2>
<h3 id="Java语言的特点"><a class="header-anchor" href="#Java语言的特点">¶</a>Java语言的特点</h3>
<p>特点一：面向对象   女朋友才叫对象<br>
两个基本概念：类、对象<br>
三大特性：封装、继承、多态</p>
<p>面向过程，例如张三打篮球，还有再做一个李四踢足球的程序？</p>
<p>面向对象，人的对象，人的运动的动作，运动的器械这三个对象，<br>
实例化一个张三的对象，对象有一个打篮球的动作，器械是篮球<br>
实例化一个李四的对象，对象有一个踢足球的动作，器械是足球</p>
<p>面向对象能够更好的在抽象的层面来分析问题，在程序实现跨越极大的赋予之前的代码<br>
这些是面向过程编程很难实现的</p>
<p>特点二：健壮性 完善性<br>
吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制</p>
<p>特点三：跨平台性  jvm<br>
跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write 	once , Run Anywhere”，一次编写，处处运行<br>
原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/%E8%B7%A8%E5%B9%B3%E5%8F%B0.png" alt></p>
<h3 id="Java两种核心机制"><a class="header-anchor" href="#Java两种核心机制">¶</a>Java两种核心机制</h3>
<p>Java虚拟机（Java Virtal Machine），JVM</p>
<p>​		JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。<br>
​		对于不同的平台，有不同的虚拟机。<br>
​		Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/2.png" alt></p>
<p><strong>垃圾收集机制（Garbage Collection），GC</strong></p>
<p>​        不再使用的内存空间应回收—— 垃圾回收。<br>
​		在C/C++等语言中，由程序员负责回收无用内存。<br>
​		Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。<br>
​		垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</p>
<p>c，c++，由程序员回收，手动编写代码回收（优点：能够在内存不使用时快速回收，准确高效；缺点：容易失误出现bug，例如忘记编写回收内存的代码？内存一直不回收）</p>
<p>java，垃圾回收是自动，开了一个习题集线程自动去检测哪些内存不用了然后回收掉（优点：自动的，意味着不会出现忘记回收；缺点：回收不及时）</p>
<p>一般的观点是，宁可回收不及时但是一定要回收，使用自动的垃圾回收更合适</p>
<h2 id="1-4-Java语言的环境搭建"><a class="header-anchor" href="#1-4-Java语言的环境搭建">¶</a>1.4 Java语言的环境搭建</h2>
<h3 id="下载-JDK、安装-JDK"><a class="header-anchor" href="#下载-JDK、安装-JDK">¶</a>下载 JDK、安装 JDK</h3>
<p><strong>官方网址：</strong><br>
<strong><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/index.html</a></strong><br>
安装JDK<br>
傻瓜式安装，下一步即可。<br>
建议：安装路径不要有中文或者特殊符号如空格等。<br>
当提示安装 JRE 时，可以选择不安装。</p>
<p><strong>推荐下载</strong>绿色压缩版JDK，解压使用<br>
<strong>链接：<a href="https://pan.baidu.com/s/1-gzYKrnW7IvUhGOBDl7J0g" target="_blank" rel="noopener">https://pan.baidu.com/s/1-gzYKrnW7IvUhGOBDl7J0g</a></strong><br>
提取码：1bm4<br>
这个jdk是32位</p>
<p>​		正规的开发工作中，你之前的工作要求统一1.6.0.102，之后换了一个项目组，这个项目组要求使用1.8.0.1_103<br>
可以先卸载掉前面的jdk，根据需要安装新的jdk</p>
<p>​		你做技术核心同时支持3个项目，这3个项目分别使用不同版本的jdk</p>
<p>​		正确的打开方式是？就是使用压缩版的jdk，根据情况解压不同版本来使用</p>
<h3 id="配置环境变量"><a class="header-anchor" href="#配置环境变量">¶</a>配置环境变量</h3>
<p><strong>设置JAVA_HOME</strong><br>
解压jdk的目录</p>
<p><strong>设置CLASSPATH</strong><br>
.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</p>
<p><strong>在path中加入两个新的配置</strong><br>
%JAVA_HOME%\bin<br>
%JAVA_HOME%\jre\bin</p>
<h3 id="验证是否成功：java-version"><a class="header-anchor" href="#验证是否成功：java-version">¶</a>验证是否成功：java -version</h3>
<h3 id="什么是JDK，JRE"><a class="header-anchor" href="#什么是JDK，JRE">¶</a>什么是JDK，JRE</h3>
<table>
<thead>
<tr>
<th><strong>JDK(Java Development Kit  Java开发工具包)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。 其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等</td>
</tr>
<tr>
<td><strong>JRE(Java Runtime Environment  Java运行环境)</strong></td>
</tr>
<tr>
<td>包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要<strong>运行</strong>一个开发好的Java程序，计算机中只需要安装JRE即可。</td>
</tr>
</tbody>
</table>
<p>简单而言，使用JDK的开发工具完成的java程序，交给JRE去运行。</p>
<h3 id="JVM、JRE、JDK-关系"><a class="header-anchor" href="#JVM、JRE、JDK-关系">¶</a>JVM、JRE、JDK 关系</h3>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE%E7%89%871.png" alt></p>
<h2 id="1-5-开发体验-—-HelloWorld"><a class="header-anchor" href="#1-5-开发体验-—-HelloWorld">¶</a>1.5 开发体验 — HelloWorld</h2>
<p><strong>步骤：</strong><br>
将 Java 代码编写到扩展名为 .java 的文件中。<br>
通过 javac 命令对该 java 文件进行编译。<br>
通过 java 命令对生成的 class 文件进行运行。</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE%E7%89%872.png" alt></p>
<p>Test.java文件代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*文档注释</span><br><span class="line">*这是一个打印hello world的类</span><br><span class="line">*@author lby</span><br><span class="line">*@version 1.0.0</span><br><span class="line">*&#x2F;</span><br><span class="line">public class Test&#123;</span><br><span class="line">        public static void main(String[] args)&#123;</span><br><span class="line">	&#x2F;&#x2F;单行注释，打印helloworld</span><br><span class="line">                System.out.print(&quot;hello world\n&quot;);</span><br><span class="line">	System.out.print(&quot;abc&quot;);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	多行注释</span><br><span class="line">	下面准备写一个打印abc的程序</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;&#x2F;System.out.print(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;*System.out.print(&quot;abc&quot;);</span><br><span class="line">	System.out.print(&quot;abc&quot;);</span><br><span class="line">	System.out.print(&quot;abc&quot;);*&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DOS中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac Test.java</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java Test</span><br></pre></td></tr></table></figure>
<h2 id="1-6-小结第一个程序"><a class="header-anchor" href="#1-6-小结第一个程序">¶</a>1.6 小结第一个程序</h2>
<p>​		Java源文件以“java”为扩展名。源文件的基本组成部分是类（class），如本类中的Test类。<br>
​		Java应用程序的执行入口是main()方法。它有固定的书写格式：<code>public static void main(String[] args)  {...}</code><br>
​		Java语言严格区分大小写。<br>
​		Java方法由一条条语句构成，每个语句以“;”结束。<br>
​		括号都是成对出现的，缺一不可。</p>
<h2 id="1-7-常见问题及解决方法"><a class="header-anchor" href="#1-7-常见问题及解决方法">¶</a>1.7 常见问题及解决方法</h2>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE%E7%89%873.png" alt></p>
<p>源文件名不存在或者写错，或者当前路径错误。</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE%E7%89%874.png" alt></p>
<p>类文件名写错，或者类文件不在当前路径下，或者不在classpath指定路径下。</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE%E7%89%875.png" alt></p>
<p>声明为public的主类应与文件名一致，否则编译失败</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE%E7%89%876.png" alt></p>
<p>编译失败，注意错误出现的行数，再到源代码中指定位置改错</p>
<h2 id="1-8-注-释"><a class="header-anchor" href="#1-8-注-释">¶</a>1.8 注  释</h2>
<p>​		用于注解说明解释程序的文字就是注释。<br>
​		提高了代码的阅读性；调试程序的重要方法。<br>
​		Java中的注释类型：<br>
​				单行注释   //<br>
​				多行注释/* */<br>
​				文档注释（java特有）<br>
​		注释是一个程序员必须要具有的良好编程习惯。<br>
​		将自己的思想通过注释先整理出来，再用代码去体现</p>
<p><strong>注：</strong><br>
对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。<br>
多行注释里面不允许有多行注释嵌套。</p>
<p>文档注释（java特有）<br>
格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*@author  指定java程序的作者</span><br><span class="line">*@version  指定源文件的版本</span><br><span class="line">*@param   方法的参数说明信息</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<p>注释内容可以被JDK提供的工具 <code>javadoc</code> 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
<h2 id="知识回顾"><a class="header-anchor" href="#知识回顾">¶</a>知识回顾</h2>
<p>●  JDK,JRE,JVM的关系。</p>
<p>●  环境变量path配置及其作用。</p>
<p>●  Java程序的编写、编译、运行步骤。</p>
<p>●  Java程序编写的规则。</p>
<p>●  在配置环境、编译、运行各个步骤中常见的错误以及解决方法。</p>
<p>●  注释</p>
]]></content>
      <categories>
        <category>求知课堂</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>b站视频</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实践-天猫前端</title>
    <url>/2020/06/23/Java%E5%AE%9E%E8%B7%B5-%E5%A4%A9%E7%8C%AB%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>源代码</tag>
        <tag>Java实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实践-天猫整站J2EE</title>
    <url>/2020/06/23/Java%E5%AE%9E%E8%B7%B5-%E5%A4%A9%E7%8C%AB%E6%95%B4%E7%AB%99J2EE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>源代码</tag>
        <tag>Java实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实践-天猫整站SSM</title>
    <url>/2020/06/23/Java%E5%AE%9E%E8%B7%B5-%E5%A4%A9%E7%8C%AB%E6%95%B4%E7%AB%99SSM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>源代码</tag>
        <tag>Java实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实践-天猫整站Springboot</title>
    <url>/2020/06/23/Java%E5%AE%9E%E8%B7%B5-%E5%A4%A9%E7%8C%AB%E6%95%B4%E7%AB%99Springboot/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>源代码</tag>
        <tag>Java实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实践-天猫整站SSH</title>
    <url>/2020/06/23/Java%E5%AE%9E%E8%B7%B5-%E5%A4%A9%E7%8C%AB%E6%95%B4%E7%AB%99SSH/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>源代码</tag>
        <tag>Java实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实践-趋势投资</title>
    <url>/2020/06/23/Java%E5%AE%9E%E8%B7%B5-%E8%B6%8B%E5%8A%BF%E6%8A%95%E8%B5%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>源代码</tag>
        <tag>Java实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实践-一本糊涂账</title>
    <url>/2020/06/23/Java%E5%AE%9E%E8%B7%B5-%E4%B8%80%E6%9C%AC%E7%B3%8A%E6%B6%82%E8%B4%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>链接：<a href="https://how2j.cn/k/hutubill/hutubill-tutorials/710.html?p=154642" target="_blank" rel="noopener">https://how2j.cn/k/hutubill/hutubill-tutorials/710.html?p=154642</a></strong></p>
<a id="more"></a>]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>源代码</tag>
        <tag>Java实践</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-IP详解</title>
    <url>/2020/06/25/TCP-IP%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>链接：<a href="https://wws.lanzous.com/b01bibjsj" target="_blank" rel="noopener">https://wws.lanzous.com/b01bibjsj</a></strong><br>
<strong>密码:1ail</strong></p>
<a id="more"></a>]]></content>
      <categories>
        <category>TCP|IP详解</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>电子书</tag>
      </tags>
  </entry>
  <entry>
    <title>【日语入门初级】从零开始学日语</title>
    <url>/2020/07/11/%E3%80%90%E6%97%A5%E8%AF%AD%E5%85%A5%E9%97%A8%E5%88%9D%E7%BA%A7%E3%80%91%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%97%A5%E8%AF%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>地址：<a href="https://www.bilibili.com/video/BV1Bp4y1D747" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Bp4y1D747</a></strong></p>
<a id="more"></a>
<iframe src="//player.bilibili.com/player.html?aid=968547402&bvid=BV1Bp4y1D747&cid=203772603&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<h1 id="【阿飞老师】新版标准日本语精讲合集——配套练习"><a class="header-anchor" href="#【阿飞老师】新版标准日本语精讲合集——配套练习">¶</a>【阿飞老师】新版标准日本语精讲合集——配套练习</h1>
<h2 id="第一单元："><a class="header-anchor" href="#第一单元：">¶</a>第一单元：</h2>
<p>1、你的爱好是什么？</p>
<p>2、这位是我的朋友吉田。</p>
<p>3、小李是JC策划公司的职员。</p>
<p>4、墙上有开关。</p>
<p>5、那是谁的电脑？</p>
<p>6、对话题</p>
<p>A:这件衬衫多少钱？</p>
<p>B:那件衬衫3605元。</p>
<p>（写出3605元的平假名）</p>
<p>7、对话题</p>
<p>A:张先生是北京人吗？</p>
<p>B:不，不是。我是上海人。</p>
<p>8、打扰一下，这个多少钱？那个多少钱？那个多少钱？</p>
<p>9、盘子里有三文鱼。</p>
<p>10、判断题</p>
<p>公園に佐藤さんがあります。</p>
<p>这句话对还是错？说出原因</p>
<p>11、猫在桌子上面。</p>
<p>12、对话题</p>
<p>A:你外祖父家在哪里？</p>
<p>B:在那里，那个公园的旁边。</p>
<p>13、包里有一件衣服和一块手帕。</p>
<p>14、对话题</p>
<p>A:你周三在家吗？</p>
<p>B:我周三不在家，周四在家。</p>
<p>15、对话题</p>
<p>A:不好意思打扰一下、请问洗手间在哪里？</p>
<p>B:在百货商场的三楼。</p>
<p>16、咖啡店的左边是一家西餐厅。</p>
<p>17、这本书是一千五百日元吗？还是一千三百日元？</p>
<p>（写出1500、1300的平假名）</p>
<p>18、对话题</p>
<p>A:森先生是日本人吗？</p>
<p>B:是的。</p>
<p>19、桌子下面有一只狗。</p>
<p>20、読解</p>
<p>木下:鈴木さんは一人暮らしですか。</p>
<p>鈴木:はい、そうです。木下さんは？</p>
<p>木下:私は母と一緒に暮らしています。</p>
<p>鈴木:そうですか。じゃあ、ご兄弟はどこですか。</p>
<p>木下:兄は東京にいます。</p>
<p>問題：木下さんの家族は何人ですか。</p>
<h2 id="第二单元"><a class="header-anchor" href="#第二单元">¶</a>第二单元</h2>
<p>1、对话题</p>
<p>A：小王，你几点起床的？</p>
<p>B：6点。</p>
<p>2、我和同学在公园里一起玩捉迷藏。</p>
<p>3、星期一到星期五我没有上班。</p>
<p>4、我在东京见到了马先生。</p>
<p>5、昨天6点，我直接回家了。</p>
<p>6、日译汉</p>
<p>私は毎週、日本語で日記を書きます。</p>
<p>7、家人给了我温暖。</p>
<p>8、对话题</p>
<p>A：今天的晚饭吃寿司吗？</p>
<p>B：不，今天的晚饭吃寿喜锅。</p>
<p>9、简述题</p>
<p>请简述“何”在哪些助词前读“なに”哪些助词前读“なん”。</p>
<p>10、我打算乘飞机去美国。</p>
<p>11、劳驾，请让田中先生接个电话。</p>
<p>12、星野先生去年在奈良邂逅了森小姐。</p>
<p>13、小王用日语给大学老师写了一封信，信是用航空邮件寄的。</p>
<p>14、对话题</p>
<p>（1）田中先生向森先生借了一辆自行车。</p>
<p>（2）森先生借给田中先生一辆自行车。</p>
<p>15、判断<br>
丸ちゃんは学校にパンフレットをもらいました。<br>
请问这句话是否正确？如果正确，请说明理由。</p>
<p>16、我7月20号到8月5号在大阪。</p>
<p>17、日译汉</p>
<p>私はおばあさんにスイカをもらいました。</p>
<p>18、以前，我从斋藤先生那里得到过恩惠。</p>
<p>19、对话题</p>
<p>A:请给我一张13点15分发车去名古屋的车票。</p>
<p>B:好的。您是要吸烟席还是要禁烟席？</p>
<p>A:要禁烟席。</p>
<p>20、読解</p>
<p>李さんはスポーツが 好きです。毎日、学校の運動場で友達とサッカーをします。５時半から６時半ごろまで、１時間ぐらいやります。李さんは 映画も 好きです。日曜日に友達と映画館で映画を見ます。家で友達と映画のDVDも見ます。先週、初めて日本の映画を見ました。でも、日本語は難しいです。李さんはまだ日本語を話すことができません。</p>
<p>問題：李さんは毎日友達と何(なに)をしますか。</p>
<h2 id="第三单元："><a class="header-anchor" href="#第三单元：">¶</a>第三单元：</h2>
<p>1、对话题</p>
<p>A：今天的作业用笔写吗？</p>
<p>B：不，今天的作业用电脑写。</p>
<p>2、对话题</p>
<p>A：小徐，你日语说的真不错。</p>
<p>B：谢谢夸奖，不过还差的很远。</p>
<p>3、对不起，那是我的座位……</p>
<p>4、日译汉</p>
<p>李さんは王さんほど親切ではありません。</p>
<p>5、对话题</p>
<p>A：这件衣服怎么样？</p>
<p>B：再大一点的好。</p>
<p>6、对话题</p>
<p>A:小野，你经常听歌吗？</p>
<p>B:不，我偶尔才听歌。</p>
<p>7、比起山，我更喜欢大海。</p>
<p>8、改错题<br>
A:休みの日に図書館で難しいの本を読みました。<br>
B:そうですか、私の家にも難しいのがあります。<br>
明日、私はの家に来ませんか。一緒にその難しいのを読みましょう。</p>
<p>9、日译汉</p>
<p>きのうのフランス料理はあまりおいしくなかったです。</p>
<p>10、她不喜欢喝可乐，但是喜欢喝意式浓缩咖啡。</p>
<p>11、明天下午三点，我们教室有会议。</p>
<p>12、在各种动漫中，我最喜欢航海王。</p>
<p>13、小王给我一本书。我从小王那里得到一本书。</p>
<p>14、对话题</p>
<p>A：日语和英语哪个难学？</p>
<p>B：日语难学</p>
<p>15、我在公园见到了小王。</p>
<p>16、9月份没有8月份那么热。</p>
<p>17、改错题</p>
<p>A:これは  何の  お茶ですか。</p>
<p>B:ちょっと  甘いお茶です。</p>
<p>18、他果然更喜欢猫。</p>
<p>19、因为小王不擅长英语，每天都在学习英语。</p>
<p>20、読解<br>
みなさん、こんにちは。ここは北海道です。北海道は日本の北にあります。冬はとても寒いです。雪がたくさん降ります。<br>
これはわたしたちの学校の前にある大きな池です。とてもきれいです。冬は池がスケート場です。夏には 毎日水泳の練習をします。みんな 水泳が得意です。<br>
わたしたちはよく外で勉強します。自然を見たり、町の人に北海道の歴史や文化の話を聞いたりします。ときどき山へ行って、動物を観察します。教室で勉強するより外で勉強するほうがおもしろいです。みなさんも北海道へ遊びに来ませんか。</p>
<p>問題：北海道は  どんな ところですか。</p>
<h2 id="第四单元："><a class="header-anchor" href="#第四单元：">¶</a>第四单元：</h2>
<p>1、三本杂志多少钱？</p>
<p>2、可以带走这里的资料吗？</p>
<p>3、我习惯喝杯咖啡然后再工作。</p>
<p>4、日译汉</p>
<p>仕事で  大変疲れたから、  どこへも  行きたくない。</p>
<p>5、小林每天早晨7点离开家。</p>
<p>6、小野女士现在正在看报纸。</p>
<p>7、我喜欢吃日本料理，一个月吃两次。</p>
<p>8、日译汉<br>
姉は  結婚してから、  ずっと  海外に  住んでいます。</p>
<p>9、我先打扫房间，再洗衣服。</p>
<p>10、劳驾，请帮我复印这份文件。</p>
<p>11、从家到公司单程需要2个小时，并且中途还得转一次车。</p>
<p>12、请好好休息一下，别太累了。</p>
<p>13、下班后日本人经常去居酒屋喝酒。</p>
<p>14、吉田科长现在在小酒馆喝着啤酒。</p>
<p>15、长泽先生住在东京的郊外。</p>
<p>16、他总是带着书，上了电车后必定要看书。</p>
<p>17、外祖母个子不怎么高却很有精神。</p>
<p>18、对不起，请把这个包裹寄到中国。</p>
<p>19、我学了三个月中文，但还不太会说。</p>
<p>20、読解</p>
<p>西安は大きい町です。ビルや車や人が多くて、にぎやかです。首都の北京からちょっと遠いですが、 新幹線がありますから、便利です。<br>
西安には名所旧跡がたくさんありますから、観光に来られた人々が (前来观光的人们)たくさんいます。  西安には国際空港が一つあります。この空港は西安の隣の町咸陽にあります。<br>
問題：西安はどんな町ですか。</p>
<h2 id="第五单元："><a class="header-anchor" href="#第五单元：">¶</a>第五单元：</h2>
<p>1、每天必须吃早餐。</p>
<p>2、日译汉<br>
ネットで飛行機のチケットを買うことができます。</p>
<p>3、他的日语越来越熟练了。</p>
<p>4、一起去郊游怎么样？</p>
<p>5、睡觉前不宜进食。</p>
<p>6、日译汉</p>
<p>家のあたりはやはり静かなほうがいいです。</p>
<p>7、我特别想去西藏旅游。</p>
<p>8、这里不能停车。</p>
<p>9、我将来想成为一名医生。</p>
<p>10、吉田先生会打高尔夫球。</p>
<p>11、长泽先生是医生吧？</p>
<p>12、吃饭前要先洗手。</p>
<p>13、暑假想做点什么。</p>
<p>14、我的梦想是能做出美味的饭菜。</p>
<p>15、工作还是忙一点好。</p>
<p>16、请不要忘记大学里的美好时光。</p>
<p>17、下班后一起去公园散步吧。</p>
<p>18、小李买了一条漂亮的围巾，我也想要。</p>
<p>19、你来中国前学过汉语吗？</p>
<p>20、読解<br>
来週の日曜日は日本語能力試験があります。試験は午前九時から十二時までです。でも、八時半に教室に入らなければなりません。家からちょっと遠いですから、朝の六時半に起きなければなりません。答えを鉛筆で書かなければなりませんので、絶対鉛筆を持たなければなりません。</p>
<p>文章の内容に合っているものは次のどれですか。</p>
<p>A  試験は  ８時半からです。<br>
B  試験は  １２時からです。<br>
C  答えは  ボールペンで書いてもいいです。<br>
D  答えは  鉛筆で書かなくてはいけません。</p>
<h2 id="第六单元："><a class="header-anchor" href="#第六单元：">¶</a>第六单元：</h2>
<p>1、我周末经常看看电影，听听音乐。</p>
<p>2、关于日本音乐，你怎么看？</p>
<p>3、对话题</p>
<p>A:这个车和那个车，哪个车型好看？</p>
<p>B:那个红色的好看。</p>
<p>4、浴衣有贵的，有便宜的，种类很多。</p>
<p>5、放暑假后一起去游泳吧。</p>
<p>6、周末和同学去展览馆，你去吗？</p>
<p>7、阿飞老师有时可爱，有时帅气。</p>
<p>8、我觉得她很善良。</p>
<p>9、我想去徐家汇，要怎么走？</p>
<p>10、A:昨天为什么没有学习？  B:我去玩了。</p>
<p>11、我不知道明天会不会下雪。</p>
<p>12、对话题</p>
<p>A:下周的会议开吗？</p>
<p>B:不，不开。</p>
<p>13、考试前还是先看看书比较好。</p>
<p>14、日译汉</p>
<p>交通銀行へ行きたいんですが、どうやって行きますか。</p>
<p>15、简述题</p>
<p>一类形容词的简体形后面能不能加“だ”？为什么？</p>
<p>16、A:陈小姐在京都工作过吗？  B:不，没有。</p>
<p>17、我忘了去年在哪里旅行过了。</p>
<p>18、对话题</p>
<p>A:下班后一起去泡温泉吧？</p>
<p>B:不好意思，我不太方便……</p>
<p>19、田中老师的兴趣是制作点心。</p>
<p>20、読解<br>
[端午の節句]、または[菖蒲の節句]などといい、現在では新暦の５月５日に行われ、３月の[桃の節句]に対して男の子の節句ということになっている。男の子のいる家では鯉のぼりを立って、武者人形を飾ったり、菖蒲湯に入ったりする。この行事は中国で始まったもので、各地では菖蒲酒を飲み、ヨモギを門に飾り、邪気払いをする。これは日本に伝わって、今では[子供の日]になる。</p>
<p>問題(1) 、日本では５月5日は何の祝日ですか。</p>
<p>問題(2) 、文章の内容に合っているものは次のどれですか。<br>
Ａ、 日本では５月５日に家で鯉のぼりを立ってる。<br>
Ｂ、  日本では５月５日に家で武士人形を飾る。<br>
C、   日本では５月５日に女の子のいる家で菖蒲酒を飲む。<br>
D、   日本では５月５日に男の子のいる家で菖蒲酒を飲む。</p>
]]></content>
      <categories>
        <category>阿飞老师</category>
      </categories>
      <tags>
        <tag>b站视频</tag>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL必知必会</title>
    <url>/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>电子书下载：<a href="https://wws.lanzous.com/b01bibcod" target="_blank" rel="noopener">https://wws.lanzous.com/b01bibcod</a><br>
密码:1a56</strong></p>
<p>《MySQL必知必会》 涵盖 《SQL必知必会》的内容</p>
<a id="more"></a>
<h1 id="自学网址："><a class="header-anchor" href="#自学网址：">¶</a>自学网址：</h1>
<h2 id="【面试必会】mysql数据库优化全剖析"><a class="header-anchor" href="#【面试必会】mysql数据库优化全剖析">¶</a>【面试必会】mysql数据库优化全剖析</h2>
<p><a href="https://www.bilibili.com/video/av68811608?rt=V%2FymTlOu4ow%2Fy4xxNWPUZ%2FjcmW8%2FytWCfhEOBVyQXqI%3D" target="_blank" rel="noopener">https://www.bilibili.com/video/av68811608?rt=V%2FymTlOu4ow%2Fy4xxNWPUZ%2FjcmW8%2FytWCfhEOBVyQXqI%3D</a></p>
<h2 id="【黑马程序员】2020最新MySQL高级教程（求职面试必备）【源码-笔记】"><a class="header-anchor" href="#【黑马程序员】2020最新MySQL高级教程（求职面试必备）【源码-笔记】">¶</a>【黑马程序员】2020最新MySQL高级教程（求职面试必备）【源码+笔记】</h2>
<p><a href="https://www.bilibili.com/video/BV1UQ4y1P7Xr?from=search&amp;seid=15035805241660387777" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1UQ4y1P7Xr?from=search&amp;seid=15035805241660387777</a></p>
<h2 id="2020最新，一天学会-MySQL-数据库"><a class="header-anchor" href="#2020最新，一天学会-MySQL-数据库">¶</a>2020最新，一天学会 MySQL 数据库</h2>
<p><a href="https://www.bilibili.com/video/BV1BZ4y1H7LZ?from=search&amp;seid=15035805241660387777" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1BZ4y1H7LZ?from=search&amp;seid=15035805241660387777</a></p>
<h2 id="MySQL-基础-高级篇-数据库-sql-尚硅谷"><a class="header-anchor" href="#MySQL-基础-高级篇-数据库-sql-尚硅谷">¶</a>MySQL 基础+高级篇- 数据库 -sql -尚硅谷</h2>
<p><a href="https://www.bilibili.com/video/BV12b411K7Zu?from=search&amp;seid=15035805241660387777" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12b411K7Zu?from=search&amp;seid=15035805241660387777</a></p>
<h2 id="MySQL-8-0-19安装教程-windows-64位-Navicat破解安装教程"><a class="header-anchor" href="#MySQL-8-0-19安装教程-windows-64位-Navicat破解安装教程">¶</a>MySQL 8.0.19安装教程(windows 64位)+ Navicat破解安装教程</h2>
<p><a href="https://www.bilibili.com/read/cv5652639?spm_id_from=333.788.b_636f6d6d656e74.20" target="_blank" rel="noopener">https://www.bilibili.com/read/cv5652639?spm_id_from=333.788.b_636f6d6d656e74.20</a></p>
<h2 id="MYSQL复习宝典-edf"><a class="header-anchor" href="#MYSQL复习宝典-edf">¶</a>MYSQL复习宝典.edf</h2>
<p><a href="https://pan.baidu.com/s/1jTS7zAXB9Yh1Hwteh4Dv5g" target="_blank" rel="noopener">https://pan.baidu.com/s/1jTS7zAXB9Yh1Hwteh4Dv5g</a></p>
<h1 id="书本笔记："><a class="header-anchor" href="#书本笔记：">¶</a>书本笔记：</h1>
<h2 id="一、软件安装"><a class="header-anchor" href="#一、软件安装">¶</a>一、软件安装</h2>
<p>1.先去官网下载</p>
<p><strong>链接：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></strong></p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%851.png" alt></p>
<p>2.下载完后解压，解压完后就是这个样子的：</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%852.png" alt></p>
<p>3.配置初始化的my.ini文件的文件</p>
<p>可以看到这个时候我们是没有my.ini文件的，没关系可以自行创建在安装根目录下添加的my.ini（新建文本文件，将文件类型改为的.ini），写入基本配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># 设置3306端口</span><br><span class="line"></span><br><span class="line">port&#x3D;3306</span><br><span class="line"></span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line"></span><br><span class="line">basedir&#x3D;D:\\MySQL\\mysql-8.0.20-winx64\\mysql-8.0.20-winx64</span><br><span class="line"></span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line"></span><br><span class="line">datadir&#x3D;D:\\MySQL\\mysql-8.0.20-winx64\\mysql-8.0.20-winx64\\Data</span><br><span class="line"></span><br><span class="line"># 允许最大连接数</span><br><span class="line"></span><br><span class="line">max_connections&#x3D;200</span><br><span class="line"></span><br><span class="line"># 允许连接失败的次数。</span><br><span class="line"></span><br><span class="line">max_connect_errors&#x3D;10</span><br><span class="line"></span><br><span class="line"># 服务端使用的字符集默认为utf8mb4</span><br><span class="line"></span><br><span class="line">character-set-server&#x3D;utf8mb4</span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line"></span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line"></span><br><span class="line"># 默认使用“mysql_native_password”插件认证</span><br><span class="line"></span><br><span class="line">#mysql_native_password</span><br><span class="line"></span><br><span class="line">default_authentication_plugin&#x3D;mysql_native_password</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"></span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line"></span><br><span class="line">default-character-set&#x3D;utf8mb4</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"></span><br><span class="line"># 设置mysql客户端连接服务端时默认使用的端口</span><br><span class="line"></span><br><span class="line">port&#x3D;3306</span><br><span class="line"></span><br><span class="line">default-character-set&#x3D;utf8mb4</span><br></pre></td></tr></table></figure>
<p><strong>以上标记的路径，是系统默认路径，可改为你自己的安装路径。 注意：my.ini文件中路径使用\\，里面不可以有空行(不过有些是/)。</strong></p>
<p>配置文件中的路径要和实际存放的路径一致（8.0.19不要手动创建Data文件夹）</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%853.png" alt></p>
<p>4.初始化MySQL</p>
<p>在安装时，避免权限问题出错我们尽量使用管理员身份运行CMD，否则在安装时会报错，会导致安装失败的情况 点击开始，直接搜索cmd，并且以管理员身份打开</p>
<p><strong>点击开始，直接搜索cmd，并且以管理员身份打开</strong></p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%854.png" alt></p>
<p>打开后进入mysql的bin目录</p>
<p><strong>安装在D盘的小伙伴注意了！！！我们的转盘是先输入D：，再输入cd空格加上bin目录的路径，如图：</strong></p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%855.png" alt></p>
<p>在MySQL目录下的bin目录下执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure>
<p>这里可能会出现如下问题，不要慌，安装一个微软常用运行库合集2018就OK啦，<a href="https://wws.lanzous.com/b01big1yh" target="_blank" rel="noopener">请自行下载</a>。密码:8kaa</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%856.png" alt></p>
<p>如果安装完成还是出现此情况：</p>
<p>试一下这个</p>
<p><strong><a href="https://cn.dll-files.com/vcruntime140_1.dll.html" target="_blank" rel="noopener">https://cn.dll-files.com/vcruntime140_1.dll.html</a></strong></p>
<p>然后下载Version 14.23，最后把vcruntim140_1.dll复制到C：\windows\system32</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%857.png" alt></p>
<p>如果你是第二次安装mysql的话，看看有没有卸载干净</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%858.png" alt></p>
<p><strong>注意！</strong></p>
<p>[注意] [MY-010454] [服务器]为root @ localhost生成临时密码：Ls&amp;W&lt;ko.N41g</p>
<p>其中root @ localhost：后面的Ls&amp;W&lt;ko.N41g就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。复制密码先保存起来!!!</p>
<p>5.安装MySQL服务 + 启动MySQL 服务</p>
<p><strong>安装mysql服务</strong></p>
<p>执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --install [服务名]           ###（服务名可以不加默认为mysql）</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%859.png" alt></p>
<p>成功了！</p>
<p>服务安装成功之后通过命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>
<p>来启动Mysql服务</p>
<p>想关闭Mysql服务可通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>
<p>来关闭Mysql服务</p>
<p>6.连接MySQL + 修改密码</p>
<p>相信大家都有的Navicat，小海豚等数据库图形化工具</p>
<p>没有我们去Navicat官网下一个（可以免费使用14天的！同样我们可以破解）</p>
<p>获取Navicat Premium 12和其对应的破解工具(现在官网只有Navicat 15)</p>
<p><strong>官网地址(<a href="https://www.navicat.com.cn/download/navicat-premium" target="_blank" rel="noopener">https://www.navicat.com.cn/download/navicat-premium</a>)</strong></p>
<p>备注：想下载Navicat Premium 15的小伙伴可以参考(Navicat Premium15安装与破解)。 MySQL的服务已经开启了就直接打开的Navicat去连接</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%8510.png" alt></p>
<p>打开软件后可以先不用管它，不需要使用注册机</p>
<p>先下载Navicat Premium 12的破解补丁</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%8511.png" alt></p>
<p>请根据自己安装Navicat Premium 12的语言（简体中文、繁体中文、英文）和版本位数（32位、64位），将对应文件夹里的所有文件拷贝至Navicat Premium 12安装位置的根目录（即能看到navicat.exe的那个目录），然后重启Navicat Premium 12。</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%8512.png" alt></p>
<p>看是不是改变了产品过期时间</p>
<p>7.新建的MySQL的连接</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%8513.png" alt></p>
<p>还记得刚刚让你复制的root @ localhost：后面的初始密码了吗？现在要用到它了复制粘贴上去！（稍微注意一下空格啊）</p>
<p>如果密码过期了可以采用命令行输入mysqladmin -uroot -p password即可解决密码过期问题。</p>
<p>测试一下！</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%8515.png" alt></p>
<p>MySQL的是成功安装了也可以登录</p>
<p>现在就是改密码的时候了</p>
<p>也可以在mysql的bin目录下 进行数据库连接 <code>mysql -u root -p</code></p>
<p>再输入密码  回车</p>
<p>有了mysql&gt; 这个的时候 你就可以去改密码了！</p>
<p>ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘新密码’;</p>
<p>密码修改成功后</p>
<p>exit;（退出mysql）</p>
<p>但是这种方法太复杂了是不是，我们的好伙伴Navicat Premium 12在建立连接的时候就会提示我们修改密码</p>
<p><img src="/2020/06/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%89%E8%A3%8514.png" alt></p>
<p>ok到这里我们就可以正常的学习数据库了！</p>
<h2 id="二、书本代码"><a class="header-anchor" href="#二、书本代码">¶</a>二、书本代码</h2>
<h3 id="第一章了解SQL"><a class="header-anchor" href="#第一章了解SQL">¶</a>第一章	了解SQL</h3>
<h4 id="1-1数据库基础"><a class="header-anchor" href="#1-1数据库基础">¶</a>1.1	数据库基础</h4>
<h5 id="1-1-1数据库基础"><a class="header-anchor" href="#1-1-1数据库基础">¶</a>1.1.1	数据库基础</h5>
<h5 id="1-1-2表"><a class="header-anchor" href="#1-1-2表">¶</a>1.1.2	表</h5>
<h5 id="1-1-3列和数据类型"><a class="header-anchor" href="#1-1-3列和数据类型">¶</a>1.1.3	列和数据类型</h5>
<h5 id="1-1-4行"><a class="header-anchor" href="#1-1-4行">¶</a>1.1.4	行</h5>
<h5 id="1-1-5主键"><a class="header-anchor" href="#1-1-5主键">¶</a>1.1.5	主键</h5>
<h4 id="1-2什么是SQL"><a class="header-anchor" href="#1-2什么是SQL">¶</a>1.2	什么是SQL</h4>
<h4 id="1-3动手实践"><a class="header-anchor" href="#1-3动手实践">¶</a>1.3	动手实践</h4>
<h4 id="1-4小结"><a class="header-anchor" href="#1-4小结">¶</a>1.4	小结</h4>
<h3 id="第二章MySQL简介"><a class="header-anchor" href="#第二章MySQL简介">¶</a>第二章	MySQL简介</h3>
<h4 id="2-1什么是MySQL"><a class="header-anchor" href="#2-1什么是MySQL">¶</a>2.1	什么是MySQL</h4>
<h5 id="2-1-1客户机——服务器软件"><a class="header-anchor" href="#2-1-1客户机——服务器软件">¶</a>2.1.1	客户机——服务器软件</h5>
<h5 id="2-1-2MySQL版本"><a class="header-anchor" href="#2-1-2MySQL版本">¶</a>2.1.2	MySQL版本</h5>
<h4 id="2-2MySQL工具"><a class="header-anchor" href="#2-2MySQL工具">¶</a>2.2	MySQL工具</h4>
<h5 id="2-2-1mysql命令行实用程序"><a class="header-anchor" href="#2-2-1mysql命令行实用程序">¶</a>2.2.1	mysql命令行实用程序</h5>
<h5 id="2-2-2MySQL-Administrator"><a class="header-anchor" href="#2-2-2MySQL-Administrator">¶</a>2.2.2	MySQL Administrator</h5>
<h5 id="2-2-3MySQL-Query-Browser"><a class="header-anchor" href="#2-2-3MySQL-Query-Browser">¶</a>2.2.3	MySQL Query Browser</h5>
<h4 id="2-3小结"><a class="header-anchor" href="#2-3小结">¶</a>2.3	小结</h4>
<h3 id="第三章使用MySQL"><a class="header-anchor" href="#第三章使用MySQL">¶</a>第三章	使用MySQL</h3>
<h4 id="3-1连接"><a class="header-anchor" href="#3-1连接">¶</a>3.1	连接</h4>
<h4 id="3-2选择数据库"><a class="header-anchor" href="#3-2选择数据库">¶</a>3.2	选择数据库</h4>
<h4 id="3-3了解数据库和表"><a class="header-anchor" href="#3-3了解数据库和表">¶</a>3.3	了解数据库和表</h4>
<h4 id="3-4小结"><a class="header-anchor" href="#3-4小结">¶</a>3.4	小结</h4>
<h3 id="第四章检索数据"><a class="header-anchor" href="#第四章检索数据">¶</a>第四章	检索数据</h3>
<h3 id="第五章排序检索数据"><a class="header-anchor" href="#第五章排序检索数据">¶</a>第五章	排序检索数据</h3>
<h3 id="第六章过滤数据"><a class="header-anchor" href="#第六章过滤数据">¶</a>第六章	过滤数据</h3>
]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>电子书</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（三）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍如何写博客，如何搭配图文，如何上传部署博客。</p>
<a id="more"></a>
<h1 id="一、写博客软件"><a class="header-anchor" href="#一、写博客软件">¶</a>一、写博客软件</h1>
<p>推荐下载<strong>Typora</strong></p>
<p><strong>官网地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></strong></p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%89%EF%BC%89/typora.png" alt></p>
<p>下载完成后要在偏好设置里-图像-优先使用相对路径，勾选上，方便以后使用。</p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%89%EF%BC%89/%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AE.png" alt></p>
<h1 id="二、创建新博客"><a class="header-anchor" href="#二、创建新博客">¶</a>二、创建新博客</h1>
<p>1.首先在博客文件夹在根目录里进入source文件夹，再进入_posts文件夹，这个文件夹上期也介绍了，主要就是存放博客的文章。我这里<strong>在 _posts里打开Git</strong>。记住以后打开Git都是这样。</p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%89%EF%BC%89/%E6%96%B0%E5%BB%BA.png" alt></p>
<p>2.创建新博客文章命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章题目&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到在_posts文件夹中创建了.md格式的Markdown文件。</p>
<p>3.实现在创建.md的同时创建一个同名文件夹，<strong>把该博客需要用到的图片全部放入</strong>。</p>
<p>打开<strong>博客</strong>配置文件_config.yml 找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>默认应该是false，改为true，**注意冒号和true之间有一个空格，别删。**之后保存。再次完成步骤2，即可实现文件夹创建。</p>
<h1 id="三、常用命令"><a class="header-anchor" href="#三、常用命令">¶</a>三、常用命令</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot; # 新建页面</span><br><span class="line">hexo g               # 生成页面</span><br><span class="line">hexo d               # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s               # 本地预览</span><br><span class="line">hexo clean           # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>
<p>发布常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean           # 清除缓存和已生成的静态文件</span><br><span class="line">hexo g               # 生成页面</span><br><span class="line">hexo s               # 本地预览</span><br><span class="line">hexo d               # 部署</span><br></pre></td></tr></table></figure>
<p>hexo clean 和 hexo s没必要每次都用，但是hexo g和hexo d每次部署都要用到。</p>
<h1 id="四、解决无法显示图片问题"><a class="header-anchor" href="#四、解决无法显示图片问题">¶</a>四、解决无法显示图片问题</h1>
<p>1.解决方法是需要一个插件，Git输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>2.下载好后，打开**/node_modules/hexo-asset-image/index.js**，将内容更换为下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var cheerio &#x3D; require(&#39;cheerio&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14480345&#x2F;how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br><span class="line">hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;</span><br><span class="line">var config &#x3D; hexo.config;</span><br><span class="line">if(config.post_asset_folder)&#123;</span><br><span class="line">  var link &#x3D; data.permalink;</span><br><span class="line">if(version.length &gt; 0 &amp;&amp; Number(version[0]) &#x3D;&#x3D; 3)</span><br><span class="line">  var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 1) + 1;</span><br><span class="line">else</span><br><span class="line">  var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 3) + 1;</span><br><span class="line">&#x2F;&#x2F; In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;...&#x2F;about&#x2F;index.html&quot;.</span><br><span class="line">var endPos &#x3D; link.lastIndexOf(&#39;&#x2F;&#39;) + 1;</span><br><span class="line">  link &#x3D; link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">  var toprocess &#x3D; [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];</span><br><span class="line">  for(var i &#x3D; 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">    var key &#x3D; toprocess[i];</span><br><span class="line"></span><br><span class="line">    var $ &#x3D; cheerio.load(data[key], &#123;</span><br><span class="line">      ignoreWhitespace: false,</span><br><span class="line">      xmlMode: false,</span><br><span class="line">      lowerCaseTags: false,</span><br><span class="line">      decodeEntities: false</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(&#39;img&#39;).each(function()&#123;</span><br><span class="line">if ($(this).attr(&#39;src&#39;))&#123;</span><br><span class="line">&#x2F;&#x2F; For windows style path, we replace &#39;\&#39; to &#39;&#x2F;&#39;.</span><br><span class="line">var src &#x3D; $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;&#x2F;&#39;);</span><br><span class="line">if(!&#x2F;http[s]*.*|\&#x2F;\&#x2F;.*&#x2F;.test(src) &amp;&amp;</span><br><span class="line">  !&#x2F;^\s*\&#x2F;&#x2F;.test(src)) &#123;</span><br><span class="line">&#x2F;&#x2F; For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.</span><br><span class="line">&#x2F;&#x2F; In addition, to support multi-level local directory.</span><br><span class="line">var linkArray &#x3D; link.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">return elem !&#x3D; &#39;&#39;;</span><br><span class="line">&#125;);</span><br><span class="line">var srcArray &#x3D; src.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">return elem !&#x3D; &#39;&#39; &amp;&amp; elem !&#x3D; &#39;.&#39;;</span><br><span class="line">&#125;);</span><br><span class="line">if(srcArray.length &gt; 1)</span><br><span class="line">srcArray.shift();</span><br><span class="line">src &#x3D; srcArray.join(&#39;&#x2F;&#39;);</span><br><span class="line">$(this).attr(&#39;src&#39;, config.root + link + src);</span><br><span class="line">console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">console.info&amp;&amp;console.info($(this));</span><br><span class="line">&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    data[key] &#x3D; $.html();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3.更改保存后重新清除缓存上传，可以看到图片可以显示出来了。</p>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构和算法【清单-源代码】（上）</title>
    <url>/2020/06/19/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>全书共584页，代码包括Page1~ 内，清单1.1~</p>
<a id="more"></a>
<p><strong>电子书下载：<a href="https://wws.lanzous.com/b01bhvjte" target="_blank" rel="noopener">https://wws.lanzous.com/b01bhvjte</a></strong><br>
<strong>密码:av01</strong></p>
<p><strong>电子书下载：<a href="https://wws.lanzous.com/b01bingmh" target="_blank" rel="noopener">https://wws.lanzous.com/b01bingmh</a></strong><br>
<strong>密码:7qd2</strong></p>
<p><strong>电子书下载：<a href="https://wws.lanzous.com/b01bingwh" target="_blank" rel="noopener">https://wws.lanzous.com/b01bingwh</a></strong><br>
<strong>密码:6vda</strong></p>
<h1 id="清单1-1-Page7"><a class="header-anchor" href="#清单1-1-Page7">¶</a>清单1.1 Page7</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BankAccount &#123;</span><br><span class="line">	private double balance; &#x2F;&#x2F;account balance</span><br><span class="line">	</span><br><span class="line">	public BankAccount(double openingBalance) &#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		balance &#x3D; openingBalance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void deposit(double amount)&#x2F;&#x2F;makes deposit</span><br><span class="line">	&#123;</span><br><span class="line">		balance &#x3D; balance + amount;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void withdraw(double amount)&#x2F;&#x2F;makes withdraw</span><br><span class="line">	&#123;</span><br><span class="line">		balance &#x3D; balance - amount;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void display()&#x2F;&#x2F;displays balance</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;balance&#x3D;&quot; + balance);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; end class BankAccount</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BankApp &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		BankAccount ba1 &#x3D; new BankAccount(100.00);&#x2F;&#x2F;creat acct</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;Before transactions, &quot;);</span><br><span class="line">		ba1.display();&#x2F;&#x2F;display balance</span><br><span class="line">		</span><br><span class="line">		ba1.deposit(74.35);&#x2F;&#x2F;make deposit</span><br><span class="line">		ba1.withdraw(20.00);&#x2F;&#x2F;make withdrawal</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;After transactions, &quot;);</span><br><span class="line">		ba1.display();&#x2F;&#x2F;display balance</span><br><span class="line">	&#125;&#x2F;&#x2F;end main</span><br><span class="line">&#125;&#x2F;&#x2F;end class BankApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Before transactions, balance&#x3D;100.0</span><br><span class="line">After transactions, balance&#x3D;154.35</span><br></pre></td></tr></table></figure>
<h1 id="清单2-1-Page22"><a class="header-anchor" href="#清单2-1-Page22">¶</a>清单2.1 Page22</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ArrayApp &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		long[] arr;&#x2F;&#x2F;reference to array</span><br><span class="line">		arr &#x3D; new long[100];&#x2F;&#x2F;make array</span><br><span class="line">		int nElems &#x3D; 0;&#x2F;&#x2F;number of items</span><br><span class="line">		int j;&#x2F;&#x2F;loop counter </span><br><span class="line">		long searchKey;&#x2F;&#x2F;key of item to search for</span><br><span class="line">		</span><br><span class="line">		arr[0] &#x3D; 77;&#x2F;&#x2F;insert 10 items</span><br><span class="line">		arr[1] &#x3D; 99;</span><br><span class="line">		arr[2] &#x3D; 44;</span><br><span class="line">		arr[3] &#x3D; 55;</span><br><span class="line">		arr[4] &#x3D; 22;</span><br><span class="line">		arr[5] &#x3D; 88;</span><br><span class="line">		arr[6] &#x3D; 11;</span><br><span class="line">		arr[7] &#x3D; 00;</span><br><span class="line">		arr[8] &#x3D; 66;</span><br><span class="line">		arr[9] &#x3D; 33;</span><br><span class="line">		nElems &#x3D; 10;&#x2F;&#x2F;now 10 items in array</span><br><span class="line">		</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;display items</span><br><span class="line">			System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">		</span><br><span class="line">		searchKey &#x3D; 66;&#x2F;&#x2F;find item with key 66</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;for each element</span><br><span class="line">			if(arr[j] &#x3D;&#x3D; searchKey)&#x2F;&#x2F;found item?</span><br><span class="line">				break;&#x2F;&#x2F;yes,exit before end</span><br><span class="line">		if(j &#x3D;&#x3D; nElems)&#x2F;&#x2F;at the end?</span><br><span class="line">			System.out.println(&quot;Can&#39;t find&quot; + searchKey);&#x2F;&#x2F;yes</span><br><span class="line">		else</span><br><span class="line">			System.out.println(&quot;Found&quot; + searchKey);&#x2F;&#x2F;no</span><br><span class="line">		</span><br><span class="line">		searchKey &#x3D; 55;&#x2F;&#x2F;delete item with key 55</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;look for it</span><br><span class="line">			if(arr[j] &#x3D;&#x3D; searchKey)</span><br><span class="line">				break;</span><br><span class="line">		for(int k&#x3D;j;k&lt;nElems;k++)&#x2F;&#x2F;move higher ones down</span><br><span class="line">			arr[k] &#x3D; arr[k+1];</span><br><span class="line">		nElems--;&#x2F;&#x2F;decrement size</span><br><span class="line">		</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;display items</span><br><span class="line">			System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">	&#125;&#x2F;&#x2F;end main()</span><br><span class="line">&#125;&#x2F;&#x2F;end class ArryApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">77 99 44 55 22 88 11 0 66 33 </span><br><span class="line">Found66</span><br><span class="line">77 99 44 22 88 11 0 66 33</span><br></pre></td></tr></table></figure>
<h1 id="清单2-2-Page25"><a class="header-anchor" href="#清单2-2-Page25">¶</a>清单2.2 Page25</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LowArray &#123;</span><br><span class="line">	private long[] a;&#x2F;&#x2F;ref to array a</span><br><span class="line">	</span><br><span class="line">	public LowArray(int size)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123; a &#x3D; new long[size];&#125;&#x2F;&#x2F;create array</span><br><span class="line">	</span><br><span class="line">	public void setElem(int index,long value)&#x2F;&#x2F;set value</span><br><span class="line">	&#123; a[index] &#x3D; value;&#125;</span><br><span class="line">	</span><br><span class="line">	public long getElem(int index)&#x2F;&#x2F;get value</span><br><span class="line">	&#123;return a[index];&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end class LowArray</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LowArrayApp &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		LowArray arr;&#x2F;&#x2F;reference</span><br><span class="line">		arr &#x3D; new LowArray(100);&#x2F;&#x2F;create LowArray object</span><br><span class="line">		int nElems &#x3D; 0;&#x2F;&#x2F;number of items in array</span><br><span class="line">		int j;&#x2F;&#x2F;loop variable</span><br><span class="line">		</span><br><span class="line">		arr.setElem(0, 77);&#x2F;&#x2F;insert 10 items</span><br><span class="line">		arr.setElem(1, 99);</span><br><span class="line">		arr.setElem(2, 44);</span><br><span class="line">		arr.setElem(3, 55);</span><br><span class="line">		arr.setElem(4, 22);</span><br><span class="line">		arr.setElem(5, 88);</span><br><span class="line">		arr.setElem(6, 11);</span><br><span class="line">		arr.setElem(7, 00);</span><br><span class="line">		arr.setElem(8, 66);</span><br><span class="line">		arr.setElem(9, 33);</span><br><span class="line">		nElems &#x3D; 10;&#x2F;&#x2F;now 10 items in array</span><br><span class="line">		</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;display items</span><br><span class="line">			System.out.print(arr.getElem(j) + &quot; &quot;);</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">		</span><br><span class="line">		int searchKey &#x3D; 26;&#x2F;&#x2F;search for data item</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;for each element</span><br><span class="line">			if(arr.getElem(j) &#x3D;&#x3D; searchKey)&#x2F;&#x2F;found item?</span><br><span class="line">				break;&#x2F;&#x2F;yes,exit before end</span><br><span class="line">		if(j &#x3D;&#x3D; nElems)&#x2F;&#x2F;at the end?</span><br><span class="line">			System.out.println(&quot;Can&#39;t find &quot; + searchKey);&#x2F;&#x2F;yes</span><br><span class="line">		else</span><br><span class="line">			System.out.println(&quot;Found&quot; + searchKey);&#x2F;&#x2F;no</span><br><span class="line">		</span><br><span class="line">								&#x2F;&#x2F;delete value 55</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;look for it</span><br><span class="line">			if(arr.getElem(j) &#x3D;&#x3D; 55)</span><br><span class="line">				break;</span><br><span class="line">		for(int k&#x3D;j;k&lt;nElems;k++)&#x2F;&#x2F;move higher ones down</span><br><span class="line">			arr.setElem(k, arr.getElem(k+1));</span><br><span class="line">		nElems--;&#x2F;&#x2F;decrement size</span><br><span class="line">		</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;display items</span><br><span class="line">			System.out.print(arr.getElem(j) + &quot; &quot;);</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">	&#125;&#x2F;&#x2F;end main()</span><br><span class="line">&#125;&#x2F;&#x2F;end class LowArrayApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">77 99 44 55 22 88 11 0 66 33 </span><br><span class="line">Can&#39;t find 26</span><br><span class="line">77 99 44 22 88 11 0 66 33</span><br></pre></td></tr></table></figure>
<h1 id="清单2-3-Page28"><a class="header-anchor" href="#清单2-3-Page28">¶</a>清单2.3 Page28</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HighArray &#123;</span><br><span class="line">	private long[] a;&#x2F;&#x2F;reference to array a</span><br><span class="line">	private int nElems;&#x2F;&#x2F;number of data items</span><br><span class="line">	</span><br><span class="line">	public HighArray(int max)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		a &#x3D; new long[max];&#x2F;&#x2F;create the array</span><br><span class="line">		nElems &#x3D; 0;&#x2F;&#x2F;no items yet</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean find(long searchKey)</span><br><span class="line">	&#123;&#x2F;&#x2F;find specified value</span><br><span class="line">		int j;</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;for each element</span><br><span class="line">			if(a[j] &#x3D;&#x3D; searchKey)&#x2F;&#x2F;found item?</span><br><span class="line">				break;&#x2F;&#x2F;exit loop before end</span><br><span class="line">		if(j &#x3D;&#x3D; nElems)&#x2F;&#x2F;gone to end?</span><br><span class="line">			return false;&#x2F;&#x2F;yes,can&#39;t find it</span><br><span class="line">		else</span><br><span class="line">			return true;&#x2F;&#x2F;no,found it</span><br><span class="line">	&#125;&#x2F;&#x2F;end find()</span><br><span class="line">	</span><br><span class="line">	public void insert(long value)&#x2F;&#x2F;put element into array</span><br><span class="line">	&#123;</span><br><span class="line">		a[nElems] &#x3D; value;&#x2F;&#x2F;insert it</span><br><span class="line">		nElems++;&#x2F;&#x2F;increment size</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean delete(long value)</span><br><span class="line">	&#123;</span><br><span class="line">		int j;</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;look for it</span><br><span class="line">			if(value &#x3D;&#x3D; a[j])</span><br><span class="line">				break;</span><br><span class="line">		if(j&#x3D;&#x3D;nElems)&#x2F;&#x2F;can&#39;t find it</span><br><span class="line">			return false;</span><br><span class="line">		else&#x2F;&#x2F;found it</span><br><span class="line">		&#123;</span><br><span class="line">			for(int k&#x3D;j;k&lt;nElems;k++)&#x2F;&#x2F;move higher ones down</span><br><span class="line">				a[k] &#x3D; a[k+1];</span><br><span class="line">			nElems--;&#x2F;&#x2F;decrement size</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#x2F;&#x2F;end delete()</span><br><span class="line">	</span><br><span class="line">	public void display()&#x2F;&#x2F;displays array contents</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;for each element</span><br><span class="line">			System.out.print(a[j] + &quot; &quot;);&#x2F;&#x2F;display it</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end class HighArray</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HighArrayApp &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int maxSize &#x3D; 100;&#x2F;&#x2F;array size</span><br><span class="line">		HighArray arr;&#x2F;&#x2F;reference to array</span><br><span class="line">		arr &#x3D; new HighArray(maxSize);&#x2F;&#x2F;create the array</span><br><span class="line">		</span><br><span class="line">		arr.insert(77);</span><br><span class="line">		arr.insert(99);</span><br><span class="line">		arr.insert(44);</span><br><span class="line">		arr.insert(55);</span><br><span class="line">		arr.insert(22);</span><br><span class="line">		arr.insert(88);</span><br><span class="line">		arr.insert(11);</span><br><span class="line">		arr.insert(00);</span><br><span class="line">		arr.insert(66);</span><br><span class="line">		arr.insert(33);</span><br><span class="line">		</span><br><span class="line">		arr.display();&#x2F;&#x2F;display items</span><br><span class="line">		</span><br><span class="line">		int searchKey &#x3D; 35;&#x2F;&#x2F;search for items</span><br><span class="line">		if( arr.find(searchKey) )</span><br><span class="line">			System.out.println(&quot;Found &quot; + searchKey);</span><br><span class="line">		else</span><br><span class="line">			System.out.println(&quot;Can&#39;t find &quot; + searchKey);</span><br><span class="line">		</span><br><span class="line">		arr.delete(00);&#x2F;&#x2F;delete 3 items</span><br><span class="line">		arr.delete(55);</span><br><span class="line">		arr.delete(99);</span><br><span class="line">		</span><br><span class="line">		arr.display();&#x2F;&#x2F;display items again</span><br><span class="line">	&#125;&#x2F;&#x2F;end main()</span><br><span class="line">&#125;&#x2F;&#x2F;end class HighArrayApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">77 99 44 55 22 88 11 0 66 33 </span><br><span class="line">Can&#39;t find 35</span><br><span class="line">77 44 22 88 11 66 33</span><br></pre></td></tr></table></figure>
<h1 id="清单2-4-Page35"><a class="header-anchor" href="#清单2-4-Page35">¶</a>清单2.4 Page35</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OrdArray &#123;</span><br><span class="line">	private long[] a;&#x2F;&#x2F;reference to array a</span><br><span class="line">	private int nElems;&#x2F;&#x2F;number of data items</span><br><span class="line">	</span><br><span class="line">	public OrdArray(int max)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		a &#x3D; new long[max];&#x2F;&#x2F;create the array</span><br><span class="line">		nElems &#x3D; 0;&#x2F;&#x2F;no items yet</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int size()</span><br><span class="line">	&#123;</span><br><span class="line">		return nElems;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int find(long searchKey)</span><br><span class="line">	&#123;</span><br><span class="line">		int lowerBound &#x3D; 0;</span><br><span class="line">		int upperBound &#x3D; nElems-1;</span><br><span class="line">		int curIn;</span><br><span class="line">		</span><br><span class="line">		while(true)</span><br><span class="line">		&#123;</span><br><span class="line">			curIn &#x3D; (lowerBound + upperBound)&#x2F;2;</span><br><span class="line">			if(a[curIn]&#x3D;&#x3D;searchKey)</span><br><span class="line">				return curIn;&#x2F;&#x2F;found it</span><br><span class="line">			else if(lowerBound &gt; upperBound)</span><br><span class="line">				return nElems;&#x2F;&#x2F;can&#39;t find it</span><br><span class="line">			else </span><br><span class="line">			&#123;</span><br><span class="line">				if(a[curIn] &lt; searchKey)</span><br><span class="line">					lowerBound &#x3D; curIn + 1;&#x2F;&#x2F;it&#39;s in upper half</span><br><span class="line">				else</span><br><span class="line">					upperBound &#x3D; curIn - 1;&#x2F;&#x2F;it&#39;s in lower half</span><br><span class="line">			&#125;&#x2F;&#x2F;end else divide range</span><br><span class="line">		&#125;&#x2F;&#x2F;end while</span><br><span class="line">	&#125;&#x2F;&#x2F;end find()</span><br><span class="line">	</span><br><span class="line">	public void insert(long value)&#x2F;&#x2F;put element into array</span><br><span class="line">	&#123;</span><br><span class="line">		int j;</span><br><span class="line">		for(j&#x3D;0; j&lt;nElems; j++)&#x2F;&#x2F;find where it goes</span><br><span class="line">			if(a[j] &gt; value)&#x2F;&#x2F;(linear search)</span><br><span class="line">				break;</span><br><span class="line">		for(int k&#x3D;nElems; k&gt;j; k--)&#x2F;&#x2F;move bigger ones up</span><br><span class="line">			a[k] &#x3D; a[k-1];</span><br><span class="line">		a[j] &#x3D; value;&#x2F;&#x2F;insert it</span><br><span class="line">		nElems++;&#x2F;&#x2F;increment size</span><br><span class="line">	&#125;&#x2F;&#x2F;end insert()</span><br><span class="line">	</span><br><span class="line">	public boolean delete(long value)</span><br><span class="line">	&#123;</span><br><span class="line">		int j &#x3D; find(value);</span><br><span class="line">		if(j&#x3D;&#x3D;nElems)&#x2F;&#x2F;can&#39;t find it</span><br><span class="line">			return false;</span><br><span class="line">		else&#x2F;&#x2F;found it</span><br><span class="line">		&#123;</span><br><span class="line">			for(int k&#x3D;j;k&lt;nElems;k++)&#x2F;&#x2F;move higher ones down</span><br><span class="line">				a[k] &#x3D; a[k+1];</span><br><span class="line">			nElems--;&#x2F;&#x2F;decrement size</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#x2F;&#x2F;end delete()</span><br><span class="line">	</span><br><span class="line">	public void display()&#x2F;&#x2F;displays array contents</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;for each element</span><br><span class="line">			System.out.print(a[j] + &quot; &quot;);&#x2F;&#x2F;display it</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end class OrdArray</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OrderedApp &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int maxSize &#x3D; 100;&#x2F;&#x2F;array size</span><br><span class="line">		OrdArray arr;&#x2F;&#x2F;reference to array</span><br><span class="line">		arr &#x3D; new OrdArray(maxSize);&#x2F;&#x2F;create the array</span><br><span class="line">		</span><br><span class="line">		arr.insert(77);</span><br><span class="line">		arr.insert(99);</span><br><span class="line">		arr.insert(44);</span><br><span class="line">		arr.insert(55);</span><br><span class="line">		arr.insert(22);</span><br><span class="line">		arr.insert(88);</span><br><span class="line">		arr.insert(11);</span><br><span class="line">		arr.insert(00);</span><br><span class="line">		arr.insert(66);</span><br><span class="line">		arr.insert(33);</span><br><span class="line">		</span><br><span class="line">		int  searchKey &#x3D; 55;&#x2F;&#x2F;search for item</span><br><span class="line">		if( arr.find(searchKey) !&#x3D; arr.size() )</span><br><span class="line">			System.out.println(&quot;Found &quot; + searchKey);</span><br><span class="line">		else</span><br><span class="line">			System.out.println(&quot;Can&#39;t find &quot; + searchKey);</span><br><span class="line">		</span><br><span class="line">		arr.display();&#x2F;&#x2F;display items</span><br><span class="line">		</span><br><span class="line">		arr.delete(00);&#x2F;&#x2F;delete 3 items</span><br><span class="line">		arr.delete(55);</span><br><span class="line">		arr.delete(99);</span><br><span class="line">		</span><br><span class="line">		arr.display();&#x2F;&#x2F;display items again</span><br><span class="line">	&#125;&#x2F;&#x2F;end main()</span><br><span class="line">&#125;&#x2F;&#x2F;end class OrderedApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Found 55</span><br><span class="line">00 11 22 33 44 55 66 77 88 99 </span><br><span class="line">11 22 33 44 66 77 88</span><br></pre></td></tr></table></figure>
<h1 id="清单2-5-Page41"><a class="header-anchor" href="#清单2-5-Page41">¶</a>清单2.5 Page41</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">	private String lastName;</span><br><span class="line">	private String firstName;</span><br><span class="line">	private int age;</span><br><span class="line">	</span><br><span class="line">	public Person(String last,String first,int a)</span><br><span class="line">	&#123;&#x2F;&#x2F;constructor</span><br><span class="line">		lastName &#x3D; last;</span><br><span class="line">		firstName &#x3D; first;</span><br><span class="line">		age &#x3D; a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void displayPerson()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(&quot;  Last name: &quot; + lastName);</span><br><span class="line">		System.out.print(&quot;,First name: &quot; + firstName);</span><br><span class="line">		System.out.println(&quot;,Age: &quot; + age);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String getLast()&#x2F;&#x2F;get last name</span><br><span class="line">	&#123;</span><br><span class="line">		return lastName;</span><br><span class="line">	&#125;&#x2F;&#x2F;end class Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassDataArray &#123;</span><br><span class="line">	private Person[] a;&#x2F;&#x2F;reference to array</span><br><span class="line">	private int nElems;&#x2F;&#x2F;number of data items</span><br><span class="line">	</span><br><span class="line">	public ClassDataArray(int max)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		a &#x3D; new Person[max];&#x2F;&#x2F;create the array</span><br><span class="line">		nElems &#x3D; 0;&#x2F;&#x2F;no items yet</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Person find(String searchName)</span><br><span class="line">	&#123;&#x2F;&#x2F;find specified value</span><br><span class="line">		int j;</span><br><span class="line">		for(j&#x3D;0; j&lt;nElems; j++)&#x2F;&#x2F;for each element</span><br><span class="line">			if( a[j].getLast().equals(searchName) )&#x2F;&#x2F;found item?</span><br><span class="line">				break;&#x2F;&#x2F;exit loop brfore end</span><br><span class="line">		if(j &#x3D;&#x3D; nElems)&#x2F;&#x2F;gone to end?</span><br><span class="line">			return null;&#x2F;&#x2F;yes,can&#39;t find it</span><br><span class="line">		else</span><br><span class="line">			return a[j];&#x2F;&#x2F;no,found it</span><br><span class="line">	&#125;&#x2F;&#x2F;end find()</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;put person into array</span><br><span class="line">	public void insert(String last,String first,int age)</span><br><span class="line">	&#123;</span><br><span class="line">		a[nElems] &#x3D; new Person(last, first, age);</span><br><span class="line">		nElems++;&#x2F;&#x2F;increment size</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean delete(String searchName)</span><br><span class="line">	&#123;&#x2F;&#x2F;delete person from array</span><br><span class="line">		int j;</span><br><span class="line">		for(j&#x3D;0;j&lt;nElems;j++)&#x2F;&#x2F;look for it</span><br><span class="line">			if( a[j].getLast().equals(searchName))</span><br><span class="line">				break;</span><br><span class="line">		if(j&#x3D;&#x3D;nElems)&#x2F;&#x2F;can&#39;t find it</span><br><span class="line">			return false;</span><br><span class="line">		else&#x2F;&#x2F;found it</span><br><span class="line">		&#123;</span><br><span class="line">			for(int k&#x3D;j;k&lt;nElems;k++)&#x2F;&#x2F;move higher ones down</span><br><span class="line">				a[k] &#x3D; a[k+1];</span><br><span class="line">			nElems--;&#x2F;&#x2F;decrement size</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#x2F;&#x2F;end delete()</span><br><span class="line">	</span><br><span class="line">	public void displayA()&#x2F;&#x2F;displays array contents</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j&#x3D;0; j&lt;nElems; j++)&#x2F;&#x2F;for each element</span><br><span class="line">			a[j].displayPerson();&#x2F;&#x2F;display it</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end class ClassDataArray</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassDataApp &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int maxSize &#x3D; 100;&#x2F;&#x2F;array size</span><br><span class="line">		ClassDataArray arr;&#x2F;&#x2F;reference to array</span><br><span class="line">		arr &#x3D; new ClassDataArray(maxSize);&#x2F;&#x2F;create the array</span><br><span class="line">		&#x2F;&#x2F;insert 10 items</span><br><span class="line">		arr.insert(&quot;Evans&quot;, &quot;Patty&quot;, 24);</span><br><span class="line">		arr.insert(&quot;Smith&quot;, &quot;Lorraine&quot;, 37);</span><br><span class="line">		arr.insert(&quot;Yee&quot;, &quot;Tom&quot;, 43);</span><br><span class="line">		arr.insert(&quot;Adams&quot;, &quot;Henry&quot;, 63);</span><br><span class="line">		arr.insert(&quot;Hashimoto&quot;, &quot;Sato&quot;, 21);</span><br><span class="line">		arr.insert(&quot;Stimson&quot;, &quot;Henry&quot;, 29);</span><br><span class="line">		arr.insert(&quot;Velasquez&quot;, &quot;Jose&quot;, 72);</span><br><span class="line">		arr.insert(&quot;Lamarque&quot;, &quot;Henry&quot;, 54);</span><br><span class="line">		arr.insert(&quot;Vang&quot;, &quot;Minh&quot;, 22);</span><br><span class="line">		arr.insert(&quot;Creswell&quot;, &quot;Lucinda&quot;, 18);</span><br><span class="line">		</span><br><span class="line">		arr.displayA();&#x2F;&#x2F;display items</span><br><span class="line">		</span><br><span class="line">		String searchKey &#x3D; &quot;Stimson&quot;;&#x2F;&#x2F;search for item</span><br><span class="line">		Person found;</span><br><span class="line">		found &#x3D; arr.find(searchKey);</span><br><span class="line">		if(found !&#x3D; null)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(&quot;Found &quot;);</span><br><span class="line">			found.displayPerson();</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			System.out.println(&quot;Can&#39;t find &quot; + searchKey);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;Deleting Smith,yee,and Creswell&quot;);</span><br><span class="line">		arr.delete(&quot;Smith&quot;);&#x2F;&#x2F;delete 3 items</span><br><span class="line">		arr.delete(&quot;Yee&quot;);</span><br><span class="line">		arr.delete(&quot;Creswell&quot;);</span><br><span class="line">		</span><br><span class="line">		arr.displayA();&#x2F;&#x2F;display items agains</span><br><span class="line">	&#125;&#x2F;&#x2F;end main()</span><br><span class="line">&#125;&#x2F;&#x2F;end class ClassDataAPP</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Last name: Evans,First name: Patty,Age: 24</span><br><span class="line">  Last name: Smith,First name: Lorraine,Age: 37</span><br><span class="line">  Last name: Yee,First name: Tom,Age: 43</span><br><span class="line">  Last name: Adams,First name: Henry,Age: 63</span><br><span class="line">  Last name: Hashimoto,First name: Sato,Age: 21</span><br><span class="line">  Last name: Stimson,First name: Henry,Age: 29</span><br><span class="line">  Last name: Velasquez,First name: Jose,Age: 72</span><br><span class="line">  Last name: Lamarque,First name: Henry,Age: 54</span><br><span class="line">  Last name: Vang,First name: Minh,Age: 22</span><br><span class="line">  Last name: Creswell,First name: Lucinda,Age: 18</span><br><span class="line">Found   Last name: Stimson,First name: Henry,Age: 29</span><br><span class="line">Deleting Smith,yee,and Creswell</span><br><span class="line">  Last name: Evans,First name: Patty,Age: 24</span><br><span class="line">  Last name: Adams,First name: Henry,Age: 63</span><br><span class="line">  Last name: Hashimoto,First name: Sato,Age: 21</span><br><span class="line">  Last name: Stimson,First name: Henry,Age: 29</span><br><span class="line">  Last name: Velasquez,First name: Jose,Age: 72</span><br><span class="line">  Last name: Lamarque,First name: Henry,Age: 54</span><br><span class="line">  Last name: Vang,First name: Minh,Age: 22</span><br></pre></td></tr></table></figure>
<h1 id="清单3-1-Page57"><a class="header-anchor" href="#清单3-1-Page57">¶</a>清单3.1 Page57</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ArrayBub &#123;</span><br><span class="line">	private long[] a;&#x2F;&#x2F;ref to array a</span><br><span class="line">	private int nElems;&#x2F;&#x2F;number of data items</span><br><span class="line">	</span><br><span class="line">	public ArrayBub(int max)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		a &#x3D; new long[max];&#x2F;&#x2F;create the array</span><br><span class="line">		nElems &#x3D; 0;&#x2F;&#x2F;no items yet</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void insert(long value)&#x2F;&#x2F;put element into array</span><br><span class="line">	&#123;</span><br><span class="line">		a[nElems] &#x3D; value;&#x2F;&#x2F;insert it</span><br><span class="line">		nElems++;&#x2F;&#x2F;increment size</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void display()&#x2F;&#x2F;displays array contents</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j&#x3D;0; j&lt;nElems; j++)&#x2F;&#x2F;for each element</span><br><span class="line">			System.out.print(a[j] + &quot; &quot;);&#x2F;&#x2F;display it</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void bubbleSort()</span><br><span class="line">	&#123;</span><br><span class="line">		int out,in;</span><br><span class="line">		</span><br><span class="line">		for(out&#x3D;nElems-1; out&gt;1; out--)&#x2F;&#x2F;outer loop (backward)</span><br><span class="line">			for(in&#x3D;0; in&lt;out; in++)&#x2F;&#x2F;inner loop (forward)</span><br><span class="line">				if( a[in] &gt; a[in+1] )&#x2F;&#x2F;out of order?</span><br><span class="line">					swap(in,in+1);&#x2F;&#x2F;swap them</span><br><span class="line">	&#125;&#x2F;&#x2F;end bubbleSort</span><br><span class="line">	</span><br><span class="line">	private void swap(int one,int two)</span><br><span class="line">	&#123;</span><br><span class="line">		long temp &#x3D; a[one];</span><br><span class="line">		a[one] &#x3D; a[two];</span><br><span class="line">		a[two] &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;&#x2F;&#x2F;end class ArrayBub</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BubbleSortApp &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int maxSize &#x3D; 100;&#x2F;&#x2F;array size</span><br><span class="line">		ArrayBub arr;&#x2F;&#x2F;reference to array</span><br><span class="line">		arr &#x3D; new ArrayBub(maxSize);&#x2F;&#x2F;create the array</span><br><span class="line">		</span><br><span class="line">		arr.insert(77);&#x2F;&#x2F;insert 10 items</span><br><span class="line">		arr.insert(99);</span><br><span class="line">		arr.insert(44);</span><br><span class="line">		arr.insert(55);</span><br><span class="line">		arr.insert(22);</span><br><span class="line">		arr.insert(88);</span><br><span class="line">		arr.insert(11);</span><br><span class="line">		arr.insert(00);</span><br><span class="line">		arr.insert(66);</span><br><span class="line">		arr.insert(33);</span><br><span class="line">		</span><br><span class="line">		arr.display();&#x2F;&#x2F;display items</span><br><span class="line">		</span><br><span class="line">		arr.bubbleSort();&#x2F;&#x2F;bubble sort them</span><br><span class="line">		arr.display();&#x2F;&#x2F;display them again</span><br><span class="line">	&#125;&#x2F;&#x2F;end main()</span><br><span class="line">&#125;&#x2F;&#x2F;end class BubbleSortApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">77 99 44 55 22 88 11 0 66 33 </span><br><span class="line">0 11 22 33 44 55 66 77 88 99</span><br></pre></td></tr></table></figure>
<h1 id="清单3-2-Page63"><a class="header-anchor" href="#清单3-2-Page63">¶</a>清单3.2 Page63</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ArraySel &#123;</span><br><span class="line">	private long[] a;&#x2F;&#x2F;ref to array a</span><br><span class="line">	private int nElems;&#x2F;&#x2F;number of data items</span><br><span class="line">	</span><br><span class="line">	public ArraySel(int max)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		a &#x3D; new long[max];&#x2F;&#x2F;create the array</span><br><span class="line">		nElems &#x3D; 0;&#x2F;&#x2F;no items yet</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void insert(long value)&#x2F;&#x2F;put element into array</span><br><span class="line">	&#123;</span><br><span class="line">		a[nElems] &#x3D; value;&#x2F;&#x2F;insert it</span><br><span class="line">		nElems++;&#x2F;&#x2F;increment size</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void display()&#x2F;&#x2F;displays array contents</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j&#x3D;0; j&lt;nElems; j++)&#x2F;&#x2F;for each element</span><br><span class="line">			System.out.print(a[j] + &quot; &quot;);&#x2F;&#x2F;display it</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void selectionSort()</span><br><span class="line">	&#123;</span><br><span class="line">		int out,in,min;</span><br><span class="line">		</span><br><span class="line">		for(out&#x3D;0; out&lt;nElems; out++)&#x2F;&#x2F;outer loop</span><br><span class="line">		&#123;</span><br><span class="line">			min &#x3D; out;&#x2F;&#x2F;minimum</span><br><span class="line">			for(in&#x3D;out+1; in&lt;nElems; in++)&#x2F;&#x2F;inner loop</span><br><span class="line">				if( a[in] &lt; a[min] )&#x2F;&#x2F;if min greater</span><br><span class="line">					min &#x3D; in;&#x2F;&#x2F;we have a new min</span><br><span class="line">					swap(out,min);&#x2F;&#x2F;swap them</span><br><span class="line">		&#125;&#x2F;&#x2F;end for(out)</span><br><span class="line">	&#125;&#x2F;&#x2F;end selectionSort()</span><br><span class="line">	</span><br><span class="line">	private void swap(int one,int two)</span><br><span class="line">	&#123;</span><br><span class="line">		long temp &#x3D; a[one];</span><br><span class="line">		a[one] &#x3D; a[two];</span><br><span class="line">		a[two] &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end class ArraySel</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SelectSortApp &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int maxSize &#x3D; 100;&#x2F;&#x2F;array size</span><br><span class="line">		ArraySel arr;&#x2F;&#x2F;reference to array</span><br><span class="line">		arr &#x3D; new ArraySel(maxSize);&#x2F;&#x2F;create the array</span><br><span class="line">		</span><br><span class="line">		arr.insert(77);&#x2F;&#x2F;insert 10 items</span><br><span class="line">		arr.insert(99);</span><br><span class="line">		arr.insert(44);</span><br><span class="line">		arr.insert(55);</span><br><span class="line">		arr.insert(22);</span><br><span class="line">		arr.insert(88);</span><br><span class="line">		arr.insert(11);</span><br><span class="line">		arr.insert(00);</span><br><span class="line">		arr.insert(66);</span><br><span class="line">		arr.insert(33);</span><br><span class="line">		</span><br><span class="line">		arr.display();&#x2F;&#x2F;display items</span><br><span class="line">		</span><br><span class="line">		arr.selectionSort();&#x2F;&#x2F;bubble sort them</span><br><span class="line">		arr.display();&#x2F;&#x2F;display them again</span><br><span class="line">	&#125;&#x2F;&#x2F;end main()</span><br><span class="line">&#125;&#x2F;&#x2F;end class BubbleSortApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">77 99 44 55 22 88 11 0 66 33 </span><br><span class="line">0 11 22 33 44 55 66 77 88 99</span><br></pre></td></tr></table></figure>
<h1 id="清单3-3-Page70"><a class="header-anchor" href="#清单3-3-Page70">¶</a>清单3.3 Page70</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ArrayIns &#123;</span><br><span class="line">	private long[] a;&#x2F;&#x2F;ref to array a</span><br><span class="line">	private int nElems;&#x2F;&#x2F;number of data items</span><br><span class="line">	</span><br><span class="line">	public ArrayIns(int max)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		a &#x3D; new long[max];&#x2F;&#x2F;create the array</span><br><span class="line">		nElems &#x3D; 0;&#x2F;&#x2F;no items yet</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void insert(long value)&#x2F;&#x2F;put element into array</span><br><span class="line">	&#123;</span><br><span class="line">		a[nElems] &#x3D; value;&#x2F;&#x2F;insert it</span><br><span class="line">		nElems++;&#x2F;&#x2F;increment size</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void display()&#x2F;&#x2F;displays array contents</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j&#x3D;0; j&lt;nElems; j++)&#x2F;&#x2F;for each element</span><br><span class="line">			System.out.print(a[j] + &quot; &quot;);&#x2F;&#x2F;display it</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void insertionSort()</span><br><span class="line">	&#123;</span><br><span class="line">		int in,out;</span><br><span class="line">		</span><br><span class="line">		for(out&#x3D;1; out&lt;nElems; out++)&#x2F;&#x2F;out is dividing line</span><br><span class="line">		&#123;</span><br><span class="line">			long temp &#x3D; a[out];&#x2F;&#x2F;remove marked item</span><br><span class="line">			in &#x3D; out;&#x2F;&#x2F;start shifts at out</span><br><span class="line">			while(in&gt;0 &amp;&amp; a[in-1] &gt;&#x3D; temp)&#x2F;&#x2F;until one is smaller</span><br><span class="line">			&#123;</span><br><span class="line">				a[in] &#x3D; a[in-1];&#x2F;&#x2F;shift item to right</span><br><span class="line">				--in;&#x2F;&#x2F;go left one position</span><br><span class="line">			&#125;</span><br><span class="line">			a[in] &#x3D; temp;&#x2F;&#x2F;insert marked item</span><br><span class="line">		&#125;&#x2F;&#x2F;end for</span><br><span class="line">	&#125;&#x2F;&#x2F;end insertionSort()</span><br><span class="line">&#125;&#x2F;&#x2F;end class ArrayIns</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class InsertSortApp &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int maxSize &#x3D; 100;&#x2F;&#x2F;array size</span><br><span class="line">		ArrayIns arr;&#x2F;&#x2F;reference to array</span><br><span class="line">		arr &#x3D; new ArrayIns(maxSize);&#x2F;&#x2F;create the array</span><br><span class="line">		</span><br><span class="line">		arr.insert(77);&#x2F;&#x2F;insert 10 items</span><br><span class="line">		arr.insert(99);</span><br><span class="line">		arr.insert(44);</span><br><span class="line">		arr.insert(55);</span><br><span class="line">		arr.insert(22);</span><br><span class="line">		arr.insert(88);</span><br><span class="line">		arr.insert(11);</span><br><span class="line">		arr.insert(00);</span><br><span class="line">		arr.insert(66);</span><br><span class="line">		arr.insert(33);</span><br><span class="line">		</span><br><span class="line">		arr.display();&#x2F;&#x2F;display items</span><br><span class="line">		</span><br><span class="line">		arr.insertionSort();&#x2F;&#x2F;bubble sort them</span><br><span class="line">		arr.display();&#x2F;&#x2F;display them again</span><br><span class="line">	&#125;&#x2F;&#x2F;end main()</span><br><span class="line">&#125;&#x2F;&#x2F;end class InsertSortApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">77 99 44 55 22 88 11 0 66 33 </span><br><span class="line">0 11 22 33 44 55 66 77 88 99</span><br></pre></td></tr></table></figure>
<h1 id="清单3-4-Page72"><a class="header-anchor" href="#清单3-4-Page72">¶</a>清单3.4 Page72</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">	private String lastName;</span><br><span class="line">	private String firstName;</span><br><span class="line">	private int age;</span><br><span class="line">	</span><br><span class="line">	public Person(String last,String first,int a)</span><br><span class="line">	&#123;&#x2F;&#x2F;constructor</span><br><span class="line">		lastName &#x3D; last;</span><br><span class="line">		firstName &#x3D; first;</span><br><span class="line">		age &#x3D; a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void displayPerson()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(&quot;  Last name: &quot; + lastName);</span><br><span class="line">		System.out.print(&quot;,First name: &quot; + firstName);</span><br><span class="line">		System.out.println(&quot;,Age: &quot; + age);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String getLast()&#x2F;&#x2F;get last name</span><br><span class="line">	&#123;</span><br><span class="line">		return lastName;</span><br><span class="line">	&#125;&#x2F;&#x2F;end class Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ArrayIn0b &#123;</span><br><span class="line">		private Person[] a;&#x2F;&#x2F;ref to array a</span><br><span class="line">		private int nElems;&#x2F;&#x2F;number of data items</span><br><span class="line">		</span><br><span class="line">		public ArrayIn0b(int max)&#x2F;&#x2F;constructor</span><br><span class="line">		&#123;</span><br><span class="line">			a &#x3D; new Person[max];&#x2F;&#x2F;create the array</span><br><span class="line">			nElems &#x3D; 0;&#x2F;&#x2F;no items yet</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void insert(String last, String first, int age)&#x2F;&#x2F;put element into array</span><br><span class="line">		&#123;</span><br><span class="line">			a[nElems] &#x3D; new Person(last,first,age);&#x2F;&#x2F;insert it</span><br><span class="line">			nElems++;&#x2F;&#x2F;increment size</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void display()&#x2F;&#x2F;displays array contents</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j&#x3D;0; j&lt;nElems; j++)&#x2F;&#x2F;for each element</span><br><span class="line">				a[j].displayPerson();&#x2F;&#x2F;display it</span><br><span class="line">			System.out.println(&quot;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void insertionSort()</span><br><span class="line">		&#123;</span><br><span class="line">			int in,out;</span><br><span class="line">			</span><br><span class="line">			for(out&#x3D;1; out&lt;nElems; out++)&#x2F;&#x2F;out is dividing line</span><br><span class="line">			&#123;</span><br><span class="line">				Person temp &#x3D; a[out];&#x2F;&#x2F;remove marked item</span><br><span class="line">				in &#x3D; out;&#x2F;&#x2F;start shifts at out</span><br><span class="line">				</span><br><span class="line">				while(in&gt;0 &amp;&amp; a[in-1].getLast().compareTo(temp.getLast())&gt;0)&#x2F;&#x2F;until one is smaller</span><br><span class="line">				&#123;</span><br><span class="line">					a[in] &#x3D; a[in-1];&#x2F;&#x2F;shift item to right</span><br><span class="line">					--in;&#x2F;&#x2F;go left one position</span><br><span class="line">				&#125;</span><br><span class="line">				a[in] &#x3D; temp;&#x2F;&#x2F;insert marked item</span><br><span class="line">			&#125;&#x2F;&#x2F;end for</span><br><span class="line">		&#125;&#x2F;&#x2F;end insertionSort</span><br><span class="line">&#125;&#x2F;&#x2F;end class ArrayIn0b</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ObjectSortApp &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int maxSize &#x3D; 100;&#x2F;&#x2F;array size</span><br><span class="line">		ArrayIn0b arr;&#x2F;&#x2F;reference to array</span><br><span class="line">		arr &#x3D; new ArrayIn0b(maxSize);&#x2F;&#x2F;create the array</span><br><span class="line">		&#x2F;&#x2F;insert 10 items</span><br><span class="line">		arr.insert(&quot;Evans&quot;, &quot;Patty&quot;, 24);</span><br><span class="line">		arr.insert(&quot;Smith&quot;, &quot;Doc&quot;, 59);</span><br><span class="line">		arr.insert(&quot;Smith&quot;, &quot;Lorraine&quot;, 37);</span><br><span class="line">		arr.insert(&quot;Smith&quot;, &quot;Pual&quot;, 37);</span><br><span class="line">		arr.insert(&quot;Yee&quot;, &quot;Tom&quot;, 43);</span><br><span class="line">		arr.insert(&quot;Adams&quot;, &quot;Henry&quot;, 63);</span><br><span class="line">		arr.insert(&quot;Hashimoto&quot;, &quot;Sato&quot;, 21);</span><br><span class="line">		arr.insert(&quot;Stimson&quot;, &quot;Henry&quot;, 29);</span><br><span class="line">		arr.insert(&quot;Velasquez&quot;, &quot;Jose&quot;, 72);</span><br><span class="line">		arr.insert(&quot;Lamarque&quot;, &quot;Henry&quot;, 54);</span><br><span class="line">		arr.insert(&quot;Vang&quot;, &quot;Minh&quot;, 22);</span><br><span class="line">		arr.insert(&quot;Creswell&quot;, &quot;Lucinda&quot;, 18);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;Before sorting:&quot;);</span><br><span class="line">		arr.display();&#x2F;&#x2F;display items</span><br><span class="line">		</span><br><span class="line">		arr.insertionSort();&#x2F;&#x2F;insertion-sort them</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;After sorting:&quot;);</span><br><span class="line">		arr.display();</span><br><span class="line">	&#125;&#x2F;&#x2F;end main()</span><br><span class="line">&#125;&#x2F;&#x2F;end class ObjectSortApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Before sorting:</span><br><span class="line">  Last name: Evans,First name: Patty,Age: 24</span><br><span class="line">  Last name: Smith,First name: Doc,Age: 59</span><br><span class="line">  Last name: Smith,First name: Lorraine,Age: 37</span><br><span class="line">  Last name: Smith,First name: Pual,Age: 37</span><br><span class="line">  Last name: Yee,First name: Tom,Age: 43</span><br><span class="line">  Last name: Adams,First name: Henry,Age: 63</span><br><span class="line">  Last name: Hashimoto,First name: Sato,Age: 21</span><br><span class="line">  Last name: Stimson,First name: Henry,Age: 29</span><br><span class="line">  Last name: Velasquez,First name: Jose,Age: 72</span><br><span class="line">  Last name: Lamarque,First name: Henry,Age: 54</span><br><span class="line">  Last name: Vang,First name: Minh,Age: 22</span><br><span class="line">  Last name: Creswell,First name: Lucinda,Age: 18</span><br><span class="line"></span><br><span class="line">After sorting:</span><br><span class="line">  Last name: Adams,First name: Henry,Age: 63</span><br><span class="line">  Last name: Creswell,First name: Lucinda,Age: 18</span><br><span class="line">  Last name: Evans,First name: Patty,Age: 24</span><br><span class="line">  Last name: Hashimoto,First name: Sato,Age: 21</span><br><span class="line">  Last name: Lamarque,First name: Henry,Age: 54</span><br><span class="line">  Last name: Smith,First name: Doc,Age: 59</span><br><span class="line">  Last name: Smith,First name: Lorraine,Age: 37</span><br><span class="line">  Last name: Smith,First name: Pual,Age: 37</span><br><span class="line">  Last name: Stimson,First name: Henry,Age: 29</span><br><span class="line">  Last name: Vang,First name: Minh,Age: 22</span><br><span class="line">  Last name: Velasquez,First name: Jose,Age: 72</span><br><span class="line">  Last name: Yee,First name: Tom,Age: 43</span><br></pre></td></tr></table></figure>
<h1 id="清单4-1-Page83"><a class="header-anchor" href="#清单4-1-Page83">¶</a>清单4.1 Page83</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class StackX &#123;</span><br><span class="line">	private int maxSize;&#x2F;&#x2F;size of stack array</span><br><span class="line">	private long[] stackArray;</span><br><span class="line">	private int top;&#x2F;&#x2F;top of stack</span><br><span class="line">	</span><br><span class="line">	public StackX(int s)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		maxSize &#x3D; s;&#x2F;&#x2F;set array size</span><br><span class="line">		stackArray &#x3D; new long[maxSize];&#x2F;&#x2F;create array</span><br><span class="line">		top &#x3D; -1;&#x2F;&#x2F;mo items yet</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void push(long j)&#x2F;&#x2F;put item on top of stack</span><br><span class="line">	&#123;</span><br><span class="line">		stackArray[++top] &#x3D; j;&#x2F;&#x2F;increment top,insert item</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public long pop()&#x2F;&#x2F;take item from top of stack</span><br><span class="line">	&#123;</span><br><span class="line">		return stackArray[top--];&#x2F;&#x2F;access item,decrement top</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public long peek()&#x2F;&#x2F;peek at top of stack</span><br><span class="line">	&#123;</span><br><span class="line">		return stackArray[top];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean isEmpty()&#x2F;&#x2F;true if stack is empty</span><br><span class="line">	&#123;</span><br><span class="line">		return (top &#x3D;&#x3D; -1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean isFull()&#x2F;&#x2F;true if stack is empty</span><br><span class="line">	&#123;</span><br><span class="line">		return (top &#x3D;&#x3D; maxSize-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end class StackX</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class StackApp &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		StackX theStack &#x3D; new StackX(10);&#x2F;&#x2F;make new stack</span><br><span class="line">		theStack.push(20);&#x2F;&#x2F;push items onto stack</span><br><span class="line">		theStack.push(40);</span><br><span class="line">		theStack.push(60);</span><br><span class="line">		theStack.push(80);</span><br><span class="line">		</span><br><span class="line">		while( !theStack.isEmpty() )&#x2F;&#x2F;until it&#39;s empty</span><br><span class="line">		&#123;</span><br><span class="line">			long value &#x3D; theStack.pop();</span><br><span class="line">			System.out.print(value);</span><br><span class="line">			System.out.print(&quot; &quot;);</span><br><span class="line">		&#125;&#x2F;&#x2F;end while</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">	&#125;&#x2F;&#x2F;end main</span><br><span class="line">&#125;&#x2F;&#x2F;end class StackApp</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80 60 40 20</span><br></pre></td></tr></table></figure>
<h1 id="清单4-2-Page87"><a class="header-anchor" href="#清单4-2-Page87">¶</a>清单4.2 Page87</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class StackXX &#123;</span><br><span class="line">	private int maxSize;&#x2F;&#x2F;size of stack array</span><br><span class="line">	private char[] stackArray;</span><br><span class="line">	private int top;&#x2F;&#x2F;top of stack</span><br><span class="line">	</span><br><span class="line">	public StackXX(int max)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		maxSize &#x3D; max;&#x2F;&#x2F;set array size</span><br><span class="line">		stackArray &#x3D; new char[maxSize];&#x2F;&#x2F;create array</span><br><span class="line">		top &#x3D; -1;&#x2F;&#x2F;mo items yet</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void push(char j)&#x2F;&#x2F;put item on top of stack</span><br><span class="line">	&#123;</span><br><span class="line">		stackArray[++top] &#x3D; j;&#x2F;&#x2F;increment top,insert item</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public char pop()&#x2F;&#x2F;take item from top of stack</span><br><span class="line">	&#123;</span><br><span class="line">		return stackArray[top--];&#x2F;&#x2F;access item,decrement top</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public char peek()&#x2F;&#x2F;peek at top of stack</span><br><span class="line">	&#123;</span><br><span class="line">		return stackArray[top];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean isEmpty()&#x2F;&#x2F;true if stack is empty</span><br><span class="line">	&#123;</span><br><span class="line">		return (top &#x3D;&#x3D; -1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean isFull()&#x2F;&#x2F;true if stack is empty</span><br><span class="line">	&#123;</span><br><span class="line">		return (top &#x3D;&#x3D; maxSize-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end class StackXX</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Reverser &#123;</span><br><span class="line">	private String input;&#x2F;&#x2F;input string</span><br><span class="line">	private String output;&#x2F;&#x2F;output string</span><br><span class="line">	</span><br><span class="line">	public Reverser(String in)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		input &#x3D; in;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String doRev()&#x2F;&#x2F;reverse the string</span><br><span class="line">	&#123;</span><br><span class="line">		int stackSize &#x3D; input.length();&#x2F;&#x2F;get max stack size</span><br><span class="line">		StackXX theStack &#x3D; new StackXX(stackSize);&#x2F;&#x2F;make stack</span><br><span class="line">		</span><br><span class="line">		for(int j&#x3D;0; j&lt;input.length(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			char ch &#x3D; input.charAt(j);&#x2F;&#x2F;get a char from input</span><br><span class="line">			theStack.push(ch);&#x2F;&#x2F;push it</span><br><span class="line">		&#125;</span><br><span class="line">		output &#x3D; &quot;&quot;;</span><br><span class="line">		while( !theStack.isEmpty() )</span><br><span class="line">		&#123;</span><br><span class="line">			char ch &#x3D; theStack.pop();&#x2F;&#x2F;pop a char</span><br><span class="line">			output &#x3D; output + ch;&#x2F;&#x2F;append to output</span><br><span class="line">		&#125;</span><br><span class="line">		return output;</span><br><span class="line">	&#125;&#x2F;&#x2F;end doRev()</span><br><span class="line">&#125;&#x2F;&#x2F;end class Reverser</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">class ReverseApp &#123;</span><br><span class="line">	public static void main(String[] args) throws IOException</span><br><span class="line">	&#123;</span><br><span class="line">		String input,output;</span><br><span class="line">		while( true )</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(&quot;Enter a string: &quot;);</span><br><span class="line">			System.out.flush();</span><br><span class="line">			input &#x3D; getString();&#x2F;&#x2F;read a string from kbd</span><br><span class="line">			if( input.equals(&quot;&quot;) )&#x2F;&#x2F;quit if [Enter]</span><br><span class="line">				break;</span><br><span class="line">			&#x2F;&#x2F;make a Reverser</span><br><span class="line">			</span><br><span class="line">			Reverser theReverser &#x3D; new Reverser(input);</span><br><span class="line">			output &#x3D; theReverser.doRev();&#x2F;&#x2F;use it</span><br><span class="line">			System.out.println(&quot;Reversed: &quot; + output);</span><br><span class="line">		&#125;&#x2F;&#x2F;end while</span><br><span class="line">	&#125;&#x2F;&#x2F;end main</span><br><span class="line">	</span><br><span class="line">	public static String getString() throws IOException</span><br><span class="line">	&#123;</span><br><span class="line">		InputStreamReader isr &#x3D; new InputStreamReader(System.in);</span><br><span class="line">		BufferedReader br &#x3D; new BufferedReader(isr);</span><br><span class="line">		String s &#x3D; br.readLine();</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; end class ReverseApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter a string: part</span><br><span class="line">Reversed: trap</span><br><span class="line">Enter a string:</span><br></pre></td></tr></table></figure>
<h1 id="清单4-3-Page90"><a class="header-anchor" href="#清单4-3-Page90">¶</a>清单4.3 Page90</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class StackXX &#123;</span><br><span class="line">	private int maxSize;&#x2F;&#x2F;size of stack array</span><br><span class="line">	private char[] stackArray;</span><br><span class="line">	private int top;&#x2F;&#x2F;top of stack</span><br><span class="line">	</span><br><span class="line">	public StackXX(int max)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		maxSize &#x3D; max;&#x2F;&#x2F;set array size</span><br><span class="line">		stackArray &#x3D; new char[maxSize];&#x2F;&#x2F;create array</span><br><span class="line">		top &#x3D; -1;&#x2F;&#x2F;mo items yet</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void push(char j)&#x2F;&#x2F;put item on top of stack</span><br><span class="line">	&#123;</span><br><span class="line">		stackArray[++top] &#x3D; j;&#x2F;&#x2F;increment top,insert item</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public char pop()&#x2F;&#x2F;take item from top of stack</span><br><span class="line">	&#123;</span><br><span class="line">		return stackArray[top--];&#x2F;&#x2F;access item,decrement top</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public char peek()&#x2F;&#x2F;peek at top of stack</span><br><span class="line">	&#123;</span><br><span class="line">		return stackArray[top];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean isEmpty()&#x2F;&#x2F;true if stack is empty</span><br><span class="line">	&#123;</span><br><span class="line">		return (top &#x3D;&#x3D; -1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean isFull()&#x2F;&#x2F;true if stack is empty</span><br><span class="line">	&#123;</span><br><span class="line">		return (top &#x3D;&#x3D; maxSize-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end class StackX</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BracketChecker &#123;</span><br><span class="line">	private String input;&#x2F;&#x2F;input string</span><br><span class="line">	</span><br><span class="line">	public BracketChecker(String in)&#x2F;&#x2F;constructor</span><br><span class="line">	&#123;</span><br><span class="line">		input &#x3D; in;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void check()</span><br><span class="line">	&#123;</span><br><span class="line">		int stackSize &#x3D; input.length();&#x2F;&#x2F;get max stack size</span><br><span class="line">		StackXX theStack &#x3D; new StackXX(stackSize);&#x2F;&#x2F;make stack</span><br><span class="line">		</span><br><span class="line">		for(int j&#x3D;0; j&lt;input.length(); j++)&#x2F;&#x2F;get chars in turn</span><br><span class="line">		&#123;</span><br><span class="line">			char ch &#x3D; input.charAt(j);&#x2F;&#x2F;get char</span><br><span class="line">			switch(ch)</span><br><span class="line">			&#123;</span><br><span class="line">			case &#39;&#123;&#39;:&#x2F;&#x2F;opening symbols</span><br><span class="line">			case &#39;[&#39;:</span><br><span class="line">			case &#39;(&#39;:</span><br><span class="line">				theStack.push(ch);&#x2F;&#x2F;push them</span><br><span class="line">			break;</span><br><span class="line">			</span><br><span class="line">			case &#39;&#125;&#39;:&#x2F;&#x2F;closing symbols</span><br><span class="line">			case &#39;]&#39;:</span><br><span class="line">			case &#39;)&#39;:</span><br><span class="line">				if( !theStack.isEmpty() )&#x2F;&#x2F;if stack not empty</span><br><span class="line">				&#123;</span><br><span class="line">					char chx &#x3D; theStack.pop();&#x2F;&#x2F;pop and check</span><br><span class="line">					if( (ch&#x3D;&#x3D;&#39;&#125;&#39; &amp;&amp; chx!&#x3D;&#39;&#123;&#39;) || (ch&#x3D;&#x3D;&#39;]&#39; &amp;&amp; chx!&#x3D;&#39;[&#39;) ||(ch&#x3D;&#x3D;&#39;)&#39; &amp;&amp; chx!&#x3D;&#39;(&#39;))</span><br><span class="line">						System.out.println(&quot;Error: &quot; +ch+&quot; at &quot;+j);</span><br><span class="line">				&#125;</span><br><span class="line">				else&#x2F;&#x2F;prematurely empty</span><br><span class="line">					System.out.println(&quot;Error: &quot; +ch+&quot; at &quot;+j);</span><br><span class="line">				break;</span><br><span class="line">				default:&#x2F;&#x2F;no action on other characters</span><br><span class="line">					break;</span><br><span class="line">			&#125;&#x2F;&#x2F;end switch</span><br><span class="line">		&#125;&#x2F;&#x2F;end for</span><br><span class="line">		&#x2F;&#x2F;at this point, all characters have been processed</span><br><span class="line">		if( !theStack.isEmpty() )</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;Error: missing right delimiter&quot;);</span><br><span class="line">		&#125;&#x2F;&#x2F;end check()</span><br><span class="line">	&#125;&#x2F;&#x2F;end class BracketChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">class BracketsApp &#123;</span><br><span class="line">	public static void main(String[] args) throws IOException</span><br><span class="line">	&#123;</span><br><span class="line">		String input;</span><br><span class="line">		while( true )</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(&quot;Enter string containing delimiters: &quot;);</span><br><span class="line">			System.out.flush();</span><br><span class="line">			input &#x3D; getString();&#x2F;&#x2F;read a string from kbd</span><br><span class="line">			if( input.equals(&quot;&quot;) )&#x2F;&#x2F;quit if [Enter]</span><br><span class="line">				break;</span><br><span class="line">			&#x2F;&#x2F;make a Reverser</span><br><span class="line">			</span><br><span class="line">			BracketChecker theChecker &#x3D; new BracketChecker(input);</span><br><span class="line">			theChecker.check();&#x2F;&#x2F;check brackets</span><br><span class="line">		&#125;&#x2F;&#x2F;end while</span><br><span class="line">	&#125;&#x2F;&#x2F;end main</span><br><span class="line">	</span><br><span class="line">	public static String getString() throws IOException</span><br><span class="line">	&#123;</span><br><span class="line">		InputStreamReader isr &#x3D; new InputStreamReader(System.in);</span><br><span class="line">		BufferedReader br &#x3D; new BufferedReader(isr);</span><br><span class="line">		String s &#x3D; br.readLine();</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end class BracketsApp</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter string containing delimiters: a&#123;b(c]d&#125;e</span><br><span class="line">Error: ] at 5</span><br><span class="line">Enter string containing delimiters:</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java数据结构和算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>源代码</tag>
        <tag>电子书</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（七）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍修改主题页面布局为圆角，去掉顶部黑线，添加动态背景—粒子漂浮聚合，文章添加结束标记，设置标题样式，修改文章底部#为图标，设置博客的图标，创建标签页，创建分类页，创建关于页，显示当前浏览进度，个性化回到顶部，修改博客字体，添加站内搜索，去掉文章中图片默认的边框，</p>
<a id="more"></a>
<h1 id="一、修改主题页面布局为圆角"><a class="header-anchor" href="#一、修改主题页面布局为圆角">¶</a>一、修改主题页面布局为圆角</h1>
<p>打开文件，路径：<code>\themes\next\source\css\_variables\Gemini.styl</code> ，添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改主题页面布局为圆角</span><br><span class="line">$border-radius-inner           &#x3D; 15px 15px 15px 15px;</span><br><span class="line">$border-radius                 &#x3D; 15px;</span><br></pre></td></tr></table></figure>
<h1 id="二、去掉顶部黑线"><a class="header-anchor" href="#二、去掉顶部黑线">¶</a>二、去掉顶部黑线</h1>
<p>打开文件，路径：<code>themes\next\source\css\_custom\custom.styl</code> ，添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;去掉顶部黑线：</span><br><span class="line">.headband &#123;display:none;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、添加动态背景—粒子漂浮聚合"><a class="header-anchor" href="#三、添加动态背景—粒子漂浮聚合">¶</a>三、添加动态背景—粒子漂浮聚合</h1>
<p>该功能由 <code>theme-next-canvas-nest</code> 插件提供，在根目录下执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;canvas-nest</span><br></pre></td></tr></table></figure>
<p>然后在<code>主题配置</code>文件中找到<code>canvas_nest</code>，修改为：<code>canvas_nest: true</code> 。</p>
<h1 id="四、文章添加结束标记"><a class="header-anchor" href="#四、文章添加结束标记">¶</a>四、文章添加结束标记</h1>
<p>在路径：<code>themes\next\layout\_macro</code>下新建<code>passage-end-tag.swig</code>文件。</p>
<p>打开<code>passage-end-tag.swig</code>，粘贴以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">       &lt;div style&#x3D;&quot;text-align:center;color:#bfbfbf;font-size:16px;&quot;&gt;</span><br><span class="line">             &lt;span&gt;-------- 本文结束 &lt;&#x2F;span&gt;</span><br><span class="line">             &lt;i class&#x3D;&quot;fa fa-paw&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">             &lt;span&gt; 感谢阅读 --------&lt;&#x2F;span&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>themes\next\layout\_macro\post.swig</code>，在<code>post-body</code>之后，<code>post-footer</code>之前，添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &#123;% include &#39;passage-end-tag.swig&#39; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>打开<strong>主题配置</strong>文件，在最后位置添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_end_tag:</span><br><span class="line">    enabled: true # 是否开启文末的本文结束标记</span><br></pre></td></tr></table></figure>
<h1 id="五、设置标题样式"><a class="header-anchor" href="#五、设置标题样式">¶</a>五、设置标题样式</h1>
<p>打开文件，路径：<code>themes\next\source\css\_common\components\post\post.styl</code></p>
<p>粘贴以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*修改博文标题样式*&#x2F;</span><br><span class="line">.post-title &#123;</span><br><span class="line">    font-size: 26px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    word-break: break-word;</span><br><span class="line">    font-weight: $posts-expand-title-font-weight</span><br><span class="line">    background-color: #b9d3ee;</span><br><span class="line">    border-radius:.3em;</span><br><span class="line">    line-height:1em;</span><br><span class="line">    padding-bottom:.12em;</span><br><span class="line">    padding-top:.12em;</span><br><span class="line">    box-shadow:2px 2px 7px #9fb6cd;</span><br><span class="line">    +mobile() &#123;</span><br><span class="line">      font-size: 22px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六、修改文章底部-为图标"><a class="header-anchor" href="#六、修改文章底部-为图标">¶</a>六、修改文章底部#为图标</h1>
<p>打开文件，路径：<code>/themes/next/layout/_macro/post.swig</code> 搜索找到 <code>rel=&quot;tag&quot;&gt;#</code> 把#替换为如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>
<h1 id="七、设置博客的图标"><a class="header-anchor" href="#七、设置博客的图标">¶</a>七、设置博客的图标</h1>
<p>首先访问网站：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.easyicon.net&#x2F;</span><br></pre></td></tr></table></figure>
<p>找一张（32*32）的ico图标，或者自己制作也行，图标名称改为<code>favicon.ico</code> 。放在路径：<code>/themes/next/source/images</code> 里。</p>
<p>之后打开<strong>主题配置</strong>文件，搜索并找到favicon，修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">    small: &#x2F;images&#x2F;favicon.ico</span><br><span class="line">    medium: &#x2F;images&#x2F;favicon.ico</span><br></pre></td></tr></table></figure>
<h1 id="八、创建标签页"><a class="header-anchor" href="#八、创建标签页">¶</a>八、创建标签页</h1>
<p>新建标签页首先在根目录下执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>执行后会在根目录<code>source</code>文件夹里新建<code>tags</code>。而<code>index.md</code>就是标签页。</p>
<p>打开<code>index.md</code>，最后面添加一行<code>type: &quot;tags&quot;</code> 注意冒号后有一空格。</p>
<p>在<strong>主题配置</strong>文件里，菜单设置里<code>/</code>后面应该没有空格直接跟<code>||</code>。但是主题默认的是有空格的。<strong>删除中间的空格</strong>。</p>
<h1 id="九、创建分类页"><a class="header-anchor" href="#九、创建分类页">¶</a>九、创建分类页</h1>
<p>创建分类页、关于页等等菜单与第8步一样。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>修改.md文件，主要title和type，type为<code>categories</code>。相对应。</p>
<h1 id="十、创建关于页"><a class="header-anchor" href="#十、创建关于页">¶</a>十、创建关于页</h1>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
<p>修改.md文件，主要title和type，type为<code>about</code>。相对应。</p>
<h1 id="十一、显示当前浏览进度"><a class="header-anchor" href="#十一、显示当前浏览进度">¶</a>十一、显示当前浏览进度</h1>
<p>打开<strong>主题配置</strong>文件，搜索找到<code>b2t</code>和<code>scrollpercent</code>。修改为<code>true</code>。</p>
<h1 id="十二、个性化回到顶部"><a class="header-anchor" href="#十二、个性化回到顶部">¶</a>十二、个性化回到顶部</h1>
<p>下载链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.lanzous.com&#x2F;i8nozmh</span><br></pre></td></tr></table></figure>
<p>把图片放在<code>source\images\</code> 下。</p>
<p>打开文件，路径：<code>themes\next\source\css\_custom\custom.styl</code>。在最后粘贴以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义回到顶部样式</span><br><span class="line">.back-to-top &#123;</span><br><span class="line">    right: 60px;</span><br><span class="line">    width: 70px; &#x2F;&#x2F;图片素材宽度</span><br><span class="line">    height: 900px; &#x2F;&#x2F;图片素材高度</span><br><span class="line">    top: -900px;</span><br><span class="line">    bottom: unset;</span><br><span class="line">    transition: all .5s ease-in-out;</span><br><span class="line">    background: url(&quot;&#x2F;images&#x2F;scroll.png&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;隐藏箭头图标</span><br><span class="line">&gt; i &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&amp;.back-to-top-on &#123;</span><br><span class="line">  bottom: unset;</span><br><span class="line">  top: 100vh &lt; (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存后本地预览，就可以看到动态效果了，但是这种返回顶部要使第11步的两项为<code>false</code>，否则会出现Bug。</p>
<h1 id="十三、修改博客字体"><a class="header-anchor" href="#十三、修改博客字体">¶</a>十三、修改博客字体</h1>
<p>访问网站：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;fonts.google.com&#x2F;</span><br></pre></td></tr></table></figure>
<p>找到自己想要设置的字体。</p>
<p>打开主题配置文件，找到<code>font</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">enable: true</span><br><span class="line"></span><br><span class="line"># 外链字体库地址，例如 &#x2F;&#x2F;fonts.googleapis.com (默认值)</span><br><span class="line">host:</span><br><span class="line"></span><br><span class="line"># 全局字体，应用在 body 元素上</span><br><span class="line">global:</span><br><span class="line">  external: true</span><br><span class="line">  family: Monda</span><br><span class="line"></span><br><span class="line"># 标题字体 (h1, h2, h3, h4, h5, h6)</span><br><span class="line">headings:</span><br><span class="line">  external: true</span><br><span class="line">  family: Roboto Slab</span><br><span class="line"></span><br><span class="line"># 文章字体</span><br><span class="line">posts:</span><br><span class="line">  external: true</span><br><span class="line">  family:</span><br><span class="line"></span><br><span class="line"># Logo 字体</span><br><span class="line">logo:</span><br><span class="line">  external: true</span><br><span class="line">  family:</span><br><span class="line"></span><br><span class="line"># 代码字体，应用于 code 以及代码块</span><br><span class="line">codes:</span><br><span class="line">  external: true</span><br><span class="line">  family:</span><br></pre></td></tr></table></figure>
<p>按照这种形式修改字体类型。字体为刚才网站上的字体名称。修改后保存。</p>
<h1 id="十四、添加站内搜索"><a class="header-anchor" href="#十四、添加站内搜索">¶</a>十四、添加站内搜索</h1>
<p>首先安装插件，输入以下两个命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>之后先在<strong>站点配置</strong>里末尾增加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">    path: search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure>
<p>再在<strong>主题配置</strong>文件里搜索找到<code>local_search</code>修改为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
<h1 id="十五、去掉文章中图片默认的边框"><a class="header-anchor" href="#十五、去掉文章中图片默认的边框">¶</a>十五、去掉文章中图片默认的边框</h1>
<p>打开文件，路径：<code>/themes/next/source/css/_common/components/post/post-expand.styl</code>。</p>
<p>找到<code>img</code>，把<code>border</code>修改为<code>none</code>。</p>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记【求知课堂】（二）</title>
    <url>/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>网址：<a href="https://www.bilibili.com/video/av76235341" target="_blank" rel="noopener">https://www.bilibili.com/video/av76235341</a></strong></p>
<p>【P13-38】</p>
<a id="more"></a>
<h1 id="二、Java基本语法"><a class="header-anchor" href="#二、Java基本语法">¶</a>二、Java基本语法</h1>
<h2 id="2-1-关键字"><a class="header-anchor" href="#2-1-关键字">¶</a>2.1  关键字</h2>
<p><strong>关键字的定义和特点</strong><br>
定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）<br>
特点：关键字中所有字母都为小写</p>
<p>关键字：就是在java语言编程的时候，在关键的地方使用的单词，体现关键的地方的含义，这些单词都是特有的事先定义好的</p>
<table>
<thead>
<tr>
<th style="text-align:center">用于定义数据类型的关键字</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>class</code></td>
<td style="text-align:center"><code>interface</code></td>
<td style="text-align:center"><code>enum</code></td>
<td style="text-align:center"><code>byte</code></td>
<td style="text-align:center"><code>short</code></td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>char</code></td>
</tr>
<tr>
<td style="text-align:center"><code>boolean</code></td>
<td style="text-align:center"><code>void</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>用于定义数据类型值的关键字</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>true</code></td>
<td style="text-align:center"><code>false</code></td>
<td style="text-align:center"><code>null</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>用于定义流程控制的关键字</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>if</code></td>
<td style="text-align:center"><code>else</code></td>
<td style="text-align:center"><code>switch</code></td>
<td style="text-align:center"><code>case</code></td>
<td style="text-align:center"><code>default</code></td>
</tr>
<tr>
<td style="text-align:center"><code>while</code></td>
<td style="text-align:center"><code>do</code></td>
<td style="text-align:center"><code>for</code></td>
<td style="text-align:center"><code>break</code></td>
<td style="text-align:center"><code>continue</code></td>
</tr>
<tr>
<td style="text-align:center"><code>return</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">用于定义访问权限修饰符的关键字</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Private</code></td>
<td style="text-align:center"><code>Protected</code></td>
<td style="text-align:center"><code>Public</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>用于定义类，函数，变量修饰符的关键字</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>abstract</code></td>
<td style="text-align:center"><code>final</code></td>
<td style="text-align:center"><code>static</code></td>
<td style="text-align:center"><code>synchronized</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>用于定义类与类之间关系的关键字</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>extends</code></td>
<td style="text-align:center"><code>implements</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>用于定义建立实例及引用实例，判断实例的关键字</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>new</code></td>
<td style="text-align:center"><code>this</code></td>
<td style="text-align:center"><code>super</code></td>
<td style="text-align:center"><code>instanceof</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>用于异常处理的关键字</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>try</code></td>
<td style="text-align:center"><code>catch</code></td>
<td style="text-align:center"><code>finally</code></td>
<td style="text-align:center"><code>throw</code></td>
<td style="text-align:center"><code>throws</code></td>
</tr>
<tr>
<td style="text-align:center"><code>用于包的关键字</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>package</code></td>
<td style="text-align:center"><code>import</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>其他修饰符关键字</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>native</code></td>
<td style="text-align:center"><code>strictfp</code></td>
<td style="text-align:center"><code>transient</code></td>
<td style="text-align:center"><code>volatile</code></td>
<td style="text-align:center"><code>assert</code></td>
</tr>
</tbody>
</table>
<h3 id="保留字"><a class="header-anchor" href="#保留字">¶</a>保留字</h3>
<p>Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标记符时要避免使用这些保留字：<code>byValue</code>、<code>cast</code>、<code>future</code>、 <code>generic</code>、 <code>inner</code>、 <code>operator</code>、 <code>outer</code>、 <code>rest</code>、 <code>var</code> 、 <code>goto</code> 、<code>const</code>。</p>
<p>保留字：可能在以后被用来作为关键字的单词，java已经把这些单词预定了，这些单词尽量就不要在编程中去随意使用</p>
<h3 id="文本编辑器"><a class="header-anchor" href="#文本编辑器">¶</a>文本编辑器</h3>
<p>Windows： Notepad++、UltraEdit 、EditPlus</p>
<p>Mac： Sublime Text、BBEdit</p>
<h2 id="2-2-标识符"><a class="header-anchor" href="#2-2-标识符">¶</a>2.2  标识符</h2>
<p><strong>标识符：</strong><br>
Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符<br>
凡是自己可以起名字的地方都叫标识符。<br>
<strong>定义合法标识符规则：</strong><br>
由26个英文字母大小写，0-9 ，_或 $ 组成<br>
数字不可以开头。<br>
不可以使用关键字和保留字，但能包含关键字和保留字。<br>
Java中严格区分大小写，长度无限制。<br>
标识符不能包含空格。</p>
<p><em>abc_1$</em></p>
<p><em>标识符可以是Test1,不能是1Test</em></p>
<p><em>比如，类名不能直接使用class,可以是class1</em></p>
<p><strong>注意：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</strong></p>
<h3 id="Java中的名称命名规范"><a class="header-anchor" href="#Java中的名称命名规范">¶</a>Java中的名称命名规范</h3>
<p>Java中的名称命名规范：<br>
包名：多单词组成时所有字母都小写：xxxyyyzzz<br>
类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz<br>
变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz<br>
常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p>
<p><em>命名规范，是一套约定俗成的规则</em></p>
<h2 id="2-3-变量"><a class="header-anchor" href="#2-3-变量">¶</a>2.3  变量</h2>
<p><em>代数，未知数的概念</em><br>
<em>设x=1，x+1=?</em></p>
<p><em>java中变量的定义：数据类型 变量名 = 变量的值，例如：int i = 1</em></p>
<p><em>int i = 1</em><br>
<em>i = 2</em></p>
<p><em>注意：声明变量过程中的这个=，不是数学意义上的=，在java编程中代表赋值（赋予变量值）</em></p>
<p><strong>变量的概念：</strong><br>
内存中的一个存储区域<br>
该区域有自己的名称（变量名）和类型（数据类型）<br>
Java中每个变量必须先声明，后使用<br>
该区域的数据可以在同一类型范围内不断变化<br>
<strong>使用变量注意：</strong><br>
变量的作用域：一对{ }之间有效	<br>
初始化值<br>
**定义变量的格式：**数据类型    变量名  =  初始化值<br>
变量是通过使用变量名来访问这块区域的</p>
<h3 id="变量的分类-按数据类型"><a class="header-anchor" href="#变量的分类-按数据类型">¶</a>变量的分类-按数据类型</h3>
<p>对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" alt></p>
<p>补充：变量的分类-按声明的位置的不同</p>
<p><em>变量的类型：声明的变量的数据类型就是变量的类型</em></p>
<p><em>在java中，数据类型分为基本数据类型和引用数据类型，其中基本数据类型有8中，除了这8中之外其他所有的数据类型都是引用数据类型</em></p>
<p>​		<strong>在方法体外，类体内声明的变量称为成员变量。</strong><br>
​		<strong>在方法体内部声明的变量称为局部变量。</strong></p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" alt></p>
<p><strong>注意：二者在初始化值方面的异同:</strong><br>
<strong>同：都有生命周期      异：局部变量除形参外，需显式初始化。</strong></p>
<h3 id="整数类型：byte、short、int、long"><a class="header-anchor" href="#整数类型：byte、short、int、long">¶</a>整数类型：byte、short、int、long</h3>
<p>​		Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。<br>
​		java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>类  型</strong></th>
<th style="text-align:center"><strong>占用存储空间</strong></th>
<th style="text-align:center"><strong>表数范围</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1字节=8bit</td>
<td style="text-align:center">-128 ~ 127</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2字节</td>
<td style="text-align:center">-2^15 ~2^15-1</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8字节</td>
<td style="text-align:center">-2^63 ~ 2^63-1</td>
</tr>
</tbody>
</table>
<p><em>byte的范围-128到127之间，声明byte类型变量的时候赋值不能超过这个范围，给byte类型变量赋值时不能超过这个范围</em></p>
<p><em>byte b = 130，这个就是超出范围了是错误的</em></p>
<p><em>byte b = 126</em></p>
<p>bit是什么单位？</p>
<p><em>0100110，这个就7bit</em></p>
<p><em>byte b = 126</em><br>
<em>int i = 1</em><br>
<em>short s = 1</em><br>
<em>long l = 3l,这个long类型变量赋值时要在值的后面跟上一个字母l</em></p>
<h3 id="浮点类型：float、double"><a class="header-anchor" href="#浮点类型：float、double">¶</a>浮点类型：float、double</h3>
<p>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体OS的影响。<br>
<strong>Java 的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。</strong><br>
浮点型常量有两种表示形式：<br>
十进制数形式：如：5.12       512.0f        .512   (必须有小数点）<br>
科学计数法形式:如：5.12e2      512E2     100E-2</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>类 型</strong></th>
<th style="text-align:center"><strong>占用存储空间</strong></th>
<th style="text-align:center"><strong>表数范围</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单精度float</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td style="text-align:center">双精度double</td>
<td style="text-align:center">8字节</td>
<td style="text-align:center">-1.798E308 ~ 1.798E308</td>
</tr>
</tbody>
</table>
<p><em>double d = 1.22</em><br>
<em>float f = 1.22f,float类型变量赋值时值后面跟上字母f</em></p>
<h3 id="字符类型：char"><a class="header-anchor" href="#字符类型：char">¶</a>字符类型：char</h3>
<p>char 型数据用来表示通常意义上“字符”(2字节)<br>
字符型常量的三种表现形式：<br>
字符常量是用单引号(‘ ’)括起来的单个字符，涵盖世界上所有书面语的字符。例如：<code>char c1 = 'a';   char c2 = '中'; char c3 =  '9';</code><br>
Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例如：<code>char c3 = ‘\n’;  // '\n'表示换行符</code><br>
直接使用 Unicode 值来表示字符型常量：<code>‘\uXXXX’</code>。其中，XXXX代表一个十六进制整数。如：<code>\u000a</code> 表示 <code>\n</code>。<br>
char类型是可以进行运算的。因为它都对应有Unicode码。</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" alt></p>
<p><em>字符：用英文的单引号括起来的单个的字母、数字、符号</em></p>
<p><em>比如：</em><br>
<em>char c1 = ‘a’</em><br>
<em>char c2 = ‘1’</em><br>
<em>char c3 = ‘%’</em></p>
<p><em>char c4 = ‘\n’</em></p>
<h3 id="布尔类型：boolean"><a class="header-anchor" href="#布尔类型：boolean">¶</a>布尔类型：boolean</h3>
<p><code>boolean</code> 类型适于逻辑运算，一般用于程序流程控制：<br>
if条件控制语句；<br>
while循环控制语句；<br>
do-while循环控制语句；<br>
for循环控制语句；<br>
<code>boolean</code>类型数据只允许取值true和false，无null。<br>
不可以0或非 0 的整数替代false和true，这点和C语言不同。</p>
<p><em>boolean b1 = true</em></p>
<p><em>boolean b2 = false</em></p>
<p>byte short int long float double char boolean,8种基本数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test1&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		&#x2F;&#x2F;System.out.print(&quot;sss\n&quot;);</span><br><span class="line">		&#x2F;&#x2F;System.out.println(&quot;sss&quot;);</span><br><span class="line">		</span><br><span class="line">		byte b &#x3D; 1;</span><br><span class="line">		System.out.println(b);</span><br><span class="line">		</span><br><span class="line">		short s &#x3D; 2;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">		</span><br><span class="line">		int i &#x3D; 4;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		</span><br><span class="line">		long l &#x3D; 79l;</span><br><span class="line">		System.out.println(l);</span><br><span class="line">		</span><br><span class="line">		float f &#x3D; 1.23f;</span><br><span class="line">		System.out.println(f);</span><br><span class="line">		</span><br><span class="line">		double d &#x3D; 1.56;</span><br><span class="line">		System.out.println(d);</span><br><span class="line">		</span><br><span class="line">		char c &#x3D; &#39;a&#39;;</span><br><span class="line">		System.out.println(c);</span><br><span class="line">		</span><br><span class="line">		boolean b1 &#x3D; false;</span><br><span class="line">		System.out.println(b1);</span><br><span class="line">		</span><br><span class="line">		String str &#x3D; &quot;hello&quot; + &quot; world&quot;;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串：-String类"><a class="header-anchor" href="#字符串：-String类">¶</a>字符串： String类</h3>
<p>​		值null可以赋值给任何引用类型（类、接口、数组）的变量，用以表示这个引用类型变量中保存的地址为空。<br>
​		String类属于引用类型，可用null赋值。<br>
​		String类是一个典型的不可变类，String对象创建出来就不可能被改变。创建出的字符串将存放在数据区，保证每个字符串常量只有一个，不会产生多个副本。</p>
<p><em>字符串？就是由0到多个字母数字符号共同组成的一个串，这个串要用英文的双引号括起来</em></p>
<p><em>引用类型，都可以用null作为值，也就是说可以在初始化的时候赋值为null</em><br>
<em>String是引用类型，也就是说可以使用null作为值</em></p>
<p><em>int i0 = 1</em><br>
<em>int i1 = 1</em><br>
<em>以上这种会在内存中存储2个1的值</em></p>
<p><em>String s0 = “hello”</em><br>
<em>String s1 = “hello”</em><br>
<em>这种的，不会在内存中存在两个&quot;hello&quot;，只存在1一个&quot;hello&quot;</em></p>
<p><em>假设&quot;hello&quot;的内存地址xxxxx,声明s0变量时给s0赋值&quot;hello&quot;实际上让s0变量引用&quot;hello&quot;的内存地址xxxxx；当我们再声明变量s1也赋值&quot;hello&quot;的时候实际上也是直接把已经存在的&quot;hello&quot;的内存地址给s1引用</em></p>
<p><em>String s3 = “he” + “ll” + “o”;</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s0 &#x3D; “hello”;</span><br><span class="line">   String s1 &#x3D; “hello”;</span><br><span class="line">   String s2 &#x3D; “he” + “ll”+”o”;</span><br><span class="line">   System.out.println(s0 &#x3D;&#x3D;s1);</span><br><span class="line">   System.out.println(s0 &#x3D;&#x3D;s2);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<h3 id="集成开发环境（IDE）"><a class="header-anchor" href="#集成开发环境（IDE）">¶</a>集成开发环境（IDE）</h3>
<p><em>创建一个java文件，用文本编辑器打开，写代码，打开dos界面，javac编译，java运行</em></p>
<p><em>集成开发环境就是为了解决刚才咱们所说的问题，里面包含文本编辑工作，自动编译，简化运行，随时进行代码的调试</em></p>
<p>Eclipse安装（推荐）<br>
官网下载，方法看以下<strong>网址</strong><br>
<strong><a href="https://jingyan.baidu.com/article/b0b63dbf02e4d24a4830701a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/b0b63dbf02e4d24a4830701a.html</a></strong></p>
<h3 id="基本数据类型转换"><a class="header-anchor" href="#基本数据类型转换">¶</a>基本数据类型转换</h3>
<p>​		自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" alt></p>
<p>​		有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。<br>
​		byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。<br>
​		当把任何基本类型的值和字符串值进行连接运算时(+)，基本类型的值将自动转化为字符串类型。</p>
<p><em>ASCII码：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#x2F;&#x2F;		int i &#x3D; 0;&#x2F;&#x2F;声明并初始化变量</span><br><span class="line">&#x2F;&#x2F;		i &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;		int k &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;		i &#x3D; k;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(i);</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		byte b &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;		int m &#x3D; b;</span><br><span class="line">&#x2F;&#x2F;		int i &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;		byte b &#x3D; i;&#x2F;&#x2F;这种异常问题叫做编译器异常，只有在javac的时候发现</span><br><span class="line">&#x2F;&#x2F;		byte b &#x3D; 3;</span><br><span class="line">&#x2F;&#x2F;		short m &#x3D; b;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(m);</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		int i &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;		short s &#x3D; 2;</span><br><span class="line">&#x2F;&#x2F;		byte b &#x3D; 3;</span><br><span class="line">&#x2F;&#x2F;		int res &#x3D; i + s + b;&#x2F;&#x2F;问题，最后得到的数字6是哪一个声明类型呢？在计算过程中i，s，b这三个变量会做数据类型的转换吗</span><br><span class="line">&#x2F;&#x2F;		&#x2F;&#x2F;在计算过程中，整数类型是int的范围最大，所以s和b都分别先转换成int类型，然后进行加的运算，最终及结果是int的数据。</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		char c &#x3D; &#39;a&#39;;&#x2F;&#x2F;char类型的数据在与数字进行数学运算的时候，它是转换为相对应的ASCII码的值，然后在进行的计算</span><br><span class="line">&#x2F;&#x2F;		byte b0 &#x3D; 2;</span><br><span class="line">&#x2F;&#x2F;		int k &#x3D; c + b0;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(k);</span><br><span class="line">		</span><br><span class="line">		String str &#x3D; &quot;abc&quot;;</span><br><span class="line">		String str0 &#x3D; &quot;1&quot; + 2 + 3;</span><br><span class="line">		int i &#x3D; 1;</span><br><span class="line">		</span><br><span class="line">		String str1 &#x3D; 1 + 3 + 5 + &quot;abc&quot; + 2 + 6;&#x2F;&#x2F;9abc26</span><br><span class="line">		</span><br><span class="line">		System.out.println(str + i);</span><br><span class="line">		System.out.println(str0);</span><br><span class="line">		System.out.println(str1);</span><br><span class="line">&#x2F;&#x2F;注意：当有一些列的+的运算的时候，如果某个部分其中含有字符串，那么这个字符串前边挨着的+开始一直往后都是要按照字符串拼接去看。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习1"><a class="header-anchor" href="#练习1">¶</a>练习1</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str1 &#x3D; 4;        &#x2F;&#x2F;判断对错：错  需要加上双引号</span><br><span class="line">String str2 &#x3D; 3.5f + “”;             &#x2F;&#x2F;判断str2对错：对</span><br><span class="line">System.out.println(str2);        &#x2F;&#x2F;输出：3.5</span><br><span class="line">System.out .println(3+4+“Hello!”);      &#x2F;&#x2F;输出：7Hello!</span><br><span class="line">System.out.println(“Hello!”+3+4);      &#x2F;&#x2F;输出：Hello!34</span><br><span class="line">System.out.println(‘a’+1+“Hello!”);    &#x2F;&#x2F;输出：98Hello!</span><br><span class="line">System.out.println(“Hello!”+‘a’+1);            &#x2F;&#x2F;输出：Hello!a1</span><br></pre></td></tr></table></figure>
<h3 id="强制类型转换"><a class="header-anchor" href="#强制类型转换">¶</a>强制类型转换</h3>
<p>​		自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符（<code>()</code>），但可能造成精度降低或溢出,格外要注意。<br>
​		通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。<br>
​		如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a &#x3D; “43”; int i &#x3D; Integer.parseInt(a);</span><br></pre></td></tr></table></figure>
<p>​		<code>boolean</code>类型不可以转换为其它的数据类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		byte b &#x3D; 9;</span><br><span class="line">		int i &#x3D; b;</span><br><span class="line">		&#x2F;&#x2F;以上这两行属于正常隐式转换</span><br><span class="line">		</span><br><span class="line">		int k &#x3D; 7;</span><br><span class="line">		byte b0 &#x3D; (byte)k;&#x2F;&#x2F;这个就是强制转换数据类型，转换的数据类型要用英文的小括号括起来。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>数字类型的运算规则：</em><br>
<em>1、有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。数字类型的从小到大分别是byte、short、int、long、float、double。</em><br>
<em>2、数字类型的运算中，多个相同类型变量参与的运算，变量要先转换为相对应的数据类型的默认类型（比如两个byte类型的变量相加，会先把两个byte类型的变量转换成默认的int类型之后再计算，得到的结果是int类型）。这种情况适用于变量的数据类型的容量比默认类型的容量小，（比如byte，short，都比int小）</em><br>
<em>3、byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</em></p>
<h3 id="练习2"><a class="header-anchor" href="#练习2">¶</a>练习2</h3>
<p>判断是否能通过编译</p>
<p>1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">short  s &#x3D; 5;</span><br><span class="line">   s &#x3D; s-2;                       &#x2F;&#x2F;判断：错</span><br></pre></td></tr></table></figure>
<p>2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte b &#x3D; 3;</span><br><span class="line">   b &#x3D; b + 4;                  &#x2F;&#x2F;判断：错</span><br><span class="line">   b &#x3D; (byte)(b+4);        &#x2F;&#x2F;判断：对</span><br></pre></td></tr></table></figure>
<p>3）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c &#x3D; ‘a’;</span><br><span class="line">   int  i &#x3D; 5;</span><br><span class="line">   double d &#x3D; .314;</span><br><span class="line">   double result &#x3D; c+i+d;     &#x2F;&#x2F;判断：对   102.314</span><br></pre></td></tr></table></figure>
<p>4）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte b &#x3D; 5;</span><br><span class="line">   short s &#x3D; 3;</span><br><span class="line">   short t &#x3D; s + b;          &#x2F;&#x2F;判断：错</span><br></pre></td></tr></table></figure>
<h2 id="2-4-运算符"><a class="header-anchor" href="#2-4-运算符">¶</a>2.4  运算符</h2>
<p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。<br>
算术运算符<br>
赋值运算符<br>
比较运算符（关系运算符）<br>
逻辑运算符<br>
位运算符<br>
三元运算符</p>
<h3 id="1-算术运算符"><a class="header-anchor" href="#1-算术运算符">¶</a>1.算术运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>运算符</strong></th>
<th style="text-align:center"><strong>运算</strong></th>
<th style="text-align:center"><strong>范例</strong></th>
<th style="text-align:center"><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>+</strong></td>
<td style="text-align:center">正号</td>
<td style="text-align:center">+3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center"><strong>-</strong></td>
<td style="text-align:center">负号</td>
<td style="text-align:center">b=4; -b</td>
<td style="text-align:center">-4</td>
</tr>
<tr>
<td style="text-align:center"><strong>+</strong></td>
<td style="text-align:center">加</td>
<td style="text-align:center">5+5</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center"><strong>-</strong></td>
<td style="text-align:center">减</td>
<td style="text-align:center">6-4</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">*****</td>
<td style="text-align:center">乘</td>
<td style="text-align:center">3*4</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center"><strong>/</strong></td>
<td style="text-align:center">除</td>
<td style="text-align:center">5/5</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>%</strong></td>
<td style="text-align:center">取模</td>
<td style="text-align:center">7%5</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center"><strong>++</strong> <br><strong>++</strong></td>
<td style="text-align:center">自增（前）：先运算后取值自增（后）：先取值后运算</td>
<td style="text-align:center">a=2;b=<ins>a; a=2;b=a</ins>;</td>
<td style="text-align:center">a=3;b=3 a=3;b=2</td>
</tr>
<tr>
<td style="text-align:center"><strong>- - <strong><br></strong>- -</strong></td>
<td style="text-align:center">自减（前）：先运算后取值 自减（后）：先取值后运算</td>
<td style="text-align:center">a=2;b=- -a a=2;b=a- -</td>
<td style="text-align:center">a=1;b=1 a=1;b=2</td>
</tr>
<tr>
<td style="text-align:center"><strong>+</strong></td>
<td style="text-align:center">字符串相加</td>
<td style="text-align:center">“He”+”llo”</td>
<td style="text-align:center">“Hello”</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;	</span><br><span class="line">		int i0 &#x3D; -3;</span><br><span class="line">		</span><br><span class="line">		System.out.println(-i0);</span><br><span class="line">		System.out.println(1 + 2);</span><br><span class="line">		System.out.println(6 &#x2F; 2);</span><br><span class="line">		System.out.println(7 &#x2F; 2);&#x2F;&#x2F;当整数除以整数的时候，会把结果的小数部分舍去，只保留整数部分</span><br><span class="line">		System.out.println(7.0 &#x2F; 2);</span><br><span class="line">		System.out.println(7 % 5);</span><br><span class="line">		</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;		i++;</span><br><span class="line">&#x2F;&#x2F;		++i;</span><br><span class="line">&#x2F;&#x2F;		int k &#x3D; i++;</span><br><span class="line">		int k &#x3D; ++i;</span><br><span class="line">		&#x2F;&#x2F;++和--分别是加1和减1的运算，++或者--符号在变量之前，先对变量进行运算然后再取变量的值；</span><br><span class="line">		&#x2F;&#x2F;如果++或者--符号在变量之后，就先取变量的值，在对变量进行运算</span><br><span class="line">		System.out.println(k);</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		</span><br><span class="line">		String str &#x3D; &quot;h&quot; + &quot;e&quot; + &quot;llo&quot;;&#x2F;&#x2F;字符串的加号是字符串拼接</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算术运算符的注意问题"><a class="header-anchor" href="#算术运算符的注意问题">¶</a>算术运算符的注意问题</h3>
<p>​		如果对负数取模，可以把模数负号忽略不记，如：<code>5%-2=1</code>。 但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。</p>
<p>​		对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。<br>
<strong>例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x&#x3D;3510;x&#x3D;x&#x2F;1000*1000;</span><br></pre></td></tr></table></figure>
<p>​		 <strong>x的结果是？</strong></p>
<p>​		“+”除字符串相加功能外，还能把非字符串转换成字符串.例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;5+5&#x3D;&quot;+5+5); &#x2F;&#x2F;打印结果是？5+5&#x3D;55</span><br></pre></td></tr></table></figure>
<p>以下二者的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&#39;*&#39; + &#39;\t&#39; +&#39;*&#39;);</span><br><span class="line">System.out.println(&quot;*&quot; + &#39;\t&#39; +&#39;*&#39;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(5 % 2);</span><br><span class="line">		System.out.println(5 % -2);</span><br><span class="line">		System.out.println(-5 % 2);</span><br><span class="line">		System.out.println(&quot;5+5&#x3D;&quot;+5+5);</span><br><span class="line">		&#x2F;&#x2F;char类型数据十可以做数学运算的，在做数学运算的时候八字符转化为ASCII码进行计算</span><br><span class="line">		System.out.println(&#39;*&#39; + &#39;\t&#39; +&#39;*&#39;);</span><br><span class="line">		&#x2F;&#x2F;字符串与其他数据类型相加时，实际上是把其他的数据传换为字符串，做字符串的拼接</span><br><span class="line">		System.out.println(&quot;*&quot; + &#39;\t&#39; +&#39;*&#39;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习1：算术运算符：自加、自减"><a class="header-anchor" href="#练习1：算术运算符：自加、自减">¶</a>练习1：算术运算符：自加、自减</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestSign&#123;</span><br><span class="line">        public static void main(String[] args)&#123;</span><br><span class="line">                int i1 &#x3D; 10,i2 &#x3D; 20;</span><br><span class="line">                int i &#x3D; i1++;</span><br><span class="line">                System.out.print(“i&#x3D;”+i);  &#x2F;&#x2F;i&#x3D;10</span><br><span class="line">                System.out.println(“i1&#x3D;”+i1);&#x2F;&#x2F;i1&#x3D;11</span><br><span class="line">                i &#x3D; ++i1;</span><br><span class="line">                System.out.print(“i&#x3D;”+i);&#x2F;&#x2F;i&#x3D;12</span><br><span class="line">                System.out.println(“i1&#x3D;”+i1);&#x2F;&#x2F;i1&#x3D;10 11 12 13</span><br><span class="line">                i &#x3D; i2--;</span><br><span class="line">                System.out.print(“i&#x3D;”+i);&#x2F;&#x2F;i&#x3D;20</span><br><span class="line">                System.out.println(“i2&#x3D;”+i2);&#x2F;&#x2F;i2&#x3D;19</span><br><span class="line">                i &#x3D; --i2;</span><br><span class="line">                System.out.print(“i&#x3D;”+i);&#x2F;&#x2F;i&#x3D;18</span><br><span class="line">                System.out.println(“i2&#x3D;”+i2);&#x2F;&#x2F;i2&#x3D;18 </span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-赋值运算符"><a class="header-anchor" href="#2-赋值运算符">¶</a>2.赋值运算符</h3>
<p>符号：=<br>
当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。<br>
支持连续赋值。</p>
<p>扩展赋值运算符： +=, -=, *=, /=, %=</p>
<p><strong>思考1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">short s &#x3D; 3; </span><br><span class="line">            s&#x3D;s+2;  &#x2F;&#x2F;①</span><br><span class="line">            s+&#x3D;2;   &#x2F;&#x2F;②</span><br></pre></td></tr></table></figure>
<p>​                     <strong>①和②有什么区别？</strong></p>
<p><strong>思考2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean b1 &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;区分好&#x3D;&#x3D;和&#x3D;的区别。</span><br><span class="line">        if(b1&#x3D;true)</span><br><span class="line">	System.out.println(&quot;结果为真&quot;);</span><br><span class="line">        else</span><br><span class="line">	System.out.println(&quot;结果为假&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>思考3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; 1;</span><br><span class="line">i *&#x3D; 0.1;</span><br><span class="line">System.out.println(i);&#x2F;&#x2F;</span><br><span class="line">i++;</span><br><span class="line">System.out.println(i);&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 1;</span><br><span class="line">		short s &#x3D; 2;</span><br><span class="line">		i &#x3D; s;&#x2F;&#x2F;自动类型转换</span><br><span class="line">		s &#x3D; (short)i;&#x2F;&#x2F;强制类型转换</span><br><span class="line">		</span><br><span class="line">		int i0 &#x3D; 0;</span><br><span class="line">		int i1 &#x3D; 0;</span><br><span class="line">		int i2 &#x3D; 0;</span><br><span class="line">		</span><br><span class="line">		i0 &#x3D; i1 &#x3D; i2 &#x3D; 1;&#x2F;&#x2F;等号可以连续赋值</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		System.out.println(i0 + &quot;,&quot; + i1 + &quot;,&quot; + i2);</span><br><span class="line">		</span><br><span class="line">		int i3 &#x3D; 1;</span><br><span class="line">		i3 &#x3D; i3 + 2;</span><br><span class="line">		i3 +&#x3D; 2;</span><br><span class="line">		i3 -&#x3D; 2;</span><br><span class="line">		System.out.println(i3);</span><br><span class="line">		</span><br><span class="line">		String str &#x3D; &quot;he&quot;;</span><br><span class="line">		str +&#x3D; &quot;llo&quot;;&#x2F;&#x2F;字符串的加等十字符串的拼接</span><br><span class="line">		System.out.println(str);</span><br><span class="line">		</span><br><span class="line">		short s1 &#x3D; 2;</span><br><span class="line">		s1 &#x3D; (short)(s1 + 3);&#x2F;&#x2F;变量参与运算时候，Java程序不知道具体的变量在做完之后会不会超出当前变量的范围，</span><br><span class="line">				  &#x2F;&#x2F;所以会先把变量转换为一个更大的长度，在这个例子中，short是一个短整型数据，会转换为默认的int</span><br><span class="line">		s1 +&#x3D; 3;&#x2F;&#x2F;在使用扩展赋值运算符时，变量在参与运算时会把结果自动强制转换为当前变量的类型</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">		</span><br><span class="line">		int i5 &#x3D; 1;</span><br><span class="line">		i5 *&#x3D; 0.1;</span><br><span class="line">		System.out.println(i5);&#x2F;&#x2F;</span><br><span class="line">		i5++;</span><br><span class="line">		System.out.println(i5);&#x2F;&#x2F;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-比较运算符"><a class="header-anchor" href="#3-比较运算符">¶</a>3.比较运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>运算符</strong></th>
<th style="text-align:center"><strong>运算</strong></th>
<th style="text-align:center">范例</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>==</strong></td>
<td style="text-align:center">相等于</td>
<td style="text-align:center">4==3</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center"><strong>!=</strong></td>
<td style="text-align:center">不等于</td>
<td style="text-align:center">4!=3</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center"><strong>&lt;</strong></td>
<td style="text-align:center">小于</td>
<td style="text-align:center">4&lt;3</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center"><strong>&gt;</strong></td>
<td style="text-align:center">大于</td>
<td style="text-align:center">4&gt;3</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center"><strong>&lt;=</strong></td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center">4&lt;=3</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center"><strong>&gt;=</strong></td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center">4&gt;=3</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center"><strong>instanceof</strong></td>
<td style="text-align:center">检查是否是类的对象</td>
<td style="text-align:center">“Hello”  instanceof  String</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<p>比较运算符的结果都是boolean型，也就是要么是true，要么是false。<br>
<strong>比较运算符“==”不能误写成“=” 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(4 &#x3D;&#x3D; 5);</span><br><span class="line">		System.out.println(4 !&#x3D; 5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-逻辑运算符"><a class="header-anchor" href="#4-逻辑运算符">¶</a>4.逻辑运算符</h3>
<p>&amp;—逻辑与            | —逻辑或       ！—逻辑非<br>
&amp;&amp; —短路与      || —短路或        ^ —逻辑异或</p>
<table>
<thead>
<tr>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>a&amp;b</strong></th>
<th><strong>a|b</strong></th>
<th><strong>!a</strong></th>
<th><strong>a^b</strong></th>
<th><strong>a&amp;&amp;b</strong></th>
<th><strong>a||b</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>true</strong></td>
<td><strong>true</strong></td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td><strong>true</strong></td>
<td><strong>false</strong></td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td><strong>false</strong></td>
<td><strong>true</strong></td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td><strong>false</strong></td>
<td><strong>false</strong></td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。<br>
“&amp;”和“&amp;&amp;”的区别：<br>
单&amp;时，左边无论真假，右边都进行运算；<br>
双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。<br>
“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。<br>
在不需要逻辑运算两边都参与运算的时候，尽量使用&amp;&amp;和||<br>
异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。<br>
<strong>理解：异或，追求的是“异”!</strong></p>
<p><em>并且、或者、异或、非</em><br>
<em>如果今天晴天并且没有事，就去游泳</em><br>
<em>明天或者后天，我都有时间去约会</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(4 &#x3D;&#x3D; 4 &amp; 1 &#x3D;&#x3D; 1);</span><br><span class="line">		System.out.println(4 &#x3D;&#x3D; 4 || 1 !&#x3D; 1);</span><br><span class="line">		int x &#x3D; 4;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(3 &lt; x &lt; 6);&#x2F;&#x2F;不能这样写，要按照下面写法写</span><br><span class="line">		System.out.println(x &gt; 3 &amp; x &lt; 6);</span><br><span class="line">		</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		int k &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(++k &#x3D;&#x3D; 2);</span><br><span class="line">&#x2F;&#x2F;		System.out.println(i !&#x3D; 0 &amp; ++k &#x3D;&#x3D; 2);&#x2F;&#x2F;单个&amp;的时候，两边都有参与计算</span><br><span class="line">		System.out.println(i !&#x3D; 0 &amp;&amp; ++k &#x3D;&#x3D; 2);&#x2F;&#x2F;2个&amp;的时候，如果左边为true，右边参与运算；如果左边为flase，</span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习2：请写出每题的输出结果"><a class="header-anchor" href="#练习2：请写出每题的输出结果">¶</a>练习2：请写出每题的输出结果</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x &#x3D; 1;</span><br><span class="line">int y&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;if(Boolean值)&#123;代码&#125;，当其中的boolean值是true时会执行大括号里面的代码，flase不执行的口号里面的代码</span><br><span class="line">if(x++&#x3D;&#x3D;2 &amp; ++y&#x3D;&#x3D;2)&#123;</span><br><span class="line">&#x2F;&#x2F;x++&#x3D;&#x3D;2，x先取值后计算，1 &#x3D;&#x3D; 2，结果是false，再计算++之后的值是2；</span><br><span class="line">&#x2F;&#x2F;++y&#x3D;&#x3D;2，y是先计算后取值，先计算++得到y的值为2，再逻辑判断2 &#x3D;&#x3D; 2，结果是true</span><br><span class="line">&#x2F;&#x2F;flase &amp; true,得到的结论是flase</span><br><span class="line">	x &#x3D;7;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;x&#x3D;&quot;+x+&quot;,y&#x3D;&quot;+y);&#x2F;&#x2F;2 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x &#x3D; 1,y &#x3D; 1;</span><br><span class="line"></span><br><span class="line">if(x++&#x3D;&#x3D;2 &amp;&amp; ++y&#x3D;&#x3D;2)&#123;</span><br><span class="line">	x &#x3D;7;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;x&#x3D;&quot;+x+&quot;,y&#x3D;&quot;+y);&#x2F;&#x2F;2 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x &#x3D; 1,y &#x3D; 1;</span><br><span class="line"></span><br><span class="line">if(x++&#x3D;&#x3D;1 | ++y&#x3D;&#x3D;1)&#123;</span><br><span class="line">	x &#x3D;7;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;x&#x3D;&quot;+x+&quot;,y&#x3D;&quot;+y);&#x2F;&#x2F;7 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x &#x3D; 1,y &#x3D; 1;</span><br><span class="line"></span><br><span class="line">if(x++&#x3D;&#x3D;1 || ++y&#x3D;&#x3D;1)&#123;</span><br><span class="line">	x &#x3D;7;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;x&#x3D;&quot;+x+&quot;,y&#x3D;&quot;+y);&#x2F;&#x2F;7 1</span><br></pre></td></tr></table></figure>
<h3 id="5-位运算符"><a class="header-anchor" href="#5-位运算符">¶</a>5.位运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>位运算符</strong></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">运算符</td>
<td style="text-align:center">运算</td>
<td style="text-align:center">范例</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
<td style="text-align:center">3 &lt;&lt; 2 = 12 --&gt; 3*2*2=12，m &lt;&lt; n --&gt; m * 2^n</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">右移</td>
<td style="text-align:center">3 &gt;&gt; 1 = 1 --&gt; 3/2=1，m &gt;&gt; n --&gt; m * 2^-n</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;&gt;</td>
<td style="text-align:center">无符号右移</td>
<td style="text-align:center">3 &gt;&gt;&gt; 1 = 1 --&gt; 3/2=1，正数的&gt;&gt;&gt;与&gt;&gt;一致</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">与运算</td>
<td style="text-align:center">6 &amp; 3 = 2</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">或运算</td>
<td style="text-align:center">6 | 3 = 7</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">异或运算</td>
<td style="text-align:center">6 ^ 3 = 5</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">反码</td>
<td style="text-align:center">~6 = -7</td>
</tr>
</tbody>
</table>
<p><strong>注意：无&lt;&lt;&lt;</strong></p>
<p>位运算是直接对二进制进行运算</p>
<p><em>二进制，</em><br>
<em>十进制，1,2,3，…9,10，逢10进1</em><br>
<em>进制的意思就逢几进1</em><br>
<em>10进制计算</em><br>
<em>1 + 8 = 9</em><br>
<em>9 + 1 = 10</em></p>
<p><em>二进制，逢2进1</em><br>
<em>0 + 1 = 1</em><br>
<em>1 + 1 = 10</em><br>
<em>10 + 1 = 11</em><br>
<em>11 + 1 = 100</em></p>
<p><a href="https://jingyan.baidu.com/article/597a0643614568312b5243c0.html" target="_blank" rel="noopener">二进制如何转十进制，十进制如何转二进制</a></p>
<p><a href="http://www.mamicode.com/info-detail-1693775.html" target="_blank" rel="noopener">计算机二进制正负转换</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		System.out.println( 1 &lt;&lt; 2);&#x2F;&#x2F;1*2的2次方</span><br><span class="line">		System.out.println( 3 &lt;&lt; 3);&#x2F;&#x2F;3*2的3次方</span><br><span class="line">		System.out.println(8 &gt;&gt; 2);</span><br><span class="line">		System.out.println(8 &gt;&gt;&gt; 2);</span><br><span class="line">		System.out.println(-8 &gt;&gt; 2);</span><br><span class="line">		System.out.println(-8 &gt;&gt;&gt; 2);</span><br><span class="line">		System.out.println(~12);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>位运算符的总结</strong></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">空位补0，被移除的高位丢弃，空缺位补0。</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">被移位的二进制最高位是0，右移后，空缺位补0；<br> 最高位是1，空缺位补1。</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;&gt;</td>
<td style="text-align:center">被移位二进制最高位无论是0或者是1，空缺位都用0补。</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">二进制位进行&amp;运算，只有1&amp;1时结果是1，否则是0;</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">二进制位进行 | 运算，只有0 | 0时结果是0，否则是1;</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">相同二进制位进行 ^ 运算，结果是0；1^1=0 , 0^0=0 <br>不相同二进制位 ^ 运算结果是1。1^0=1 , 0^1=1</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">正数取反，各二进制码按补码各位取反<br>负数取反，各二进制码按补码各位取反</td>
</tr>
</tbody>
</table>
<h3 id="6-三元运算符"><a class="header-anchor" href="#6-三元运算符">¶</a>6.三元运算符</h3>
<p>格式:<br>
(条件表达式)? 表达式1：表达式2；</p>
<p>​            为true ，运算后的结果是表达式1；<br>
​            为false，运算后的结果是表达式2；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 1;</span><br><span class="line">		int k &#x3D; i &gt; 0 ? 1 : 0;</span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		int m &#x3D; 1;</span><br><span class="line">		int n &#x3D; 2;</span><br><span class="line">		System.out.println(m &gt; n ? m : n);</span><br><span class="line">		</span><br><span class="line">		int k &#x3D; 0;</span><br><span class="line">		System.out.println(m &gt; n ? (m &gt; k ? m : k) : (n &gt; k ? n : k));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运算符的优先级</strong></p>
<p>●运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如下表，上一行运算符总优先于下一行。<br>
● 只有单目运算符、三元运算符、赋值运算符是从右向左运算的。</p>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" alt></p>
<h2 id="2-5-程序流程控制"><a class="header-anchor" href="#2-5-程序流程控制">¶</a>2.5  程序流程控制</h2>
<h3 id="顺序结构"><a class="header-anchor" href="#顺序结构">¶</a><strong>顺序结构</strong></h3>
<p>​		程序从上到下逐行地执行，中间没有任何判断和跳转。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Java中定义成员变量时采用合法的前向引用。如：</span><br><span class="line">public class Test&#123;</span><br><span class="line">        int num1 &#x3D; 12;</span><br><span class="line">        int num2 &#x3D; num1 + 2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;错误形式：</span><br><span class="line">public class Test&#123;</span><br><span class="line">       int num2 &#x3D; num1 + 2；</span><br><span class="line">       int num1 &#x3D; 12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分支结构"><a class="header-anchor" href="#分支结构">¶</a><strong>分支结构</strong></h3>
<p>​		根据条件，选择性地执行某段代码。<br>
​		有if…else和switch两种分支语句。</p>
<h4 id="分支语句1：-if-else语句"><a class="header-anchor" href="#分支语句1：-if-else语句">¶</a>分支语句1： if-else语句</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if语句三种格式：</span><br><span class="line"></span><br><span class="line">1.  if(true)&#123;</span><br><span class="line">	执行代码块；</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">2.  if(条件表达式)&#123;</span><br><span class="line">	执行代码块；</span><br><span class="line">      &#125;</span><br><span class="line">     else&#123;</span><br><span class="line">	执行代码块；</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">3.  if(条件表达式)&#123;</span><br><span class="line">	执行代码块；</span><br><span class="line">      &#125;</span><br><span class="line">      else if (条件表达式)&#123;</span><br><span class="line">	执行代码块；</span><br><span class="line">      &#125;</span><br><span class="line">       ……</span><br><span class="line">       else&#123;</span><br><span class="line">	执行代码块；</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="if-else语句应用举例"><a class="header-anchor" href="#if-else语句应用举例">¶</a>if-else语句应用举例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestAge&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">	int age &#x3D; 75;	</span><br><span class="line">if (age&lt; 0) &#123;</span><br><span class="line">	System.out.println(&quot;不可能！&quot;);</span><br><span class="line">&#125; else if (age&gt;250) &#123;</span><br><span class="line">	System.out.println(&quot;是个妖怪！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	System.out.println(“人家芳龄 &quot; + age +&quot; ,马马乎乎啦！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;判断一个数字是奇数还是偶数，输出结果</span><br><span class="line">		int i &#x3D; 2;</span><br><span class="line">		</span><br><span class="line">		if(i % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			System.out.println(&quot;偶数&quot;);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			System.out.println(&quot;奇数&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;如果是数字一，输出星期一，2输出星期二，3输出星期三</span><br><span class="line">		&#x2F;&#x2F;如果不是123，输出不知道星期几</span><br><span class="line">		int j &#x3D; 5;</span><br><span class="line">		if(j &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			System.out.println(&quot;星期一&quot;);</span><br><span class="line">		&#125;else if(j &#x3D;&#x3D; 2) &#123;</span><br><span class="line">			System.out.println(&quot;星期二&quot;);</span><br><span class="line">		&#125;else if(j &#x3D;&#x3D; 3) &#123;</span><br><span class="line">			System.out.println(&quot;星期三&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;不知道星期几&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if语句例题1"><a class="header-anchor" href="#if语句例题1">¶</a>if语句例题1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">判断小明的期末成绩。</span><br><span class="line">当成绩为100分时，奖励一辆BMW；</span><br><span class="line">当成绩为（80，99]时，奖励一个台iphone5s；</span><br><span class="line">当成绩为[60,80]时，奖励一本参考书；</span><br><span class="line">其它时，什么奖励也没有。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public 	static void main(String[] args) &#123;</span><br><span class="line">		int score &#x3D; 80;</span><br><span class="line">		</span><br><span class="line">		if(score &#x3D;&#x3D; 100) &#123;</span><br><span class="line">			System.out.println(&quot;奖励一辆BMW&quot;);</span><br><span class="line">		&#125;else if(score &gt; 80 &amp;&amp; score &lt;&#x3D; 99) &#123;</span><br><span class="line">			System.out.println(&quot;奖励一台iPhone5s&quot;);</span><br><span class="line">		&#125;else if(score &gt;&#x3D; 60 &amp;&amp; score &lt;&#x3D;80)&#123;</span><br><span class="line">			System.out.println(&quot;奖励一本参考书&quot;);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			System.out.println(&quot;什么奖励也没有&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if语句练习1"><a class="header-anchor" href="#if语句练习1">¶</a>if语句练习1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1)对下列代码，若有输出，指出输出结果。</span><br><span class="line">int x &#x3D; 4;</span><br><span class="line">int y &#x3D; 1;</span><br><span class="line">if (x &gt; 2) &#123;&#x2F;&#x2F;x&#x3D;4，所以走if的分支</span><br><span class="line">       if (y &gt; 2) &#123;&#x2F;&#x2F;判断y是不是大于2的数，如果是走这个分支</span><br><span class="line">                System.out.println(x + y);</span><br><span class="line">                System.out.println(&quot;atguigu&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">       System.out.println(&quot;x is &quot; + x);</span><br><span class="line">&#125;&#x2F;&#x2F;无输出</span><br></pre></td></tr></table></figure>
<h4 id="分支结构2：switch语句"><a class="header-anchor" href="#分支结构2：switch语句">¶</a>分支结构2：switch语句</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch(变量)&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">	语句1;</span><br><span class="line">	break;</span><br><span class="line">case 常量2:</span><br><span class="line">	语句2;</span><br><span class="line">	break;</span><br><span class="line">… …</span><br><span class="line">case 常量N:</span><br><span class="line">	语句N;</span><br><span class="line">	break;</span><br><span class="line">default:</span><br><span class="line">	语句;</span><br><span class="line">	break;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch语句应用举例"><a class="header-anchor" href="#switch语句应用举例">¶</a>switch语句应用举例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">       public static void main(String args[])&#123;</span><br><span class="line">		int i &#x3D; 1;</span><br><span class="line">		switch (i) &#123;</span><br><span class="line">	       	case 0:</span><br><span class="line">			System.out.println(&quot;zero&quot;);</span><br><span class="line">			break;</span><br><span class="line">	       	case 1:</span><br><span class="line">			System.out.println(&quot;one&quot;);</span><br><span class="line">			break;</span><br><span class="line">	        	default:</span><br><span class="line">			System.out.println(&quot;default&quot;);</span><br><span class="line">			break;</span><br><span class="line">	 	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch语句应用举例-v2"><a class="header-anchor" href="#switch语句应用举例-v2">¶</a>switch语句应用举例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">       public static void main(String args[])&#123;</span><br><span class="line">		String season &#x3D; “summer”;</span><br><span class="line">		switch (season) &#123;</span><br><span class="line">	    case “spring”:</span><br><span class="line">			System.out.println(“春暖花开&quot;);</span><br><span class="line">			break;</span><br><span class="line">	    case “summer”:</span><br><span class="line">			System.out.println(“夏日炎炎&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case “autumn”:</span><br><span class="line">			System.out.println(“秋高气爽&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case “winter”:</span><br><span class="line">			System.out.println(“冬雪皑皑&quot;);</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">	    default:</span><br><span class="line">			System.out.println(“季节输入有误&quot;);</span><br><span class="line">			break;</span><br><span class="line">	 	&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch语句有关规则"><a class="header-anchor" href="#switch语句有关规则">¶</a>switch语句有关规则</h4>
<p>​		<strong>switch</strong>(表达式)中表达式的<strong>返回值</strong>必须是下述几种类型之一：<strong>byte</strong>，<strong>short</strong>，<strong>char</strong>，<strong>int</strong>，<strong>枚举</strong>，<strong>String</strong>；<br>
​		<strong>case</strong>子句中的值必须是<strong>常量</strong>，且所有<strong>case</strong>子句中的值应是不同的；<br>
​		<strong>default</strong>子句是<strong>可任选的</strong>，当没有匹配的<strong>case</strong>时，执行<strong>default</strong><br>
​		<strong>break</strong>语句用来在执行完一个<strong>case</strong>分支后使程序跳出<strong>switch</strong>语句块；如果没有<strong>break</strong>，程序会顺序执行到<strong>switch</strong>结尾</p>
<h4 id="switch语句练习1"><a class="header-anchor" href="#switch语句练习1">¶</a>switch语句练习1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用switch语句改写下列if语句：</span><br><span class="line"> 	 int a &#x3D; 3;</span><br><span class="line"> 	 int x &#x3D; 100;</span><br><span class="line"> 	 if(a&#x3D;&#x3D;1)</span><br><span class="line">		x+&#x3D;5;</span><br><span class="line"> 	 else if(a&#x3D;&#x3D;2)</span><br><span class="line">		x+&#x3D;10;</span><br><span class="line"> 	 else if(a&#x3D;&#x3D;3)</span><br><span class="line">		x+&#x3D;16;</span><br><span class="line"> 	 else		</span><br><span class="line">		x+&#x3D;34;</span><br></pre></td></tr></table></figure>
<h4 id="switch和if语句的对比"><a class="header-anchor" href="#switch和if语句的对比">¶</a>switch和if语句的对比</h4>
<p>if和switch语句很像，具体什么场景下，应用哪个语句呢？<br>
如果判断的具体数值不多，而且符合byte、 short 、int、 char这四种类型。虽然两个语句都可以使用，建议使用swtich语句。因为效率稍高。<br>
其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。</p>
<h3 id="循环结构"><a class="header-anchor" href="#循环结构">¶</a><strong>循环结构</strong></h3>
<p>​		根据循环条件，重复性的执行某段代码。<br>
​		有while、do…while、for三种循环语句。<br>
​		注：JDK1.5之后提供了foreach循环，方便的遍历集合、数组元素。</p>
<p>循环语句功能<br>
在某些条件满足的情况下，反复执行特定代码的功能<br>
循环语句的四个组成部分<br>
初始化部分（init_statement）<br>
循环条件部分（test_exp）<br>
循环体部分（body_statement）<br>
迭代部分（alter_statement）<br>
循环语句分类<br>
for 循环<br>
while 循环<br>
do/while 循环</p>
<h4 id="for-循环语句"><a class="header-anchor" href="#for-循环语句">¶</a>for 循环语句</h4>
<p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (初始化表达式①; 布尔值测试表达式②; 更改表达式)｛</span><br><span class="line">        	语句或语句块③；</span><br><span class="line"> ｝</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E6%B1%82%E7%9F%A5%E8%AF%BE%E5%A0%82%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;应用举例</span><br><span class="line">	public class ForLoop &#123;</span><br><span class="line">		public static void main(String args[])&#123;</span><br><span class="line">		          int result &#x3D; 0;</span><br><span class="line">		          for(int i&#x3D;1; i&lt;&#x3D;100; i++) &#123;</span><br><span class="line">			  result +&#x3D; i;</span><br><span class="line">		          &#125;</span><br><span class="line">  	          System.out.println(&quot;result&#x3D;&quot; + result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for语句例题"><a class="header-anchor" href="#for语句例题">¶</a>for语句例题</h4>
<p>编写程序FooBizBaz.java，从1循环到150并在每行打印一个值，另外在每个3的倍数行上打印出“foo”,在每个5的倍数行上打印“biz”,在每个7的倍数行上打印输出“baz”。</p>
<h4 id="for语句练习"><a class="header-anchor" href="#for语句练习">¶</a>for语句练习</h4>
<p>1.打印1~100之间所有奇数的和<br>
2.打印1~100之间所有是7的倍数的整数的个数及总和（体会设置计数器的思想）<br>
3.输出所有的水仙花数，所谓水仙花数是指一个3位数，其各个位上数字立方和等于其本身。<br>
例如： 153 = 1<em>1</em>1 + 3<em>3</em>3 + 5<em>5</em>5</p>
<h4 id="while-循环语句"><a class="header-anchor" href="#while-循环语句">¶</a>while 循环语句</h4>
<p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[初始化语句]</span><br><span class="line">while( 布尔值测试表达式)｛</span><br><span class="line">       		语句或语句块;</span><br><span class="line">	[更改语句;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	public class WhileLoop &#123;</span><br><span class="line">        public static void main(String args[])&#123;</span><br><span class="line">      		int result &#x3D; 0;</span><br><span class="line">	int i&#x3D;1;</span><br><span class="line">	while(i&lt;&#x3D;100) &#123;</span><br><span class="line">	        result +&#x3D; i;</span><br><span class="line">          	       	        i++;</span><br><span class="line">	&#125;</span><br><span class="line">	        System.out.println(&quot;result&#x3D;&quot; + result);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="do-while-循环语句"><a class="header-anchor" href="#do-while-循环语句">¶</a>do-while 循环语句</h4>
<p>语法格式</p>
<p>应用举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[初始化语句]</span><br><span class="line">do｛</span><br><span class="line">       	语句或语句块;</span><br><span class="line">        [更改语句;]</span><br><span class="line">｝while(布尔值测试表达式);</span><br></pre></td></tr></table></figure>
<p>应用举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WhileLoop &#123;</span><br><span class="line">        public static void main(String args[])&#123;</span><br><span class="line">      		  int result &#x3D; 0,  i&#x3D;1;</span><br><span class="line">	        do&#123;</span><br><span class="line">	        	   result +&#x3D; i;</span><br><span class="line">         		       	   i++;</span><br><span class="line">		 &#125;while(i&lt;&#x3D;100);</span><br><span class="line">	 System.out.println(&quot;result&#x3D;&quot; + result);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环语句练习"><a class="header-anchor" href="#循环语句练习">¶</a>循环语句练习</h4>
<p>编写程序一：求1到100之间所有偶数的和。用for和while语句分别完成。</p>
<p><strong>补充：</strong><br>
最简单无限循环格式：while(true) , for(;😉,无限循环存在的原因是并不知道循环多少次，需要根据某些条件，来控制循环。</p>
<h4 id="嵌套循环"><a class="header-anchor" href="#嵌套循环">¶</a>嵌套循环</h4>
<p>​		将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while均可以作为外层循环和内层循环。</p>
<p>​		实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。</p>
<p>​		设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n=mn次。</p>
<p><strong>例题：1）九九乘法表<br>
2）1—100之间的所有质数</strong></p>
<h4 id="特殊流程控制语句1"><a class="header-anchor" href="#特殊流程控制语句1">¶</a>特殊流程控制语句1</h4>
<p>​    <strong>break 语句</strong><br>
break语句用于终止某个语句块的执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	&#123;    ……	 </span><br><span class="line">     break;</span><br><span class="line">     ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>break终止当前所在的循环</p>
<p><strong>break 语句用法举例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	 public class TestBreak&#123;</span><br><span class="line">		public static void main(String args[])&#123;</span><br><span class="line">	    for(int i &#x3D; 0; i&lt;10; i++)&#123; </span><br><span class="line">	     	if(i&#x3D;&#x3D;3)</span><br><span class="line">		      break;	  </span><br><span class="line">	    	System.out.println(&quot; i &#x3D;&quot; + i);</span><br><span class="line">	    &#125;</span><br><span class="line">	    System.out.println(&quot;Game Over!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="特殊流程控制语句2"><a class="header-anchor" href="#特殊流程控制语句2">¶</a>特殊流程控制语句2</h4>
<p><strong>continue 语句</strong><br>
continue语句用于跳过某个循环语句块的一次执行<br>
continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</p>
<p><strong>continue语句用法举例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ContinueTest &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">    	   for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">     	         	  if (i%10&#x3D;&#x3D;0)</span><br><span class="line">	        		continue;</span><br><span class="line">         	                System.out.println(i);</span><br><span class="line">         	               &#125;  &#125;  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="特殊流程控制语句3"><a class="header-anchor" href="#特殊流程控制语句3">¶</a>特殊流程控制语句3</h4>
<p>​		return：并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个return语句时，这个方法将被结束。</p>
<p>​		与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内</p>
<h4 id="特殊流程控制语句说明"><a class="header-anchor" href="#特殊流程控制语句说明">¶</a>特殊流程控制语句说明</h4>
<p>break只能用于switch语句和循环语句中。<br>
continue 只能用于循环语句中。<br>
二者功能类似，但continue是终止本次循环，break是终止本层循环。<br>
break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。</p>
<h2 id="2-6-数组"><a class="header-anchor" href="#2-6-数组">¶</a>2.6 数组</h2>
<h3 id="一维数组声明"><a class="header-anchor" href="#一维数组声明">¶</a>一维数组声明</h3>
<p>一维数组的声明方式：<br>
<code>type  var[]</code> 或 <code>type[]  var</code>；<br>
例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[];</span><br><span class="line">   int[] a1;</span><br><span class="line">double  b[];</span><br><span class="line">Mydate[] c;  &#x2F;&#x2F;对象数组</span><br></pre></td></tr></table></figure>
<h3 id="一维数组初始化"><a class="header-anchor" href="#一维数组初始化">¶</a>一维数组初始化</h3>
<p><strong>动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] arr &#x3D; new int[3];</span><br><span class="line">arr[0] &#x3D; 3;</span><br><span class="line">arr[1] &#x3D; 9;</span><br><span class="line">arr[2] &#x3D; 8;</span><br></pre></td></tr></table></figure>
<p><strong>静态初始化：在定义数组的同时就为数组元素分配空间并赋值。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[] &#x3D; new int[]&#123; 3, 9, 8&#125;;</span><br><span class="line">int[] a &#x3D; &#123;3,9,8&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数组元素的引用"><a class="header-anchor" href="#数组元素的引用">¶</a>数组元素的引用</h3>
<p>定义并用运算符new为之分配空间后，才可以引用数组中的每个元素；<br>
数组元素的引用方式：数组名[数组元素下标]<br>
数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];<br>
数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —&gt;n-1；如int a[]=new int[3];  可引用的数组元素为a[0]、a[1]、a[2]<br>
每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数)<br>
数组一旦初始化，其长度是不可变的</p>
<h3 id="数组元素的默认初始化"><a class="header-anchor" href="#数组元素的默认初始化">¶</a>数组元素的默认初始化</h3>
<p>数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String argv[])&#123;</span><br><span class="line">int a[]&#x3D; new int[5]; </span><br><span class="line">System.out.println(a[3]);	&#x2F;&#x2F;a[3]的默认值为0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a class="header-anchor" href="#多维数组">¶</a>多维数组</h3>
<table>
<thead>
<tr>
<th style="text-align:center">二维数组**<code>[][]</code>**：数组中的数组</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>格式1（动态初始化）：int<code>[][]</code> arr = new int <code>[3][2]</code></strong></td>
</tr>
<tr>
<td style="text-align:center">定义了名称为arr的二维数组<br>二维数组中有3个一维数组<br>每一个一维数组中有2个元素<br>一维数组的名称分别为arr[0], arr[1], arr[2]<br>给第一个一维数组1脚标位赋值为78写法是：arr<code>[0][1]</code> = 78;</td>
</tr>
<tr>
<td style="text-align:center"><strong>格式2（动态初始化）：int<code>[][]</code> arr = new int<code>[3][]</code>;</strong></td>
</tr>
<tr>
<td style="text-align:center">二维数组中有3个一维数组。<br>每个一维数组都是默认初始化值null (注意：区别于格式1）<br>可以对这个三个一维数组分别进行初始化<br>arr[0] = new int[3];  arr[1] = new int[1];  arr[2] = new int[2]; <br><strong>注：int<code>[][]</code>arr = new int<code>[][3]</code>; //非法</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>格式3（静态初始化）：int<code>[][]</code> arr = new int<code>[][]{</code>{3,8,2},{2,7},{9,0,1,6}<code>}</code>;</strong></td>
</tr>
<tr>
<td style="text-align:center">定义一个名称为arr的二维数组，二维数组中有三个一维数组<br>每一个一维数组中具体元素也都已初始化<br>第一个一维数组 arr[0] = {3,8,2};<br>第二个一维数组 arr[1] = {2,7};<br>第三个一维数组 arr[2] = {9,0,1,6};<br>第三个一维数组的长度表示方式：arr[2].length;</td>
</tr>
</tbody>
</table>
<p>注意特殊写法情况：int[] x,y[]; x是一维数组，y是二维数组。<br>
Java中多维数组不必都是规则矩阵形式 |</p>
<p>练习2：获取arr数组中所有元素的和。使用for的嵌套循环即可。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>j</strong>       <strong>i</strong></th>
<th style="text-align:center"><strong>j = 0</strong></th>
<th style="text-align:center"><strong>j = 1</strong></th>
<th style="text-align:center"><strong>j = 2</strong></th>
<th style="text-align:center"><strong>j = 3</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>i = 0</strong></td>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center"><strong>8</strong></td>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>i = 1</strong></td>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><strong>7</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>i = 2</strong></td>
<td style="text-align:center"><strong>9</strong></td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center"><strong>6</strong></td>
</tr>
</tbody>
</table>
<p>练习3:</p>
<p>声明：int[] x,y[];  以下选项允许通过编译的是：<br>
a )   x[0] = y;  //no, x[0]是一个数，y是一个二维数组<br>
b)    y[0] = x; //yes， y[0]就是一维数组，x是一维数组<br>
c)    y<code>[0][0]</code> = x;//no， y<code>[0][0]</code> 是一个数字，x是一维数组<br>
d)    x<code>[0][0]</code> = y;//no， x<code>[0][0]</code> 不存在，x是一维数组，没有第二维<br>
e)    y<code>[0][0]</code> = x[0];//yes， y<code>[0][0]</code> 是一个数字， x[0]是一个数<br>
f)    x = y; //no， x是一维数组，y是一个二维数组<br>
<strong>一维数组：int[] x  或者int x[]<br>
二维数组：int<code>[][]</code> y 或者  int[] y[]  或者 int  y</strong><code>[][]</code></p>
<h3 id="数组中涉及的常见算法"><a class="header-anchor" href="#数组中涉及的常见算法">¶</a>数组中涉及的常见算法</h3>
<p>1.求数组元素的最大值、最小值、总和、平均数</p>
<p>2.数组的复制、反转</p>
<p>3.数组元素的排序</p>
<h3 id="数组排序"><a class="header-anchor" href="#数组排序">¶</a>数组排序</h3>
<p>插入排序<br>
直接插入排序、折半插入排序、Shell排序</p>
<p>交换排序<br>
冒泡排序、快速排序（或分区交换排序）</p>
<p>选择排序<br>
简单选择排序、堆排序</p>
<p>归并排序</p>
<p>基数排序</p>
<h3 id="冒泡排序"><a class="header-anchor" href="#冒泡排序">¶</a>冒泡排序</h3>
<p><strong>排序思想：</strong><br>
相邻两元素进行比较，如有需要则进行交换，每完成一次循环就将最大元素排在最后（如从小到大排序），下一次循环是将其它的数进行类似操作。</p>
<h3 id="数组操作常见问题"><a class="header-anchor" href="#数组操作常见问题">¶</a>数组操作常见问题</h3>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>数组下标越界异常(ArrayIndexOutOfBoundsException)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int[] arr = new int[2];<br>System.out.println(arr[2]);<br>访问到了数组中的不存在的脚标时发生。</td>
</tr>
<tr>
<td style="text-align:center"><strong>空指针异常(NullPointerException)</strong></td>
</tr>
<tr>
<td style="text-align:center">int[] arr = null;<br>System.out.println(arr[0]);<br>arr引用没有指向实体，却在操作实体中的元素时。</td>
</tr>
</tbody>
</table>
<h2 id="作业"><a class="header-anchor" href="#作业">¶</a>作业</h2>
<p>使用简单数组<br>
(1)创建一个名为TestArray的类，在main()方法中声明array1和array2两个变量，他们是int[]类型的数组。<br>
(2)使用大括号{}，把array1初始化为8个素数：2,3,5,7,11,13,17,19。<br>
(3)显示array1的内容。<br>
(4)赋值array2变量等于array1，修改array2中的偶索引元素，使其等于索引值(如array[0]=0,array[2]=2)。打印出array1。</p>
<p><strong>思考：array1和array2是什么关系？</strong><br>
<strong>拓展：修改题目，实现array2对array1数组的复制</strong></p>
]]></content>
      <categories>
        <category>求知课堂</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>b站视频</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（二）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍在本地安装Hexo博客，以及把预览博客，并上传到GitHub上去。</p>
<a id="more"></a>
<h1 id="一、安装Hexo程序及预览博客内容"><a class="header-anchor" href="#一、安装Hexo程序及预览博客内容">¶</a>一、安装Hexo程序及预览博客内容</h1>
<p>1.首先在磁盘里新建一个文件夹，用来存放个人博客的程序、主题以及后面你要写的文章。<strong>路径最好不要有中文</strong>。新建后打开文件夹，右键，点击【Git Bash Here】。进入git命令窗口。</p>
<p>2.使用npm安装Hexo博客程序。输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>3.初始化和安装所需的组件，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>4.初始化完成后安装组件，继续输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>5.完成安装后启用本地服务器进行本地预览，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g     #生成页面</span><br></pre></td></tr></table></figure>
<p>6.继续输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s    #启动预览</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl +C   #停止预览</span><br></pre></td></tr></table></figure>
<p>7.在上面不关闭预览的前提下在浏览器中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000</span><br></pre></td></tr></table></figure>
<p>已经可以看到个人博客的主题了，这是Hexo的默认界面，本地博客安装到此成功。</p>
<h1 id="二、介绍主要配置"><a class="header-anchor" href="#二、介绍主要配置">¶</a>二、介绍主要配置</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public     #网站文件</span><br><span class="line">themes     #主题文件夹，用来存放主题，美化博客</span><br><span class="line">source     #存放用户文件，主要存放用户写的文章，图片等等。</span><br><span class="line">_config.yml     #网站的配置信息，要跟主题里的配置信息分开，主题文件夹里也有一个同名的文件。</span><br></pre></td></tr></table></figure>
<h1 id="三、上传部署"><a class="header-anchor" href="#三、上传部署">¶</a>三、上传部署</h1>
<p>1.本地刚才预览已经没有问题，就要上传到GitHub进行部署。使其能够通过域名或者网址访问。首先安装hexo-deployer-git。输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>2.打开<strong>网站</strong>配置文件_config.yml。在文件的末尾加上下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:用户名&#x2F;用户名.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<p>3.完成后输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d     #部署发布</span><br></pre></td></tr></table></figure>
<p>将网站上传部署到GitHub仓库中。</p>
<p>4.上传成功后我们就可以用网址进行访问了，网址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;用户名.github.io</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（九）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍隐藏博客底部powered By Hexo / 强力驱动，文章访问量统计，修改阅读全文颜色，文章分享功能，修改``代码块自定义样式，开启emoji表情，搞怪网页标题，增加canvas粒子时钟，取消文章目录的自动编号，去掉侧边栏声明，代码块复制功能，设置点击头像返回首页。</p>
<a id="more"></a>
<h1 id="一、隐藏博客底部powered-By-Hexo-强力驱动"><a class="header-anchor" href="#一、隐藏博客底部powered-By-Hexo-强力驱动">¶</a>一、隐藏博客底部powered By Hexo / 强力驱动</h1>
<p>打开文件，路径：<code>themes/next/layout/_partials/footer.swig</code>。删除或者注释掉以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">&#123;% if theme.footer.powered %&#125;</span><br><span class="line">  &lt;div class&#x3D;&quot;powered-by&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#39;footer.powered&#39;, &#39;&lt;a class&#x3D;&quot;theme-link&quot; target&#x3D;&quot;_blank&quot; href&#x3D;&quot;https:&#x2F;&#x2F;hexo.io&quot;&gt;Hexo&lt;&#x2F;a&gt;&#39;) &#125;&#125;&#123;#</span><br><span class="line">#&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.theme.enable %&#125;</span><br><span class="line">  &lt;div class&#x3D;&quot;theme-info&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#39;footer.theme&#39;) &#125;&#125; &amp;mdash; &#123;#</span><br><span class="line">  #&#125;&lt;a class&#x3D;&quot;theme-link&quot; target&#x3D;&quot;_blank&quot; href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next&quot;&gt;&#123;#</span><br><span class="line">    #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;#</span><br><span class="line">  #&#125;&lt;&#x2F;a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<h1 id="二、文章访问量统计"><a class="header-anchor" href="#二、文章访问量统计">¶</a>二、文章访问量统计</h1>
<p>该功能基于LeanCloud，之前在评论功能也用过，先注册登录，没有应用的先创建应用，如果之前添加过评论的话应该是创建了应用。</p>
<p>之后新建一个名为<code>Counter</code>的<code>Class</code>，ACL权限设置为所有用户。</p>
<p>在设置-&gt;应用Key中获取并复制ID和Key。</p>
<p>打开主题配置文件，找到<code>leancloud_visitors</code>。分别粘贴ID和Key。</p>
<p>打开文件，路径：<code>themes\next\layout_macro\post.swig</code>，找到LeanCould，修改如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# LeanCould PageView #&#125;</span><br><span class="line">  ...</span><br><span class="line">  &#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line">-     &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&#39;post.views&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">+     &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&#39;post.views&#39;)&#125;&#125; &lt;&#x2F;span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;span class&#x3D;&quot;leancloud-visitors-count&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">+   &lt;span&gt;℃&lt;&#x2F;span&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>-号表述删除这一行，+号表示增加这一行。增加后删掉+号。配置后如下图：</p>
<p>打开文件，路径：<code>themes/next/languages/zh-CN.yml</code>。找到<code>post</code>。修改为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post:</span><br><span class="line">    views: 热度</span><br></pre></td></tr></table></figure>
<h1 id="三、修改阅读全文颜色"><a class="header-anchor" href="#三、修改阅读全文颜色">¶</a>三、修改阅读全文颜色</h1>
<p>打开文件，路径：<code>themes\next\source\css\_custom\custom.styl</code>。添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改按键（button）样式</span><br><span class="line">.btn &#123;</span><br><span class="line">color: #49b1f5;</span><br><span class="line">background: #fff;</span><br><span class="line">border: 2px solid #49b1f5;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 按键（button）点击时样式</span><br><span class="line">.btn:hover &#123;</span><br><span class="line">border-color: #49b1f5;</span><br><span class="line">color: #fff;</span><br><span class="line">background: #49b1f5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、文章分享功能"><a class="header-anchor" href="#四、文章分享功能">¶</a>四、文章分享功能</h1>
<p>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-needmoreshare2 themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;needsharebutton</span><br></pre></td></tr></table></figure>
<p>打开主题配置文件，找到<code>needmoreshare2</code>。修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">needmoreshare2:</span><br><span class="line">    enable: true</span><br><span class="line">postbottom:</span><br><span class="line">  enable: true</span><br><span class="line">  options:</span><br><span class="line">    iconStyle: box</span><br><span class="line">    boxForm: horizontal</span><br><span class="line">    position: bottomCenter</span><br><span class="line">    networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br><span class="line">float:</span><br><span class="line">  enable: false #浮动分享</span><br><span class="line">  options:</span><br><span class="line">    iconStyle: box</span><br><span class="line">    boxForm: horizontal</span><br><span class="line">    position: middleRight</span><br><span class="line">    networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br></pre></td></tr></table></figure>
<h1 id="五、修改-代码块自定义样式"><a class="header-anchor" href="#五、修改-代码块自定义样式">¶</a>五、修改``代码块自定义样式</h1>
<p>打开文件，路径：<code>\themes\next\source\css\_custom\custom.styl</code>。添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下修改&#96;&#96;代码块自定义样式</span><br><span class="line">&#x2F;&#x2F; Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">color: #ff7600;</span><br><span class="line">background: #fbf7f8;</span><br><span class="line">margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 以上修改&#96;&#96;代码块自定义样式</span><br></pre></td></tr></table></figure>
<h1 id="六、开启emoji表情"><a class="header-anchor" href="#六、开启emoji表情">¶</a>六、开启emoji表情</h1>
<p>卸载默认的，安装新的，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure>
<p>之后安装 <code>markdown-it-emoji</code> 插件 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure>
<p>打开<strong>站点配置</strong>文件，在后面添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Markdown-it config</span><br><span class="line">## Docs: https:&#x2F;&#x2F;github.com&#x2F;celsomiranda&#x2F;hexo-renderer-markdown-it&#x2F;wiki</span><br><span class="line">markdown:</span><br><span class="line">  render:</span><br><span class="line">    html: true</span><br><span class="line">    xhtmlOut: false</span><br><span class="line">    breaks: true</span><br><span class="line">    linkify: true</span><br><span class="line">    typographer: true</span><br><span class="line">    quotes: &#39;“”‘’&#39;</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-ins</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">    - markdown-it-emoji  ## add emoji</span><br><span class="line">  anchors:</span><br><span class="line">    level: 1</span><br><span class="line">    collisionSuffix: &#39;v&#39;</span><br><span class="line">    # If &#96;true&#96;, creates an anchor tag with a permalink besides the heading.</span><br><span class="line">    permalink: true</span><br><span class="line">    permalinkClass: header-anchor</span><br><span class="line">    # The symbol used to make the permalink</span><br><span class="line">    permalinkSymbol: ¶</span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.emojicopy.com&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;copy.emojiall.com&#x2F;</span><br></pre></td></tr></table></figure>
<p>只要复制网站中的表情就可以了。</p>
<h1 id="七、搞怪网页标题"><a class="header-anchor" href="#七、搞怪网页标题">¶</a>七、搞怪网页标题</h1>
<p>打开文件，路径：<code>themes\next\layout_custom\custom.swig</code>。在最后添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# 搞怪网页标题 #&#125;</span><br><span class="line">&#123;% if theme.title_trick.enable %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var OriginTitile &#x3D; document.title;</span><br><span class="line">  var titleTime;</span><br><span class="line">  document.addEventListener(&quot;visibilitychange&quot;, function() &#123;</span><br><span class="line">    if (document.hidden) &#123;</span><br><span class="line">      document.title &#x3D; &quot;&#123;&#123; theme.title_trick.leave &#125;&#125;&quot; + OriginTitile;</span><br><span class="line">      clearTimeout(titleTime);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      document.title &#x3D; &quot;&#123;&#123; theme.title_trick.enter &#125;&#125;&quot; + OriginTitile;</span><br><span class="line">      titleTime &#x3D; setTimeout(function() &#123;</span><br><span class="line">        document.title &#x3D; OriginTitile;</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>打开主题配置文件，在最后添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 搞怪网页标题</span><br><span class="line">title_trick:</span><br><span class="line">  enable: true</span><br><span class="line">  leave: &quot;(つェ⊂)我藏好了哦~&quot;</span><br><span class="line">  enter: &quot;(*´∇｀*) 被你发现啦~&quot;</span><br></pre></td></tr></table></figure>
<h1 id="八、增加canvas粒子时钟"><a class="header-anchor" href="#八、增加canvas粒子时钟">¶</a>八、增加canvas粒子时钟</h1>
<p>在路径：<code>/themes/next/layout/_custom/</code>新建文件<code>clock.swig</code>。</p>
<p>在<code>clock.swig</code>中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;&quot;&gt;</span><br><span class="line">  &lt;canvas id&#x3D;&quot;canvas&quot; style&#x3D;&quot;width:60%;&quot;&gt;当前浏览器不支持canvas，请更换浏览器后再试&lt;&#x2F;canvas&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line"></span><br><span class="line">   var digit&#x3D;</span><br><span class="line">    [</span><br><span class="line">        [</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,1,1,0,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,0,1,1,0],</span><br><span class="line">            [0,0,1,1,1,0,0]</span><br><span class="line">        ],&#x2F;&#x2F;0</span><br><span class="line">        [</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,1,1,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [1,1,1,1,1,1,1]</span><br><span class="line">        ],&#x2F;&#x2F;1</span><br><span class="line">        [</span><br><span class="line">            [0,1,1,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,1,1,0,0,0,0],</span><br><span class="line">            [1,1,0,0,0,0,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,1,1,1,1,1]</span><br><span class="line">        ],&#x2F;&#x2F;2</span><br><span class="line">        [</span><br><span class="line">            [1,1,1,1,1,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0]</span><br><span class="line">        ],&#x2F;&#x2F;3</span><br><span class="line">        [</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,1,0],</span><br><span class="line">            [0,0,1,1,1,1,0],</span><br><span class="line">            [0,1,1,0,1,1,0],</span><br><span class="line">            [1,1,0,0,1,1,0],</span><br><span class="line">            [1,1,1,1,1,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,1,1]</span><br><span class="line">        ],&#x2F;&#x2F;4</span><br><span class="line">        [</span><br><span class="line">            [1,1,1,1,1,1,1],</span><br><span class="line">            [1,1,0,0,0,0,0],</span><br><span class="line">            [1,1,0,0,0,0,0],</span><br><span class="line">            [1,1,1,1,1,1,0],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0]</span><br><span class="line">        ],&#x2F;&#x2F;5</span><br><span class="line">        [</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,1,1,0,0,0,0],</span><br><span class="line">            [1,1,0,0,0,0,0],</span><br><span class="line">            [1,1,0,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0]</span><br><span class="line">        ],&#x2F;&#x2F;6</span><br><span class="line">        [</span><br><span class="line">            [1,1,1,1,1,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0]</span><br><span class="line">        ],&#x2F;&#x2F;7</span><br><span class="line">        [</span><br><span class="line">            [0,1,1,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0]</span><br><span class="line">        ],&#x2F;&#x2F;8</span><br><span class="line">        [</span><br><span class="line">            [0,1,1,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,1,1,0,0,0,0]</span><br><span class="line">        ],&#x2F;&#x2F;9</span><br><span class="line">        [</span><br><span class="line">            [0,0,0,0,0,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,0,0,0,0,0],</span><br><span class="line">            [0,0,0,0,0,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,0,0,0,0,0]</span><br><span class="line">        ]&#x2F;&#x2F;:</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">var canvas &#x3D; document.getElementById(&#39;canvas&#39;);</span><br><span class="line"></span><br><span class="line">if(canvas.getContext)&#123;</span><br><span class="line">    var cxt &#x3D; canvas.getContext(&#39;2d&#39;);</span><br><span class="line">    &#x2F;&#x2F;声明canvas的宽高</span><br><span class="line">    var H &#x3D; 100,W &#x3D; 700;</span><br><span class="line">    canvas.height &#x3D; H;</span><br><span class="line">    canvas.width &#x3D; W;</span><br><span class="line">    cxt.fillStyle &#x3D; &#39;#f00&#39;;</span><br><span class="line">    cxt.fillRect(10,10,50,50);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;存储时间数据</span><br><span class="line">    var data &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F;存储运动的小球</span><br><span class="line">    var balls &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F;设置粒子半径</span><br><span class="line">    var R &#x3D; canvas.height&#x2F;20-1;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        var temp &#x3D; &#x2F;(\d)(\d):(\d)(\d):(\d)(\d)&#x2F;.exec(new Date());</span><br><span class="line">        &#x2F;&#x2F;存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成</span><br><span class="line">        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    &#x2F;*生成点阵数字*&#x2F;</span><br><span class="line">    function renderDigit(index,num)&#123;</span><br><span class="line">        for(var i &#x3D; 0; i &lt; digit[num].length; i++)&#123;</span><br><span class="line">            for(var j &#x3D; 0; j &lt; digit[num][i].length; j++)&#123;</span><br><span class="line">                if(digit[num][i][j] &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                    cxt.beginPath();</span><br><span class="line">                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);</span><br><span class="line">                    cxt.closePath();</span><br><span class="line">                    cxt.fill();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*更新时钟*&#x2F;</span><br><span class="line">    function updateDigitTime()&#123;</span><br><span class="line">        var changeNumArray &#x3D; [];</span><br><span class="line">        var temp &#x3D; &#x2F;(\d)(\d):(\d)(\d):(\d)(\d)&#x2F;.exec(new Date());</span><br><span class="line">        var NewData &#x3D; [];</span><br><span class="line">        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);</span><br><span class="line">        for(var i &#x3D; data.length-1; i &gt;&#x3D;0 ; i--)&#123;</span><br><span class="line">            &#x2F;&#x2F;时间发生变化</span><br><span class="line">            if(NewData[i] !&#x3D;&#x3D; data[i])&#123;</span><br><span class="line">                &#x2F;&#x2F;将变化的数字值和在data数组中的索引存储在changeNumArray数组中</span><br><span class="line">                changeNumArray.push(i+&#39;_&#39;+(Number(data[i])+1)%10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;增加小球</span><br><span class="line">        for(var i &#x3D; 0; i&lt; changeNumArray.length; i++)&#123;</span><br><span class="line">            addBalls.apply(this,changeNumArray[i].split(&#39;_&#39;));</span><br><span class="line">        &#125;</span><br><span class="line">        data &#x3D; NewData.concat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*更新小球状态*&#x2F;</span><br><span class="line">    function updateBalls()&#123;</span><br><span class="line">        for(var i &#x3D; 0; i &lt; balls.length; i++)&#123;</span><br><span class="line">            balls[i].stepY +&#x3D; balls[i].disY;</span><br><span class="line">            balls[i].x +&#x3D; balls[i].stepX;</span><br><span class="line">            balls[i].y +&#x3D; balls[i].stepY;</span><br><span class="line">            if(balls[i].x &gt; W + R || balls[i].y &gt; H + R)&#123;</span><br><span class="line">                balls.splice(i,1);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*增加要运动的小球*&#x2F;</span><br><span class="line">    function addBalls(index,num)&#123;</span><br><span class="line">        var numArray &#x3D; [1,2,3];</span><br><span class="line">        var colorArray &#x3D;  [&quot;#3BE&quot;,&quot;#09C&quot;,&quot;#A6C&quot;,&quot;#93C&quot;,&quot;#9C0&quot;,&quot;#690&quot;,&quot;#FB3&quot;,&quot;#F80&quot;,&quot;#F44&quot;,&quot;#C00&quot;];</span><br><span class="line">        for(var i &#x3D; 0; i &lt; digit[num].length; i++)&#123;</span><br><span class="line">            for(var j &#x3D; 0; j &lt; digit[num][i].length; j++)&#123;</span><br><span class="line">                if(digit[num][i][j] &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                    var ball &#x3D; &#123;</span><br><span class="line">                        x:14*(R+2)*index + j*2*(R+1)+(R+1),</span><br><span class="line">                        y:i*2*(R+1)+(R+1),</span><br><span class="line">                        stepX:Math.floor(Math.random() * 4 -2),</span><br><span class="line">                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],</span><br><span class="line">                        color:colorArray[Math.floor(Math.random()*colorArray.length)],</span><br><span class="line">                        disY:1</span><br><span class="line">                    &#125;;</span><br><span class="line">                    balls.push(ball);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*渲染*&#x2F;</span><br><span class="line">    function render()&#123;</span><br><span class="line">        &#x2F;&#x2F;重置画布宽度，达到清空画布的效果</span><br><span class="line">        canvas.height &#x3D; 100;</span><br><span class="line">        &#x2F;&#x2F;渲染时钟</span><br><span class="line">        for(var i &#x3D; 0; i &lt; data.length; i++)&#123;</span><br><span class="line">            renderDigit(i,data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;渲染小球</span><br><span class="line">        for(var i &#x3D; 0; i &lt; balls.length; i++)&#123;</span><br><span class="line">            cxt.beginPath();</span><br><span class="line">            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);</span><br><span class="line">            cxt.fillStyle &#x3D; balls[i].color;</span><br><span class="line">            cxt.closePath();</span><br><span class="line">            cxt.fill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearInterval(oTimer);</span><br><span class="line">    var oTimer &#x3D; setInterval(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;更新时钟</span><br><span class="line">        updateDigitTime();</span><br><span class="line">        &#x2F;&#x2F;更新小球状态</span><br><span class="line">        updateBalls();</span><br><span class="line">        &#x2F;&#x2F;渲染</span><br><span class="line">        render();</span><br><span class="line">    &#125;,50);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>/themes/next/layout/_custom/sidebar.swig</code>。添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;.&#x2F;clock.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>/themes/next/layout/_macro/sidebar.swig</code>。增加下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.custom_file_path.sidebar %&#125;</span><br><span class="line">	&#123;% set custom_sidebar &#x3D; &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;&#39; + theme.custom_file_path.sidebar %&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">	&#123;% set custom_sidebar &#x3D; &#39;..&#x2F;_custom&#x2F;sidebar.swig&#39; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% include custom_sidebar %&#125;</span><br></pre></td></tr></table></figure>
<p>在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.links %&#125;</span><br><span class="line">           &lt;div class&#x3D;&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.links_layout | default(&#39;inline&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">             &lt;div class&#x3D;&quot;links-of-blogroll-title&quot;&gt;</span><br><span class="line">               &lt;i class&#x3D;&quot;fa  fa-fw fa-&#123;&#123; theme.links_icon | default(&#39;globe&#39;) | lower &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">               &#123;&#123; theme.links_title &#125;&#125;</span><br><span class="line">             &lt;&#x2F;div&gt;</span><br><span class="line">             &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;</span><br><span class="line">               &#123;% for name, link in theme.links %&#125;</span><br><span class="line">                 &lt;li class&#x3D;&quot;links-of-blogroll-item&quot;&gt;</span><br><span class="line">                   &lt;a href&#x3D;&quot;&#123;&#123; link &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; name &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">                 &lt;&#x2F;li&gt;</span><br><span class="line">               &#123;% endfor %&#125;</span><br><span class="line">             &lt;&#x2F;ul&gt;</span><br><span class="line">           &lt;&#x2F;div&gt;</span><br><span class="line">         &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>前</p>
<p>打开文件，路径：<code>/themes/next/source/css/_custom/custom.styl</code>。在末尾添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 粒子时钟样式</span><br><span class="line">.site-overview &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas#canvas &#123;</span><br><span class="line">  margin-top: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九、取消文章目录的自动编号"><a class="header-anchor" href="#九、取消文章目录的自动编号">¶</a>九、取消文章目录的自动编号</h1>
<p>打开主题配置文件，找到<code>toc</code>，把<code>number</code>值修改为<code>false</code>。</p>
<h1 id="十、去掉侧边栏声明"><a class="header-anchor" href="#十、去掉侧边栏声明">¶</a>十、去掉侧边栏声明</h1>
<p>打开<strong>主题配置</strong>文件，找到<code>creative_commons</code>。把它注释掉即可。</p>
<h1 id="十一、代码块复制功能"><a class="header-anchor" href="#十一、代码块复制功能">¶</a>十一、代码块复制功能</h1>
<p>1.下载 clipboard.js</p>
<p>三方插件 clipboardjs ，<strong>下载地址：<a href="https://github.com/Superheroo/copy-text" target="_blank" rel="noopener">https://github.com/Superheroo/copy-text</a></strong></p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B9%9D%EF%BC%89/1.png" alt></p>
<p>2.选择下载zip</p>
<p>3.保存文件<code>clipboard.js / clipboard.min.js</code> ，目录如下：<br>
<code>.\themes\next\source\js\src</code></p>
<p>4.在<code>.\themes\next\source\js\src</code>目录下，创建<code>clipboard-use.js</code>，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*页面载入完成后，创建复制按钮*&#x2F;</span><br><span class="line">!function (e, t, a) &#123; </span><br><span class="line">  &#x2F;* code *&#x2F;</span><br><span class="line">  var initCopyCode &#x3D; function()&#123;</span><br><span class="line">    var copyHtml &#x3D; &#39;&#39;;</span><br><span class="line">    copyHtml +&#x3D; &#39;&lt;button class&#x3D;&quot;btn-copy&quot; data-clipboard-snippet&#x3D;&quot;&quot;&gt;&#39;;</span><br><span class="line">    copyHtml +&#x3D; &#39;  &lt;i class&#x3D;&quot;fa fa-globe&quot;&gt;&lt;&#x2F;i&gt;&lt;span&gt;copy&lt;&#x2F;span&gt;&#39;;</span><br><span class="line">    copyHtml +&#x3D; &#39;&lt;&#x2F;button&gt;&#39;;</span><br><span class="line">    $(&quot;.highlight .code pre&quot;).before(copyHtml);</span><br><span class="line">    new ClipboardJS(&#39;.btn-copy&#39;, &#123;</span><br><span class="line">        target: function(trigger) &#123;</span><br><span class="line">            return trigger.nextElementSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  initCopyCode();</span><br><span class="line">&#125;(window, document);</span><br></pre></td></tr></table></figure>
<p>5.在<code>.\themes\next\source\css\_custom\custom.styl</code>样式文件中添加下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码块复制按钮</span><br><span class="line">.highlight&#123;</span><br><span class="line">  &#x2F;&#x2F;方便copy代码按钮（btn-copy）的定位</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    background-color: #eee;</span><br><span class="line">    background-image: linear-gradient(#fcfcfc,#eee);</span><br><span class="line">    border: 1px solid #d5d5d5;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">    user-select: none;</span><br><span class="line">    -webkit-appearance: none;</span><br><span class="line">    font-size: 13px;</span><br><span class="line">    font-weight: 700;</span><br><span class="line">    line-height: 20px;</span><br><span class="line">    color: #333;</span><br><span class="line">    -webkit-transition: opacity .3s ease-in-out;</span><br><span class="line">    -o-transition: opacity .3s ease-in-out;</span><br><span class="line">    transition: opacity .3s ease-in-out;</span><br><span class="line">    padding: 2px 6px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 5px;</span><br><span class="line">    top: 5px;</span><br><span class="line">    opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy span &#123;</span><br><span class="line">    margin-left: 5px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight:hover .btn-copy&#123;</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.在<code>.\themes\next\layout\_layout.swig</code>文件中，添加引用（注：在 swig 末尾或 body 结束标签（<code>&lt;/body&gt;</code>）之前添加）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 代码块复制功能 --&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;src&#x2F;clipboard.min.js&quot;&gt;&lt;&#x2F;script&gt;  </span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;src&#x2F;clipboard-use.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="十二、设置点击头像返回首页"><a class="header-anchor" href="#十二、设置点击头像返回首页">¶</a>十二、设置点击头像返回首页</h1>
<p>打开文件，路径：<code>themes\next\layout\_macro\sidebar.swig</code></p>
<p>。按照下面代码添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+        &lt;a href&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">          &lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot;</span><br><span class="line">               src&#x3D;&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &#39;&#x2F;avatar.gif&#39;) ) &#125;&#125;&quot;</span><br><span class="line">               alt&#x3D;&quot;&#123;&#123; theme.author &#125;&#125;&quot; &#x2F;&gt;</span><br><span class="line">+        &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里注意找到中间代码，添加a标签就行了，中间不用修改。</span><br></pre></td></tr></table></figure>
<p>这里搜索关键词找到这一部分后在位置添加就行了，+号表示增加代码，如果复制后记得把+号去掉。就一个a标签，建议自己直接写。</p>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（五）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍主题的一些配置，主要是语言、外观、菜单、头像、作者，站点描述，博客标题，字体大小的配置。</p>
<a id="more"></a>
<h1 id="一、设置博客语言"><a class="header-anchor" href="#一、设置博客语言">¶</a>一、设置博客语言</h1>
<p>编辑<strong>站点</strong>配置文件，找到 language并修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure>
<p>目前NexT支持的语言如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">语言</th>
<th style="text-align:center">代码</th>
<th style="text-align:center">设定示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">English</td>
<td style="text-align:center"><code>en</code></td>
<td style="text-align:center"><code>language: en</code></td>
</tr>
<tr>
<td style="text-align:center">简体中文</td>
<td style="text-align:center"><code>zh-Hans</code></td>
<td style="text-align:center"><code>language: zh-Hans</code></td>
</tr>
<tr>
<td style="text-align:center">Français</td>
<td style="text-align:center"><code>fr-FR</code></td>
<td style="text-align:center"><code>language: fr-FR</code></td>
</tr>
<tr>
<td style="text-align:center">Português</td>
<td style="text-align:center"><code>pt</code></td>
<td style="text-align:center"><code>language: pt</code> or <code>language: pt-BR</code></td>
</tr>
<tr>
<td style="text-align:center">繁體中文</td>
<td style="text-align:center"><code>zh-hk</code> 或者 <code>zh-tw</code></td>
<td style="text-align:center"><code>language: zh-hk</code></td>
</tr>
<tr>
<td style="text-align:center">Русский язык</td>
<td style="text-align:center"><code>ru</code></td>
<td style="text-align:center"><code>language: ru</code></td>
</tr>
<tr>
<td style="text-align:center">Deutsch</td>
<td style="text-align:center"><code>de</code></td>
<td style="text-align:center"><code>language: de</code></td>
</tr>
<tr>
<td style="text-align:center">日本語</td>
<td style="text-align:center"><code>ja</code></td>
<td style="text-align:center"><code>language: ja</code></td>
</tr>
<tr>
<td style="text-align:center">Indonesian</td>
<td style="text-align:center"><code>id</code></td>
<td style="text-align:center"><code>language: id</code></td>
</tr>
<tr>
<td style="text-align:center">Korean</td>
<td style="text-align:center"><code>ko</code></td>
<td style="text-align:center"><code>language: ko</code></td>
</tr>
</tbody>
</table>
<h1 id="二、设置外观主题"><a class="header-anchor" href="#二、设置外观主题">¶</a>二、设置外观主题</h1>
<p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
</ul>
<p>编辑主题配置文件。</p>
<p>搜索scheme关键词。要选择哪个外观，把#相当于注释去掉。</p>
<h1 id="三、设置菜单选项"><a class="header-anchor" href="#三、设置菜单选项">¶</a>三、设置菜单选项</h1>
<p>1.编辑<strong>主题</strong>配置文件。搜索找到menu。</p>
<table>
<thead>
<tr>
<th style="text-align:center">键值</th>
<th style="text-align:center">设定值</th>
<th style="text-align:center">显示文本（简体中文）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">home</td>
<td style="text-align:center"><code>home: /</code></td>
<td style="text-align:center">主页</td>
</tr>
<tr>
<td style="text-align:center">archives</td>
<td style="text-align:center"><code>archives: /archives</code></td>
<td style="text-align:center">归档页</td>
</tr>
<tr>
<td style="text-align:center">categories</td>
<td style="text-align:center"><code>categories: /categories</code></td>
<td style="text-align:center">分类页</td>
</tr>
<tr>
<td style="text-align:center">tags</td>
<td style="text-align:center"><code>tags: /tags</code></td>
<td style="text-align:center">标签页</td>
</tr>
<tr>
<td style="text-align:center">about</td>
<td style="text-align:center"><code>about: /about</code></td>
<td style="text-align:center">关于页面</td>
</tr>
<tr>
<td style="text-align:center">commonweal</td>
<td style="text-align:center"><code>commonweal: /404.html</code></td>
<td style="text-align:center">公益 404</td>
</tr>
</tbody>
</table>
<p>只需要把自己想要的菜单项注释#去掉，位置也可以更改，互相换行就行。就可以显示。</p>
<p>2.更换菜单栏位置</p>
<p>编辑<strong>主题</strong>配置文件。找到<strong>sidebar</strong>。</p>
<p>按照自己的喜好来。修改时去掉注释。</p>
<p>设置侧栏的显示时机。</p>
<ul>
<li><code>post</code> - 默认行为，在文章页面（拥有目录列表）时显示</li>
<li><code>always</code> - 在所有页面中都显示</li>
<li><code>hide</code> - 在所有页面中都隐藏（可以手动展开）</li>
<li><code>remove</code> - 完全移除</li>
</ul>
<h1 id="四、设置头像"><a class="header-anchor" href="#四、设置头像">¶</a>四、设置头像</h1>
<p>1.将头像放置主题目录下的 <code>source/uploads/</code> （若不存在新建uploads） 配置为：<code>next/source/uploads/picture.png</code></p>
<p>2.编辑<strong>主题</strong>配置文件，找到avatar。修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar: &#x2F;uploads&#x2F;picture.png</span><br></pre></td></tr></table></figure>
<p>3.修改后本地预览。头像方框为方形。</p>
<h1 id="五、设置头像为圆形"><a class="header-anchor" href="#五、设置头像为圆形">¶</a>五、设置头像为圆形</h1>
<p>进入下面的文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...&#x2F;themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_common&#x2F;components&#x2F;sidebar</span><br></pre></td></tr></table></figure>
<p>打开<code>sidebar-author.styl</code></p>
<p>在<code>.site-author-image</code>末尾位置增加代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;头像圆形</span><br><span class="line">border-radius: 50%;</span><br><span class="line">webkit-border-radius: 1.4s all;</span><br><span class="line">moz-transition: 1.4s all;</span><br><span class="line">ms-transition: 1.4s all;</span><br><span class="line">transition: 1.4s all;</span><br></pre></td></tr></table></figure>
<h1 id="六、头像360°旋转"><a class="header-anchor" href="#六、头像360°旋转">¶</a>六、头像360°旋转</h1>
<p>打开<code>sidebar-author.styl</code></p>
<p>在代码末尾加上下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;头像旋转</span><br><span class="line">.site-author-image:hover &#123;</span><br><span class="line">background-color: #55DAE1;</span><br><span class="line">webkit-transform: rotate(360deg) scale(1.1);</span><br><span class="line">moz-transform: rotate(360deg) scale(1.1);</span><br><span class="line">ms-transform: rotate(360deg) scale(1.1);</span><br><span class="line">transform: rotate(360deg) scale(1.1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七、设置作者、站点描述、博客标题"><a class="header-anchor" href="#七、设置作者、站点描述、博客标题">¶</a>七、设置作者、站点描述、博客标题</h1>
<p>编辑<strong>站点</strong>配置文件，搜素找到<strong>author</strong>。</p>
<p>修改作者、博客标题、站点描述等等。</p>
<h1 id="八、修改字体大小"><a class="header-anchor" href="#八、修改字体大小">¶</a>八、修改字体大小</h1>
<p>打开下面文件夹<code>...\themes\next\source\css\ _variables</code></p>
<p>打开<code>base.styl</code></p>
<p>找到<code>Font-size</code></p>
<p>把<code>font-size-base</code>的14px修改为16px。</p>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（六）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍fork me on github，点击鼠标出现桃心效果，博文压缩，修改文章页面宽度，文章分块显示，增大首页文章与文章距离，主页文章添加阴影效果。</p>
<a id="more"></a>
<h1 id="一、fork-me-on-github"><a class="header-anchor" href="#一、fork-me-on-github">¶</a>一、fork me on github</h1>
<p>1.首先访问图标网站：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.blog&#x2F;2008-12-19-github-ribbons&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;tholman.com&#x2F;github-corners&#x2F;</span><br></pre></td></tr></table></figure>
<p>挑选自己喜欢的样式，有数字也有图标。复制代码。</p>
<p>2.打开文件夹，路径：<code>...themes/next/layout</code>，打开<code>_layout.swig</code></p>
<p>粘贴刚才复制的代码，（放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面）。并把<code>href</code>也就是链接改为你的github地址。</p>
<h1 id="二、点击鼠标出现桃心效果"><a class="header-anchor" href="#二、点击鼠标出现桃心效果">¶</a>二、点击鼠标出现桃心效果</h1>
<p>复制下列代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(window,document,undefined)&#123;</span><br><span class="line">        var hearts &#x3D; [];</span><br><span class="line">        window.requestAnimationFrame &#x3D; (function()&#123;</span><br><span class="line">                return window.requestAnimationFrame || </span><br><span class="line">                           window.webkitRequestAnimationFrame ||</span><br><span class="line">                           window.mozRequestAnimationFrame ||</span><br><span class="line">                           window.oRequestAnimationFrame ||</span><br><span class="line">                           window.msRequestAnimationFrame ||</span><br><span class="line">                           function (callback)&#123;</span><br><span class="line">                                   setTimeout(callback,1000&#x2F;60);</span><br><span class="line">                           &#125;</span><br><span class="line">        &#125;)();</span><br><span class="line">        init();</span><br><span class="line">        function init()&#123;</span><br><span class="line">                css(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;);</span><br><span class="line">                attachEvent();</span><br><span class="line">                gameloop();</span><br><span class="line">        &#125;</span><br><span class="line">        function gameloop()&#123;</span><br><span class="line">                for(var i&#x3D;0;i&lt;hearts.length;i++)&#123;</span><br><span class="line">                    if(hearts[i].alpha &lt;&#x3D;0)&#123;</span><br><span class="line">                            document.body.removeChild(hearts[i].el);</span><br><span class="line">                            hearts.splice(i,1);</span><br><span class="line">                            continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hearts[i].y--;</span><br><span class="line">                    hearts[i].scale +&#x3D; 0.004;</span><br><span class="line">                    hearts[i].alpha -&#x3D; 0.013;</span><br><span class="line">                    hearts[i].el.style.cssText &#x3D; &quot;left:&quot;+hearts[i].x+&quot;px;top:&quot;+hearts[i].y+&quot;px;opacity:&quot;+hearts[i].alpha+&quot;;transform:scale(&quot;+hearts[i].scale+&quot;,&quot;+hearts[i].scale+&quot;) rotate(45deg);background:&quot;+hearts[i].color;</span><br><span class="line">            &#125;</span><br><span class="line">            requestAnimationFrame(gameloop);</span><br><span class="line">        &#125;</span><br><span class="line">        function attachEvent()&#123;</span><br><span class="line">                var old &#x3D; typeof window.onclick&#x3D;&#x3D;&#x3D;&quot;function&quot; &amp;&amp; window.onclick;</span><br><span class="line">                window.onclick &#x3D; function(event)&#123;</span><br><span class="line">                        old &amp;&amp; old();</span><br><span class="line">                        createHeart(event);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        function createHeart(event)&#123;</span><br><span class="line">            var d &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">            d.className &#x3D; &quot;heart&quot;;</span><br><span class="line">            hearts.push(&#123;</span><br><span class="line">                    el : d,</span><br><span class="line">                    x : event.clientX - 5,</span><br><span class="line">                    y : event.clientY - 5,</span><br><span class="line">                    scale : 1,</span><br><span class="line">                    alpha : 1,</span><br><span class="line">                    color : randomColor()</span><br><span class="line">            &#125;);</span><br><span class="line">            document.body.appendChild(d);</span><br><span class="line">    &#125;</span><br><span class="line">    function css(css)&#123;</span><br><span class="line">            var style &#x3D; document.createElement(&quot;style&quot;);</span><br><span class="line">                style.type&#x3D;&quot;text&#x2F;css&quot;;</span><br><span class="line">                try&#123;</span><br><span class="line">                    style.appendChild(document.createTextNode(css));</span><br><span class="line">                &#125;catch(ex)&#123;</span><br><span class="line">                    style.styleSheet.cssText &#x3D; css;</span><br><span class="line">                &#125;</span><br><span class="line">                document.getElementsByTagName(&#39;head&#39;)[0].appendChild(style);</span><br><span class="line">    &#125;</span><br><span class="line">        function randomColor()&#123;</span><br><span class="line">                return &quot;rgb(&quot;+(~~(Math.random()*255))+&quot;,&quot;+(~~(Math.random()*255))+&quot;,&quot;+(~~(Math.random()*255))+&quot;)&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)(window,document);</span><br></pre></td></tr></table></figure>
<p>在路径：<code>/themes/next/source/js/src</code>里面新建<code>love.js</code>文件。</p>
<p>打开<code>love.js</code>粘贴刚才复制的代码。</p>
<p>然后打开<code>\themes\next\layout\_layout.swig</code>。添加下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;src&#x2F;love.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="三、博文压缩"><a class="header-anchor" href="#三、博文压缩">¶</a>三、博文压缩</h1>
<p>首先git输入以下两个命令安装gulp：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp -g</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure>
<p>之后在博客根目录新建<code>gulpfile.js</code>文件。</p>
<p>打开<code>gulpfile.js</code>，粘贴以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gulp &#x3D; require(&#39;gulp&#39;);</span><br><span class="line">var minifycss &#x3D; require(&#39;gulp-minify-css&#39;);</span><br><span class="line">var uglify &#x3D; require(&#39;gulp-uglify&#39;);</span><br><span class="line">var htmlmin &#x3D; require(&#39;gulp-htmlmin&#39;);</span><br><span class="line">var htmlclean &#x3D; require(&#39;gulp-htmlclean&#39;);</span><br><span class="line">&#x2F;&#x2F; 压缩 public 目录 css</span><br><span class="line">gulp.task(&#39;minify-css&#39;, function() &#123;</span><br><span class="line">  return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.css&#39;)</span><br><span class="line">      .pipe(minifycss())</span><br><span class="line">      .pipe(gulp.dest(&#39;.&#x2F;public&#39;));</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 压缩 public 目录 html</span><br><span class="line">gulp.task(&#39;minify-html&#39;, function() &#123;</span><br><span class="line">  return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.html&#39;)</span><br><span class="line">      .pipe(htmlclean())</span><br><span class="line">      .pipe(htmlmin(&#123;</span><br><span class="line">          removeComments: true,</span><br><span class="line">          minifyJS: true,</span><br><span class="line">          minifyCSS: true,</span><br><span class="line">          minifyURLs: true,</span><br><span class="line">      &#125;))</span><br><span class="line">      .pipe(gulp.dest(&#39;.&#x2F;public&#39;))</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 压缩 public&#x2F;js 目录 js</span><br><span class="line">gulp.task(&#39;minify-js&#39;, function() &#123;</span><br><span class="line">  return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.js&#39;)</span><br><span class="line">      .pipe(uglify())</span><br><span class="line">      .pipe(gulp.dest(&#39;.&#x2F;public&#39;));</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 执行 gulp 命令时执行的任务</span><br><span class="line">&#x2F;&#x2F; gulp 4.0 适用的方式</span><br><span class="line">gulp.task(&#39;build&#39;, gulp.parallel(&#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;</span><br><span class="line">  &#x2F;&#x2F;build the website</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<p>生成博文是执行 <code>hexo g &amp;&amp; gulp</code> 就会根据 <code>gulpfile.js</code> 中的配置，对 public 目录中的静态资源文件进行压缩。</p>
<p>当你想要压缩的话执行上面命令就行，压缩后再上传部署。</p>
<h1 id="四、修改文章页面宽度"><a class="header-anchor" href="#四、修改文章页面宽度">¶</a>四、修改文章页面宽度</h1>
<p>打开文件，路径：<code>\themes\next\source/css/_schemes/Picses/_layout.styl</code></p>
<p>文件末尾添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下为新增代码！！修改post宽度</span><br><span class="line">header&#123; width: 80% !important; &#125;</span><br><span class="line">header.post-header &#123;</span><br><span class="line">width: auto !important;</span><br><span class="line">&#125;</span><br><span class="line">.container .main-inner &#123; width: 80%; &#125;</span><br><span class="line">.content-wrap &#123; width: calc(100% - 260px); &#125;</span><br><span class="line"></span><br><span class="line">.header &#123;</span><br><span class="line">+tablet() &#123;</span><br><span class="line">  width: auto !important;</span><br><span class="line">&#125;</span><br><span class="line">+mobile() &#123;</span><br><span class="line">  width: auto !important;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container .main-inner &#123;</span><br><span class="line">+tablet() &#123;</span><br><span class="line">  width: auto !important;</span><br><span class="line">&#125;</span><br><span class="line">+mobile() &#123;</span><br><span class="line">  width: auto !important;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content-wrap &#123;</span><br><span class="line">+tablet() &#123;</span><br><span class="line">  width: 100% !important;</span><br><span class="line">&#125;</span><br><span class="line">+mobile() &#123;</span><br><span class="line">  width: 100% !important;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、文章分块显示"><a class="header-anchor" href="#五、文章分块显示">¶</a>五、文章分块显示</h1>
<p>打开<strong>主题配置</strong>文件，找到<code>scheme</code> 把主题改为<strong>Gemini</strong>。</p>
<h1 id="六、增大首页文章与文章距离"><a class="header-anchor" href="#六、增大首页文章与文章距离">¶</a>六、增大首页文章与文章距离</h1>
<p>打开文件，路径<code>\themes\next\source\css\_custom\custom.styl</code>。</p>
<p>添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 主页文章添加阴影效果</span><br><span class="line">.post &#123;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">  margin-bottom: 60px;</span><br><span class="line">  padding: 0px;</span><br><span class="line">  -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">  -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>margin-top</code>和<code>margin-bottom</code>就是间距，根据自己的喜好选择吧。</p>
<h1 id="七、主页文章添加阴影效果"><a class="header-anchor" href="#七、主页文章添加阴影效果">¶</a>七、主页文章添加阴影效果</h1>
<p>在第6步的基础上修改<code>padding</code>，也就是阴影的宽度。</p>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（十一）</title>
    <url>/2020/06/13/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要解决在博客使用过程中所遇到的问题，与解决方法。在Hexo中插入外链音频文件，在Hexo中插入外链视频文件，解决翻页按钮不正常显示问题。</p>
<a id="more"></a>
<h1 id="一、在Hexo中插入外链音频文件"><a class="header-anchor" href="#一、在Hexo中插入外链音频文件">¶</a>一、在Hexo中插入外链音频文件</h1>
<p>1.以喜马拉雅为例，点击分享图标</p>
<p><img src="/2020/06/13/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/1.png" alt></p>
<p>2.点击通用代码后的复制</p>
<p><img src="/2020/06/13/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/2.png" alt></p>
<p>3.将改代码复制到博文中想要的位置即可</p>
<h1 id="二、在Hexo中插入外链视频文件"><a class="header-anchor" href="#二、在Hexo中插入外链视频文件">¶</a>二、在Hexo中插入外链视频文件</h1>
<p>1.以bilibili为例，点击分享图标</p>
<p><img src="/2020/06/13/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/3.png" alt></p>
<p>2.点击嵌入代码后的复制</p>
<p><img src="/2020/06/13/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/4.png" alt></p>
<p>3.将改代码复制到博文中想要的位置即可</p>
<h1 id="三、解决翻页按钮不正常显示问题"><a class="header-anchor" href="#三、解决翻页按钮不正常显示问题">¶</a>三、解决翻页按钮不正常显示问题</h1>
<p>在 <code>themes\hexo-theme-next\layout_partials</code> 下找到<code>hexo-theme-next</code>的翻页组件，就是<code>pagination.swig</code><br>
将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  &lt;nav class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">        next_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  &lt;nav class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &#39;上一页&#39;,</span><br><span class="line">        next_text: &#39;下一页&#39;,</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>重新发布以后可以看到翻页按钮可以正常显示了</p>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>拓展</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（十）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍增加微信公众号订阅，彩色标签页，侧边栏推荐阅读，文章内链接样式，相关文章推荐，图片灯箱功能，显示近期文章，页面顶部加载进度条，页面动画，添加文末版权声明，添加豆瓣阅读/电影/游戏。</p>
<a id="more"></a>
<h1 id="一、增加微信公众号订阅"><a class="header-anchor" href="#一、增加微信公众号订阅">¶</a>一、增加微信公众号订阅</h1>
<p>在路径：<code>\themes\next\source\uploads</code>下保存公众号二维码，文件名无所谓，但是在后面配置的时候要对应上。</p>
<p>打开主题配置文件，找到<code>wechat_subscriber</code>，自己设置，路径要和前面的文件名、文件格式对应上。</p>
<h1 id="二、彩色标签页"><a class="header-anchor" href="#二、彩色标签页">¶</a>二、彩色标签页</h1>
<p>在路径：<code>/themes/next/layout</code>下新建文件 <code>tag-color.swig</code>。添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var alltags &#x3D; document.getElementsByClassName(&#39;tag-cloud-tags&#39;);</span><br><span class="line">    var tags &#x3D; alltags[0].getElementsByTagName(&#39;a&#39;);</span><br><span class="line">    for (var i &#x3D; tags.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">      var r&#x3D;Math.floor(Math.random()*75+130);</span><br><span class="line">      var g&#x3D;Math.floor(Math.random()*75+100);</span><br><span class="line">      var b&#x3D;Math.floor(Math.random()*75+80);</span><br><span class="line">      tags[i].style.background &#x3D; &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.tag-cloud-tags&#123;</span><br><span class="line">  &#x2F;*font-family: Helvetica, Tahoma, Arial;*&#x2F;</span><br><span class="line">  &#x2F;*font-weight: 100;*&#x2F;</span><br><span class="line">  text-align: center;</span><br><span class="line">  counter-reset: tags;</span><br><span class="line">&#125;</span><br><span class="line">.tag-cloud-tags a&#123;</span><br><span class="line">  border-radius: 6px;</span><br><span class="line">  padding-right: 5px;</span><br><span class="line">  padding-left: 5px;</span><br><span class="line">  margin: 8px 5px 0px 0px;</span><br><span class="line">&#125;</span><br><span class="line">.tag-cloud-tags a:before&#123;</span><br><span class="line">  content: &quot;🔖&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tag-cloud-tags a:hover&#123;</span><br><span class="line">    box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);</span><br><span class="line">    transform: scale(1.1);</span><br><span class="line">    &#x2F;*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*&#x2F;</span><br><span class="line">    transition-duration: 0.15s;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>打开同级目录下的 <code>page.swig</code>文件，在下图位置增加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;tag-color.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、侧边栏推荐阅读"><a class="header-anchor" href="#三、侧边栏推荐阅读">¶</a>三、侧边栏推荐阅读</h1>
<p>打开<code>主题配置</code>文件，找到<code>Blog rolls</code>。配置为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 推荐阅读</span><br><span class="line">#links_layout: block</span><br><span class="line">links_layout: inline</span><br><span class="line">links:</span><br><span class="line">博客搭建: https:&#x2F;&#x2F;sushan102.top&#x2F;posts&#x2F;1410804403&#x2F;</span><br></pre></td></tr></table></figure>
<p>在<code>links</code>下添加你想要推荐阅读的永久链接即可。</p>
<h1 id="四、文章内链接样式"><a class="header-anchor" href="#四、文章内链接样式">¶</a>四、文章内链接样式</h1>
<p>打开文件，路径：<code>themes/next/source/css/_custom/custom.styl</code>。在末尾添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">color: #0593d3;</span><br><span class="line">border-bottom: none;</span><br><span class="line">border-bottom: 2px solid #0593d3;</span><br><span class="line">&amp;:hover &#123;</span><br><span class="line">  color: #fc6423;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #fc6423;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、图片灯箱功能"><a class="header-anchor" href="#五、图片灯箱功能">¶</a>五、图片灯箱功能</h1>
<p>默认的图片不能全屏查看，所以要安装依赖。</p>
<p>添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 fancyBox 提供。</p>
<p>首先安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;fancybox</span><br></pre></td></tr></table></figure>
<p>安装后打开<strong>主题配置</strong>文件，找到<code>fancybox</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure>
<h1 id="六、显示近期文章"><a class="header-anchor" href="#六、显示近期文章">¶</a>六、显示近期文章</h1>
<p>打开<code>主题配置</code>文件，添加以下配置代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 近期文章</span><br><span class="line">recent_posts: true</span><br><span class="line">recent_posts_layout: block</span><br></pre></td></tr></table></figure>
<p>打开语言配置文件，路径：<code>themes/next/languages/zh-CN.yml</code>，在下面位置添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">recent_posts: 近期文章</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>themes/next/layout/_macro/sidebar.swig</code>。在侧边栏的合适位置添加以下代码：</p>
<p>在链接图标<code>social</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.social %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>后面添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 添加近期文章 --&gt;</span><br><span class="line">&#123;% if theme.recent_posts %&#125;</span><br><span class="line">  &lt;div class&#x3D;&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;links-of-blogroll-title&quot;&gt;</span><br><span class="line">      &lt;!-- modify icon to fire by szw --&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &#123;&#123; __(&#39;sidebar.recent_posts&#39;) &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;</span><br><span class="line">      &#123;% set posts &#x3D; site.posts.sort(&#39;-date&#39;) %&#125;</span><br><span class="line">      &#123;% for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七、页面顶部加载进度条"><a class="header-anchor" href="#七、页面顶部加载进度条">¶</a>七、页面顶部加载进度条</h1>
<p>在根目录下执行下面命令安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pace themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;pace</span><br></pre></td></tr></table></figure>
<p>之后打开<strong>主题配置</strong>文件，找到<code>pace</code>。<code>enable</code>设为<code>true</code>。</p>
<h1 id="八、页面动画"><a class="header-anchor" href="#八、页面动画">¶</a>八、页面动画</h1>
<p>页面配置动画主要是在加载页面的时候，每一部分元素加载的效果。</p>
<p>打开<code>主题配置</code>文件，找到<code>motion</code>，默认的动画如下，可根据自己的喜好修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">motion:</span><br><span class="line">enable: true</span><br><span class="line">async: false</span><br><span class="line">transition:</span><br><span class="line">  # Transition variants:</span><br><span class="line">  # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span><br><span class="line">  # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span><br><span class="line">  # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span><br><span class="line">  # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span><br><span class="line">  # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span><br><span class="line">  # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span><br><span class="line">  post_block: fadeIn</span><br><span class="line">  post_header: slideDownIn</span><br><span class="line">  post_body: slideDownIn</span><br><span class="line">  coll_header: slideLeftIn</span><br><span class="line">  # Only for Pisces | Gemini.</span><br><span class="line">  sidebar: slideUpIn</span><br></pre></td></tr></table></figure>
<h1 id="九、添加文末版权声明"><a class="header-anchor" href="#九、添加文末版权声明">¶</a>九、添加文末版权声明</h1>
<p>打开<code>主题配置</code>文件，找到<code>post_copyright</code>，开启内置版权声明，版权声明默认使用 CC BY-NC-SA 4.0 许可协议，用户可以根据自身需要修改 <code>licence</code> 字段变更协议。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_copyright:</span><br><span class="line">enable: true</span><br><span class="line">license: &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;&quot; rel&#x3D;&quot;external nofollow&quot; target&#x3D;&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>themes\next\layout\_macro\post-copyright.swig</code>。删除掉原来代码，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- JS库 clipboard 拷贝内容到粘贴板--&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;clipboard.js&#x2F;2.0.1&#x2F;clipboard.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- JS库 sweetalert 显示提示信息--&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;sweetalert&#x2F;dist&#x2F;sweetalert.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul class&#x3D;&quot;post-copyright&quot;&gt;</span><br><span class="line">&lt;!-- 本文标题 --&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">  &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.title&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125; &lt;&#x2F;strong&gt;</span><br><span class="line">  &#123;&#123; post.title &#125;&#125;</span><br><span class="line">&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 本文作者 --&gt;</span><br><span class="line">&lt;li class&#x3D;&quot;post-copyright-author&quot;&gt;</span><br><span class="line">  &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.author&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125; &lt;&#x2F;strong&gt;</span><br><span class="line">  &#123;&#123; post.author | default(author) &#125;&#125;</span><br><span class="line">&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 创建时间 --&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">  &lt;strong&gt;&#123;&#123; __(&#39;post.created&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125; &lt;&#x2F;strong&gt;</span><br><span class="line">  &#123;&#123; post.date.format(&quot;YYYY年MM月DD日 - HH时MM分&quot;) &#125;&#125;</span><br><span class="line">&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修改时间 --&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">  &lt;strong&gt;&#123;&#123; __(&#39;post.modified&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125; &lt;&#x2F;strong&gt;</span><br><span class="line">  &#123;&#123; post.updated.format(&quot;YYYY年MM月DD日 - HH时MM分&quot;) &#125;&#125;</span><br><span class="line">&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 引用链接 --&gt;</span><br><span class="line">&lt;li class&#x3D;&quot;post-copyright-link&quot;&gt;</span><br><span class="line">  &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.link&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot;</span><br><span class="line">    &gt;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&lt;&#x2F;a</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;copy-path&quot; title&#x3D;&quot;点击复制引用链接&quot;</span><br><span class="line">    &gt;&lt;i</span><br><span class="line">      style&#x3D;&quot;cursor: pointer&quot;</span><br><span class="line">      class&#x3D;&quot;fa fa-clipboard&quot;</span><br><span class="line">      data-clipboard-text&#x3D;&quot;[&#123;&#123; post.author | default(author) &#125;&#125;&#39;s Blog | &#123;&#123; post.title &#125;&#125;](&#123;&#123; post.permalink &#125;&#125;)&quot;</span><br><span class="line">      aria-label&#x3D;&quot;&#123;&#123; __(&#39;post.copy_success&#39;) &#125;&#125;&quot;</span><br><span class="line">    &gt;&lt;&#x2F;i</span><br><span class="line">  &gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 版权声明 --&gt;</span><br><span class="line">&lt;li class&#x3D;&quot;post-copyright-license&quot;&gt;</span><br><span class="line">  &lt;strong</span><br><span class="line">    &gt;&#123;&#123; __(&#39;post.copyright.license_title&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;strong&gt;</span><br><span class="line">  &#123;&#123; __(&#39;post.copyright.license_content&#39;, theme.post_copyright.license) &#125;&#125;</span><br><span class="line">&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var clipboard &#x3D; new ClipboardJS(&quot;.fa-clipboard&quot;);</span><br><span class="line">clipboard.on(&quot;success&quot;, function(target) &#123;</span><br><span class="line">  var message &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">  message.innerHTML &#x3D;</span><br><span class="line">    &#39;&lt;i class&#x3D;&quot;fa fa-check-circle message-icon&quot;&gt;&lt;&#x2F;i&gt;&lt;span class&#x3D;&quot;message-content&quot;&gt;&#39; +</span><br><span class="line">    target.trigger.getAttribute(&quot;aria-label&quot;) +</span><br><span class="line">    &quot;&lt;&#x2F;span&gt;&quot;;</span><br><span class="line">  swal(&#123;</span><br><span class="line">    content: message,</span><br><span class="line">    className: &quot;copy-success-message&quot;,</span><br><span class="line">    timer: 1000,</span><br><span class="line">    button: false</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>打开样式配置文件，路径：<code>themes\next\source\css\_common\components\post\post-copyright.styl</code>，最末尾添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.swal-overlay &#123;</span><br><span class="line">background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.copy-success-message &#123;</span><br><span class="line">box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.15);</span><br><span class="line">border-radius: 4px;</span><br><span class="line">width: auto;</span><br><span class="line">margin: 16x 0px;</span><br><span class="line">vertical-align: top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.copy-success-message .swal-content &#123;</span><br><span class="line">margin: 0px 0px !important;</span><br><span class="line">padding: 10px 16px;</span><br><span class="line">line-height: 1em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.copy-success-message .message-icon &#123;</span><br><span class="line">color: #52c41a;</span><br><span class="line">margin-right: 8px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.copy-success-message .message-content &#123;</span><br><span class="line">font-size: 14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开语言配置文件，路径：<code>themes/next/languages/zh-CN.yml</code>，按照下面代码补全：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post:</span><br><span class="line">created: 创建时间</span><br><span class="line">modified: 修改时间</span><br><span class="line">copy_success: 复制成功</span><br><span class="line">copyright:</span><br><span class="line">  title: 本文标题</span><br><span class="line">  author: 本文作者</span><br><span class="line">  link: 本文链接</span><br><span class="line">  license_title: 版权声明</span><br><span class="line">  license_content: &quot;本博客所有文章除特别声明外，均采用 %s 许可协议。转载请注明出处！&quot;</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>themes/next/layout/_macro/post.swig</code>，找到如下字段进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#123;% if theme.post_copyright.enable and not is_index %&#125;</span><br><span class="line">+ &#123;% if theme.post_copyright.enable and page.copyright and not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &#39;post-copyright.swig&#39; with &#123; post: post &#125; %&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>-号表示删除这一行，+号表示添加这一行，添加后删除+号。</p>
<p>再打开文件，路径：<code>scaffolds\post.md</code>，添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copyright: true #版权声明</span><br></pre></td></tr></table></figure>
<h1 id="十、添加豆瓣阅读-电影-游戏"><a class="header-anchor" href="#十、添加豆瓣阅读-电影-游戏">¶</a>十、添加豆瓣阅读/电影/游戏</h1>
<p>在Hexo中可以添加豆瓣阅读/电影/游戏，这个模块在GitHub已经有人写好了，我们只要安装再稍微配置一下就行。</p>
<p>GitHub项目地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mythsman&#x2F;hexo-douban</span><br></pre></td></tr></table></figure>
<p>首先要安装<code>hexo-douban</code>，在根目录执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-douban --save</span><br></pre></td></tr></table></figure>
<p>打开<code>站点配置</code>文件，添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">douban:</span><br><span class="line">user: mythsman</span><br><span class="line">builtin: false</span><br><span class="line">book:</span><br><span class="line">  title: &#39;This is my book title&#39;</span><br><span class="line">  quote: &#39;This is my book quote&#39;</span><br><span class="line">movie:</span><br><span class="line">  title: &#39;This is my movie title&#39;</span><br><span class="line">  quote: &#39;This is my movie quote&#39;</span><br><span class="line">game:</span><br><span class="line">  title: &#39;This is my game title&#39;</span><br><span class="line">  quote: &#39;This is my game quote&#39;</span><br><span class="line">timeout: 10000</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>user</strong>: 你的豆瓣ID.打开豆瓣，登入账户，然后在右上角点击 “个人主页” ，这时候地址栏的URL大概是这样：“<a href="https://www.douban.com/people/xxxxxx/" target="_blank" rel="noopener">https://www.douban.com/people/xxxxxx/</a>” ，其中的&quot;xxxxxx&quot;就是你的个人ID了。</li>
<li><strong>builtin</strong>: 是否将生成页面的功能嵌入<code>hexo s</code>和<code>hexo g</code>中，默认是<code>false</code>,另一可选项为<code>true</code>。</li>
<li><strong>title</strong>: 该页面的标题。</li>
<li><strong>quote</strong>: 写在页面开头的一段话,支持html语法。</li>
<li><strong>timeout</strong>: 爬取数据的超时时间，默认是 10000ms ,如果在使用时发现报了超时的错(ETIMEOUT)可以把这个数据设置的大一点。</li>
</ul>
<p>如果只想显示某一个页面(比如movie)，那就把其他的配置项注释掉即可。</p>
<p>打开<code>主题配置</code>文件，找到<code>menu</code>，在<code>menu</code>下添加以下代码菜单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || tasks</span><br><span class="line">+   books: &#x2F;books&#x2F; || book</span><br><span class="line">+   movies: &#x2F;movies&#x2F; || video-camera</span><br><span class="line">+   games: &#x2F;games&#x2F; || gamepad</span><br></pre></td></tr></table></figure>
<p>+号表示添加这一行，菜单的位置按照自己的想法来，如果阅读/电影/游戏哪一个功能不想要，注释掉就行。添加后删除+号。</p>
<p>之后打开文件，路径：<code>themes\next\language\zh_CN.yml</code>，在如下位置添加代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">+   movies: 电影</span><br><span class="line">+   books: 读书</span><br><span class="line">+   games: 游戏</span><br></pre></td></tr></table></figure>
<p>+号表示添加这一行，添加后删除+号。</p>
<p>以上就算配置完了，还有一些注意的地方。</p>
<p>安装完豆瓣阅读/电影/游戏功能后，我们需要执行以下命令生成豆瓣阅读/电影/游戏页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo douban</span><br></pre></td></tr></table></figure>
<ul>
<li>-b | --books: 只生成豆瓣读书页面</li>
<li>-m | --movies: 只生成豆瓣电影页面</li>
<li>-g | --games: 只生成豆瓣游戏页面</li>
</ul>
<p>也可以输入<code>hexo douban -bgm</code>生成页面，效果与<code>hexo douban</code>一样。如果想要生成单独的页面，单独输入就行，比如：<code>hexo douban -b</code>生成读书页面。</p>
<p>执行完<code>hexo douban</code>后再执行<code>hexo g</code>、<code>hexo s</code>。</p>
<p>但是安装完这个插件后<code>hexo d</code>就不能使用了，因为<code>douban</code>和<code>deploy</code>首字母都是d，执行<code>hexo d</code>会有歧义，因此安装了此插件后上传部署执行<code>hexo deploy</code>即可，也就是要使用全称，不能简写。</p>
<p>如果设置了<code>builtin: true</code>，则每次执行<code>hexo g</code> 和<code>hexo s</code>的时候会自动执行<code>hexo douban</code>，也就是不需要手动执行<code>hexo douban</code>命令了，但是这样设置可能会增加打包编译的时间，如果你的豆瓣阅读/电影/游戏也不更新的话每次<code>hexo douban</code>也没有必要。</p>
<p>如果设置了<code>builtin: false</code>，则每次豆瓣数据更新后需要手动执行<code>hexo douban</code>命令，建议如果没有特殊情况的话设置为<code>builtin: false</code>。这样自己豆瓣数据更新后再手动执行<code>hexo douban</code>命令部署即可。</p>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客 Hexo+Next （一）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍个人静态博客安装时，需要用到的软件及安装地址，注册Github账户，创建SSH密钥，Github Pages仓库</p>
<a id="more"></a>
<h1 id="一、Node-js安装"><a class="header-anchor" href="#一、Node-js安装">¶</a>一、Node.js安装</h1>
<p>1.Hexo基于Node.js，搭建中还需要npm（Node.js自带）和git，因此我们需要首先安装Node.js和Git。</p>
<p><strong>Node.js安装：</strong></p>
<p><strong>Node.js官网：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></strong></p>
<p>进入官网后下载Windows（x64）长期支持版。</p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%80%EF%BC%89/node%E4%B8%8B%E8%BD%BD.png" alt></p>
<p>2.安装位置选择处C盘外其他位置，其它选项默认。点击下一步。完成软件安装。</p>
<h1 id="二、Git安装"><a class="header-anchor" href="#二、Git安装">¶</a>二、Git安装</h1>
<p>1.<strong>Git官网下载网址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></strong></p>
<p>进入官网后选择Windows就会自动下载，或是选择电脑位数下载。</p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%80%EF%BC%89/node%E4%B8%8B%E8%BD%BD.png" alt="node下载"></p>
<p>2.安装位置选择处C盘外其他位置，其它选项默认。点击下一步。完成软件安装。</p>
<h1 id="三、验证是否完成安装"><a class="header-anchor" href="#三、验证是否完成安装">¶</a>三、验证是否完成安装</h1>
<p>1.验证Node.js和Git是否安装成功，也就是本地环境是否搭建成功。Win+R打开运行。输入cmd，进入命令提示符。</p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%80%EF%BC%89/cmd.png" alt="cmd"></p>
<p>2.依次输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>如果出现对应的版本号，那么表示本地环境搭建成功。</p>
<h1 id="四、注册Github账户，密码"><a class="header-anchor" href="#四、注册Github账户，密码">¶</a>四、注册Github账户，密码</h1>
<p>1.<strong>GitHub官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></strong></p>
<p>2.点击 <strong>Sign up</strong> 进入注册界面</p>
<p>3.输入信息，验证邮箱信息，即可完成注册</p>
<h1 id="五、创建SSH密钥"><a class="header-anchor" href="#五、创建SSH密钥">¶</a>五、创建SSH密钥</h1>
<p>1.在桌面，鼠标右键，点击【Git Bash Here】。</p>
<p>2.依次输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub用户名&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;GitHub邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>3.输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;GitHub邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>回车，创建SSH密钥。</p>
<h1 id="六、添加密钥"><a class="header-anchor" href="#六、添加密钥">¶</a>六、添加密钥</h1>
<p>1.在<strong>C：\用户\用户名\ .ssh</strong>下找到<strong>id_rsa.pub</strong>文件。复制文件中的内容。</p>
<p>2.登陆GitHub，点击setting。</p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%80%EF%BC%89/setting.png" alt></p>
<p>3.选择左边SSH and GPG Keys选项。进行添加密匙。</p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%80%EF%BC%89/SSH.png" alt></p>
<p>4.点击New SSH Key进行添加。</p>
<p>5.title随便取，把刚才复制的密匙粘贴到Key中，点击Add SSH Key添加完成。</p>
<p>6.打开Git Bash，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>出现Are you sure……的时候输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>
<p>回车。</p>
<p>最后显示**You’ve successfully……**的时候表示连接成功。</p>
<h1 id="七、新建GitHub-Pages仓库。"><a class="header-anchor" href="#七、新建GitHub-Pages仓库。">¶</a>七、新建GitHub Pages仓库。</h1>
<p>1.点击右上角加号，点击New repository新建GitHub Pages仓库。</p>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E4%B8%80%EF%BC%89/%E5%8A%A0%E5%8F%B7.png" alt></p>
<p>2.在Repository name中输入：<strong><a href="http://xn--eqr924avxo.github.io" target="_blank" rel="noopener">用户名.github.io</a></strong></p>
<p><strong>勾选</strong>“Initialize this repository with a README”</p>
<p>Description不填。</p>
<p>填好后点击Create repository。创建后默认启用HTTPS。</p>
<p><strong>博客的地址为:<a href="https://xn--eqr924avxo.github.io" target="_blank" rel="noopener">https://用户名.github.io</a></strong></p>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（四）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍更改Hexo主题以及博客不是全文显示的设置。</p>
<a id="more"></a>
<h1 id="一、主题更改"><a class="header-anchor" href="#一、主题更改">¶</a>一、主题更改</h1>
<p>1.访问Hexo网站，<strong>网址：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></strong></p>
<p>2.推荐下载NexT主题配置，<strong>网址：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></strong></p>
<p>打开Git，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>安装NexT主题。</p>
<p>3.打开<strong>网站</strong>配置文件 _config.yml。找到theme。修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<h1 id="二、只显示部分摘要"><a class="header-anchor" href="#二、只显示部分摘要">¶</a>二、只显示部分摘要</h1>
<p>要前面写一点摘要或者概述，之后加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%9B%9B%EF%BC%89/1.png" alt></p>
<p>之后再书写全文。</p>
<h1 id="三、推荐书写格式"><a class="header-anchor" href="#三、推荐书写格式">¶</a>三、推荐书写格式</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019&#x2F;3&#x2F;26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">- Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">- PS4</span><br><span class="line">- Games</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>喜马听书笔记【附电子书】（二）</title>
    <url>/2020/06/13/%E5%96%9C%E9%A9%AC%E5%90%AC%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%90%E9%99%84%E7%94%B5%E5%AD%90%E4%B9%A6%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本期包括《毕司沃斯先生的房子》、《救命饮食》、《态度》、《影响力大师》、《只需倾听》、《恐惧》、《血疫》共七本书。</p>
<a id="more"></a>
<p>电子书下载地址：<strong><a href="https://wws.lanzous.com/b01bhdefc" target="_blank" rel="noopener">https://wws.lanzous.com/b01bhdefc</a></strong><br>
<strong>密码:gyni</strong></p>
<h1 id="008文学丨《毕司沃斯先生的房子》：诺奖作家奈保尔代表作，殖民作家永远的身份追寻"><a class="header-anchor" href="#008文学丨《毕司沃斯先生的房子》：诺奖作家奈保尔代表作，殖民作家永远的身份追寻">¶</a>008文学丨《毕司沃斯先生的房子》：诺奖作家奈保尔代表作，殖民作家永远的身份追寻</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=247976794&type=red" frameborder="0" allowfullscreen></iframe>
<p>2001年诺贝尔文学奖获得者奈保尔的代表作《毕司沃斯先生的房子》。出版于半个多世纪前的1961年，它的关键词——房子，今天依然能牵动我们的心。对于小说主人公毕司沃斯先生来说，房子不仅仅是一个遮风挡雨的住所，更是他拥有独立身份和尊严的至高无上的证明。</p>
<p><strong>为什么说这部小说融入了奈保尔的自身经历？</strong></p>
<p>1932年，奈保尔出生在特立尼达和多巴哥共和国一个印度婆罗门移民家庭。特立尼达是个位于加勒比海的落后、闭塞的岛国，面积不及上海的十分之一。它之前是西班牙殖民地，但是1797年，英国舰队挫败西班牙，占领了这个岛国，从此便不断地输送印度和非洲人口来此。奈保尔家族也就是在这时，以契约劳工的身份从印度来到特立尼达。奈保尔从小阅读大量英国文学作品，11岁就确立了当作家的梦想，以及去英国实现梦想的决心。后来奈保尔如愿考上了牛津大学，毕业后也成了一名作家，一生创作了三十多部作品，荣获布克奖、诺贝尔文学奖等各项荣誉，还被英国女王封为爵士。奈保尔似乎实现了作家梦；但是，无论在特立尼达、印度还是英国，他始终都觉得自己是一个异乡人，这种无所依傍的漂泊感一直持续到2018年去世。在英国，奈保尔曾饱受颠沛流离之苦，几乎一度被贫穷和歧视推入绝境。他曾经尝试过开煤气自杀，结果因煤气不够没有成功。在寻求身份的艰难岁月中，对房子的渴求也成为奈保尔难解的情结。奈保尔曾声称：“在我所有的作品中，《毕司沃斯先生的房子》是最贴近我的一部。”评论界也把这部小说视为奈保尔最成功的小说，将其归入英国20世界百佳小说的榜单。</p>
<p><strong>为什么小说又被成为家庭传记和移民史诗？</strong></p>
<p>小说将近五十万字，奈保尔以史诗般的规模描写了毕司沃斯先生平庸、忙碌、辛酸而悲伤的一生，具有鲜明的家庭传记色彩与移民史诗风格。</p>
<p>主人公毕司沃斯先生，是特立尼达首府西班牙港《卫报》的新闻编辑，一生最大的梦想就是拥有自己的房子。为什么呢？与作者奈保尔一样，毕司沃斯先生是个印度移民，他虽然属于婆罗门种姓，是贵族阶层，但是他生于贫寒家庭，自结婚后一直住在属于妻子图尔斯家族的房子里。他曾经自己尝试建造木头房子，但是最终都以失败告终。在他生命的最后时光，他终于拥有了自己的房子，也为此背上了繁重的债务。</p>
<p>小说开始从头叙述毕司沃斯先生为房子而奋斗的一生，为了便于讲述，我们以他结婚入赘图尔斯家族和进入《卫报》当记者为界，将主人公的生命历程分成三个阶段。</p>
<p>第一阶段是毕司沃斯先生童年和青年成长的经历。在写童年阶段时，奈保尔的笔触带着拉丁美洲式的魔幻色彩。毕司沃斯先生出生于特立尼达一个有着浓厚印度生活习俗和宗教信仰的乡村社区，他的出生充满了不祥之兆：胎位不正，生在半夜时分，还长着六指。</p>
<p>毕司沃斯先生违反禁令偷偷溜到水边玩耍，结果不小心让邻居家的牛犊淹死在水塘里，他吓得躲了起来；大家到处寻他不见，都以为他也掉到水塘里了，父亲便下塘寻找儿子，结果不幸淹死了。父亲的死，让毕司沃斯家从此失去了家庭支柱，他们频繁遭受村里人的欺侮，母亲最后不得已把房子和地都卖给了邻居，然后搬家到邻近的波各迪斯小镇，投靠姐姐塔拉生活。</p>
<p>这次搬离是毕司沃斯先生人生的第一次转折，也是他第一次意识到“房子”的重要意义。而作为移民者，毕司沃斯先生家园的丧失，也展现出了更深层次的意蕴。小说写道：“毕司沃斯先生离开了这个他唯一有权力的房子。在以后的三十五年里，他像个流浪者一样到处辗转，却没有一处他可以称之为家。”</p>
<p>由于毕司沃斯先生的婆罗门身份，在姨妈塔拉家特殊的宗教仪式中，他作为婆罗门时可以登堂人室，享受高种性的上等人应该享受的尊贵身份，姨妈还安排他到梵学家杰拉姆家里学习，希望他也能成为一个婆罗门学者。然而毕司沃斯先生对印度语和经文也毫无兴趣，最终因为不小心玷污了圣树，而被粗暴地逐出师门。</p>
<p>这次被驱逐事件，可以视为毕司沃斯先生第二次人生转折，他的身份意识慢慢觉醒，他希望拥有自己的独立空间，拥有一套独立的房子。</p>
<p>**之后，毕司沃斯先生进入了成年阶段，他迎来了生命的第二阶段——步入婚姻。**他在朋友的帮助下找到了一份画广告牌的工作，充分发挥了自己的印刷体书写优势。也正是这份工作，使他来到了堪称豪门的图尔斯家族，并遇见了后来的妻子莎玛。毕司沃斯先生得以入赘图尔斯家族，一方面在于他婆罗门种姓的印度移民身份。</p>
<p>成了上门女婿后，毕司沃斯先生迷失在庞大的图尔斯家族中。他和妻子莎玛住在一个阳台隔成的长形小屋中，他因贫穷而被指责，人人都说，“你来到这个家时，你所拥有的东西还不够挂满一根一英寸的钉子”，人人都觉得他应该对图尔斯家族感恩戴德。毕司沃斯先生在家中没有任何权力，孩子的名字都是图尔斯家族的人取的，他甚至无法为自己的孩子买一件与众不同的玩具，因为姐妹们的嫉妒，妻子莎玛不得不把他为女儿买的昂贵的玩具房子砸烂。他的生活总是由图尔斯家族安排：先是安排他成为一家店铺的小店主，然后又安排他成为甘蔗种植园的工头。在拥挤、喧哗的大宅子中，司沃斯先生无足轻重，他既没有个人或小家庭的空间，更得不到身份的认同和尊重。</p>
<p>为了抗拒无时不在的被吞没的感觉，毕司沃斯先生时常和家庭成员发生冲突，但是，每一次都以他的失败结束。他越来越强烈地想要出逃，想要摆脱这个大家庭的控制，寻求自己的立身之处。于是，建立一处自己的房子，成了他的人生目标。为此，他带着一家人经历了一次又一次的迁居，无数次做着拥有自己的房子的美梦。</p>
<p>毕司沃斯先生为房子奋斗的一生进入第三阶段——他来到西班牙港，之后他将在锡金街度过生命的最后十五年。毕司沃斯先生凭借画广告牌的手艺和阅读的积累，进入《特立尼达卫报》做记者，这自然是一份再理想不过的工作。他很快把妻子玛莎、四个孩于一家六口接到西班牙港，不过依然没有自己的房子，住的是图尔斯家在西班牙港的房产。由于记者事业的成功起步，毕司沃斯先生找回了一些自信，他怀着对新生活的热忱对住所进行了改造：砌花园，种玫瑰，挖水塘种莲花，还买了一些家具。后来他自己找了一块地皮，建了一所和绿谷差不多的房子，不幸是的，房子毁于一场大火。毕司沃斯先生又随全家搬到了西班牙港的房子里，他和家族矛盾丛生，特别是当他冲撞了图尔斯太太的小儿子奥华德，冲突变得更加激烈。</p>
<p>伴随着房子梦想的一次次破灭，毕司沃斯在工作上也渐渐失势。他觉得再也不能在图尔斯家住下去，他拼命四处寻找房子，准备贷款买房子。此时，一位法务官文书自愿将自己的一幢房子低价出让给他。毕司沃斯求房心切，他毫不犹豫地花光一生的积蓄、加上贷款3000美元将房子买厂来。但是当他带着一家六口搬进新居时，才发现房子质量低劣。</p>
<p>虽然这座住宅不甚完美，但是不管怎样，最后他终于拥有了自己的房子了，哪怕是在这最后的岁月里。小说写道，“在被疾病和绝望折磨的数月里，他一次又一次地觉得，住在自己的房子里，拥有自己的房子，是多么不可思议的事情。从小，他就从一个陌生人的屋子迁移到另一个陌生人的家，从小他就不断遭到指责。而现在，每天晚上关上门窗，除了自己家里的声音，他听不见任何喧嚣；他自由自在地穿梭在自己的房间和庭院之间。”</p>
<p>就这样，毕司沃斯先生终于有了自己的房子，只是背下了繁重的贷款。为了偿还贷款，毕司沃斯先生不得不超负荷加班加点工作，终因心脏病突发而猝死在这座还没付完贷款的房子里。小说以毕司沃斯先生的葬礼结尾，之后，“莎玛和孩子们回到空空的房子里”。</p>
<p><strong>毕司沃斯先生的故事是一个移民者追求尊严与身份的悲喜剧？</strong></p>
<p>就像书中写的，当他们搬到新房子里时，妻子莎玛离开她的母亲和姐妹们，对毕司沃斯先生和孩子萌生了一种新的忠诚，这简直是和拥有自己的房子一样是天大的胜利。锡金街的住宅，让他真正属于自己的空间，但是很不幸，他并没有时间享受这种自由和安定的喜悦，就英年早逝了。</p>
<p>但是，与其他文学作品中的边缘人不同的是，在卑微和漂泊的命运中，毕司沃斯先生始终怀有一个坚定的梦想：拥有独立的房屋，建构自己的身份和尊严。这种信念和追求伴随着他的整个一生。毕司沃斯的人生史，就是他为了拥有自己的房子的奋斗史。</p>
<p><strong>为什么说小说展现出奈保尔对于印度社群归属的担忧？</strong></p>
<p>小说中，图尔斯家族从特立尼达搬到西班牙港，已经展现出印度移民群体性的衰落。在特立尼达，印度移民社会是分裂的，按宗教、民族、种姓划分的各移民集团之间缺乏认同，同当地的其他民族更是很难归化。这种现象在印度移民人数占多数比重的地方，如特立尼达，特别突出。20世纪上半叶，特立尼阿达印度移民在异国他乡的奋斗，是充满着困惑和无奈的。西印度群岛契约劳工及其后代，毕司沃斯的奋斗和遭遇，他们希望建造一所属于自己的、自由支配的、有主人翁感觉的房子的追求，正是这一艰难旅程的侧影。作为毕司沃斯对立面的图尔斯家族，其实与毕司沃斯先生同样面临着身份归属的危机。哈努曼大宅的名称，正是来源于《罗摩衍那》中令印度人民无限尊崇的英雄。</p>
<p><strong>奈保尔如何分析印度社会衰落的原因？</strong></p>
<p>首先，奈保尔将批判的笔触指向殖民者。奈保尔本人出身于印度婆罗门贵族，但却生活在落后、闭塞的殖民地特立尼达；而在印度，他又被认为是特立尼达人，无法找到自己的民族之根；在英国伦敦，他是遭受歧视、艰难求生的印度人。在这三地不同历史文化的撕扯当中，奈保尔也陷入寻求身份的长久的苦闷和艰难之中。而这一切，都是建立于殖民历史背景之中。特立尼达和印度都曾经是英国的殖民地，当殖民地在上世纪获得独立身份，却仍然摆脱不了殖民国家对他们的评判，摆脱不了作为第三世界国家被裁判和审视的地位，更摆脱不了文明延续被摧毁的残酷现状。</p>
<p>奈保尔不仅批判殖民主义，对于第三世界国家，奈保尔展开的批判更加毫不留情。在被奈保尔称为“半吊子社会”的国家中，比如特立尼达，印度移民常常会谈论要不要回到印度家乡，但是谁也没有真正动身，大家都懒于改变现状，懒于去开创和行动。他在《印度三部曲》中写道，印度是个早已被挫败的国家，这个国家唯一的希望在于更迅速的衰败。对于特立尼达，他同样认为，这是个价值观彻底错乱、人人活得卑微的小地方。</p>
<p>从某种意义上来说，奈保尔虽然被归为后殖民作家，但是他并没有因外界对于一个殖民地作家的期待而改变自己的立场。他的批判锋芒不仅仅针对殖民主义，甚至更强烈地落在殖民地人民的身上。在他的早期作品中，奈保尔书写了特立尼达的混乱、丑陋，后来他在其《印度三部曲》中大谈印度的贫穷、喧嚣和盲目，在批判的同时，奈保尔亦不乏深度的探索和思考，他说，20世纪后期的印度，其独立的含义远不止是英国人的离开，更需要印度政府和人民做到真正的独立。</p>
<p>作为双重的文化移民，奈保尔既不属于殖民地印度、特立尼达，也不属于宗主国英国，他在这个印度-特立尼达-英国的文化三角中的身份寻求，正应了德国哲学家阿多诺的话，即，对于一个没有故乡的人来说，写作成为居住之地。</p>
<p>在2001年的诺贝尔文学奖颁奖仪式上，瑞典文学院曾这样评价奈保尔说：“他将极具洞察力的叙述与不为世俗左右的探索融为一体，让我们从被扭曲的历史中探寻真相。”其实从某种意义上来说，阅读奈保尔，不仅是走进殖民地人民的思想和感情世界，也是对现代人的文化困境的审视。毕司沃斯先生的家园寻求，也正是奈保尔自己的身份追问，对于他们来说，移民的遭遇让他们更迫切地想抓住一砖一瓦，以安放自己、保护自己、证明自己。</p>
<p>这也是我们每个人都会面临的生存困境。即使我们不是被殖民者，但是移民、无家可归的境遇依然困扰着我们。我们依然在寻求认同和尊严的漫漫长路上跋涉前行，我们依然不惜押上自己的一切，去获得这种空间占有和身份证明的笃定感。毋庸置疑，人类始终在经历人生的某种一致性：殖民地人民并不是来自另一个世界的异类，他们的痛苦离我们并不遥远；而像奈保尔这样的后殖民作家，与和平世界的我们一样，在背井离乡、在陌生城市打拼，在不被接受、无法得到认同时，这种生命和尊严的寻求，将是人们面临的永恒的身份追问。</p>
<p>作者：（英）V.S.奈保尔</p>
<h1 id="009科普丨《救命饮食》：为你揭示饮食和疾病的真相"><a class="header-anchor" href="#009科普丨《救命饮食》：为你揭示饮食和疾病的真相">¶</a>009科普丨《救命饮食》：为你揭示饮食和疾病的真相</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=247358998&type=red" frameborder="0" allowfullscreen></iframe>
<p>精华笔记</p>
<p>本书的作者柯林·坎贝尔是康奈尔大学的终身教授。从业40余年来一直从事营养和慢性病关系的研究。</p>
<p>20世纪80年代初，在坎贝尔的推动下，其所在的美国康奈尔大学联合英国牛津大学、中国疾病预防与控制中心，以及中国医学科学院等多家权威机构，在中国开展了三次关于膳食、生活方式和疾病死亡率的流行病学研究，也就是本书副标题中说到的中国健康调查。这项中国研究被誉为流行病学的巅峰之作。</p>
<p>在本书中，作者整合了这项中国研究中的一些重要的发现，对饮食和慢性病的关系提出了独到的见解。在此基础上，他还给出了一套理想的膳食方案，能让你保持健康，远离疾病。</p>
<p>我将分两部分内容为你解读本书：</p>
<p><strong>第一、 什么是救命饮食？</strong></p>
<p>结论是：如果你平常吃肉蛋奶等动物性食品较多，就比较容易得癌症等慢性病；而如果你吃的天然素食较多，就能预防或者延缓疾病的发生。因此，所谓能救命的饮食，简单来说，就是要少吃荤，多吃素。</p>
<p>这个结论是怎么得到的呢？</p>
<p><strong>1</strong>**、一个重要的动物实验**</p>
<p>坎贝尔和同事在动物实验中发现，对于接触黄曲霉毒素的大鼠来说，蛋白质含量为20%的高蛋白饮食会促进肝癌的发展，而5%的低蛋白饮食对于肝癌有很好的抵抗作用。这里的蛋白质是牛奶蛋白质的主要成分，酪蛋白。</p>
<p>但来自植物的大豆蛋白和小麦蛋白，即便都达到了20%的高剂量，也不会产生促癌的效果。</p>
<p><strong>这让坎贝尔意识到，通常被认为优质的动物蛋白质，比如牛奶，可能会带来潜在的疾病风险，而来源于植物的营养成分可能更加健康。</strong></p>
<p>不过，动物实验的结论不能直接照搬到人类身上。想要获得饮食和疾病关系更直接的证据，还需要依靠流行病学研究。中国健康调查就是一项大型流行病学研究。</p>
<p><strong>2</strong>**、中国健康调查**</p>
<p>这项研究发现饮食和疾病之间存在着三个统计学上的显著相关：</p>
<p><strong>第一个相关性是，动物性食物吃得越多，癌症发病率就越高；植物性食物吃得多呢，癌症发病率就低。</strong></p>
<p>研究人员发现，血液中的胆固醇高，多种癌症的发病率就高，反之，癌症发病率就低。而血液中的胆固醇只来源于动物性食物。</p>
<p><strong>第二个相关性是，动物性食品吃得多，乳腺癌发病率就高；吃得少，就不怎么容易得乳腺癌。</strong></p>
<p>研究人员发现，如果饮食中脂肪的含量大幅下降，乳腺癌的发病率就会显著降低。而当时中国农村，饮食中的脂肪都来自于动物食品。</p>
<p><strong>第三个相关性是，植物性食物吃得越多，消化道癌症的发病率就越低；吃得少，就比较容易得病。</strong></p>
<p>吃进的膳食纤维多，多种消化道癌症发病率就低。膳食纤维都来自于植物性食物。体内维生素C和胡萝卜素含量越高，癌症越不容易发生。它们同样是植物来源的营养素。</p>
<p>不过，在科学领域，这些显著相关仍不能直接说明饮食和疾病的因果关系。因此坎贝尔又分析了大量权威的科学研究结论。这些结论更有针对性地指出，饮食方式会对疾病带来关键性的影响。</p>
<p><strong>3</strong>**、其他针对特定疾病的研究**</p>
<p>**心脏病：**全素食饮食介入可缓解疾病</p>
<p>**糖尿病：**全素食饮食介入可缓解疾病</p>
<p>**前列腺癌：**肉类、奶类摄入过多会增加一种叫做胰岛素样生长因子的荷尔蒙，它会促进前列腺癌的病发和转移</p>
<p>**痴呆症：**饱和脂肪摄入增加，患血管性痴呆症的风险增加。饱和脂肪主要来自于动物食品。</p>
<p>第二、 <strong>作者的研究和观点对人们有哪些启发呢？</strong></p>
<p><strong>第一个启示，基因对疾病并不起决定作用，饮食对疾病也会有比较大的影响。</strong></p>
<p>对于很多疾病，比如癌症、心脏病、糖尿病和阿尔茨海默病等来说，基因只提供了子弹，但是扣下扳机的还有很多其他可控的因素，比如起关键作用的饮食。</p>
<p><strong>第二个启示，是要重视天然素食在饮食中的作用。</strong></p>
<p><strong>一是要吃真正的纯天然素食。</strong></p>
<p>纯天然素食，指的是粗加工的谷类、豆类、新鲜果蔬等，精制加工后的食物不包括在内。因为它们在加工时失去了天然素食最宝贵的部分。</p>
<p>除了天然素食以外，还要尽可能多样化。素食在脂肪和蛋白质的含量上稍有欠缺，因此需要多样化的种类，来保证营养和能量需求。</p>
<p>不推荐用植物营养补充剂来代替天然素食。单个营养补充剂无法达到食物营养的综合效果，还有可能会给人体带来危害。</p>
<p>除了吃天然素食，吃的方面**，坎贝尔建议不要走极端。**</p>
<p><strong>一种极端是严格全素食。</strong></p>
<p>首先，全素食并不像想象的那么容易。全素食要付出很多努力，一不小心就可能会营养不良。</p>
<p>其次，对于大多数中国人来说，全素食也没有必要。因为中国人的动物性食品摄入量相对偏低，而且，对于儿童和青少年来说，动物性食品促进生长发育的效率也更高。</p>
<p>因此，没必要做到100%严格素食。</p>
<p><strong>另一种极端是，将素食等同于药物。</strong></p>
<p>天然素食能够预防甚至扭转疾病的进程，但是这并不是说一旦确诊了疾病，就可以不用吃药就医，而靠吃素来治疗。这是因为营养的作用机制比较缓慢温和，而且素食治疗疾病的证据也还不够明确和充分。</p>
<p>综上，坎贝尔推荐的健康饮食模式就是：在你现有的饮食中增加多样化天然素食，同时减少一部分的动物性食品就可以了。</p>
<p><strong>第三个启示是，除了饮食和营养，也不要忽视其他健康因素。</strong></p>
<p>健康是一个系统工程，营养只是其中的一个方面。比如运动和情绪，都在其中充当了很重要的角色。这些因素共同作用才能有综合的健康效果。同时，这些因素之间也会互相影响，健康就要尽可能地去保持生活各方面的平衡。</p>
<p>作者：[美]柯林·坎贝尔 托马斯·坎贝尔</p>
<h1 id="010成长丨《态度》：吴军教你把简单的事情做得出人意料地精彩"><a class="header-anchor" href="#010成长丨《态度》：吴军教你把简单的事情做得出人意料地精彩">¶</a>010成长丨《态度》：吴军教你把简单的事情做得出人意料地精彩</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=246838961&type=red" frameborder="0" allowfullscreen></iframe>
<p>听书笔记</p>
<p>本书作者吴军，本科和硕士毕业于清华大学，博士毕业于美国约翰·霍普金斯大学，是知名的人工智能、语音识别和互联网搜索专家。他先后在谷歌、腾讯任职，还创立了自己的投资公司。同时他还是一名作家，著有《浪潮之巅》《智能时代》《文明之光》等多部畅销书。</p>
<p>在吴军的人生经历中，他发现一些起点差不多的人会不断分化，进而拉开人生的差距，而其中起到决定性作用的就是一个人为人处世的态度。因此，吴军想要将“态度决定命运”这个道理告诉他的两个女儿。</p>
<p>下面我将吴军的40封家书总结为以下五个态度</p>
<p><strong>第一个态度——做人的态度。</strong></p>
<p>关于做人的态度，吴军给出了三个建议，就是要乐观，要做个好人，还要学会抵制诱惑。</p>
<p>我们先来讲乐观的做人态度。吴军认为，一个乐观的人生态度比什么都重要。一个人积极乐观，他就不容易被怨恨、嫉妒这些不良情绪影响，会更达观地看待身边的人事物，也更容易获得快乐和幸福。</p>
<p>吴军认为做人的<strong>第二个态度是要做一个好人</strong>。一个人的品行比能力更加重要。那怎样才算是一个好人呢？吴军认为有三条标准：有教养、对他人友善、对世界有爱心。</p>
<p>吴军教给年轻人做人的第<strong>三个态度是要抵制诱惑。</strong></p>
<p>人在成长的过程中经常会面临很多诱惑。那如何才能抵制诱惑呢？可以从两方面着手：</p>
<p>首先，要有一个长远的目标，并积极地为实现目标而努力。</p>
<p>其次，是多做一些有成就感、有回报的事情。就是那些能够真正提升你的能力，让你变得更加强大的事情。</p>
<p>第二个态度**——**学习的态度。吴军自己就是一个学霸，关于学习的态度，他有很多经验可以传授给年轻人，总结起来主要是四个方面：</p>
<p>首先是要脚踏实地。在学习所有学科时，按部就班的笨办法才是好办法。这样才能打好学习的基础。而那些一味想着走捷径的人，在学习过程中反而容易有遗漏和缺失。</p>
<p>第二个学习态度，是要注重培养自己的逻辑思维能力。比如，学好数学，或者是多阅读经典的非虚构类名著。</p>
<p>学习中要注意的第三个态度是要有独立思考能力。吴军的建议是做一个理性的怀疑者，并学会证伪。 除此之外，要想做一个理性的怀疑者，即使是面对科学也要持怀疑的态度。</p>
<p>学习的第四个态度，是要努力开拓眼界。就是不要把目光局限在自己所学的专业上。</p>
<p><strong>第三个态度——做事的态度。</strong></p>
<p>当我们决定要不要做一件事情时，最关键的就是要记住八个字：<strong>“<strong>格局要大，境界要高</strong>”</strong>。</p>
<p>格局要大，就是在决定要做什么，不做什么时，不要只想着如何为自己创造利益，而要想着用自己的能力为更多的人创造利益。</p>
<p>境界要高呢，就是看事情要看得长远，不要只考虑眼前的一点蝇头小利。人一旦习惯获得短期利益，那境界就高不起来了。</p>
<p>另外，做事前不要过分计算成功的概率，自己想做的事情就去做，也不要一味追求做到最好，而裹足不前。最好的方法是先开始做，然后再逐步优化。</p>
<p>想好了要开始做，但是在做的过程中还会面临很多困难。吴军认为要把事情做好还要有三个态度：</p>
<p>第一，要设定好优先级。现实生活中，往往是旧的工作还没有完成，新的任务就来了。这时候找到优先级就很关键了。</p>
<p>第二，要主动做事。主动做事不仅仅是指你不拖延，积极地完成手中的工作，它还有更深层次的意义，就是要求你去主动沟通、主动优化。</p>
<p>第三，要努力将事情做到极致。人们常说失败是成功之母，但吴军认为成功才是成功之母。正是因为人们有了成功的经验，才会更加有信心。所以我们在做事情的时候，要全力以赴，将事情做到极致。</p>
<p>当一件事情做完以后，我们还要学会正确地看待挫折和运气。</p>
<p>很多人在遭遇挫折之后将失败归结于运气太差，命运不济，然后就一蹶不振，选择逃避。吴军认为，世界上当然有运气这回事，像那些买彩票中大奖的人，他们的好运气自然不必说。但更多的运气背后藏着人们付出的努力。</p>
<p><strong>第四个态度——人际交往的态度。</strong></p>
<p>第一点，不要怕吃亏。吴军认为，与人交往最重要的是真诚，不要怕吃亏，毕竟人无完人，不要一味地苛求他人。</p>
<p>第二点，学会识人。生活中我们应该怎样识人呢？</p>
<p>第一，要看一个人和你交往的动机如何。</p>
<p>第二，想防范小人，首先你自己就要戒除贪欲。</p>
<p>第三，还要观察这个人的生活圈子。</p>
<p>第三点，学会拒绝他人。人际交往是一个复杂的事情，当别人请你帮忙时，对方和你的关系，以及请求事情的难易程度，都会让你有不同的考量。但最重要的是要有一个真诚的态度，不要夸大自己的能力，也不要违背自己的本心。</p>
<p>**第五个态度——对待钱的态度。**吴军对待钱的态度可以总结为两句话：第一，不要乱花钱，也不要乱省钱；第二，让钱生钱，还要让钱发挥更大的作用。</p>
<p>年轻人一定要坚持先赚钱再花钱，这个顺序绝对不能颠倒过来。吴军还希望年轻人能够从大处着眼，从自身的需求出发，该花的钱大胆花。</p>
<p>有了钱以后，要学会用钱生钱，也就是要学会投资。吴军认为各种投资方法，年轻人都可以去尝试。但是一定要注意不要过于冒险，也不要去盲目进行自己不懂的投资。</p>
<p>吴军还建议年轻人可以拿三分之一的钱去投资指数基金，这个方法也是巴菲特给普通投资者的建议。</p>
<p>最后，当你真的有一天赚到了大钱，实现了财务自由，要学会让钱发挥更大的作用。吴军认为人不能过于守财。他希望年轻人在有钱以后能够回馈社会，利用财富做一点其他人没有做或者做不到的事。</p>
<p>作者：吴军</p>
<h1 id="011成长-《影响力大师》：影响力培训经典教材，6大策略360度影响他人和组织"><a class="header-anchor" href="#011成长-《影响力大师》：影响力培训经典教材，6大策略360度影响他人和组织">¶</a>011成长 《影响力大师》：影响力培训经典教材，6大策略360度影响他人和组织</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=246083687&type=red" frameborder="0" allowfullscreen></iframe>
<p><strong>听书笔记</strong></p>
<p>本书的作者约瑟夫•格雷尼采访了很多影响力大师，发现大师们的做法其实是有共通之处，他从中总结出了一套通用的方法。今天，我将分两个部分为你解读这套方法。</p>
<p>先说**第一部分，**影响力的目标。</p>
<p>所谓影响力，就是让人做出改变的能力。而要让人改变，你首先要知道，你希望他达成什么样的结果，创造什么样的价值。也就是说，你的影响力<strong>目标</strong>是什么？你要在自己的头脑中把这一点想清楚。不仅要自己想清楚，你还需要能把它传达给你的影响对象，也就是当事人。只有当事人完全领会和认可你的意图，他才能更好地参与起来。所以，你的目标必须制定得足够清晰，让人一听就懂。</p>
<p>仅仅制定有了一个目标还不够。你还需要分析，达成目标所需要的<strong>关键行为</strong>是什么。所谓关键行为，就是一两个最需要改变的地方，一旦改变了，目标就能实现。为什么要强调“关键”两个字呢？因为一旦人们发现需要改变的地方太多，他们会感到巨大的压力，导致他们要么一直拖着不做，延误了时机，要么浅尝辄止，就此放弃。</p>
<p>那怎么去发现关键行为呢？有两个技巧。<strong>第一个技巧是关注那些重要的小事</strong>。这类小事，往往是大家都知道它重要、应该做，但由于它太小、太不起眼了，所以根本没有得到真正的落实。</p>
<p>**第二个技巧是找出频繁犯错的时刻。**接下来的问题是，你需要找到合适的策略，引导人们在关键行为上做出改变。人们会不会做出改变，要看两个要素。一个是动力，他是不是愿意改变。另一个是能力，如果他愿意改变，是不是能做到。这两个要素缺一不可。所以，影响力策略的目的，就是要让他同时具备这两个要素。</p>
<p>**第二部分，**从六个角度来设计影响力策略。</p>
<p>先说第一个角度**，个人动力。**</p>
<p>当事人内心当中有抵触，不想改变，怎么办呢？这种情况其实是很常见的，改变往往会让人付出一些代价。所以，你要引导当事人看待问题的角度。如果他现在琢磨的是眼下付出了什么，你可以引导他关注未来能得到什么。如果他理性上觉得不划算，那就从情感上触动他，让他感到哪怕有点损失也是值得的。</p>
<p>第二个角度是<strong>社会动力。</strong></p>
<p>人是高度社会性的动物，其他人的看法也极大地影响他做事情的动力。比如说，你想在公司干点事，老板是不是认可你的点子，他是不是舍得花时间、花钱，是不是投入了大量的关注。其他人都会看在眼里，进而决定是否支持。这很好理解。</p>
<p>因为老板在这个群体拥有最大的权力，他属于群体中的正式领袖。除了正式领袖，还有一类人，他们可能没有什么头衔，但也会发挥领袖的作用。这类人我们称之为“意见领袖”。意见领袖和正式领袖一样，极大地影响着当事人的动力。</p>
<p>第三个角度是<strong>系统动力。</strong></p>
<p>简单说，系统动力就是奖惩机制。如果当事人发现，做出改变会受到奖励，不做就会受到惩罚，那么他改变的动力相对就更加充足。运用奖惩机制来增强当事人的动力，需要注意它只适合用来锦上添花。什么意思呢？就是说，你要优先从个人角度和社会角度来设计动力策略，奖惩机制放在最后，起到一个巩固的作用。</p>
<p>所以，千万不要过度依赖奖惩机制。正确的做法是，仅仅把奖惩机制作为一个有益的补充。</p>
<p>第四个角度是<strong>个人能力。</strong></p>
<p>如果当事人存在能力短板，改变对他来说难度太大，他自然不会行动。这时候你需要设计一些针对性的训练。当他经过训练补齐了能力短板，做出改变的可能性就大多了。</p>
<p>第五个角度是<strong>社会能力。</strong></p>
<p>也就是说，让其他人伸出援助之手，帮助当事人改变。影响力大师们不会指望当事人单纯靠自己的力量战胜困难。单打独斗经常是无法解决问题的。这时候，你就需要想办法，让当事人能够从其他人那里得到必要的帮助。</p>
<p>第六个角度是**，系统能力。**</p>
<p>所谓系统能力，指的是优化环境中的某些因素可以提升当事人的能力。这些因素中最重要的是信息、工具和空间。比如，军队去打仗，首先需要知道作战的指令，需要知道前进的方向，这就是信息。其次，士兵和敌人战斗，他需要有趁手的武器，有防护的盔甲，这就是工具。最后，整个队伍还需要保持严密的队形，什么兵种站在什么位置，那都是有讲究的。再有，和敌人对阵的时候，要争取占据有利的地势。这些就属于空间因素。所以，如果你发现当事人能力不足，你可以考虑从信息、工具和空间这几个方面进行优化。</p>
<p>作者：约瑟夫•格雷尼</p>
<h1 id><a class="header-anchor" href="#">¶</a></h1>
<h1 id="012心理-《只需倾听》：学会倾听，是你能和所有人沟通的秘密"><a class="header-anchor" href="#012心理-《只需倾听》：学会倾听，是你能和所有人沟通的秘密">¶</a>012心理 《只需倾听》：学会倾听，是你能和所有人沟通的秘密</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=245335835&type=red" frameborder="0" allowfullscreen></iframe>
<p><strong>精华笔记</strong></p>
<p>眼下，你急需与一个人沟通，可你完全不知道该拿他怎么办——</p>
<p>这个人可能是你青春期叛逆的孩子，他摆出与世隔绝的态度，屏蔽了你所有的话；这个人可能是你固执的老板，他把项目失败完全归因于你，根本不想听你解释；这个人还可能是你新开发的客户，他冷淡地回应着你的热情，压根不信任你。</p>
<p>你试过了一切办法，可是统统无效。你心如乱麻，充满了挫败感，心想：这可如何是好？</p>
<p>面对生活中这么多棘手的问题，到底有没有一套可以与所有人沟通的方法呢？</p>
<p>本书的作者马克·郭士敦把他30余年精神科医生的临床经验，与工作和生活中的沟通问题结合起来，总结出一种可以和任何人沟通的办法，就是——<strong>倾听</strong>。凭借这种独特的沟通方法，他成为美国警方和FBI的培训教员，服务过高盛、IBM、联邦快递、德意志银行等大型知名企业，还受邀担任《华尔街日报》、《财富》、路透社、美国国家公共电台、“奥普拉秀”的特约嘉宾等。他撰写本书，就是想为你揭开倾听的奥秘，并希望你能善用它。本书将从下面两部分来讲解：</p>
<p><strong>第一，  倾听为什么那么重要？</strong></p>
<p>脑科学认为，在特定的情绪下，人的大脑会对沟通产生“生理性防御”，而<strong>倾听是帮大脑卸下“生理性防御”最重要的手段。</strong></p>
<p>影响沟通的“大脑生理性防御”主要有两种。第一种是“杏仁核劫持”——就是大脑中掌管理智思考的额叶等高级脑区，被掌管本能反应的杏仁核遏制，让人在情绪激动时只能凭本能作出反应。而正确的倾听能帮人快速疏导情绪，让紧张的杏仁核放松，从而让大脑额叶等高级脑区从“杏仁核劫持”状态解脱，理智将重回大脑。</p>
<p>第二种大脑的“生理性防御”是“镜像神经元接收匮乏”。“镜像神经元”就是一种“当别人在经历某件事，会让自己感同身受”的神经元，而“镜像神经元接受匮乏”可以理解为人们认为“他人对自己缺乏同理心”。假如你试着去倾听这个人，就满足了他渴望别人对他有同理心的需求。唯有让他感受到你理解他，沟通才能继续。</p>
<p>除此之外，对于每个人来说，出于自我保护、保全面子或者一些别的原因，人们都有可能在心里筑起一道厚厚的大门，通常这道大门对所有人都是紧闭的。作者根据多年的经验总结出，<strong>倾听也是让人们主动打开心门的唯一办法</strong>。</p>
<p><strong>第二，我们应该如何倾听？</strong></p>
<p>首先，我们要调整好自己的情绪，摘下对他人有色眼镜、放下偏见，做好倾听前的准备。</p>
<p>其次，我们要培养自己的“同理心”，要学会站在别人的角度看待问题，在这里作者建议我们掌握倾听的三大原则——“让别人感到被理解”“让别人感到我们对他感兴趣”“让别人感到自己有价值”；</p>
<p>最后，我们还要学会倾听的四大技巧：第一是“替别人说‘不’”，第二是“主动示弱、自我揭短”，第三是要学会“在聊天的氛围里提问”，第四是要“善用简单的言语帮别人平复心情”。</p>
<p>作者：[美]马克·郭士敦</p>
<h1 id="013社科丨《恐惧》：深度剖析当今社会的恐惧文化，是什么让我们越来越没有安全感？"><a class="header-anchor" href="#013社科丨《恐惧》：深度剖析当今社会的恐惧文化，是什么让我们越来越没有安全感？">¶</a>013社科丨《恐惧》：深度剖析当今社会的恐惧文化，是什么让我们越来越没有安全感？</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=272086258&type=red" frameborder="0" allowfullscreen></iframe>
<p><strong>精华笔记</strong></p>
<p>恐惧是一种常见的情绪和心理。然而，历史上从来没有一个时候像今天这样，有这么多人、这么频繁地感到恐惧。</p>
<p>本书作者弗兰克·菲雷迪是英国社会学家，肯特大学社会学荣休教授，被《伦敦书评》评价为“英国、欧洲乃至世界上最为领先的知识分子之一”。他曾写过《恐惧文化》、《恐惧政治》、《知识分子都到那里去了？》、《偏执狂父母》等著作。</p>
<p><strong>一、恐惧文化的历史演变和它在当代的主要特点：</strong></p>
<p>恐惧首先是一种生理本能。然而人类还有一种从文化中传承而来的恐惧习性。</p>
<p><strong>传统的恐惧包括死亡恐惧和宗教恐惧。</strong></p>
<p>而今天，人类社会的恐惧和过去的恐惧有很大的差异，表现出新的特征——</p>
<ol>
<li>
<p>心理学和精神分析学的崛起，让恐惧从一种道德问题变成为医学问题；</p>
</li>
<li>
<p>恐惧变得普遍化。原先，人们的恐惧多半有关生死存亡这样的大事，而现在，人们在日常生活的细枝末节中，都能发现潜在的风险，并为此惶惶不可终日；</p>
</li>
<li>
<p>恐惧呈现出“个人化”的特征。原先，人们的恐惧往往是群体化的。而今天，人们的恐惧多半集中在对个人及家人的担忧中。</p>
</li>
</ol>
<p><strong>二、谁在为恐惧文化推波助澜？</strong></p>
<ol>
<li>
<p>媒体是传播恐惧信息的主力军。媒体通过连篇累牍的报道，描绘出一个危机丛生的世界，并通过恐惧修辞，唤起人们大难临头的感觉。</p>
</li>
<li>
<p>政客通过恐惧诉求操纵民意、鼓动选民。他们珍视所有可以表现焦虑或恐惧的机会，一有机会就进行恐惧表演，以此唤起选民心中的不安全感，为自己赢得选票。</p>
</li>
<li>
<p>科学家也沾染上了恐惧文化的习气。越来越多的科学家爱用耸人听闻的语气进行科普，将有关全球大灾难的预言劈头盖脸向大众砸去。</p>
</li>
</ol>
<p>媒体、政客和科学家不谋而合，用铺天盖地、耸人听闻的言论，让整个人类社会在恐惧文化中越陷越深。</p>
<p><strong>三、恐惧文化有什么样的害处，又该如何应对？</strong></p>
<p><strong>危害：</strong></p>
<ol>
<li>
<p>恐惧文化削弱了道德的力量。今天的人们只愿意对风险进行各种评估，却不愿意拿出勇气去做正确的事。</p>
</li>
<li>
<p>它影响年轻人的成长与成熟。今天的年轻人是脆弱而幼稚的“巨婴”，不愿承担公共责任，更不愿意去冒险。</p>
</li>
<li>
<p>恐惧文化让人们消极地看待未来。当代社会弥漫着一种悲观主义的未来观。对于未来的恐惧，甚至已经动摇到了人类对自己的信念。</p>
</li>
</ol>
<p>对此，我们绝不能听之任之。除了一味的恐惧和焦虑，<strong>人类其实还有其他的选择。</strong></p>
<p>比如，我们应该注重培养孩子们思想和行为的独立性，给他们更多试错和冒险的机会，让他们更有经验地去应对各种风险和挑战。</p>
<p>更重要的，是<strong>唤醒人们渐渐疏远的道德意识</strong>，尤其是勇敢和审慎这两种美德。</p>
<p>书      名：恐惧</p>
<p>作      者：[英]弗兰克·菲雷迪</p>
<h1 id="014纪实-《血疫》"><a class="header-anchor" href="#014纪实-《血疫》">¶</a>014纪实  《血疫》</h1>
<iframe height="233" width="260" src="https://www.ximalaya.com/thirdparty/player/album/player.html?id=29900175&type=red" frameborder="0" allowfullscreen></iframe>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=167648082&type=red" frameborder="0" allowfullscreen></iframe>
<p><strong>听书笔记</strong></p>
<p>《血疫：埃博拉的故事》一书的主角是来自非洲、致死率为流感4000倍的埃博拉病毒。它1970年代末最早出现在人类社会时，表现出了怎样残忍的属性？而面对它，因为无知，人类产生了莫大的恐惧，人们又是如何面对这种恐惧的？</p>
<p>作者<strong>理查德·普雷斯顿</strong>是唯一以非医师身份获得美国“防疫斗士奖”的人，这本书曾连续15个月登上《纽约时报》畅销书榜。</p>
<p><strong>第一，埃博拉有多恐怖？它从哪里来？</strong></p>
<p>作者详实记录一位名叫夏尔·莫内的人如何在非洲的埃尔贡山感染了病毒，而后一周内全身淤斑、面目呆滞、最终血崩而死的。</p>
<p>他感染的是“马尔堡病毒”。马尔堡病毒、苏丹埃博拉病毒、扎伊尔埃博拉病毒被叫做“埃博拉三姐妹”，她们是病毒中最致命的。它们生存在非洲热带雨林地区，1976年突然同时出现在人类社会。</p>
<p>作者认为这是因为近年来，人类活动不断侵蚀热带雨林，它们的出现是大自然的反扑。另一方面，人类的粗心和贪婪又助长了它们在文明社会的传播。</p>
<p><strong>第二，面对大自然“头号杀手”，人类如何抗争？</strong></p>
<p>在埃博拉刚刚爆发的1970年代末，有美国科研人员飞到非洲的疫情村庄，在关着病人的茅屋里采集血样，只是穿着纸质的外科手术服和鞋套，最终险些被传染。</p>
<p>在实验室里也同样存在危险。在美国陆军传染病研究所里，埃博拉属于最危险的等级，有研究者差点因为手套被刺破而感染，研究埃博拉的负责人也多年来都做着被感染的噩梦。</p>
<p>勇气之外，还需要运气。他们研究多年，可能都在原地打转、徒劳无功，无法确定埃博拉的传播途径、摸不清埃博拉的源头、更别提治疗了。</p>
<p><strong>第三，埃博拉不是非洲故事，它还曾出现在了美国首都附近，还去了两次。</strong></p>
<p>在华盛顿特区旁边一个叫做“雷斯顿”的地方有一处实验用的猴舍，1989年他们从菲律宾运来的一批猴子离奇死亡，被证明感染了埃博拉。</p>
<p>面对可能威胁全美的最大一场生物灾难，官方的应对显得混乱，他们出现了机构扯皮、向媒体隐瞒，最终派了一支兽医队伍去给埃博拉猴子安乐死。他们杀死了所有猴子，但不久之后来了同样一批病猴，他们选择让猴子自生自灭。</p>
<p>其实在这次危机中，人类之所以能逃生，原因在于埃博拉出现了新的特征。比如，选择不攻击人类。在两次病毒来袭后，都没有人员出现之前被感染致死的情况，哪怕是体内发现了病毒也没事。</p>
<p>但同时，此次埃博拉被证明可以通过空气传播。研究者恐惧的是，一旦埃博拉选择攻击人类、又可以通过空气传播，它对人类来说将堪比核威胁。</p>
<p>作者认为埃博拉一定会卷土重来。就在2014年人类确实爆发了更大规模的埃博拉疫情。同时在2016年研制出了第一种埃博拉疫苗。但这只是在黑暗中与猛兽斗争时捡起的第一个盾牌，离战胜它还很远。</p>
]]></content>
      <categories>
        <category>听书笔记</category>
      </categories>
      <tags>
        <tag>电子书</tag>
        <tag>喜马拉雅</tag>
        <tag>读书推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库【HOW2J】</title>
    <url>/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>仅针对应用在Java程序上的数据库资料。</p>
<a id="more"></a>
<h1 id="第一章-oracle"><a class="header-anchor" href="#第一章-oracle">¶</a>第一章 oracle</h1>
<h1 id="第二章-mysql"><a class="header-anchor" href="#第二章-mysql">¶</a>第二章 mysql</h1>
<h2 id="1、安装MYSQL-SERVER"><a class="header-anchor" href="#1、安装MYSQL-SERVER">¶</a>1、安装MYSQL-SERVER</h2>
<h3 id="步骤-1-关于MySQL"><a class="header-anchor" href="#步骤-1-关于MySQL">¶</a>步骤 1 : 关于MySQL</h3>
<p>MySQL是一款关系数据库。 <strong>My</strong>SQL里面的<strong>My</strong> 不是 <strong>我的</strong> 意思。是创始人Michael Widenius 的闺女 My Widenius。</p>
<h3 id="步骤-2-开始安装"><a class="header-anchor" href="#步骤-2-开始安装">¶</a>步骤 2 : 开始安装</h3>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/840.png" alt></p>
<h3 id="步骤-3-选择compelete，完整安装"><a class="header-anchor" href="#步骤-3-选择compelete，完整安装">¶</a>步骤 3 : 选择compelete，完整安装</h3>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/841.png" alt></p>
<h3 id="步骤-4-自动弹出配置界面"><a class="header-anchor" href="#步骤-4-自动弹出配置界面">¶</a>步骤 4 : 自动弹出配置界面</h3>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/842.png" alt></p>
<h3 id="步骤-5-选择标准配置"><a class="header-anchor" href="#步骤-5-选择标准配置">¶</a>步骤 5 : 选择标准配置</h3>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/843.png" alt></p>
<h3 id="步骤-6-设置root密码"><a class="header-anchor" href="#步骤-6-设置root密码">¶</a>步骤 6 : 设置root密码</h3>
<p>root是Mysql默认的管理员账号<br>
尽量密码设置为<strong>admin</strong>，后续和数据库相关的学习，都使用该密码</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/844.png" alt></p>
<h3 id="步骤-7-成功界面"><a class="header-anchor" href="#步骤-7-成功界面">¶</a>步骤 7 : 成功界面</h3>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/845.png" alt></p>
<h3 id="步骤-8-客户端"><a class="header-anchor" href="#步骤-8-客户端">¶</a>步骤 8 : 客户端</h3>
<p>在Mysql中执行sql语句一般都是用客户端进行的，接下来安装客户端 [Mysql-front]</p>
<h3 id="步骤-9-安装失败"><a class="header-anchor" href="#步骤-9-安装失败">¶</a>步骤 9 : 安装失败</h3>
<p>有时候会碰到如下的Apply Security Setting 失败的情况。 怎么办呢？ 就需要对mysql进行完全卸载，才能重新安装成功了。</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/5534.png" alt></p>
<h2 id="2、安装MYSQL-FRONT"><a class="header-anchor" href="#2、安装MYSQL-FRONT">¶</a>2、安装MYSQL-FRONT</h2>
<h3 id="步骤-1-不停的下一步就可以了。。。"><a class="header-anchor" href="#步骤-1-不停的下一步就可以了。。。">¶</a>步骤 1 : 不停的下一步就可以了。。。</h3>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/846.png" alt></p>
<h3 id="步骤-2-登陆"><a class="header-anchor" href="#步骤-2-登陆">¶</a>步骤 2 : 登陆</h3>
<p>名称： local<br>
host： 127.0.0.1 （表示本机）<br>
用户：root<br>
密码：admin<br>
数据库： test</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/847.png" alt></p>
<h3 id="步骤-3-注册码"><a class="header-anchor" href="#步骤-3-注册码">¶</a>步骤 3 : 注册码</h3>
<p>gNBpPFgyOw9Rwt/ozsnjgM7tJNo2<br>
bhaaAThangemMkaz2tQhq3/f7dZ7<br>
Vj29WeGHjuupj/AhYqymjAuokhYi<br>
X1T/fG+q1yR22PdcEP39dxU3ovEo<br>
lLLzwIZlQr9oJYwUf5eG4x5e1bMP<br>
nfIaIl8reszQPHFNbrxBjCVrBEXL<br>
TyBLehxzUpVI672t3LjX8q4ytCRC<br>
ezcoZQfMAc0DulJzNREbwlcf0Rco<br>
N0zW3ojBUxGsplBBZZPrD7/bPhkM<br>
rjtS8Bxym+HeV1TJDTXuiL8QLg==</p>
<h2 id="3、创建数据库"><a class="header-anchor" href="#3、创建数据库">¶</a>3、创建数据库</h2>
<h3 id="步骤-1-执行sql"><a class="header-anchor" href="#步骤-1-执行sql">¶</a>步骤 1 : 执行sql</h3>
<ol>
<li>
<p>选中SQL 编辑器</p>
</li>
<li>
<p>敲入sql语句：</p>
</li>
</ol>
<p>create database how2java</p>
<ol start="3">
<li>F9执行</li>
</ol>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/848.png" alt></p>
<h3 id="步骤-2-使用数据库how2java"><a class="header-anchor" href="#步骤-2-使用数据库how2java">¶</a>步骤 2 : 使用数据库how2java</h3>
<ol>
<li>
<p>重新登陆</p>
</li>
<li>
<p>属性</p>
</li>
<li>
<p>选择数据库</p>
</li>
<li>
<p>选择how2java</p>
</li>
</ol>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/854.png" alt></p>
<h2 id="4、创建表"><a class="header-anchor" href="#4、创建表">¶</a>4、创建表</h2>
<h3 id="步骤-1-创建表hero"><a class="header-anchor" href="#步骤-1-创建表hero">¶</a>步骤 1 : 创建表hero</h3>
<p>表名Hero<br>
有字段<br>
id<br>
name<br>
hp<br>
damage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE hero (</span><br><span class="line">  id int(11) AUTO_INCREMENT,</span><br><span class="line">  name varchar(30) ,</span><br><span class="line">  hp float ,</span><br><span class="line">  damage int(11) ,</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">)  DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>
<h2 id="5、插入数据"><a class="header-anchor" href="#5、插入数据">¶</a>5、插入数据</h2>
<h3 id="步骤-1-insert-into"><a class="header-anchor" href="#步骤-1-insert-into">¶</a>步骤 1 : insert into</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into hero values (null, &#39;盖伦&#39;, 616, 100)</span><br></pre></td></tr></table></figure>
<h2 id="6、查询数据"><a class="header-anchor" href="#6、查询数据">¶</a>6、查询数据</h2>
<h3 id="步骤-1-查询所有数据"><a class="header-anchor" href="#步骤-1-查询所有数据">¶</a>步骤 1 : 查询所有数据</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from hero</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-统计表中有多少条数据"><a class="header-anchor" href="#步骤-2-统计表中有多少条数据">¶</a>步骤 2 : 统计表中有多少条数据</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(*) from hero</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-分页查询"><a class="header-anchor" href="#步骤-3-分页查询">¶</a>步骤 3 : 分页查询</h3>
<p>显示前5条数据</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/876.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from hero limit 0,5</span><br></pre></td></tr></table></figure>
<h2 id="7、修改数据"><a class="header-anchor" href="#7、修改数据">¶</a>7、修改数据</h2>
<h3 id="步骤-1-修改"><a class="header-anchor" href="#步骤-1-修改">¶</a>步骤 1 : 修改</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update hero set hp &#x3D; 818 where id &#x3D; 1</span><br></pre></td></tr></table></figure>
<h2 id="8、删除数据"><a class="header-anchor" href="#8、删除数据">¶</a>8、删除数据</h2>
<h3 id="步骤-1-删除"><a class="header-anchor" href="#步骤-1-删除">¶</a>步骤 1 : 删除</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from hero where id &#x3D; 1</span><br></pre></td></tr></table></figure>
<h2 id="9、备份"><a class="header-anchor" href="#9、备份">¶</a>9、备份</h2>
<h3 id="步骤-1-使用客户端MySQL-FRONT-备份"><a class="header-anchor" href="#步骤-1-使用客户端MySQL-FRONT-备份">¶</a>步骤 1 : 使用客户端MySQL-FRONT 备份</h3>
<ol>
<li>
<p>右键点击数据库</p>
</li>
<li>
<p>输出菜单</p>
</li>
<li>
<p>SQL 文件</p>
</li>
</ol>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/2629.png" alt></p>
<h3 id="步骤-2-使用Mysql自带命令行-备份"><a class="header-anchor" href="#步骤-2-使用Mysql自带命令行-备份">¶</a>步骤 2 : 使用Mysql自带命令行 备份</h3>
<p>假定mysql安装在D:/software/MySQL Server 5.1/<br>
那么其bin目录下有一个mysqldump.exe文件<br>
账号是root<br>
密码是admin<br>
备份的数据库名是 test<br>
备份后的文件是 d:\test.sql</p>
<p><code>&quot;D:/software/MySQL Server 5.1/bin/mysqldump.exe&quot; -uroot   -padmin   -hlocalhost   -P3306   test -r d:\test.sql</code></p>
<h2 id="10、还原"><a class="header-anchor" href="#10、还原">¶</a>10、还原</h2>
<h3 id="步骤-1-使用客户端Mysql-front还原"><a class="header-anchor" href="#步骤-1-使用客户端Mysql-front还原">¶</a>步骤 1 : 使用客户端Mysql-front还原</h3>
<p>与备份类似的</p>
<ol>
<li>
<p>右键点击test数据库</p>
</li>
<li>
<p>输入</p>
</li>
<li>
<p>SQL文件</p>
</li>
<li>
<p>选中前一步备份生成的SQL文件</p>
</li>
</ol>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/2630.png" alt></p>
<h3 id="步骤-2-使用mysql自带命令"><a class="header-anchor" href="#步骤-2-使用mysql自带命令">¶</a>步骤 2 : 使用mysql自带命令</h3>
<p>假定mysql安装在D:/software/MySQL Server 5.1/<br>
那么其bin目录下有一个mysql.exe文件<br>
账号是root<br>
密码是admin<br>
还原的数据库名是 test<br>
还原的文件是 d:\test.sql</p>
<p><code>&quot;D:/software/MySQL Server 5.1/bin/mysql.exe&quot; -u root -padmin test &lt; d:/test.sql</code></p>
<h2 id="11、检查MYSQL-是否开启INNODB，以及如何开启"><a class="header-anchor" href="#11、检查MYSQL-是否开启INNODB，以及如何开启">¶</a>11、检查MYSQL 是否开启INNODB，以及如何开启</h2>
<h3 id="步骤-1-MYSQL-版本"><a class="header-anchor" href="#步骤-1-MYSQL-版本">¶</a>步骤 1 : MYSQL 版本</h3>
<p>本教材经实验可在5.1、5.5上使用，5.7默认是InnoDB的，所以无需额外开启</p>
<h3 id="步骤-2-检查是否innodb已开启"><a class="header-anchor" href="#步骤-2-检查是否innodb已开启">¶</a>步骤 2 : 检查是否innodb已开启</h3>
<p>执行命令</p>
<p>SHOW variables like ‘have_%’;</p>
<p>在结果中的have_innodb，如果显示为YES，即表示启动了。 如果是NO或者DISABLED表示未启动。<br>
如果不存在也表示未启动。</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/4061.png" alt></p>
<h3 id="步骤-3-停止mysql"><a class="header-anchor" href="#步骤-3-停止mysql">¶</a>步骤 3 : 停止mysql</h3>
<p>首先执行命令停止mysql</p>
<p>net stop mysql</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/4062.png" alt></p>
<h3 id="步骤-4-删除3个文件"><a class="header-anchor" href="#步骤-4-删除3个文件">¶</a>步骤 4 : 删除3个文件</h3>
<p>定位到D:\tools\MYSQL\mysql-5.1.57-win32\data 目录下，找到这3个文件<br>
ib_logfile0<br>
ib_logfile1<br>
ibdata1<br>
备份后，删除掉</p>
<p>注： D:\tools\MYSQL\mysql-5.1.57-win32 是我的安装目录，请自行调整</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/4064.png" alt></p>
<h3 id="步骤-5-在配置文件中增加一句"><a class="header-anchor" href="#步骤-5-在配置文件中增加一句">¶</a>步骤 5 : 在配置文件中增加一句</h3>
<p>打开文件：D:\tools\MYSQL\mysql-5.1.57-win32\my.ini</p>
<p>添加一行</p>
<p>default-storage-engine=InnoDB</p>
<p>也许已经存在</p>
<p>default-storage-engine=MyISAM</p>
<p>像下面这样，注释掉即可</p>
<p>#default-storage-engine=MyISAM</p>
<p>注： D:\tools\MYSQL\mysql-5.1.57-win32 是我的安装目录，请自行调整</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/4065.png" alt></p>
<h3 id="步骤-6-启动mysql"><a class="header-anchor" href="#步骤-6-启动mysql">¶</a>步骤 6 : 启动mysql</h3>
<p>执行命令 net start</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/4063.png" alt></p>
<h3 id="步骤-7-再检测"><a class="header-anchor" href="#步骤-7-再检测">¶</a>步骤 7 : 再检测</h3>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/4066.png" alt></p>
<p>这个方法有些版本查不出来InnoDB是否开启   执行下面的语句 SELECT SUPPORT FROM INFORMATION_SCHEMA.ENGINES WHERE ENGINE = ‘InnoDB’; 如果innodb被启用并且是默认数据库，那么会出现</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/1251.png" alt></p>
<p>如果innodb可用，但不是默认引擎，则结果将是yes。如果没有，结果显然是no</p>
<h2 id="12、修改ROOT密码"><a class="header-anchor" href="#12、修改ROOT密码">¶</a>12、修改ROOT密码</h2>
<h3 id="步骤-1-首先使用当前的密码进入mysql"><a class="header-anchor" href="#步骤-1-首先使用当前的密码进入mysql">¶</a>步骤 1 : 首先使用当前的密码进入mysql</h3>
<p>执行如下命令：<br>
“D:\tools\MYSQL\mysql-5.1.57-win32\bin\mysql.exe” -u root -padmin</p>
<p><strong>注：</strong> 我的mysql.exe文件位于D:\tools\MYSQL\mysql-5.1.57-win32\bin，请根据自己的情况，做相应的修改<br>
<strong>注：</strong> 我的密码是 <strong>admin</strong>, 请做相应调整。</p>
<p>登陆成功后，如图所示，出现mysql提示符。</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/4132.png" alt></p>
<h3 id="步骤-2-修改密码"><a class="header-anchor" href="#步骤-2-修改密码">¶</a>步骤 2 : 修改密码</h3>
<p>执行如下命令，即可把root密码修改为admin</p>
<p>set password for root@localhost = password(‘admin’);</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/4133.png" alt></p>
<h2 id="13、MYSQL-安装失败，提示APPLY-SECURITY-SETTINGS-的处理办法"><a class="header-anchor" href="#13、MYSQL-安装失败，提示APPLY-SECURITY-SETTINGS-的处理办法">¶</a>13、MYSQL 安装失败，提示APPLY SECURITY SETTINGS 的处理办法</h2>
<h3 id="步骤-1-mysql-卸载不干净"><a class="header-anchor" href="#步骤-1-mysql-卸载不干净">¶</a>步骤 1 : mysql 卸载不干净</h3>
<p>mysql 自带的卸载很多时候都卸载不干净，导致重新安装mysql的时候出现如图所示的问题。</p>
<p>接下来讲解如何手动完全卸载干净mysql</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/5533.png" alt></p>
<h3 id="步骤-2-mysql-卸载"><a class="header-anchor" href="#步骤-2-mysql-卸载">¶</a>步骤 2 : mysql 卸载</h3>
<p>运行[安装mysql-server] 右上角安装程序，点击Remove进行卸载。</p>
<p>如果当前Mysql在运行，会提示是否要关闭，点击YES</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/5524.png" alt></p>
<h3 id="步骤-3-删除mysql安装目录"><a class="header-anchor" href="#步骤-3-删除mysql安装目录">¶</a>步骤 3 : 删除mysql安装目录</h3>
<p>删除mysql目录</p>
<p>C:\Program Files\MySQL</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/5526.png" alt></p>
<h3 id="步骤-4-删除my-ini"><a class="header-anchor" href="#步骤-4-删除my-ini">¶</a>步骤 4 : 删除my.ini</h3>
<p>检查C:\WINDOWS目录下是否有my.ini文件,将其删除</p>
<p>这个文件不一定存在</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/5532.png" alt></p>
<h3 id="步骤-5-运行注册表"><a class="header-anchor" href="#步骤-5-运行注册表">¶</a>步骤 5 : 运行注册表</h3>
<p>win+r，弹出运行程序窗口，然后输入</p>
<p>regedit</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/5527.png" alt></p>
<h3 id="步骤-6-删除key1"><a class="header-anchor" href="#步骤-6-删除key1">¶</a>步骤 6 : 删除key1</h3>
<p>删除</p>
<p>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/5528.png" alt></p>
<h3 id="步骤-7-删除key2"><a class="header-anchor" href="#步骤-7-删除key2">¶</a>步骤 7 : 删除key2</h3>
<p>如下两个key不一定有，没有就不理了<br>
删除</p>
<p>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application \MySQL</p>
<p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/5529.png" alt></p>
<h3 id="步骤-8-删除ProgramData目录下的文件"><a class="header-anchor" href="#步骤-8-删除ProgramData目录下的文件">¶</a>步骤 8 : 删除ProgramData目录下的文件</h3>
<p>如果是win10, 则删除</p>
<p>C:\ProgramData\MySQL Server 5.5</p>
<p>这个目录默认是隐藏的，需要在文件夹选项中显示出来</p>
<p>如果是XP或者win7,对应的位置是：</p>
<p>C:\Documents and Settings\All Users\Application Data\MySQL</p>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%90HOW2J%E3%80%91/5530.png" alt></p>
<h3 id="步骤-9-重新安装"><a class="header-anchor" href="#步骤-9-重新安装">¶</a>步骤 9 : 重新安装</h3>
<p>运行[安装mysql-server]右上角安装程序，重新安装</p>
<h1 id="第三章-hsqldb"><a class="header-anchor" href="#第三章-hsqldb">¶</a>第三章 hsqldb</h1>
<h1 id="第四章-sqlite"><a class="header-anchor" href="#第四章-sqlite">¶</a>第四章 sqlite</h1>
]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>英语作文</title>
    <url>/2020/07/11/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>
<h1 id="一、对医护人员的感谢信"><a class="header-anchor" href="#一、对医护人员的感谢信">¶</a>一、对医护人员的感谢信</h1>
<p><strong>原题干:</strong></p>
<p>假如你是李华， 你所在的福州国际学校要征集一封英文感谢信，以致敬奋战在抗击新冠病毒第一线的医护人员。请你写一封感谢信参与投稿，内容包括：</p>
<ol>
<li>表达谢意；2. 个人感受；3. 表达信心</li>
</ol>
<p>注意： 次数100左右</p>
<hr>
<p>Dear all medical workers,</p>
<p>My name is Hua Li, a high school <strong>senior</strong> from Fuzhou. I would like to express my sincere gratitude to all <strong>frontline health care professionals</strong> who have been <strong>battling</strong> the COVID-19 <strong>epidemic</strong>. Our society is <strong>privileged</strong> to have <strong>guardian angels</strong>, such as yourselves. <strong>In spite of</strong> (despite) the lack of <strong>personal protective equipment</strong> and the risk of being infected, it was you whose <strong>endeavours</strong> were <strong>dedicated</strong> to preventing the <strong>dissemination</strong> of the <strong>novel</strong> coronavirus. As a member of the society, I feel <strong>obligated</strong> to practise <strong>social distancing</strong> and <strong>good personal hygiene, lest</strong> all your past efforts should be deemed wasted. After all, it is not what <strong>profession</strong> you are in; it is what you do that will <strong>protect the people you love.</strong></p>
<p>The disease may <strong>wax and wane</strong>, but this country has been more <strong>united</strong> than ever. With our <strong>joint efforts</strong>, I believe that nothing is <strong>unstoppable</strong>.</p>
<p><strong>Best regards,</strong></p>
<p>Hua Li</p>
<hr>
<h3 id="知识点总结"><a class="header-anchor" href="#知识点总结">¶</a>知识点总结</h3>
<ul>
<li>Senior: n. 毕业班学生 （high school senior = 高三/高四，college senior = 大四）</li>
<li>Frontline: n. 前线</li>
<li>Health care professional (HCP): 医疗专业人员</li>
<li>Battle: n/v. 战斗</li>
<li>Epidemic: n. 流行病</li>
<li>Privileged: adj. 荣幸的</li>
<li>Guardian angel: 守护天使</li>
<li>In spite of: 尽管 = despite</li>
<li>Personal protective equipment (PPE): 个人保护措施</li>
<li>Endeavour: n/v. 努力</li>
<li>Dedicate: v. 奉献给</li>
<li>Dissemination: n. 传播</li>
<li>Novel: adj. 全新的</li>
<li>Obligated: adj. 有义务的</li>
<li>Social distancing: 社交距离</li>
<li>Personal hygiene: 个人卫生</li>
<li>Lest: 以免 （详见卡蜜尔）</li>
<li>Profession: n. 行业，专业</li>
<li>Wax and wane: 反复无常 （详见龙王）</li>
<li>United: adj. 联合的</li>
<li>Joint effort: 共同努力</li>
<li>Unstoppable: adj. 无人能挡的</li>
<li>Best regards: (邮件结尾）最高的敬意，此致敬礼</li>
</ul>
]]></content>
      <categories>
        <category>英语作文</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>本格推理小说推荐大长篇！（作者：浩东黄）</title>
    <url>/2020/06/26/%E6%9C%AC%E6%A0%BC%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AF%B4%E6%8E%A8%E8%8D%90%E5%A4%A7%E9%95%BF%E7%AF%87%EF%BC%81%EF%BC%88%E4%BD%9C%E8%80%85%EF%BC%9A%E6%B5%A9%E4%B8%9C%E9%BB%84%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先解释下哈，这篇文章是转载自龙空@浩东黄 童鞋的同名帖子，介绍了大量国内外的优秀推理佳作。</p>
<p>看了这些文章你就知道，赤戟为啥总说龙空卧龙藏虎，大神辈出了~</p>
<p>篇幅很长，14514字，需要耐心，值得收藏~</p>
<a id="more"></a>
<p><strong>全电子书下载地址：<a href="https://wws.lanzous.com/b01bigkli" target="_blank" rel="noopener">https://wws.lanzous.com/b01bigkli</a></strong><br>
<strong>密码:8umg</strong></p>
<p>首先，定义一下所谓本格小说&lt;或者叫正统推理小说&gt;的概念。推理小说在西方从兴起到基本没落有一个比较漫长的发展过程，大致上经历了起源，高潮，低潮，没落这四个流程。在现在，欧美的所谓的推理小说基本上全部是社会冒险、硬汉派、心理悬疑等等类型。已经算不上，至少在我心里已经算不上真正的推理小说。</p>
<p>而本格小说这个概念，是日本推理文坛提出的一个名词。具体意思，自然就是指的传统的，正规的，以诡计为卖点，以线索做导向，让认真看书的读者可以在故事后半段根据书上的线索认真推理思考后，可以和作者公平竞赛的推理小说。</p>
<p>而在这个名称上，又出现了90年代初以岛田庄司为起源的“新本格”小说。新本格的话，和本格小说相比，公平性要稍微差一些。但是，在诡计方面，更加犀利，想象力十分奇诡，所以个人十分喜爱。话说，奎因开创的公平性极高的推理小说，实在是很难写。</p>
<p>而作为和本格小说相对应的推理小说，又有了“社会派”“变格派”“硬汉派”等等对应名称。因为个人对于这种类型的所谓推理小说十分蔑视完全无爱，也没看过几本这些类型的小说，就不深入解释了。</p>
<p>因为西方本格小说几乎已经死亡的原因，90年代以后，百分之九十的本格小说，都出自日本。所以呢，看到下面推荐的小说大部分来自日本，请不要生气。这不是笔者哈日，是除了古老的上世纪遗物外，大多数可以购买到而且有一定水准的本格小说，都来自日本。</p>
<p>然后，因为是推荐给大家看，一些太过出名而且比较古老的作者，比如黄金年代三巨头等推理小说开创者，就不推荐了，毕竟一般来说喜欢看本格的肯定都看过，就不说了。</p>
<p>最后，因为推理小说的特性，不能介绍的太过深入，所以大致都是抒情向的介绍，希望大家不要介意，推荐值为五星制。</p>
<p>好来，废话一大堆，下面就开始推荐了。</p>
<p><strong>岛田庄司。</strong></p>
<p>新本格小说的旗手，其多部小说诡计宏大，让初级读者几乎绕不过的一个名字。岛田本人，大概有两个水准不错的系列推理，一个是纯本格小说御手洗洁系列，一个是加入了一些社会派元素的吉敷竹史系列。下面，就先从御手洗系列开始介绍。</p>
<p>《占星术杀人魔法》推荐值：★★★★★</p>
<p><strong>地址1：<a href="https://pan.baidu.com/s/1com21" target="_blank" rel="noopener">https://pan.baidu.com/s/1com21</a></strong></p>
<p><strong>地址2：<a href="https://wws.lanzous.com/idmHhe23tha" target="_blank" rel="noopener">https://wws.lanzous.com/idmHhe23tha</a></strong></p>
<p>岛田的出道作品，史上最震撼人心的超强诡计，几乎没有人可以在结局前猜到诡计是什么。同样，书中的核心诡计不止一次被各种动画、小说、电影、电视剧所模仿抄袭，但是从未被超越。这本小说，几乎可以称的上是完美——除了其中凶手的动机值得商榷。</p>
<p>《异邦骑士》推荐值：★★★★</p>
<p><strong>地址1：<a href="https://pan.baidu.com/s/10CWpO" target="_blank" rel="noopener">https://pan.baidu.com/s/10CWpO</a></strong></p>
<p><strong>地址2：<a href="https://wws.lanzous.com/i21fxe23ykd" target="_blank" rel="noopener">https://wws.lanzous.com/i21fxe23ykd</a></strong></p>
<p>其实此书，才是岛田真正的处女作，但是因为各种原因，此书在岛田出道多年之后才真正出版。和占星术相比的话，诡计未免不够宏大惊人，但是也不可小视。常年高居岛田最受欢迎作品第二名，读后自然不会后悔。而且真正将书中侦探御手洗洁的性格塑造完全，而记录者石冈的悲催也很好的表达出来。</p>
<p>《斜屋犯罪》推荐值：★★★★</p>
<p><strong>地址1：<a href="https://pan.baidu.com/s/1pLCeK8F" target="_blank" rel="noopener">https://pan.baidu.com/s/1pLCeK8F</a></strong></p>
<p><strong>地址2：<a href="https://wws.lanzous.com/iMToze2467i" target="_blank" rel="noopener">https://wws.lanzous.com/iMToze2467i</a></strong></p>
<p>这本书，还是一样的岛田流，诡计同样的宏大。毛病也和岛田其他书一样，在杀人动机方面，让我有些囧。但是本格小说嘛，看的就是诡计是否震撼人心，其他的小细节，不用深究。那些社会派的异端，全部烧死好了。</p>
<p>《黑暗坡食人树》推荐值：★★★</p>
<p><strong>地址1：<a href="https://wws.lanzous.com/iHNMfe24bgh" target="_blank" rel="noopener">https://wws.lanzous.com/iHNMfe24bgh</a></strong></p>
<p>御手洗系列中的又一高峰，岛田天马行空一般的想象力在这一本小说中可以说是达到了顶峰。剧情让人紧张的喘不过气来，但是公平性难免让人质疑，所以只给一个三星评价。</p>
<p>《水晶金字塔》推荐值：★★★</p>
<p><strong>地址1：<a href="https://wws.lanzous.com/iPRK9e24bef" target="_blank" rel="noopener">https://wws.lanzous.com/iPRK9e24bef</a></strong></p>
<p>大家公认的，从这一本小说开始，岛田走上了絮叨啰嗦流。和网络小说很类似，变得越来越水了。诡计的可行性，也变得有些偏离现实，如果不是我这种岛田的死忠读者，应该是不会把这本书买回家吧。</p>
<p>推荐这么多，我发现其实推理小说真的很难写评论，特别是纯推荐的评论。剧透是无比可恶的，我最讨厌的人就是剧透的人。但是呢，只抒情的话又觉得有点无聊而且没什么说服力，所以就把御手洗洁其他我认为值得一读的推荐出来吧。</p>
<p>《御手洗洁的旋律》《御手洗洁的问候》《御手洗洁的舞蹈》这三本都是御手洗系列的短篇合集，诡计都是短小精悍型，类似福尔摩斯的感觉，诡计质量一般还算不错。同样，有些故事，并没有多大的悬念，主要是用来塑造御手洗与他的伙伴石岗的性格。如果爱上了这套系列小说，倒应该好好去读一读。</p>
<p><strong>地址1：<a href="https://wws.lanzous.com/b01bign1g" target="_blank" rel="noopener">https://wws.lanzous.com/b01bign1g</a></strong><br>
<strong>密码:63uh</strong></p>
<p>除了这三本短篇小说合集以外，御手洗系列还有《眩晕》《螺丝人》值得一读。当然，御手洗系列是十分庞大的。除了我推荐的这些以外，还有许多本。如果你读了我推荐的这些，还想继续看下去，那么可以自己去找找其他的来读一读。</p>
<p><strong>地址1：<a href="https://wws.lanzous.com/b01bign5a" target="_blank" rel="noopener">https://wws.lanzous.com/b01bign5a</a></strong><br>
<strong>密码:gxou</strong></p>
<p>推荐玩了御手洗系列，那么就来到了以刑警吉敷竹史为主角的吉敷竹史系列了。前面说过，这一套系列，因为岛田当年出道时被当年日本压倒性优势的社会派们排斥攻击，所以这一套御手洗之后的系列加入了一系列的社会派元素。</p>
<p>不仅如此，在这本书中，主角吉敷竹史和他那个离婚的老婆，貌似是叫什么加纳通子什么的前妻，感情让人着急。这一系列的缘故，让我不太喜欢这一系列的小说。虽然家里的书柜也有十几套这个系列的小说，但是留下印象的并不多，下面就推荐基本给大家。</p>
<p>《北方夕鹤2/3杀人事件》</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iDMaae24trg" target="_blank" rel="noopener">https://wws.lanzous.com/iDMaae24trg</a></strong></p>
<p>毋庸置疑，这本小说是吉敷竹史最高峰的杰作。很多读者甚至认为，从各个方面来说，这本书不会比占星术要差，甚至很多读者会认为，这本小说才是岛田最巅峰的作品。这个就是仁者见仁智者见智了，并不需要去争吵。不过，看了一定不会后悔就是了。</p>
<p>《奇想天动》</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iSKPHe24x6j" target="_blank" rel="noopener">https://wws.lanzous.com/iSKPHe24x6j</a></strong></p>
<p>这本书，诡计其实并不算多么的奇妙。但是在气氛渲染上，个人十分喜爱。就好像一流的厨师，可以用最普通的食材做出最最最精妙的大餐一样。写这本书的岛田，当时就处于这样一个犀利的状态中，所以值得好好品尝！</p>
<p>好吧。因为这个系列很多社会派元素，个人印象深刻的就这两本书了。其他的分子系列，和消失的水晶特快等等，还算可以一读，但是我就懒得推荐了，让我们进入下一个人吧！</p>
<p><strong>西泽保彦。</strong></p>
<p>西泽保彦（にしざわ やすひこ、1960年12月25日-），日本著名推理作家，SF（科幻）推理派的代表。喜欢喝啤酒，所以对于电脑使用比较畏惧，自称是「一指神功派」。</p>
<p>以上，是百度百科的介绍。让我来说的话，其实并不精准。不可否认，西泽是有一些或不错或坑爹的科幻推理。但是，真正让我爱上此人的，还是那一套匠千晓系列。下面，就让我来邦大家介绍一下这套推理小说吧。</p>
<p>《解体诸因》推荐值：★★★★★	五星&lt;喂喂喂，你们知道不知道，不会打符号的我，每次一到这环节就要去复制粘帖星星是多么的麻烦？&gt;</p>
<p><strong>地址：<a href="https://wws.lanzous.com/idY1ge24ync" target="_blank" rel="noopener">https://wws.lanzous.com/idY1ge24ync</a></strong></p>
<p>这本书，是我200X年左右读到的，第一次看真是让人有种三观崩溃的感觉——这本书是短篇合集&lt;最后一个故事勉强算中篇&gt;。每个故事里讲都是被害人因为各种各样的原因被分尸，然后开始推理的故事。</p>
<p>这本小说中，每一次的分尸，都是有原因有理由的——不管这个理由是多么的坑爹多么的无稽。不仅如此，因为作者本人的个性，就算是分尸这么恐怖的事情，在他笔下写出来，看了都会给人一种很搞笑的感觉。</p>
<p>不仅如此，在这本小说中，匠千晓系列的核心人物：匠千晓，高濑千帆，边见佑辅三人都完成了第一次的登场。所以非常推荐去看。</p>
<p>《她死去的那一晚》推荐值：★★★★	四星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iL6fee2528b" target="_blank" rel="noopener">https://wws.lanzous.com/iL6fee2528b</a></strong></p>
<p>按照时间轴来说，这算是第一本匠千晓系列小说。诡计不多说，虽然有点扯，但是看起来也是可以接受的。这里重点说说西泽这个作者的优点。作为阅读推理小说无数的我来说，西泽在我心中，是最最最会塑造人物性格的小说家。</p>
<p>大多数推理小说，作者只能塑造出一个人角色性格。而这个人，往往就是小说中的侦探了。再厉害一点的，勉强还可以把“华生”这个角色塑造好。但是能想西泽这样，把四个系列主角，加上每本书中出现的新人物都塑造好的，那就十分少见了。要我自己来说，除了西泽以外，那就只有一个人了。这个人，暂时不说，是我下一个要介绍的主角。</p>
<p>《啤酒之家的冒险》推荐值：★★★★	四星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iYSIFe257fi" target="_blank" rel="noopener">https://wws.lanzous.com/iYSIFe257fi</a></strong></p>
<p>这本书，是传统意义上的安乐椅推理小说。所谓安乐椅推理呢，就是几个人在一个密闭的房间里，根据一些不太靠谱线索，各种嘴炮，然后得到解答&lt;很多时候，解答靠不靠谱，作者也不保证。&gt;</p>
<p>当然，西泽这个人嘛，不是那么墨守陈规的。和正统意义上的安乐椅推理对比，这本小说还是有些区别的。不过这不是重点，大家不用在意。</p>
<p>最后，西泽这个人，也不知道是不是真的嗜酒如命。在他的作品中，几乎每个角色都十分爱酒。这本书，至少三十次的描写了大口和啤酒的感觉与过程。当年第一次在晚上看这本小说的时候，我也跟着主角们喝了七灌啤酒，感觉十分不错！</p>
<p>《羔羊们的平安夜》推荐值：★★★★	四星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iJBsRe259bg" target="_blank" rel="noopener">https://wws.lanzous.com/iJBsRe259bg</a></strong></p>
<p>因为爱所以爱，所以西泽的书除了特别坑爹的，我一般给四星。这一本仍然是千晓系列。故事的主题挺深刻的，让我不止一次的感慨了日本人的根性和变态性，反正也是值得一读。</p>
<p>顺便一说，西泽真的超级会塑造人物！高千是我的最爱啊！大家一定不能错过。</p>
<p>《苏格兰游戏》推荐值：你懂的！</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iUC0Je25e5a" target="_blank" rel="noopener">https://wws.lanzous.com/iUC0Je25e5a</a></strong></p>
<p>这本书，前半本书都在将女主角高千高中时遇到的一次连环杀人案。她的女朋友，也在这一次案件中被杀。是的，你没看错，这本书的女主角，高中时的恋人是女人。但是呢，高千这个人并不是传统意义上的同性恋。勉强来说，应该算是只要对的人，不论男女都可以吧。</p>
<p>这本书的诡计其实一般，但是塑造人物很成功，让高千成功的成为了我心中的女神。</p>
<p>这里着重说一下西泽小说的一个特点——一般来说，推理小说是很难让人重复观看的。因为知道了诡计和最终的结局，一般我就不愿意再把小说看一遍了。但是西泽的书不一样，因为人物塑造优秀，而且对话轻松诙谐的缘故，他的小说是少有的可以让我每本至少阅读两边的书！</p>
<p>《依存》推荐值：你真的不懂嘛？？！</p>
<p><strong>在线看：<a href="http://st.kanxshuo.com/book-94291-1.html" target="_blank" rel="noopener">http://st.kanxshuo.com/book-94291-1.html</a></strong></p>
<p>如果上一本是讲的高千的过去，这一般就是男主角匠千晓的救赎了。这本书呢，最后和反派大BOSS决斗时稍显无稽，但是也是好书！依存依存，两个人才能依存嘛！</p>
<p>系列小说读到这里，实际上西泽的诡计已经很少能震惊到我了，但是让我更加关注的是人物的命运了。这在推理小说中，是极其少见的！</p>
<p>《替罪羊》或者又叫《替身》推荐值：你还是不懂？？！</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iCcFGe26bxg" target="_blank" rel="noopener">https://wws.lanzous.com/iCcFGe26bxg</a></strong></p>
<p>还是一本优秀的系列小说，让我对日本人的扭曲又有了更深刻的了解，值得一读。</p>
<p>顺便一说，我读匠千晓系列很早了，那时候除了解体和啤酒之外，并没有实体书可以购买。其他基本，都是下的TXT观看，不知道现在如何了。</p>
<p>最后！如果有人有这个系列的黑色的贵妇和谜亭论处的TXT资源，请一定要发给我。</p>
<p>嗯，匠系列说完，那我就说说西泽的非系列小说。《神的逻辑，人的魔法》史上第一坑爹啊！这本书让我看完恨不得打死西泽，余味很糟。《死了七次的男人》挺有趣的SF推理小说，结局虽然不出意料之外，但是也是很有趣的阅读体验。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/b01bigs6b" target="_blank" rel="noopener">https://wws.lanzous.com/b01bigs6b</a></strong><br>
<strong>密码: byck</strong></p>
<p>《人格转移杀人》推荐值：三星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/ifbIye265bi" target="_blank" rel="noopener">https://wws.lanzous.com/ifbIye265bi</a></strong></p>
<p>其实个人觉得这本书更适合的名字是灵魂转移杀人。这本书真的超级纠结的，主要讲的是，几个人中了某种神秘的物质，然后灵魂就会在这几个人的身体中不断转移，要想回到正常，你就得保证自己的身体不被破坏，而且要把其他人都杀了。反正就是这样，爱看的可以去看看。</p>
<p>啊啊啊啊啊啊，打了这么多字一下子觉得好累好累啊。果然，我这种爱看系列推理的人，真的不适合写推荐帖。一推荐，就要推荐这么多，所以说，暂时休息一下吧，算是第一季推理结束了。</p>
<p><strong>京极夏彦</strong></p>
<p>原名：大江胜彦，日本小说家、妖怪研究家、艺术总监。</p>
<p>世界妖怪会议评议员（主办）、关东水木会员、东亚怪异学会会员。是日本独具特色的“妖怪型”推理作家。也是新本格派先锋人物，思维极其大胆灵活，作品的走向多变宽广，读者年龄层极广。</p>
<p>京极夏彦的兴趣和爱好非常广泛，其中最有名的是他的藏书，藏书量已经超过三万册，相当惊人。而广泛地涉猎各种知识，也是京极作品之所以包罗万象的原因之一。另外，京极也非常热爱收藏漫画。</p>
<p>从以上来自百度百科的介绍大家就可以看出来，这个人不是普通的本格作家。对于此人的小说，个人觉得如果用一种蔬菜或者瓜果来评价的话，一定是“苦瓜”或者“榴莲”。</p>
<p>这两样东西，爱吃的人会爱到无法自拔。讨厌的人，甚至看一眼都会心生厌恶。所以呢，我也不知道因为我的推荐能让几位龙友喜欢上他的小说，但是如果对眼缘的话，去仔细阅读此人的小说，绝对不是一场会后悔的阅读体验。</p>
<p>简单来说，京极的小说分成两个大系列，一个系列是“百鬼夜行系列”一个系列是“巷说百物语系列”。这两个系列，按照个人口味来说，百鬼系列无疑更加优秀，所以主推这个系列的所有书，希望能让更多的人走进这个系列。</p>
<p>《姑获鸟之夏》推荐值：五星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/ie3tCe268af" target="_blank" rel="noopener">https://wws.lanzous.com/ie3tCe268af</a></strong></p>
<p>相信大家一定有些诱惑，什么叫做妖怪推理？妖怪这种东西，明显是不符合唯物世界的，既然如此，怎么还能叫做是推理小说？其实这个，就是日本一种独特的妖怪文化了。个人并不是日本文化专家，只能大概的解释一下。</p>
<p>日本这个扭曲的国家，有种妖怪附身的文化。很多做了极其邪恶坏事的人，在这种文化中，都被京极称为被“妖怪”附身了。所以，京极小说的最终侦探角色，就是一位外号京极堂，真名中禅寺秋彦的祈祷师、神主、加旧书店店主三职合一的角色。</p>
<p>这本书的具体内容，我就不多说，先解释一下为什么我会把此人的书比喻成苦瓜或者榴莲。</p>
<p>和一般的推理小说不同，京极夏彦的小说，有一种极其独特的韵味。这个系列小说的大背景，实在日本二战结束后的50年代之间。也只有这样的年代，才能让妖怪附身这个概念变得真正符合逻辑。不仅如此，此作者的书，还有十足的炫学成分，如果没有爱上作者的文字，是很难一直看下去的。</p>
<p>说来惭愧，本人第一次买京极的书，也是在一个十分巧合的情况下。那一天在当当闲逛，一不小心看到了上海人民出版社出版的这一套书。当时，虽然不知道书好看不好看，但是已经完全被这套书极有韵味的书皮封面征服，一不小心就全部订购了。</p>
<p>得到这一套书之后，打开第一本姑获鸟之夏，仅仅看了十几页，我心中的卧槽就不断爆发——这是什么破书啊，完全乱七八糟不知所云。</p>
<p>直到十几天后的一个失眠的夜晚，无所事事的情况下，再一次翻开这本书，突然不知为什么，居然感觉非常好看，居然一发不可收拾的看到了凌晨4点，实在是很奇怪。</p>
<p>说实话吧，这本书的诡计呢，有那么一点点的坑爹，但是仔细阅读，确实会让人拥有很不错的余味。所以，只能是仁者见仁了。</p>
<p>《魍魉之匣》</p>
<p>推荐值：五星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iWimze26i1g" target="_blank" rel="noopener">https://wws.lanzous.com/iWimze26i1g</a></strong></p>
<p><strong>地址：<a href="https://wws.lanzous.com/imnOee26i0f" target="_blank" rel="noopener">https://wws.lanzous.com/imnOee26i0f</a></strong></p>
<p>上一次的推荐，大家应该记得，我说过，除了西泽保彦之外，个人只认为还有一个个推理作家能够在自己的作品塑造出许多鲜明的人物。这个人，显然就是这一回推荐的京极了。</p>
<p>史上最悲剧的男主角关口巽，野兽刑警木场修，傀儡娃娃一般精致而且拥有神奇能力的榎木津礼二郎，最后就是本书真正的侦探京极堂中禅寺秋彦。这四个人，大概算是书中戏份最多的四人了。除了这四人以外，每本书中新出现的角色。不论是四人组的朋友，还是案件中认识的可能是犯人的角色们，一个个都是那么的个性鲜明。</p>
<p>顺便，我再来吐个槽——这京极夏彦是有多爱用生僻汉字啊，别的不说，就说这四人组。当年我就不认识这个巽字和榎字啊啊啊啊啊啊！！！</p>
<p>额，请大家不要吐槽我的文盲！第一次你就认识这两个字的话，我只能说一句佩服佩服！</p>
<p>不仅如此，在这本书中，京极堂对于“超能力折”“占卜家”“宗教家”等等不同职业的真正内涵与不同点，有过一翻非常精彩的演讲，极为精彩，绝对不能错过！</p>
<p>而且，这一本书，许多京极的读者们，都认为是系列最高作。这一点，我倒是不敢苟同。不过呢，诡计和结构，确实达到一种完美的平衡，完全不像姑获鸟那么坑爹，所以绝对推荐去看！</p>
<p>《狂骨之梦》推荐值：五星.</p>
<p><strong>地址：<a href="https://wws.lanzous.com/im3Qhe26jpg" target="_blank" rel="noopener">https://wws.lanzous.com/im3Qhe26jpg</a></strong></p>
<p>相信大家一定感觉有些奇怪——这作者怎么每本书的名字都怪怪的啊？不是姑获鸟，就是魍魉，要不然就是这非主流气息弥漫的狂骨，到底是要哪样啊？？！</p>
<p>其实京极的作品都是这个模式的XXX之X。这个XXX，不论是姑获鸟还是魍魉狂骨还是接下来的铁鼠络新妇之类的东西，都是日本妖怪文化中的妖怪。不仅如此，包括姑获鸟啊，魍魉之类的妖怪，都是发源自我们中国的妖怪，最后传播到日本被他们写进了百鬼夜行图鉴中的。</p>
<p>而之之后的X，就点明了这一本书的主题。不论是夏，还是匣，或者是这本书的梦，都是很重要的点题，让人不能忽略！</p>
<p>狂骨这本书，是我个人最喜爱的一本小说。在书中，作者用他渊博到可怕的学识，塑造了一本梦境之术。在妖怪之下，又认真的讨论了弗洛伊德荣格等等心理学派。不仅如此，还深入的探讨了“童年创伤”与“记忆”之间的关系。</p>
<p>整本书读下来，看到结局的最后一个字，只能让我对作者写一个服字！</p>
<p>《铁鼠之槛》	推荐值：四星</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iogfIe26m3c" target="_blank" rel="noopener">https://wws.lanzous.com/iogfIe26m3c</a></strong></p>
<p>说来有趣，日本人这种奇特的生物，不论是做什么，都可以做的一本正经。唐朝传播过去的佛教，也是如此。</p>
<p>看书名大家就能知道，这本书主要讲的是佛教中的禅宗。说来惭愧，作为一个无宗教信仰的人，我是看了这本书以后才真正肤浅的懂得了一些禅宗的道理。如果没有记错的话，这本书，通篇就是在讲一个“悟”字。</p>
<p>为了顿悟为了大悟，书中的和尚们，一个个的实践着自己心中的道路。一个困住所有人的高槛结界，就这样的形成了。杀人事件，也就一件件的来了。</p>
<p>总之，这本书的气氛塑造极为优秀，对于禅宗的讲解，个人也是十分认可。当然，我不是宗教家，也判断不出作者说的到底是对是错。但是，仅仅把这本书当成一个优秀的故事来看，也是一种不错的体验！</p>
<p>《络新妇之理》推荐值：四星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iFzR4e26nxi" target="_blank" rel="noopener">https://wws.lanzous.com/iFzR4e26nxi</a></strong></p>
<p>所谓的络新妇，在妖怪文化中是站在蜘蛛网中的蜘蛛。“你，就是蜘蛛吗？”是这套书开篇第一句话。</p>
<p>这本书的中心，也就很容易理解了。一位心机深沉似海的凶手，利用他/她那超人的智慧，编织了一张可怕的巨网。很多时候，根本不需要亲自动手杀人，只要触碰几下那张看不见的网，杀人事件就这样出现了。</p>
<p>同时，这本书还说出了“测不准原理”，甚至让真主角京极堂都不确定自己能不能成功的“驱魔”，甚至最后放弃了“驱魔”。</p>
<p>那位极其可怕但又极有魅力的最终BOSS，也在我的心中留下了异常深刻的印象！所以，一定不能错过！</p>
<p>《涂佛之宴宴之支度》《涂佛之宴宴之始末》推荐值：三星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/b01bigsyj" target="_blank" rel="noopener">https://wws.lanzous.com/b01bigsyj</a></strong><br>
<strong>密码:523s</strong></p>
<p>这本书，是一个故事分成上下两册，所以放在一起介绍。也许是更新速度太快，也许是故事结构越来越宏大。就算是京极夏彦这种被日本媒体认为唯一有可能获得诺贝尔的推理作家，也在这本书中有些失控了，给人一种故事大而无当感觉。</p>
<p>确实，这一本书的整体评价，在整个系列之中也是最低的。这里不做太多讨论，反正我觉得吧，如果是看完了前面几本书的读者，就算知道评价不高，也不会放过这一本的。</p>
<p>这里，我主要来吐槽一下关口巽这位史上最悲催的男主角。</p>
<p>关口巽：穷B，非常悲催的小说家，抑郁症患者，个性懦弱，行动力极为底下，各种被另外三人吐槽鄙夷。只看这个介绍，大家就可以感觉到关口的悲催了。</p>
<p>但是作者仿佛没有一点写书代入主角的感觉，反而在这套书中更进一步——在书的一开头，就把关口做人杀人嫌疑犯被警察抓捕了，还受到了十分粗暴的审讯。</p>
<p>显然，我们曾经的抑郁症患者，在这样的心理冲击下，几乎走到了崩溃的边缘，直到下一本书，才慢慢开始恢复。</p>
<p>《阴摩罗鬼之瑕》推荐值：四星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/b01bigtri" target="_blank" rel="noopener">https://wws.lanzous.com/b01bigtri</a></strong><br>
<strong>密码:8dnx</strong></p>
<p>经过上本书的失败，这本书京极不再片面的追求宏大的背景，而是回到了他最擅长的领域。</p>
<p>这本书呢，中心是讨论“儒家”以及如何成为一个真正的儒者。而那最后的瑕字，更是画龙点睛一般的犀利！看完整个故事，我的心中简直阵阵颤栗，完全不知道应该说些什么才好，最后只能一声叹息。</p>
<p>不仅如此，这本书对于气氛的渲染，真是达到了一个让我望尘莫及的地步。具体我不多说，大家看了就知道了。对于我的评价，一定不会有任何的意见！</p>
<p>这本书不能多说，任何泄底的行为，都是对这一套书的亵渎！</p>
<p>最后，京极堂百鬼夜行系列还有邪魅之雫最后一本。但是这本书，貌似还没有出版简体中文版，网上我也没有找到资源，所以没有办法阅读。如果谁有这本书的TXT资源，请一定不要忘记发给我一套哦！</p>
<p>说了这么多，显然大家都看出来了，我是京极的粉丝。所以，他一个人的推书，才会写了这么这么多。</p>
<p>京极夏彦的书就推荐到这里，顺便说一下，除了我主推的百鬼夜行系列，他还有巷说百物语系列，也是水准相当高的系列。如果看完了百鬼夜行系列，那么一定要去看看。</p>
<p>第四季</p>
<p>哇哈哈，迟来的第三季终于要和大家见面了——之所以拖了这么久，主要是最近天气实在太热，工作又忙成狗，所以就没有兴致写这个帖子了。</p>
<p>话说，当年哥也是写过百万字网络小说拿过日更一万月全勤的男人，现在懒成这样实在是让我自己都看不下去。今天休息，所以就继续把这个帖子写下去吧。虽然，这个帖子一直遭到龙友们和版主的冷漠对待，但是我也是不会放弃的啊！！</p>
<p>鬼扯就到这里结束，正式的推荐之前，先说说我对本格小说评级的理由。一般来说，我对本格小说还是满宽容的，只要不是坑爹无极限，我就不会给太恐怖的差评。小说是否优秀方面，我有几个评判萌点。</p>
<p>一类，要不然就是占星术那样，有极为宏大超越前人的经典诡计。二类，诡计可以老套一点，但是创造良好，气氛渲染给力，我也不吝啬给出大大的好评。三类，就是逻辑性了。如果能够完全依靠书中所给线索进行逻辑推演，并且合理让我信服的作品，我也会十分欣赏。最后呢，就是能够创造让我喜欢的人物，那也是很棒的阅读体验。</p>
<p>今天懒得复制一个个作者的推荐环节，我决定在我电脑边的书柜随便看，在三百本左右的本格小说中随便寻觅，看运气咯~~</p>
<p>《首无·作祟之物》推荐值：五星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/ibwrIe26vmf" target="_blank" rel="noopener">https://wws.lanzous.com/ibwrIe26vmf</a></strong></p>
<p>此书作者三津田信三，是我个人很喜欢的作者之一。而很恰巧，这本首无也是我个人认为他一系列作品之中最好的那一本。</p>
<p>此作者这个系列，是以刀城言耶为主角的系列小说。然后呢，这本小说，诡计并不算多么宏大，也不是前人未有的新创造，但是极为经典。不但没有任何违和感，也和小说完全紧密的联系在了一起。我记得，书中一共有三十三个谜题&lt;貌似是吧，懒得重复翻书，所以不确定数字是否准确。&gt;。而这些谜题，只要能想到那唯一的诡计，就能一口气全部解决。</p>
<p>虽然难免有一点牵强或者不符合唯一解释的地方，但是也绝对是经典中的经典，千万不要错过！！</p>
<p>最后说一句，这个系列的小说，背景和京极堂系列有些类似，但是完全是两种文风的小说，绝对不会有看过那个系列不想看这个系列的感觉！</p>
<p>《恶意》推荐值：三星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iGKuxe26xaf" target="_blank" rel="noopener">https://wws.lanzous.com/iGKuxe26xaf</a></strong></p>
<p>难得啊，居然终于推荐到了一本东野圭吾的小说。实话是说，对于东野圭吾，个人基本上只喜欢他前期到中期的作品，这本恶意，大概算是前中期作品之一。</p>
<p>我也不太确定该怎么界定这本小说，说它是本格吧，好像有点不对。说是社会派吧，又好像有那么一点点对作者不公平。勉强来说，算是混合派小说吧。</p>
<p>这本书具体内容不浪费时间多说，想要看的，可以去百度一下，不要自己剧透自己就OK。说实话，剧透了其实也无所谓咯。反正我觉得，只有日本人那种纠结的性格，才能写出这么极端的小说吧。</p>
<p>不过呢，这本书倒是很适合初看这类悬疑小说的读者，因为很容易进入，不会太晦涩。</p>
<p>《活尸之死》推荐值：四星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/i9k9Qe26yzg" target="_blank" rel="noopener">https://wws.lanzous.com/i9k9Qe26yzg</a></strong></p>
<p>这本书的作者山口雅也，绝对是一个很有想法的奇才作者。作品虽然不多，但是都能给我一种耳目一新的感觉。</p>
<p>人死竟然“可以”复生？！那么所有杀人凶手都要“节哀顺变”了！全美各地频频发生“死人复活”的怪现象——被斧头劈死的尸体睁开眼睛，带着新鲜的伤痕跳窗逃走；全身血液早已被抽光的死者还开口向人要三明治！……而如此诡异的气氛，也弥漫至看似僻静详和的墓碑村。在当地经营墓园致富的巴利科恩家族，大家长史迈利病重快要去世了，公布遗嘱前找到了自己的孙子葛林。可就在遗嘱公布前，史迈利的孙子葛林被毒死，然而紧接着——他竟又活了过来！葛林怀疑自己的死与遗产之争有关，于是他给自己的身体做防腐处理，伪装成活人，找出杀了自己的凶手……</p>
<p>以上内容来自百度百科，看完了，大家就可以知道这本书的背景设置的是多么的玄幻了吧？一个很重要的点，既然人死了可以复活，那为什么好友杀人案？如果杀人时被受害者看到了自己的样子，那么岂不是瞬间败露了？</p>
<p>反正呢，这本书很好看，而且字数很多，在气氛渲染上很足，看完绝对不会是一本让大家觉得浪费了生命的小说！</p>
<p>《第七重解答》推荐值：四星</p>
<p><strong>地址：<a href="https://wws.lanzous.com/i7ZVde271wb" target="_blank" rel="noopener">https://wws.lanzous.com/i7ZVde271wb</a></strong></p>
<p>前文说过，本格小说在欧美“几乎”死亡。那么，这本书的作者保罗霍尔特，就是欧美难得一直坚持创作纯正推理小说的作家之一了。</p>
<p>这本书具体内容介绍，大家可以自己去百度，而且看名字就知道，这是一个不断反转让人一次次摸不着头脑的故事了。诡计说实话并不是太强，但是强就强在那一次次的反转之中，让人情不自禁的就完全的沉迷在了故事之中。</p>
<p>我到现在还记得，第一次看这本小说时，我可以从晚上9点一直看到了凌晨4点，异常酣畅淋漓的一次阅读旅行，让人十分愉快。同时，也让我完全喜欢上了这位作者，将能在中国购买到的十几本小说，全部买回了家里。</p>
<p>《剪刀男》推荐值：四星</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iqR40e274if" target="_blank" rel="noopener">https://wws.lanzous.com/iqR40e274if</a></strong></p>
<p>出现了，终于出现了，终于出现“这个”类型的小说了。可以明确的告诉大家，这本小说就是一本叙述性诡计的推理小说。</p>
<p>至于叙述性诡计倒是是什么意思，大家可以去百度一下。</p>
<p>这种类型小说的鼻祖，大家公认是推理女王阿加莎克里斯蒂创作出来。但是呢，女王的那本书，不能说名字，说了名字，知道是叙述性诡计的小说，那就很容易猜到谜底，这里就不毁灭大家的阅读体验了。</p>
<p>但是日本人，性格真的是异常的极端扭曲，我可以很明确的告诉大家，这本书就是叙述性诡计，完全可以带着一万个警惕之心去读这本书。但是呢，仍然很难猜到真正的谜底是什么！</p>
<p>反正，当年的我，兴致勃勃的想做一个侦探，可惜完全被这本小说骗倒了。</p>
<p>这里多说几句，一般来说叙述性诡计小说读完之后的分三种。一种是——我靠作者你这写得是什么鬼玩意啊，完全不公平不合理，看完之后想摔书顺便真人PK一下那傻缺的作者。</p>
<p>一种是——切，我就知道是这里有问题，书都没看完一半我就知道作者的诡计是什么了，实在是小儿科一点挑战性都没有啊！！！</p>
<p>最后一种是——我靠！作者真是犀利！原来是这样！我怎么没想到呢！真是厉害的作者！</p>
<p>到底一本叙述性诡计能得到哪一种评价，那就完全看作者自己的创造功力了。剪刀男，毫无疑问，就是属于最后一种！</p>
<p>《向日葵不开的夏天》推荐值：四星</p>
<p><strong>地址：<a href="https://wws.lanzous.com/i3ONje275dg" target="_blank" rel="noopener">https://wws.lanzous.com/i3ONje275dg</a></strong></p>
<p>要来叙述性诡计就一次来个够，这本书也同样属于叙述性诡计的小说，也同样是最后一种评价的小说。</p>
<p>这本小说，我大概是在五年前读的，但是里面的主角，一个年纪很小的男孩，那种气氛渲染和绝望感，让我至今无法忘怀。所以，大家可以去看看，绝对不会让你失望的。</p>
<p>顺便说说这本小说的作者道尾秀介吧，这位作者在日本的名气很大，而且属于那种年纪轻轻就有了极高地位的天才。然后呢，困扰我们东野圭吾天王多年的直木奖&lt;日本的一个小说奖，地位很高，很多作者都异常想得到。&gt;，他年纪轻轻就轻而易举的用一本貌似是叫《月与蟹》的小说拿到了。</p>
<p>我呢，也是看完向日葵之后，买了他很多本书，顺便想想有独眼猴啊，乌鸦的拇指啊，影子啊，所罗门之犬啊之类的很多本，但是看完以后，都觉得很糟糕，没有一本比得上向日葵。特别是那本得了大奖的月与蟹，完全无法理解有什么好看的。</p>
<p>这个呢，可能就是我自己的阅读口味问题了，所以呢，也就不多说，大家自己斟酌着看吧。</p>
<p>《钟表馆幽灵》推荐值：四星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/i4Ndre276gf" target="_blank" rel="noopener">https://wws.lanzous.com/i4Ndre276gf</a></strong></p>
<p>这本书，作者是绫辻行人，同时，也是一个系列小说。系列的序列是这样的，《十角馆杀人预告》《水车馆幻影》《迷宫馆的诱惑》《偶人馆之谜》《钟表馆幽灵》《黑猫馆手记》《黑暗馆不死传说》《惊愕馆杀人童话》嘿嘿嘿，故意把全部的系列列出来，看看有没有不收全不舒服斯基的人会克制不住的购买一套。</p>
<p>因为都有一个馆字，所以一般来说这套书被称为馆系列，然后呢，因为我买这套书的时间比较早，所以买的是老板，没有惊愕馆这一本。</p>
<p>总的来说，作为号称“新本格棋手”的绫辻行人写的书，基本上都是水准以上的作品。不过老实说，虽然我拥有一套馆系列，但是可能是因为阅读时间比较久了，现在印象比较深刻一点的，也只有十角馆钟表馆和黑暗馆了，所以大概这三本是系列最好的三本吧。</p>
<p>最后，钟表馆的诡计并不创新，甚至可以说有点老套，但是气氛渲染真的很好，同时结局也给人一种意料之外情理之中的感觉。读一次，绝对不会浪费时间。</p>
<p>第五季</p>
<p>哈，一点都不久违的第四季光速一样的到来了。上一季最后，说好带来一期中国本格小说推荐，但是仔细想了想发现了一个无奈的事实。可能因为市场并不畅销，也没有什么推理奖项的缘故，中国的推理小说作者极少，偶尔有一两个出名的，也不算纯粹的推理小说。</p>
<p>所以呢，这一季的话，我就来一次混合类推荐吧。</p>
<p>《双头恶魔》推荐值：三星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/iJsLhe27b0j" target="_blank" rel="noopener">https://wws.lanzous.com/iJsLhe27b0j</a></strong></p>
<p>这本书的作者是有栖川有栖，作品蛮多的，在日本推理文坛的地位貌似也挺高。主要来说的话，有两个大系列，一个是双头恶魔为代表作的江神二郎系列。和另外一个“国名系列”为代表作的活村英生系列。</p>
<p>纵观他大部分的作品，这个作者是很传统很保守的推理作家。两个系列中，不论是诡计的设置，还是谜题的展开，或者最后的逻辑推理，都十分严密，可以称的上一句严丝合缝。所以呢，在日本推理文坛，他也被人称为“日本的艾勒里奎因”。</p>
<p>不过个人，并不是很喜欢他的作品。原因的话，一来是我感觉他的人物塑造比较糟糕，二来虽然他的逻辑性确实极强，但是在气氛渲染以及诡计塑造上都太保守了一点，让我总是不能有惊艳的阅读体验。</p>
<p>所以，他的作品我没有收藏癖发作全部购买，只买了大概5本左右，大家自己斟酌着看咯。</p>
<p>《二阶堂黎人兰子系列》推荐值：四星。</p>
<p>请注意，这个推荐值，不仅仅是因为一本书，而是基于作者二阶堂黎人所创造的这整个系列的一套小说。</p>
<p>这个系列，一本被称为“二阶堂兰子”系列。按照时间顺序的话，一共有《吸血之家》《地狱奇术师》《圣奥斯拉修道院的悲剧》《恶灵公馆》《恐怖的人狼城》《魔术王事件》《双面兽事件》短篇《百合迷宫》、《玫瑰迷宫》、《恶魔迷宫》这么多。下面呢，我就把我看过的这个系列的小说给大家推荐一下。</p>
<p>《地狱奇术师》这本书，我买到的时间恨早了，至少4 5年之前了。那时候的我，看过的推理小说并不算多，鉴赏能力还没有培养起来，所以对这本书的印象还蛮深刻的。总的来说，这本书值得一看，最后的结局也写的蛮不错的。</p>
<p><strong>地址：<a href="http://st.kanxshuo.com/book-116470-1.html" target="_blank" rel="noopener">http://st.kanxshuo.com/book-116470-1.html</a></strong></p>
<p>最重要的是，因为作者本人对于推理小说的阅读量极大的缘故，在小说中谈论了很多本的推理小说，有一定程度上的炫学成分，给当时阅读渴望极高的我推荐了不少粮草，所以还算蛮有趣的一本小说。</p>
<p>《魔术王事件》仍然是作者一贯的风格，诡计的杀人时间，略带一点恐怖小说写法的氛围，出奇的魔术，算得上是一本优秀的推理小说。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/idtVPe283tg" target="_blank" rel="noopener">https://wws.lanzous.com/idtVPe283tg</a></strong></p>
<p>不过呢，这个作者有一个最大的缺点，就是人物塑造的非常不好。作者华生角色的记述者，性格属于那种很带日漫风格的弱受主角，而且十分无能，属于我很不喜欢的那一种类型。而最重要的人物，也是推理小说核心的侦探二阶堂兰子，同样塑造的很不讨喜。</p>
<p>本来按照作者的塑造，兰子不单是美女，而且聪明敏锐，绝对不是花瓶一样的存在。但是呢，就算加上了这些属性，却还是给人一种装模作样绿茶婊的感觉，总的来说，很难让我投入进去。</p>
<p>本来的话，作为本格小说中少有的女性系列侦探，应该是十分讨喜的创作。但是因为作者的缘故，让我反而厌恶这个侦探，就真的只能说是笔力的问题了。</p>
<p>其实想一想，弱受加强女王的搭配，不管是在日漫还是日本小说中，都是十分长剑的组合。比如我在第一期推荐的西泽保彦系列中的匠千晓系列，高千加匠仔同样是这样的模式。但是酒鬼西泽的塑造，就能让我异常喜爱他的人物，而二阶堂就不行。</p>
<p>《恐怖的人狼城》这本书真的不得了，一共分四本，名字分别为《德国篇》《法国篇》《侦探篇》《完结篇》，号称是史上最长的本格推理小说。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/b01bigwva" target="_blank" rel="noopener">https://wws.lanzous.com/b01bigwva</a></strong><br>
<strong>密码:fbw2</strong></p>
<p>更加难得是，这本书的结构十分有趣，前面两本德国篇法国篇，分别描写了两件连环杀人案件，不但读起来没有让当时的我觉得厌烦雷同或者啰嗦，反而让我读的十分爽快。</p>
<p>不但如此，因为结构关系，这两本书，不管先读哪一本都是可以的，完全不影响后续的阅读。</p>
<p>这本书是真的长，而且因为是推理小说的缘故，一目十行的网文阅读法是绝对不行的，所以我足足看了快两个星期才把四本看完。虽然我现在还记得看完这四本书的疲惫感，但是心中的满足感也同样存在。不但没有作者灌水的感觉，还得到了一个极为惊艳的解答。</p>
<p>至于这本书的缺点呢，我看来有两个。一是因为场面比较宏大，难免有一些地方逻辑性不是唯一。二来呢，就是作者的老毛病人物塑造问题了，这里就不多说了。</p>
<p>总的来说，喜欢推理小说的龙友们，这个作者其他系列也就罢了，这四本书，绝对绝对不要错过哦！！</p>
<p>《全部成为F》推荐值：五星。</p>
<p><strong>地址：<a href="https://wws.lanzous.com/ifKDFe27x7i" target="_blank" rel="noopener">https://wws.lanzous.com/ifKDFe27x7i</a></strong></p>
<p>这本书的作者的是森</p>
<p>博嗣（もり</p>
<p>ひろし，1957年12月7日－）工学博士，前名古屋大学副教授，现为日本小说、推理小说作家。森于日本爱知县出生，东海中学校・高校，名古屋大学工学部（博士）毕业。当过三重大学助手，后任名古屋大学副教授，名古屋大学大学院环境学研究科都市环境学専攻，于2005年3月离职全职写作。</p>
<p>以上来自百度，看资料就可以看出来，这位作者的学历蛮高的，也深刻反应在了他的作品之中。所以森</p>
<p>博嗣的作品，又被称为“理工科”推理小说。</p>
<p>这本F，急救室犀川&amp;萌绘系列小之中的一本。这套系列小说一共有十本，这里我就不列举全部系列的名字了。我只说一点，这是最近三十年创造的系列小说中，少有的结局系列作品。不仅如此，虽然系列的成就有上涨下跌，但都被作者维持在了一个并不太大的曲线之中，基本上都是水准以上的作品，收集完全的话，不会有特别坑爹的作品出现。</p>
<p>最后，说说F这本书，如果考虑到1996年创造的时代背景的话，这本书在当年绝对是一本极为少见的极品小说。就算换到2015年的现在来看，也不算有多么的落后过时。</p>
<p>如果想要入手这个系列，可以先考虑购买阅读着一本，然后再根据自己的阅读体验，考虑是不是继续入手！</p>
<p>《紫金陈系列》推荐值：四星。</p>
<p>最后进入国产推理小说推荐环节。说实话，要考虑推荐国产小说，我真的是绞尽脑汁想了很久很久，还是有点头疼的感觉。有些作品吧，比如既晴的《请把门锁好》《别进地下道》虽然不错，但是总觉得少了些什么。在我看来，实在算不上特别好特别只得推荐的作品。</p>
<p>不仅如此，中国最近10年左右，真正能说是本格推理小说的作家少之又少，我思来想去，有一定水准又能说是本格小说的推理作家，也就紫金陈一个人而已！</p>
<p>紫金陈的谋杀官员系列，系列中水准的起伏又实在太大。第一本徐策做主角的那本，说实话，除了杀官这个G点，基本上没有太多优点。所谓的逻辑王子，在我看来应该叫漏洞王子才对。而且怎么说呢，文笔实在太干。但是考虑这是作者第一本处女作，那就应该宽容一些，仍然值得一读！</p>
<p>不过也不知道是作者第一本只是练笔的缘故，第二本《化工女王的逆袭》倒是一本极为不错的推理粮草，虽然文笔还是很干，但是在诡计和气氛方面，已经是水准以上的推理小说了，倒是值得认真一读。</p>
<p>而到了谋3物理教师的时空诡计，水准又一下狂降。不但人物动机值得商榷，诡计更是水准以下，稍微思考一下，就能发现这本书的核心诡计是绝对不能现实实现的空想诡计。反正就我来说，着一本小说是作者所有的小说中最差的那一本，完全不及格。</p>
<p>最后的谋4代上帝之手，水准倒是回复了许多，除了仍然让我觉得有些无理的人物动机以外，又成为了一本值得好好阅读一次的推理小说。</p>
<p>推理之王1无证之罪，很深的模仿嫌疑犯X的现身的感觉，书中有几个吸引人阅读下去的情节疑点，但是几乎没有惊艳的诡计，总的来说，不是特别好，算是干草水平吧。</p>
<p>推理之王2坏小孩。一本少年犯罪的小说，读过很多日系虐心系列比如向日葵不开的夏天还有黑乙一作品的我，很难被虐心题材打动。这本书我为了支持作者买了实体书，我个人因为口味重所以没有被打动，但是我老娘倒是很喜欢，看的唏嘘不已。所以，口味比较轻的龙友，还是可以认真一读的。</p>
<p>虽然上面我个人对谋杀官员系列提出了一些批评，但是考虑这四本书都是免费发在网络上，带有一定练笔倾向的小说，所以大家还是可以期待期待紫金陈日后的作品的。</p>
<p>说道这，我倒是忘记了，本国推理小说给我留下印象的作者还有两位，一位是轩弦的慕容思炫系列，一位是御手洗熊猫。</p>
<p>先说说慕容思炫系列吧，这位作者的书大部分是短篇，发表在各种推理杂志上。如果用杂志水准来要求的话，写得还算可以，如果无聊的时候倒很适合读一读。长篇的话，我只看过一本五次方谋杀，感觉水准不是太高，很深的“蝴蝶效应”这部电影的模仿痕迹，也许是口味不太符合吧。</p>
<p>御手洗熊猫呢，从名字来说很明显是岛田庄司的粉丝，其作品好像是地下众筹出版过一次，很可惜我当时不知道这件事，所以没有参与，自然没有看过了。然后作品因为小众的缘故，在网络上也很少有，我也只看过几个短篇。</p>
<p>印象不太深刻，在记忆中，貌似蛮有岛田风格的，但是模仿方面痕迹很重，感觉也是一般。</p>
<p>啊哈哈，今天的推荐就到这里了，希望大家看的过瘾。</p>
<p>最后，做一个免责生命——阅读体验本来就是一个很私人的事情，如果不小心对您的心爱小说做出来不太好的评价，请一定要包涵！</p>
]]></content>
      <categories>
        <category>本格推理</category>
      </categories>
      <tags>
        <tag>电子书</tag>
      </tags>
  </entry>
  <entry>
    <title>电子信息类课件视频分享</title>
    <url>/2020/07/09/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E7%B1%BB%E8%AF%BE%E4%BB%B6%E8%A7%86%E9%A2%91%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>电子信息类课件信息分享</p>
<a id="more"></a>
<h1 id="注意："><a class="header-anchor" href="#注意：">¶</a>注意：</h1>
<p>1.课程视频的下载可以使用 <strong>JiJiDown</strong>,使用说明见 <a href="https://www.bilibili.com/video/BV1Dt411p73X" target="_blank" rel="noopener">BV1Dt411p73X</a> 因为<strong>JiJiDown</strong>只支持Windows客户端 使用MAC和Linux的同学可以使用<strong>you-get</strong> Github主页见 <a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">soimort/you-get</a> (you-get暂时还不支持bv号的下载 需要将bv号转换回av号 具体转换方法见这个[知乎回答](<a href="https://shimo.im/docs/YhHjYkvHqCQ3Pcd9/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85" target="_blank" rel="noopener">https://shimo.im/docs/YhHjYkvHqCQ3Pcd9/如何看待</a> 2020 年 3 月 23 日哔哩哔哩将稿件的「av 号」变更为「BV 号」？ - mcfx的回答 - 知乎 <a href="https://www.zhihu.com/question/381784377/answer/1099438784" target="_blank" rel="noopener">https://www.zhihu.com/question/381784377/answer/1099438784</a>))</p>
<p>2.课程相关信息的问题请先查看课程简介和评论区(虽然我不是每一门都有写) 但是诸如课程配套教材是什么 看西电的课程能不能用郑君里老师的书 XXX教材出了新版要不要买新版之类的问题一律不回答 请不要私信问我</p>
<p>3.所有的百度云链接请复制后在浏览器中打开 B站封杀了百度云的链接 所以在B站内直接打开百度云链接会提示链接已失效 如果在浏览器中打开百度云链接提示失效 并且在刷新过后还是得到同样的结果的 请在课程的评论区留言告诉我 不要给我发私信 谢谢</p>
<hr>
<p>信号与系统 - 北京交通大学 <a href="https://www.bilibili.com/video/BV1As411H7Q3" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1As411H7Q3</a></p>
<p>课件链接：<a href="https://pan.baidu.com/s/1BT26BfJlJaYbqRc-VKga7g" target="_blank" rel="noopener">https://pan.baidu.com/s/1BT26BfJlJaYbqRc-VKga7g</a></p>
<p>提取码：e6u2</p>
<p>信号与系统 - 西安电子科技大学 <a href="https://www.bilibili.com/video/BV18s411H7rX" target="_blank" rel="noopener">https://www.bilibili.com/video/BV18s411H7rX</a></p>
<p>链接：<a href="https://pan.baidu.com/s/123NqA6nDYQRivCv-3ovSyA" target="_blank" rel="noopener">https://pan.baidu.com/s/123NqA6nDYQRivCv-3ovSyA</a></p>
<p>提取码：8w8f</p>
<p>信号与系统 - 东南大学 <a href="https://www.bilibili.com/video/BV1js411H7VJ" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1js411H7VJ</a></p>
<p>课件链接: <a href="https://pan.baidu.com/s/1LsPyWom4YahqJ1D9kOqppQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1LsPyWom4YahqJ1D9kOqppQ</a></p>
<p>密码: yuyu</p>
<p>信号与系统 - 北京邮电大学 <a href="https://www.bilibili.com/video/BV1Jt411C7jU" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Jt411C7jU</a></p>
<p>课件链接：<a href="https://pan.baidu.com/s/1_WbbhtB27LdfRQ12dkvMmA" target="_blank" rel="noopener">https://pan.baidu.com/s/1_WbbhtB27LdfRQ12dkvMmA</a></p>
<p>提取码：it1m</p>
<p>信号与线性系统 - 华中科技大学 <a href="https://www.bilibili.com/video/BV1tt411V7XD" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1tt411V7XD</a></p>
<p>课件链接：<a href="https://pan.baidu.com/s/1-JcsWN-ojK2eXp_6LwepKg" target="_blank" rel="noopener">https://pan.baidu.com/s/1-JcsWN-ojK2eXp_6LwepKg</a></p>
<p>提取码：cn2t</p>
<p>数字信号处理 - 北京航空航天大学 <a href="https://www.bilibili.com/video/BV1Ws411H7JY" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ws411H7JY</a></p>
<p>课件链接: <a href="https://pan.baidu.com/s/1D7kn0sqQF0IfrOedygnizQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1D7kn0sqQF0IfrOedygnizQ</a></p>
<p>提取码: 8v4j</p>
<p>数字信号处理 - 西安电子科技大学 <a href="https://www.bilibili.com/video/BV1es411H7eJ" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1es411H7eJ</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1QzP-tHQ3cF0cqyzjN_5BAA" target="_blank" rel="noopener">https://pan.baidu.com/s/1QzP-tHQ3cF0cqyzjN_5BAA</a></p>
<p>提取码：cujo</p>
<p>数字信号处理 - 北京交通大学 <a href="https://www.bilibili.com/video/BV1zs411H7jx" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1zs411H7jx</a></p>
<p>课件链接：<a href="https://pan.baidu.com/s/1ibbvsNXFw-NmS7x_xOLmfw" target="_blank" rel="noopener">https://pan.baidu.com/s/1ibbvsNXFw-NmS7x_xOLmfw</a></p>
<p>提取码：jqsw</p>
<p>数字信号处理 - 南京邮电大学 <a href="https://www.bilibili.com/video/BV1bJ411M7jc" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1bJ411M7jc</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1xiGypTgR_IUy7Hn9DsgtQw" target="_blank" rel="noopener">https://pan.baidu.com/s/1xiGypTgR_IUy7Hn9DsgtQw</a></p>
<p>提取码：xqp2</p>
<p>数字信号处理 - 东南大学 <a href="https://www.bilibili.com/video/BV1qs411H7T4" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1qs411H7T4</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1qf5LW8clg2vwoXW08X5wyg" target="_blank" rel="noopener">https://pan.baidu.com/s/1qf5LW8clg2vwoXW08X5wyg</a></p>
<p>提取码：6viz</p>
<p>数字信号处理 - 电子科技大学 <a href="https://www.bilibili.com/video/BV1as411H7BN" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1as411H7BN</a></p>
<p>链接：<a href="https://pan.baidu.com/s/10DWQgqLboZYr1b4RCSa3Yw" target="_blank" rel="noopener">https://pan.baidu.com/s/10DWQgqLboZYr1b4RCSa3Yw</a></p>
<p>提取码：h8tk</p>
<p>通信原理 - 国防科技大学 <a href="https://www.bilibili.com/video/BV19E411R7yu" target="_blank" rel="noopener">https://www.bilibili.com/video/BV19E411R7yu</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1kF8Xtk8Mdt-WpwCJ4utZXw" target="_blank" rel="noopener">https://pan.baidu.com/s/1kF8Xtk8Mdt-WpwCJ4utZXw</a></p>
<p>提取码：06lu</p>
<p>通信原理 - 电子科技大学 <a href="https://www.bilibili.com/video/BV1NJ411M7dE" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1NJ411M7dE</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1u2iwG6TRQI6A6ppxHnqZvA" target="_blank" rel="noopener">https://pan.baidu.com/s/1u2iwG6TRQI6A6ppxHnqZvA</a></p>
<p>提取码：3fcj</p>
<p>通信原理 - 北京邮电大学 <a href="https://www.bilibili.com/video/BV1kE411R71u" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1kE411R71u</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1kxYoETe4ag-3b0x9QrtS0A" target="_blank" rel="noopener">https://pan.baidu.com/s/1kxYoETe4ag-3b0x9QrtS0A</a></p>
<p>提取码：tds1</p>
<p>电磁场 - 哈尔滨工业大学 <a href="https://www.bilibili.com/video/BV1GJ411M7YR" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GJ411M7YR</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Sze9BMHaZr39fdczXp-RxA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Sze9BMHaZr39fdczXp-RxA</a></p>
<p>提取码：fsjl</p>
<p>电磁场与电磁波 - 西北工业大学 <a href="https://www.bilibili.com/video/BV1iJ411M7oe" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iJ411M7oe</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1GbaByNL9a0Jt967vdPIjhw" target="_blank" rel="noopener">https://pan.baidu.com/s/1GbaByNL9a0Jt967vdPIjhw</a></p>
<p>提取码：dt52</p>
<p>电磁场与电磁波 - 武汉大学 <a href="https://www.bilibili.com/video/BV1GJ411M7y7" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GJ411M7y7</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1H0cpwnpaqD7R-uptUj6X5w" target="_blank" rel="noopener">https://pan.baidu.com/s/1H0cpwnpaqD7R-uptUj6X5w</a></p>
<p>提取码：dlhm</p>
<p>电磁场与电磁波 - 北京交通大学 <a href="https://www.bilibili.com/video/BV1XJ411M7T7" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1XJ411M7T7</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1NIw7qu6E0aSetbVGDGdu4g" target="_blank" rel="noopener">https://pan.baidu.com/s/1NIw7qu6E0aSetbVGDGdu4g</a></p>
<p>提取码：lxzh</p>
<p>应用信息论基础 - 清华大学(第1章PPT遗失) <a href="https://www.bilibili.com/video/BV1Fs411g7G7" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Fs411g7G7</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1E5Vcwe2Um9tcLiyoEfuuZw" target="_blank" rel="noopener">https://pan.baidu.com/s/1E5Vcwe2Um9tcLiyoEfuuZw</a></p>
<p>提取码：2jvp</p>
<p>随机信号分析 - 西安电子科技大学 <a href="https://www.bilibili.com/video/BV1Bs411H7Pi" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Bs411H7Pi</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1C87-aUF11Q3iG_hQMGSm3g" target="_blank" rel="noopener">https://pan.baidu.com/s/1C87-aUF11Q3iG_hQMGSm3g</a></p>
<p>提取码：g6fj</p>
<p>自动控制原理 - 华中科技大学 <a href="https://www.bilibili.com/video/BV1qJ411M7EU" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1qJ411M7EU</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Uuv2afUJOFlokvS7RhH-1g" target="_blank" rel="noopener">https://pan.baidu.com/s/1Uuv2afUJOFlokvS7RhH-1g</a></p>
<p>提取码：lobu</p>
<p>电路分析基础 - 西安电子科技大学 <a href="https://www.bilibili.com/video/BV15s411P7qz" target="_blank" rel="noopener">https://www.bilibili.com/video/BV15s411P7qz</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ZvDGRP8jmGjJRE4SixMTfw" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZvDGRP8jmGjJRE4SixMTfw</a></p>
<p>提取码：4jnb</p>
<p>模拟电子电路与技术基础 - 西安电子科技大学 <a href="https://www.bilibili.com/video/BV1Ss411c7oM" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ss411c7oM</a></p>
<p>链接：<a href="https://pan.baidu.com/s/172WWvkAI3mLbBYnO4fJIFw" target="_blank" rel="noopener">https://pan.baidu.com/s/172WWvkAI3mLbBYnO4fJIFw</a></p>
<p>提取码：z50s</p>
<p>数字电子技术基础 - 华中科技大学 <a href="https://www.bilibili.com/video/BV1GW411y73c" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GW411y73c</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1YM7csbO90O2u6VV-4R8m1g" target="_blank" rel="noopener">https://pan.baidu.com/s/1YM7csbO90O2u6VV-4R8m1g</a></p>
<p>提取码：yk47</p>
<p>数电电路与系统设计 - 西安电子科技大学 <a href="https://www.bilibili.com/video/BV1tb41187VP" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1tb41187VP</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1UQ-R-ZA5S7NX7jK-6m_r_g" target="_blank" rel="noopener">https://pan.baidu.com/s/1UQ-R-ZA5S7NX7jK-6m_r_g</a></p>
<p>提取码：kauu</p>
]]></content>
      <categories>
        <category>电子信息</category>
      </categories>
      <tags>
        <tag>b站视频</tag>
      </tags>
  </entry>
  <entry>
    <title>个人静态博客-Hexo-Next-（八）</title>
    <url>/2020/06/12/%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-Hexo-Next-%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍文章添加评论功能，评论输入打字特效，分类和标签页显示年份，增加字数统计功能，文章加密访问，3D动态标签云，开启打赏功能，设置背景图片，博客内容透明化，站点运行时间统计，站点访问量统计，实现头像旋转。</p>
<a id="more"></a>
<h1 id="一、文章添加评论功能"><a class="header-anchor" href="#一、文章添加评论功能">¶</a>一、文章添加评论功能</h1>
<p>1.首先访问<strong>网站：<a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a></strong></p>
<p>来进行注册登录。</p>
<p>2.登录后按照官网的教程新建应用。之后进入设置，点击应用Keys。最主要的就是AppID和AppKey。用的时候分别复制。</p>
<p>3.打开<strong>主题配置</strong>文件，找到valine。</p>
<p>按照下面代码进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">    enable: true</span><br><span class="line">    appid: ***&lt;app_id&gt;***</span><br><span class="line">    appkey: ***&lt;app_key&gt;***</span><br><span class="line">    notify: false # 收到新评论是否邮件通知</span><br><span class="line">    verify: false # 是否开启验证码</span><br><span class="line">    placeholder: # 默认填充文字</span><br><span class="line">    avatar: mm # 设置默认评论列表</span><br><span class="line">    guest_info: nick,mail # 评论区头部表单</span><br><span class="line">    pageSize: 10 # 每页评论数</span><br></pre></td></tr></table></figure>
<p>把刚才的AppID和AppKey复制到对应的位置，注意冒号后有一个空格。开启notify有评论会发送到你的邮箱。其余默认。</p>
<h1 id="二、评论输入打字特效"><a class="header-anchor" href="#二、评论输入打字特效">¶</a>二、评论输入打字特效</h1>
<p>在路径：<code>themes\next\source\js\src</code>中<strong>新建</strong><code>activate-power-mode.js</code>文件。</p>
<p>打开<code>activate-power-mode.js</code>，粘贴以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function webpackUniversalModuleDefinition(root,factory)&#123;if(typeof exports&#x3D;&#x3D;&#x3D;&#39;object&#39;&amp;&amp;typeof module&#x3D;&#x3D;&#x3D;&#39;object&#39;)module.exports&#x3D;factory();else if(typeof define&#x3D;&#x3D;&#x3D;&#39;function&#39;&amp;&amp;define.amd)define([],factory);else if(typeof exports&#x3D;&#x3D;&#x3D;&#39;object&#39;)exports[&quot;POWERMODE&quot;]&#x3D;factory();else root[&quot;POWERMODE&quot;]&#x3D;factory()&#125;)(this,function()&#123;return(function(modules)&#123;var installedModules&#x3D;&#123;&#125;;function __webpack_require__(moduleId)&#123;if(installedModules[moduleId])return installedModules[moduleId].exports;var module&#x3D;installedModules[moduleId]&#x3D;&#123;exports:&#123;&#125;,id:moduleId,loaded:false&#125;;modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);module.loaded&#x3D;true;return module.exports&#125;__webpack_require__.m&#x3D;modules;__webpack_require__.c&#x3D;installedModules;__webpack_require__.p&#x3D;&quot;&quot;;return __webpack_require__(0)&#125;)([function(module,exports,__webpack_require__)&#123;&#39;use strict&#39;;var canvas&#x3D;document.createElement(&#39;canvas&#39;);canvas.width&#x3D;window.innerWidth;canvas.height&#x3D;window.innerHeight;canvas.style.cssText&#x3D;&#39;position:fixed;top:0;left:0;pointer-events:none;z-index:999999&#39;;window.addEventListener(&#39;resize&#39;,function()&#123;canvas.width&#x3D;window.innerWidth;canvas.height&#x3D;window.innerHeight&#125;);document.body.appendChild(canvas);var context&#x3D;canvas.getContext(&#39;2d&#39;);var particles&#x3D;[];var particlePointer&#x3D;0;POWERMODE.shake&#x3D;true;function getRandom(min,max)&#123;return Math.random()*(max-min)+min&#125;function getColor(el)&#123;if(POWERMODE.colorful)&#123;var u&#x3D;getRandom(0,360);return&#39;hsla(&#39;+getRandom(u-10,u+10)+&#39;, 100%, &#39;+getRandom(50,80)+&#39;%, &#39;+1+&#39;)&#39;&#125;else&#123;return window.getComputedStyle(el).color&#125;&#125;function getCaret()&#123;var el&#x3D;document.activeElement;var bcr;if(el.tagName&#x3D;&#x3D;&#x3D;&#39;TEXTAREA&#39;||(el.tagName&#x3D;&#x3D;&#x3D;&#39;INPUT&#39;&amp;&amp;el.getAttribute(&#39;type&#39;)&#x3D;&#x3D;&#x3D;&#39;text&#39;))&#123;var offset&#x3D;__webpack_require__(1)(el,el.selectionStart);bcr&#x3D;el.getBoundingClientRect();return&#123;x:offset.left+bcr.left,y:offset.top+bcr.top,color:getColor(el)&#125;&#125;var selection&#x3D;window.getSelection();if(selection.rangeCount)&#123;var range&#x3D;selection.getRangeAt(0);var startNode&#x3D;range.startContainer;if(startNode.nodeType&#x3D;&#x3D;&#x3D;document.TEXT_NODE)&#123;startNode&#x3D;startNode.parentNode&#125;bcr&#x3D;range.getBoundingClientRect();return&#123;x:bcr.left,y:bcr.top,color:getColor(startNode)&#125;&#125;return&#123;x:0,y:0,color:&#39;transparent&#39;&#125;&#125;function createParticle(x,y,color)&#123;return&#123;x:x,y:y,alpha:1,color:color,velocity:&#123;x:-1+Math.random()*2,y:-3.5+Math.random()*2&#125;&#125;&#125;function POWERMODE()&#123;&#123;var caret&#x3D;getCaret();var numParticles&#x3D;5+Math.round(Math.random()*10);while(numParticles--)&#123;particles[particlePointer]&#x3D;createParticle(caret.x,caret.y,caret.color);particlePointer&#x3D;(particlePointer+1)%500&#125;&#125;&#123;if(POWERMODE.shake)&#123;var intensity&#x3D;1+2*Math.random();var x&#x3D;intensity*(Math.random()&gt;0.5?-1:1);var y&#x3D;intensity*(Math.random()&gt;0.5?-1:1);document.body.style.marginLeft&#x3D;x+&#39;px&#39;;document.body.style.marginTop&#x3D;y+&#39;px&#39;;setTimeout(function()&#123;document.body.style.marginLeft&#x3D;&#39;&#39;;document.body.style.marginTop&#x3D;&#39;&#39;&#125;,75)&#125;&#125;&#125;;POWERMODE.colorful&#x3D;false;function loop()&#123;requestAnimationFrame(loop);context.clearRect(0,0,canvas.width,canvas.height);for(var i&#x3D;0;i&lt;particles.length;++i)&#123;var particle&#x3D;particles[i];if(particle.alpha&lt;&#x3D;0.1)continue;particle.velocity.y+&#x3D;0.075;particle.x+&#x3D;particle.velocity.x;particle.y+&#x3D;particle.velocity.y;particle.alpha*&#x3D;0.96;context.globalAlpha&#x3D;particle.alpha;context.fillStyle&#x3D;particle.color;context.fillRect(Math.round(particle.x-1.5),Math.round(particle.y-1.5),3,3)&#125;&#125;requestAnimationFrame(loop);module.exports&#x3D;POWERMODE&#125;,function(module,exports)&#123;(function()&#123;var properties&#x3D;[&#39;direction&#39;,&#39;boxSizing&#39;,&#39;width&#39;,&#39;height&#39;,&#39;overflowX&#39;,&#39;overflowY&#39;,&#39;borderTopWidth&#39;,&#39;borderRightWidth&#39;,&#39;borderBottomWidth&#39;,&#39;borderLeftWidth&#39;,&#39;borderStyle&#39;,&#39;paddingTop&#39;,&#39;paddingRight&#39;,&#39;paddingBottom&#39;,&#39;paddingLeft&#39;,&#39;fontStyle&#39;,&#39;fontVariant&#39;,&#39;fontWeight&#39;,&#39;fontStretch&#39;,&#39;fontSize&#39;,&#39;fontSizeAdjust&#39;,&#39;lineHeight&#39;,&#39;fontFamily&#39;,&#39;textAlign&#39;,&#39;textTransform&#39;,&#39;textIndent&#39;,&#39;textDecoration&#39;,&#39;letterSpacing&#39;,&#39;wordSpacing&#39;,&#39;tabSize&#39;,&#39;MozTabSize&#39;];var isFirefox&#x3D;window.mozInnerScreenX!&#x3D;null;function getCaretCoordinates(element,position,options)&#123;var debug&#x3D;options&amp;&amp;options.debug||false;if(debug)&#123;var el&#x3D;document.querySelector(&#39;#input-textarea-caret-position-mirror-div&#39;);if(el)&#123;el.parentNode.removeChild(el)&#125;&#125;var div&#x3D;document.createElement(&#39;div&#39;);div.id&#x3D;&#39;input-textarea-caret-position-mirror-div&#39;;document.body.appendChild(div);var style&#x3D;div.style;var computed&#x3D;window.getComputedStyle?getComputedStyle(element):element.currentStyle;style.whiteSpace&#x3D;&#39;pre-wrap&#39;;if(element.nodeName!&#x3D;&#x3D;&#39;INPUT&#39;)style.wordWrap&#x3D;&#39;break-word&#39;;style.position&#x3D;&#39;absolute&#39;;if(!debug)style.visibility&#x3D;&#39;hidden&#39;;properties.forEach(function(prop)&#123;style[prop]&#x3D;computed[prop]&#125;);if(isFirefox)&#123;if(element.scrollHeight&gt;parseInt(computed.height))style.overflowY&#x3D;&#39;scroll&#39;&#125;else&#123;style.overflow&#x3D;&#39;hidden&#39;&#125;div.textContent&#x3D;element.value.substring(0,position);if(element.nodeName&#x3D;&#x3D;&#x3D;&#39;INPUT&#39;)div.textContent&#x3D;div.textContent.replace(&#x2F;\s&#x2F;g,&quot;\u00a0&quot;);var span&#x3D;document.createElement(&#39;span&#39;);span.textContent&#x3D;element.value.substring(position)||&#39;.&#39;;div.appendChild(span);var coordinates&#x3D;&#123;top:span.offsetTop+parseInt(computed[&#39;borderTopWidth&#39;]),left:span.offsetLeft+parseInt(computed[&#39;borderLeftWidth&#39;])&#125;;if(debug)&#123;span.style.backgroundColor&#x3D;&#39;#aaa&#39;&#125;else&#123;document.body.removeChild(div)&#125;return coordinates&#125;if(typeof module!&#x3D;&quot;undefined&quot;&amp;&amp;typeof module.exports!&#x3D;&quot;undefined&quot;)&#123;module.exports&#x3D;getCaretCoordinates&#125;else&#123;window.getCaretCoordinates&#x3D;getCaretCoordinates&#125;&#125;())&#125;])&#125;);</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>themes\next\layout\_custom\custom.swig</code>，如果不存在此文件，则新建。</p>
<p>打开<code>custom.swig</code>文件，粘贴以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# 打字特效 #&#125;</span><br><span class="line">&#123;% if theme.typing_effect %&#125;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;src&#x2F;activate-power-mode.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">          POWERMODE.colorful &#x3D; &#123;&#123; theme.typing_effect.colorful &#125;&#125;;</span><br><span class="line">           POWERMODE.shake &#x3D; &#123;&#123; theme.typing_effect.shake &#125;&#125;;</span><br><span class="line">           document.body.addEventListener(&#39;input&#39;, POWERMODE);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>如果刚新建了<code>custom.swig</code>文件，那么还要在<code>themes\next\layout\_layout.swig</code>引入，在后面添加下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;_custom&#x2F;custom.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<p>打开<strong>主题配置</strong>文件，在末尾添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># typing effect</span><br><span class="line">typing_effect:</span><br><span class="line">    colorful: true # 礼花特效</span><br><span class="line">    shake: false # 震动特效</span><br></pre></td></tr></table></figure>
<h1 id="三、分类和标签页显示年份"><a class="header-anchor" href="#三、分类和标签页显示年份">¶</a>三、分类和标签页显示年份</h1>
<p>打开文件，路径：<code>\themes\next\layout\category.swig</code>查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for post in page.posts %&#125;</span><br><span class="line">&#123;&#123; post_template.render(post) &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>改为下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for post in page.posts %&#125;</span><br><span class="line">    &#123;# Show year #&#125;</span><br><span class="line">    &#123;% set year %&#125;</span><br><span class="line">    &#123;% set post.year &#x3D; date(post.date, &#39;YYYY&#39;) %&#125;</span><br><span class="line">    &#123;% if post.year !&#x3D;&#x3D; year %&#125;</span><br><span class="line">    &#123;% set year &#x3D; post.year %&#125;</span><br><span class="line">    &lt;div class&#x3D;&quot;collection-title&quot;&gt;</span><br><span class="line">       &lt;h2 class&#x3D;&quot;archive-year motion-element&quot; id&#x3D;&quot;archive-year-&#123;&#123; year &#125;&#125;&quot;&gt;&#123;&#123; year &#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &#123;# endshow #&#125;</span><br><span class="line">    &#123;&#123; post_template.render(post) &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>在末尾再添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% block script_extra %&#125;</span><br><span class="line">  &#123;% if theme.use_motion %&#125;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; id&#x3D;&quot;motion.page.archive&quot;&gt;</span><br><span class="line">    $(&#39;.archive-year&#39;).velocity(&#39;transition.slideLeftIn&#39;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>标签页的操作和分类页一模一样。代码都一样，只不过打开文件，路径：<code>\themes\next\layout\tag.swig</code>。</p>
<h1 id="四、增加字数统计功能"><a class="header-anchor" href="#四、增加字数统计功能">¶</a>四、增加字数统计功能</h1>
<p>NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件<code>\themes\next_config.yml</code>中打开<code>wordcount</code> 统计功能即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;willin&#x2F;hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br></pre></td></tr></table></figure>
<p>如果仅仅只是打开开关，部署之后会发现文章的【字数统计】和【阅读时长】后面没有对应的xxx字，xx分钟等字样，只有光秃秃的数字在那里。</p>
<p>找到<code>themes\next\layout\_macro\post.swig</code> 文件</p>
<p>搜索到找到如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span title&#x3D;&quot;&#123;&#123; __(&#39;post.wordcount&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">     &#123;&#123; wordcount(post.content) &#125;&#125;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<p>修改后为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span title&#x3D;&quot;&#123;&#123; __(&#39;post.wordcount&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">     &#123;&#123; wordcount(post.content) &#125;&#125; 字</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<p>找到如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span title&#x3D;&quot;&#123;&#123; __(&#39;post.min2read&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">   &#123;&#123; min2read(post.content) &#125;&#125;</span><br><span class="line"> &lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<p>修改后为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span title&#x3D;&quot;&#123;&#123; __(&#39;post.min2read&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">   &#123;&#123; min2read(post.content) &#125;&#125; 分钟</span><br><span class="line"> &lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<h1 id="五、文章加密访问"><a class="header-anchor" href="#五、文章加密访问">¶</a>五、文章加密访问</h1>
<p>打开文件，路径：<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head-&gt;head-unique.swig</code>。</p>
<p>在末尾加入下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        if(&#39;&#123;&#123; page.password &#125;&#125;&#39;)&#123;</span><br><span class="line">            if (prompt(&#39;请输入查看密码&#39;) !&#x3D;&#x3D; &#39;&#123;&#123; page.password &#125;&#125;&#39;)&#123;</span><br><span class="line">                alert(&#39;密码不正确&#39;);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>最后在想加密的文章.md中添加password。注意password冒号后面有空格。</p>
<h1 id="六、3D动态标签云"><a class="header-anchor" href="#六、3D动态标签云">¶</a>六、3D动态标签云</h1>
<p>首先，安装标签云插件，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud@^2.* --save</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>next/layout/_macro/sidebar.swig</code>。在下面位置添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#x2F;js&#x2F;tagcloud.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#x2F;js&#x2F;tagcanvas.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;widget-wrap&quot;&gt;</span><br><span class="line">            &lt;div id&#x3D;&quot;myCanvasContainer&quot; class&#x3D;&quot;widget tagcloud&quot;&gt;</span><br><span class="line">                &lt;canvas width&#x3D;&quot;250&quot; height&#x3D;&quot;250&quot; id&#x3D;&quot;resCanvas&quot; style&#x3D;&quot;width&#x3D;100%&quot;&gt;</span><br><span class="line">                    &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">                &lt;&#x2F;canvas&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七、开启打赏功能"><a class="header-anchor" href="#七、开启打赏功能">¶</a>七、开启打赏功能</h1>
<p>把想要打赏的微信或者支付宝二维码放到路径：<code>themes/next/source/images</code>目录下。</p>
<p>打开主题配置文件，搜索找到Reward。</p>
<p>配置路径。注意图片格式。</p>
<p>开启后发现打赏的时候字体闪动很频繁。解决如下：</p>
<p>打开文件，路径：<code>themes/next/source/css/_common/components/post/post-reward.styl</code>。</p>
<p>注释掉闪动部分代码。如下</p>
<h1 id="八、设置背景图片"><a class="header-anchor" href="#八、设置背景图片">¶</a>八、设置背景图片</h1>
<p>打开文件，路径：<code>themes/next/source/css/ _custom/custom.styl</code>。</p>
<p>添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(你的背景图片URL);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-size: cover;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background:url 为图片路径，也可以直接使用链接，本地路径，例如：&#x2F;images&#x2F;yourbackground.jpg</span><br><span class="line">background-repeat：如果背景图片不能全屏，那么是否平铺显示，充满屏幕</span><br><span class="line">background-attachment：背景是否随着网页上下滚动而滚动，fixed 为固</span><br></pre></td></tr></table></figure>
<p>如果想要选择一个网站，随机选择图片作为背景。</p>
<p><strong>unsplash</strong>网站提供大量高清图片，可随机选择。</p>
<p>只要把背景URL换为下面就行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;source.unsplash.com&#x2F;random&#x2F;1600x900</span><br></pre></td></tr></table></figure>
<h1 id="九、博客内容透明化"><a class="header-anchor" href="#九、博客内容透明化">¶</a>九、博客内容透明化</h1>
<p>有了博客背景，但是博客内容不透明，看起来不太好看，设置一下。</p>
<p>打开文件，路径：<code>themes/next/source/css/_custom/custom.styl</code>。添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;博客内容透明化</span><br><span class="line">&#x2F;&#x2F;文章内容的透明度设置</span><br><span class="line">.content-wrap &#123;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;侧边框的透明度设置</span><br><span class="line">.sidebar &#123;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;菜单栏的透明度设置</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;搜索框（local-search）的透明度设置</span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十、站点运行时间统计"><a class="header-anchor" href="#十、站点运行时间统计">¶</a>十、站点运行时间统计</h1>
<p>打开文件，路径：<code>thems\next\layout_custom\custom.swig</code>。关于<code>custom.swig</code>如果没有，是要新建的，前面哪一期已经新建并配置过，在此不再赘述。添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# 页脚站点运行时间统计 #&#125;</span><br><span class="line">&#123;% if theme.footer.ages.enable %&#125;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;moment@2.22.2&#x2F;moment.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;moment-precise-range-plugin@1.3.0&#x2F;moment-precise-range.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function timer() &#123;</span><br><span class="line">    var ages &#x3D; moment.preciseDiff(moment(),moment(&#123;&#123; theme.footer.ages.birthday &#125;&#125;,&quot;YYYYMMDD&quot;));</span><br><span class="line">    ages &#x3D; ages.replace(&#x2F;years?&#x2F;, &quot;年&quot;);</span><br><span class="line">    ages &#x3D; ages.replace(&#x2F;months?&#x2F;, &quot;月&quot;);</span><br><span class="line">    ages &#x3D; ages.replace(&#x2F;days?&#x2F;, &quot;天&quot;);</span><br><span class="line">    ages &#x3D; ages.replace(&#x2F;hours?&#x2F;, &quot;小时&quot;);</span><br><span class="line">    ages &#x3D; ages.replace(&#x2F;minutes?&#x2F;, &quot;分&quot;);</span><br><span class="line">    ages &#x3D; ages.replace(&#x2F;seconds?&#x2F;, &quot;秒&quot;);</span><br><span class="line">    ages &#x3D; ages.replace(&#x2F;\d+&#x2F;g, &#39;&lt;span style&#x3D;&quot;color:&#123;&#123; theme.footer.ages.color &#125;&#125;&quot;&gt;$&amp;&lt;&#x2F;span&gt;&#39;);</span><br><span class="line">    div.innerHTML &#x3D; &#96;&#123;&#123; __(&#39;footer.age&#39;)&#125;&#125; $&#123;ages&#125;&#96;;</span><br><span class="line">  &#125;</span><br><span class="line">  var div &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">  &#x2F;&#x2F;插入到copyright之后</span><br><span class="line">  var copyright &#x3D; document.querySelector(&quot;.copyright&quot;);</span><br><span class="line">  document.querySelector(&quot;.footer-inner&quot;).insertBefore(div, copyright.nextSibling);</span><br><span class="line">  timer();</span><br><span class="line">  setInterval(&quot;timer()&quot;,1000)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>打开<code>主题配置</code>文件，找到<code>footer</code>。在下面添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ages:</span><br><span class="line">     # site running time</span><br><span class="line">     enable: true</span><br><span class="line">     # birthday of your site</span><br><span class="line">     birthday: 20200610</span><br><span class="line">     # color of number</span><br><span class="line">     color: &quot;#1890ff&quot;</span><br></pre></td></tr></table></figure>
<p><code>birthday</code>为你创建博客的日期，按照自己的来。</p>
<p>打开文件，路径：<code>themes\next\languages\zh-CN.yml</code>。按照下图在<code>footer</code>下添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age: 我已在此等候你</span><br></pre></td></tr></table></figure>
<h1 id="十一、站点访问量统计"><a class="header-anchor" href="#十一、站点访问量统计">¶</a>十一、站点访问量统计</h1>
<p>该功能由不蒜子提供，打开文件，路径：<code>themes\next\layout_partial\footer.swig</code>。在首行添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  async</span><br><span class="line">  src&#x3D;&quot;https:&#x2F;&#x2F;dn-lbstatics.qbox.me&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;</span><br><span class="line">&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>打开主题配置文件，找到<code>busuanzi_count</code>。做如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true # 访客数</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true # 访问量</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>themes\next\layout_third-party\analytics\busuanzi-counter.swig</code>。按照我的部分修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">-   &lt;span class&#x3D;&quot;site-uv&quot; title&#x3D;&quot;&#123;&#123; __(&#39;footer.total_visitors&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">+   &lt;span class&#x3D;&quot;site-uv&quot;&gt;</span><br><span class="line">+     &#123;&#123; __(&#39;footer.total_visitors&#39;, &#39;&lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;&#39;) &#125;&#125;</span><br><span class="line">-     &lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">-     &lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">-   &lt;span class&#x3D;&quot;site-pv&quot; title&#x3D;&quot;&#123;&#123; __(&#39;footer.total_views&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">+   &lt;span class&#x3D;&quot;site-pv&quot;&gt;</span><br><span class="line">+     &#123;&#123; __(&#39;footer.total_views&#39;, &#39;&lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;&#39;) &#125;&#125;</span><br><span class="line">-     &lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">-     &lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>-号表示删除这一行，+号表示增加这一行。增加后把+号删除。</p>
<p>打开文件，路径：<code>themes/next/source/css/_custom/custom.styl</code>。添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;修改不蒜子数据颜色</span><br><span class="line">.busuanzi-value &#123;</span><br><span class="line">  color: #1890ff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开文件，路径：<code>themes\next\languages\zh-CN.yml</code>。修改以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  total_views: &quot;历经 %s 次回眸才与你相遇&quot;</span><br><span class="line">  total_visitors: &quot;我的第 %s 位朋友，&quot;</span><br></pre></td></tr></table></figure>
<h1 id="十二、实现头像旋转"><a class="header-anchor" href="#十二、实现头像旋转">¶</a>十二、实现头像旋转</h1>
<p>打开文件，路径：<code>/themes/next/source/css/_common/components/sidebar/sidebar-author.styl</code>。</p>
<p>在我图片的位置分别增加代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 鼠标经过头像旋转360度 *&#x2F;</span><br><span class="line">  -webkit-transition: -webkit-transform 1.0s ease-out;</span><br><span class="line">  -moz-transition: -moz-transform 1.0s ease-out;</span><br><span class="line">  transition: transform 1.0s ease-out;</span><br></pre></td></tr></table></figure>
<p>在代码末尾添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img:hover &#123;</span><br><span class="line">  &#x2F;* 鼠标经过停止头像旋转</span><br><span class="line">  -webkit-animation-play-state:paused;</span><br><span class="line">  animation-play-state:paused;*&#x2F;</span><br><span class="line">  &#x2F;* 鼠标经过头像旋转360度 *&#x2F;</span><br><span class="line">  -webkit-transform: rotateZ(360deg);</span><br><span class="line">  -moz-transform: rotateZ(360deg);</span><br><span class="line">  transform: rotateZ(360deg);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* Z 轴旋转动画 *&#x2F;</span><br><span class="line">@-webkit-keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-moz-keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -moz-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    -moz-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 自顶向下</title>
    <url>/2020/06/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>链接：<a href="https://wws.lanzous.com/b01bibjub" target="_blank" rel="noopener">https://wws.lanzous.com/b01bibjub</a></strong><br>
<strong>密码:f0uw</strong></p>
<a id="more"></a>]]></content>
      <categories>
        <category>自顶向下方法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>电子书</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>喜马听书笔记【附电子书】（一）</title>
    <url>/2020/06/13/%E5%96%9C%E9%A9%AC%E5%90%AC%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%90%E9%99%84%E7%94%B5%E5%AD%90%E4%B9%A6%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本期包括《坏血》，《雍正继位新探》，《后真相时代》，《掌控习惯》，《神祇、陵墓与学者》，《暗店街》，《幸福过了头》共七本书。</p>
<a id="more"></a>
<p>电子书下载地址：<strong><a href="https://wws.lanzous.com/b01bhamkh" target="_blank" rel="noopener">https://wws.lanzous.com/b01bhamkh</a></strong><br>
<strong>密码:dbn0</strong></p>
<h1 id="001纪实丨《坏血》：“女版乔布斯”如何用贪婪打造价值近百亿美元的硅谷骗局？"><a class="header-anchor" href="#001纪实丨《坏血》：“女版乔布斯”如何用贪婪打造价值近百亿美元的硅谷骗局？">¶</a>001纪实丨《坏血》：“女版乔布斯”如何用贪婪打造价值近百亿美元的硅谷骗局？</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=258322362&type=red" frameborder="0" allowfullscreen></iframe>
<p><strong>精华笔记</strong></p>
<p>2004年，伊丽莎白.霍姆斯创立了一家名为“希拉洛斯”的公司，号称研发出了一种革命性的技术，只用一滴血就能进行250项医疗检测。她的公司仅用十年就成长为估值90亿美元的硅谷“独角兽”，伊丽莎白本人也被誉为“女版乔布斯”。</p>
<p>然而光鲜的背后，是一场彻头彻尾的骗局：希拉洛斯声称的革命性技术是虚构的。2015年，本书的作者约翰.卡雷鲁在《华尔街日报》上首次公开报道了希拉洛斯的骗局，使这家公司轰然倒塌。接着他又花了3年的时间，写成了《坏血》这本书，不仅重现了骗局始末，也详细记录了自己戳穿骗局的过程。</p>
<p>一、 为什么说希拉洛斯是一场骗局？</p>
<ol>
<li>伊丽莎白的志向</li>
</ol>
<p>伊丽莎白出生在精英家庭，从小就希望成为亿万富翁。考入斯坦福大学化学工程系之后，因为自己对针头的恐惧，和对专业知识的一点了解，立志成立公司改变传统的验血方式。希拉洛斯的愿景是，在一个巴掌大的机器里，能完成一滴血做数百项检测的任务。</p>
<ol start="2">
<li>公司的三次失败实验</li>
</ol>
<p>这个愿景也是专业人员努力了二十多年都没能实现的目标，希拉洛斯实际上也做不到。伊丽莎白找来的第一支团队，发现两个无法克服的障碍：一个是一滴血太少，必须大量稀释才能做多项检测，但稀释太多则测不准；第二是机器太小，在巴掌大的空间里完成多种液体的分流、彼此逐一发生化学反应，是做不到的。</p>
<p>第二支团队也没能克服这两个障碍，只是用简易的机器人替换掉之前用泵和阀门来完成的化学反应，勉强做成了漏洞百出的产品。此外，伊丽莎白找来第三支团队，把市面上多种检测设备买来，希望把它们微缩化放到一个盒子里，然而直到希拉洛斯倒闭，这个产品都没做成。</p>
<p>二、为什么这场金玉其外、败絮其中的骗局可以维持十五年呢？</p>
<p>在产品没做成的基础上，希拉洛斯还是成为了硅谷“独角兽”，之所以能成功，在于伊丽莎白对内和对外采取的手段。</p>
<ol>
<li>对公司内部，她实施了四种程度递增的措施：</li>
</ol>
<p>1） 隔离信息：伊丽莎白不允许不同部门之间的交流，甚至不能彼此发送信息。这就使得没有员工掌握公司全局，对公司的不满也只能止步于怀疑。</p>
<p>2） 监视员工：伊丽莎白习惯于监视员工，包括他们的上下班时间、邮件、网页浏览历史、甚至脸书，还鼓励员工互相“扒料”。这种文化下，员工不敢轻易跟同事和外人吐露怀疑。</p>
<p>3） 威胁解雇：对于敢于直接向伊丽莎白表露质疑的员工，几乎全部都会遭遇无理由解雇。</p>
<p>4） 法律震慑：无论是被解雇，还是自己辞职，员工都需要签署极为严格的保密协议。公司花钱最多的地方就是法律费用，伊丽莎白想让所有个体负担不起和公司打官司的费用，进而让他们闭嘴。</p>
<ol start="2">
<li>对外，伊丽莎白能够维持骗局在于以下三个原因：</li>
</ol>
<p>1） 伊丽莎白的个人魅力：她的勃勃生机、满怀壮志是典型创业家的形象，从外貌、嗓音到话术，她非常容易说服投资人、合作者和想要招入麾下的员工。</p>
<p>2） 善于包装公司：伊丽莎白租下了硅谷最贵的地区，找来了最贵的广告公司包装自己和产品，显得希拉洛斯像生物医疗行业的“苹果”。</p>
<p>3） 善于撒谎：伊丽莎白几乎是全方位地对外撒谎，从盈利情况、商业合同、PPT、甚至现场演示结果都是编造的，而且希拉洛斯也始终游走在监管的空白地带。</p>
<p>三、记者如何与伊丽莎白斗智斗勇？</p>
<p>在伊丽莎白声名最盛的2014年底，有医学博士在博客质疑了她的浅薄，同时爆料给了作为《华尔街日报》记者的本书作者。作者由此展开了10个月左右的调查。</p>
<ol>
<li>
<p>起初，记者遇到最大的困难是没有合适的信息源，和伊丽莎白打官司的人不能完全采信，也不能全部都是匿名信息源，但保密协议下无人肯实名爆料。于是记者同时去了希拉洛斯的线下门店听医生检测失误的抱怨并亲身检测。</p>
</li>
<li>
<p>作者终于遇到了一位实名爆料人，泰勒.舒尔茨曾在希拉洛斯工作，爷爷还是前国务卿和希拉洛斯的董事。在他发现伊丽莎白的骗局并接受采访后，连续几个月受到跟踪、威胁，最终搭上了人民币200多万元的诉讼费，却没有后悔过。</p>
</li>
<li>
<p>这时，希拉洛斯代表团和《华尔街日报》进行了两次面对面交锋，并不断传来律师函，威胁他们不允许做报道。同时，《华尔街日报》的老板默多克，也是希拉洛斯最后一轮融资的最大投资人，也被四次“公关”，但他始终不肯干预编辑对稿件的判断，不肯撤稿。</p>
</li>
</ol>
<p>2015年10月，这篇报道终于发出来了，引起轩然大波。并在伊丽莎白和《华尔街日报》之间开始了拉锯战。最终，希拉洛斯的谎言在CMS的检查报告中大白于天下：他们的检测大多是在别人的机器上做的，自己的机器做的检测还非常不准确。之后，希拉洛斯倒闭，伊丽莎白受到刑事诈骗起诉，投资人损失10亿美金。</p>
<p>文末，作者评论道：“过度承诺”和“演久成真”的风气在硅谷蔓延，人们往往敢于把还没做到的事情拿出去宣传，然后用谎言遮盖谎言，去募资、招人、寻找合作，希望现实最终能赶上自己的吹嘘。但这一套用在医疗产品上，就是致命的。</p>
<p>最终，是希拉洛斯前员工们的医疗从业者的良知、《华尔街日报》的新闻专业主义精神，合力戳穿了这场骗局，让谎言回归常识。</p>
<p>作者：[美]约翰.卡雷鲁</p>
<h1 id="002历史丨《雍正继位新探》：清史专家断案“九子夺嫡”事件，四爷靠什么逆袭？"><a class="header-anchor" href="#002历史丨《雍正继位新探》：清史专家断案“九子夺嫡”事件，四爷靠什么逆袭？">¶</a>002历史丨《雍正继位新探》：清史专家断案“九子夺嫡”事件，四爷靠什么逆袭？</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=256992516&type=red" frameborder="0" allowfullscreen></iframe>
<p><strong>听书笔记</strong></p>
<p>本书作者冯尔康是著名清史专家、南开大学教授。他查阅了大量原始史料，进行比对、分析，还原了雍正继位的整个过程，得出了雍正是合法继位的结论。今天，我将分成四个部分，为你讲述雍正继位之谜。</p>
<p>先说第一部分，雍正是在什么背景下参与夺储之争的。</p>
<p>康熙十四年，年仅两岁的二阿哥胤礽被册立为太子。随着年龄渐长，二阿哥一直处在一种渴望接班，却迟迟接不了班的尴尬状态中。他急于继位，竟然谋划政变，想逼康熙退位。</p>
<p>康熙识破了二阿哥的阴谋，于康熙四十七年废黜其太子之位。这就是第一次废太子事件。那之后，诸位阿哥开始争夺空出来的储君之位，雍正就是在此时加入夺储之争的。</p>
<p>第二部分，夺储之争。</p>
<p>先说第一个阶段：明争。</p>
<p>最先跳出来的是大阿哥胤禔。为了尽早当上太子，大阿哥向康熙提议，杀掉废太子，永绝后患。他还自告奋勇，表示愿意揽下这趟差事。</p>
<p>大阿哥的举动惹怒了康熙。他万没想到，大阿哥是如此狠毒的一个人，竟然要对亲弟弟下手。震怒之下，康熙剥夺了大阿哥的王爵，把他交给宗人府，终生圈禁。</p>
<p>宫斗大戏的帷幕才掀开一角，第一个竞争者，大阿哥胤禔就出局了。</p>
<p>下一个跳出来的，是八阿哥胤禩。吸取二阿哥的教训，八阿哥没有主动跳出来，而是采取了迂回策略。</p>
<p>康熙四十七年十一月，即太子被废黜后两个月，康熙命群臣举荐新太子。八阿哥见状积极联络大臣，给自己造势。于是，由马齐、阿灵阿领衔，群臣共同推举八阿哥。连已经退休的元老重臣佟国维，都出面保举他。</p>
<p>然而，此举在康熙看来，无异于八阿哥背着他结党营私，对皇权产生了威胁。康熙不仅对大臣的推举不认账，还把领头保荐八阿哥的大学士马齐革职、拘禁。</p>
<p>在阿哥当中，能揣摩康熙本意的，只有四阿哥胤禛，也就是雍正。当康熙要求群臣推举新太子时，雍正力保二阿哥。这正符合老皇帝的心意，对雍正另眼相看。</p>
<p>果然，康熙四十八年三月，康熙正式宣布，重新立二阿哥为太子。可惜好景不长，二阿哥再度谋划政变，失望透顶的康熙，再度废黜了他。</p>
<p>接着讲夺储之争的第二个阶段：暗斗。</p>
<p>暗斗的主人公，是四阿哥雍正和十四阿哥胤禵。他们竭尽所能，加大自己在康熙心目中的分量。</p>
<p>先看雍正。表面上，雍正走的是低调路线，成天吃斋念佛，同喇嘛讨论佛法，自称“天下第一闲人”。而实际上，雍正是抓住了康熙的软肋，大打亲情牌。</p>
<p>二阿哥再度被废后，康熙郁郁寡欢。雍正经常邀请康熙来自己的私家花园，游玩散心。雍正还让儿子乾隆作陪，让康熙感受祖孙之情，大为宽慰。</p>
<p>当然，光打亲情牌是不够的。作为皇位继承人，治国理政的才能，才是最重要的。</p>
<p>为此，雍正采取两面手法。对康熙交办的事，他尽心尽力完成，展现出认真负责、雷厉风行、奖罚分明的办事特点。同时刻意保持低调。做任何决定，都要先揣摩康熙的意思；事情办成了，不居功自傲，都归功于皇阿玛的英明领导；平时也小心谨慎，不和大臣往来。这样，雍正就在康熙心目中，树立了有才干又安分的良好形象。</p>
<p>而暗地里，雍正结交党羽，为继位培植私人势力。这一切，都是背着康熙干的。</p>
<p>尽管康熙对雍正大体满意，但他也有短板：军事才能平平。这方面的能力，十四阿哥胤禵就要胜出一筹了。</p>
<p>康熙五十七年，康熙封十四阿哥为抚远大将军，命他代父出征，讨伐准噶尔部的进犯。十四阿哥果然争气，完成了任务。他的统帅也才能得到充分体现。一时之间，十四阿哥凭赫赫战功，晋升皇太子，似乎大有希望。</p>
<p>在生命的最后日子里，康熙也的确在雍正和十四阿哥之间犹豫，吃不准该选谁。直到弥留之际，才做出选择：命雍正继位。</p>
<p>第三部分，康熙驾崩那晚，雍正究竟靠什么，取得了最终胜利？这里起关键作用的，是距离远近。</p>
<p>康熙病危时，十四阿哥远在千里之外，回京需要很长时间。等他回来继位，空档期长，变数多。弄不好，有野心的阿哥发动政变，局面将难以控制。雍正则近在身边，可以立刻继位，实现皇权的平稳交接。因此康熙当机立断，命雍正继位。</p>
<p>在这个过程中，雍正的两个党羽，隆科多和年羹尧，起了重要作用。康熙遗命，就是步军统领隆科多传达的。康熙病逝次日，京城九门关闭，诸皇子禁止进入大内。这些事，也是由掌握京城防御的隆科多，亲手操办。</p>
<p>年羹尧时任川陕总督，十四阿哥统领的西北远征军，驻扎甘州。后勤保障依赖年羹尧，要向京城进兵，也要先经过川陕地区。所以他不敢轻举妄动，只能奉诏回京。</p>
<p>从整个过程来看，雍正是合法继位，并不存在篡位的情况。</p>
<p>第四部分，雍正何以这么不受人待见，以至于在历史上留下了暴君的名声呢？</p>
<p>外部原因。</p>
<p>雍正继位后，他的政敌极度愤恨，编造故事，四处宣扬。很多民间传闻，比如雍正毒死康熙、雍正篡改遗诏等待，都源自雍正的政敌。此外，由于雍正推行的一些政策，损害了士绅阶层的利益，导致一些人在私底下传扬宫廷丑闻，以此发泄怨恨。</p>
<p>外部原因。</p>
<p>第一，雍正诛杀隆科多、年羹尧这两个功臣，让人怀疑他是杀人灭口，掩饰篡位的事实。</p>
<p>第二，撰写《大义觉迷录》，为自己辩护。结果适得其反，让人觉得他是做贼心虚。并且，由于《大义觉迷录》大量引发，反倒让更多人知道了夺储之争，生发出更多离奇的故事。</p>
<p>乾隆继位后，立刻将《大义觉迷录》全部收回、销毁。然而一切都晚了。围绕雍正继位的种种阴谋论，已经在民间扩散，覆水难收。</p>
<p>作者：冯尔康</p>
<h1 id="003社科丨《后真相时代》：-当真相被操纵和利用时如何思考"><a class="header-anchor" href="#003社科丨《后真相时代》：-当真相被操纵和利用时如何思考">¶</a>003社科丨《后真相时代》： 当真相被操纵和利用时如何思考</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=256059452&type=red" frameborder="0" allowfullscreen></iframe>
<p>读书笔记</p>
<p>这些年来，想要了解一件事情的真相，似乎变得越来越难。各种各样的说法经常前后矛盾，我们的情绪也随之大起大落，很多人常常还没搞清楚真相是什么，就稀里糊涂地站了队。而在《后真相时代》这本书里，作者就把这种真相和逻辑被忽视，情绪主导舆论的情形，概括为“后真相”。</p>
<p>《后真相时代》的作者赫克托·麦克唐纳是美国的商业咨询专家。他认为，真相就像一个多面体，别有用心的人只会描述其中的一面。一个人即使说的都是真话，也可以对真相进行刻意的挑选、裁剪和操纵，制造出各种各样的花招和陷阱。而在《后真相时代》这本书中，麦克唐纳就用生动的案例，向我们展示了真相如何被挑选、肢解、扭曲和掩盖的，帮助我们打开思路，更全面、更理性地认识这个世界。</p>
<p>“后真相”有四种表现形式：</p>
<p>一、片面真相</p>
<p>它指的是，我们获得的大部分信息虽然是真实的，但没有传达出完整的真相，而是被选择过、被剪裁过的真相。片面真相产生的原因：</p>
<p>1.事物的“复杂性”。在我们的生活中，即使是最平凡的事物也是非常复杂的，我们很难看到全貌，所以在认识一个事物时，我们往往会遗漏掉很多重要的方面。</p>
<p>2.事物的“背景”。很多时候，我们对于一个事物的看法取决于背景，而不取决于事物本身。这里的背景指的是与一件事物有关系的因素，所有这些因素都会影响我们的看法，进而影响我们的行动。</p>
<p>3.貌似客观的“数据”。我们经常觉得数据是客观的，殊不知在传播过程中，只要为数据选择不同的统计单位和统计方式，就会造成非常不一样的传播效果。</p>
<p>二、主观真相</p>
<p>“主观真相”指的是会受到道德、吸引力等主观因素影响的所谓“真相”。当你宣布某件事物很好、很有吸引力或者很有价值时，你其实是在表达主观真相。由于这种真相是“主观的”，所以它是可以被改变的。</p>
<p>换言之，什么是道德的，什么是不道德的；什么是好看的，什么是不好看的；什么是值钱的，什么是不值钱的……在不同的时代、不同的社会、不同的群体中都可能都有不一样的看法，而且很多时候，这些看法是可以被利用、被操纵的。</p>
<p>三、人造真相</p>
<p>很多时候，我们会为事物下定义和起名字，而这些定义和名字又常常会反过来，对现实产生影响。因为这些定义和名字都是人造的，所以叫做“人造真相”。</p>
<p>1.人们在给事物下定义之后，经常会根据自己的现实需要去利用定义，从而回避了本来的真相，或者误导了信息的接受者。</p>
<p>2.人们在给事物起名字的时候，也经常怀有命名之外的目的，比如煽动情绪，或者抹黑对手。</p>
<p>四、未知真相</p>
<p>它指的是，不同的人对未来持有不同的看法。在未来变成现实之前，只要我们无法证明这些看法是错误的，那么所有这些看法也都可以被看作是真相，并且对现实产生影响。导致“未知真相”产生的因素</p>
<p>1.预测。人们基于不同立场，往往会对未来做出不同的预测，还会根据预测采取不同的行动，因为这些预测对现实产生了直接影响，所以它们应该被看作是一种真相。</p>
<p>2.信仰。人们会对未来怀有某些坚定的信仰，会将这些信仰的内容视为真相，并会以此为依据开展行动。</p>
<p>作者：[英]赫克托·麦克唐纳</p>
<h1 id="004心理丨《掌控习惯》：四条黄金定律，帮你轻松养成好习惯"><a class="header-anchor" href="#004心理丨《掌控习惯》：四条黄金定律，帮你轻松养成好习惯">¶</a>004心理丨《掌控习惯》：四条黄金定律，帮你轻松养成好习惯</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=255115489&type=red" frameborder="0" allowfullscreen></iframe>
<p>精华笔记</p>
<p>本书作者詹姆斯·克利尔是习惯培养领域的专家，他在《时代》、《福布斯》等主流媒体上连载习惯相关的文章，并创办了自己的培训平台“习惯学院”，许多世界500强企业都把员工送到这里参加培训，有超过1万名的经理、教练和老师从习惯学院毕业。</p>
<p>习惯的培养分成四个步骤：</p>
<p>**1、提示：**这是外界环境的线索，它让我们意识到，某种行动会带来奖励。</p>
<p>**2、渴求：**我们对奖励的欲望，欲望越强，就越容易行动起来。</p>
<p>**3、反应：**为了得到奖励，要采取的具体行动。</p>
<p>**4、奖励：**奖励会满足我们的渴求，并激励我们寻找更多提示，继续行动获得奖励，形成一个良好的循环。</p>
<p>本书的主要内容，就是对应这四个步骤的四条定律。</p>
<p><strong>第一定律：让习惯显而易见</strong></p>
<p>1、建立习惯记分卡来反思习惯：</p>
<p>通过分析现有习惯的性质，我们会加强对习惯的印象，当习惯发生时能立刻觉察到，从而更好地坚持坏习惯，戒除坏习惯</p>
<p>2、制定执行意图：</p>
<p>按照“如果发生情况A，我就采取行动B”的形式，来制定培养习惯的计划。A的常见形式是具体的时间地点，这会让习惯的提示线索更明显。</p>
<p>执行意图的特殊形式是习惯叠加，习惯叠加里的情况A是已有习惯，这能更有效地激活行动，培养新习惯。</p>
<p>3、改变环境提示：</p>
<p>很多时候人们的行为，并没有经过大脑的深思熟练，而是受到环境的影响。因此我们可以突出习惯对应的环境提示，来培养好习惯，消除环境中的提示，来戒除坏习惯。</p>
<p>我们还可以把习惯和特定环境联系在一起，让环境本身成为提示，在分工明确的稳定环境中，好习惯会更容易培养。</p>
<p><strong>第二定律：让习惯有吸引力</strong></p>
<p>1、绑定喜好：</p>
<p>把需要做的事，和喜欢做的事联系起来。</p>
<p>2、加入特定的群体：</p>
<p>人类最深层的愿望之一，就是群体归属感。当某种习惯有助于我们融入群体，它就有了更强的吸引力。</p>
<p>我们可以和有好习惯的亲朋好友多接触互动，或模仿自己羡慕的成功人士。</p>
<p>3、强调习惯带来的结果：</p>
<p>多思考好习惯的益处和坏习惯的危害，并寻找替代坏习惯的其他行为。</p>
<p><strong>第三定律：让习惯简便易行</strong></p>
<p>1、改变习惯的阻力：</p>
<p>通过优化环境，来降低行动的阻力。也可以减少好习惯的准备步骤，增加坏习惯的准备步骤。</p>
<p>2、两分钟规则：</p>
<p>一开始培养新习惯，它所用的时间应该不超过两分钟。</p>
<p>这能降低行动开头的阻力，把习惯先建立起来，以后再找机会去改善优化。它还会改变我们对自己身份的理解，让我们主动坚持好习惯。</p>
<p>3、建立承诺机制：</p>
<p>提前预定好未来的安排，逼迫自己行动起来。我们可以通过技术手段和他人的帮助，来建立承诺机制。</p>
<p><strong>第四定律：让习惯令人愉悦</strong></p>
<p>1、改变即时奖励：</p>
<p>让习惯的好处更明显，或是增加额外奖励，来培养好习惯。也可以寻找问责伙伴加强惩罚，来戒除坏习惯。</p>
<p>2、追踪习惯：</p>
<p>记录下自己的习惯轨迹，这种追踪行动本身就是即时奖励，让我们觉得自己在不断进步。它能提醒我们不要半途而废。</p>
<p>作者：[美] 詹姆斯·克利尔</p>
<h1 id="005历史丨《神祇、陵墓与学者》：从考古学揭开人类早期文明之谜"><a class="header-anchor" href="#005历史丨《神祇、陵墓与学者》：从考古学揭开人类早期文明之谜">¶</a>005历史丨《神祇、陵墓与学者》：从考古学揭开人类早期文明之谜</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=252043119&type=red" frameborder="0" allowfullscreen></iframe>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=252907556&type=red" frameborder="0" allowfullscreen></iframe>
<p><strong>读书笔记</strong></p>
<p>考古学是一门非常重要的学科，因为人们想了解过去的事情，特别是几千年前的历史，很大程度上，要依赖考古学。那么，考古学家都是些什么人，他们是怎么工作的？考古学又是如何诞生和发展的？它对认识古文明，究竟起到了什么作用？《神祇、陵墓与学者》这本书，就能满足你的好奇心。</p>
<p>首先来讲考古学奠基人——德国的温克尔曼。</p>
<p>1717年，温克尔曼生于德国的一个鞋匠家庭。他家境平平，没有受过太好的教育。不过，温克尔曼自幼喜欢古董和文物，三十出头的时候，温克尔曼来到德国德累斯顿，成了一名图书管理员。</p>
<p>温克尔曼对古希腊、罗马时期的文化和艺术，产生了浓厚兴趣，并花大力气进行研究。1755年他出版了对古希腊、古罗马的雕像艺术进行解读的专著，逐渐有了名气。与此同时，赫库兰尼姆和庞贝这两座古城有大量珍贵文物出土的消息，也传到了温克尔曼耳朵里。他决定实地探访一番。</p>
<p>然而，温克尔曼是德国人，根据卡尔国王的命令，外国人是不允许进入发掘现场的。实地探访的设想落空了。经过努力，温克尔曼获准参观博物馆，一睹文物的真容。但对方又有新的规定：只许看，不许记录。</p>
<p>温克尔曼只能采取非正常手段，贿赂博物馆工作人员，才给一些文物画了像。然而要做研究，这当然是远远不够的。幸运的是，温克尔曼结识了修士皮亚吉。皮亚吉致力于保存和修复古代的莎（suo）草纸文卷。这些莎草纸上记录了大量涉及古希腊历史、音乐、艺术等领域的内容。这让温克尔曼得以把文物和文献资料相结合，进行研究。</p>
<p>1762年，温克尔曼根据已经掌握的资料，写了篇通讯稿，介绍赫库兰尼姆古城遗址。两年后他搜集到更多资料，又写了篇通讯稿，还出版了专著《古代艺术史》。</p>
<p>这两篇通讯稿加一部专著，在考古学上具有里程碑意义。因为它正式确立了考古学作为一门独立学科的地位。</p>
<p>德国考古学家：海因里希·施里曼</p>
<p>如果说温克尔曼的贡献，是揭示了一千年前的古罗马社会；那么施里曼，就往前推进了一千年，帮助人们了解了两千多年前的古希腊社会。</p>
<p>说起来，施里曼还是半路出家。1822年，他出生于德国北部的一座小村庄，父亲是当地牧师。平时，父亲喜欢给施里曼讲《荷马史诗》里的故事。通过父亲绘声绘色的讲述，他从小就对特洛伊战争、木马计、海伦、阿喀琉斯这些古希腊传说，心生向往。七岁那年，施里曼立下志愿：长大了要当一名考古学家，找到特洛伊遗址！</p>
<p>1864年，42岁的施里曼在商业上取得成功之后，宣布退出商界，全身心投入考古工作。</p>
<p>他的第一站，选在了土耳其西南部的一座小村庄——布纳尔巴什。当时的考古学家普遍认为，此处的某座山丘下，就埋着特洛伊古城的遗迹。他雇了向导，在村子里寻找，结果令他大失所望。</p>
<p>施里曼不死心，他回想了一遍《荷马史诗》的情节。根据描述，希腊联军是坐着战船远征的。等船靠岸，联军登陆的当天，就向特洛伊城发起了进攻。这也就是说，特洛伊城距离海岸线应该比较近，否则联军不可能这么快走到。</p>
<p>施里曼还意识到另一个问题。一般来说，古城遗址附近总会有些散落的文物，可施里曼里里外外翻了个遍，连个碎陶片都没见着。种种迹象都表明，特洛伊城遗址不在布纳尔巴什。</p>
<p>那能在哪儿呢？施里曼把目光投向了另一个村落——希沙利克。它位于布纳尔巴什北面，离大海很近，希腊联军要在登陆后赶过去，不会太费力。更重要的是，希沙利克有一座外表挺奇特的小土丘。看起来不像是自然形成的，而是人工建造的。施里曼推断，土丘下面应该埋藏着一幢建筑。那是什么建筑呢？</p>
<p>从1870年4月动工到1873年6月停止，施里曼带领团队埋头挖了三年多，收获之大，出乎所有人的意料。土丘下面居然挖出了整整九座古城！其中，令施里曼日思夜想的特洛伊城，位于第六层。</p>
<p>特洛伊城重见天日，震惊了整个西方，施里曼也成为家喻户晓的考古明星。</p>
<p>施里曼在继温克尔曼之后，将考古学的理论和方法又往前推了一步。在施里曼之前，《荷马史诗》仅被当作文学作品。书中描写的人物、情节和对话，都被认为是虚构的。连特洛伊战争是否发生过，海伦、阿伽门农、奥德修斯这些人是否存在过，都备受质疑。</p>
<p>施里曼之所以能找到特洛伊和迈锡尼古墓葬，都是从《荷马史诗》等古希腊著作中寻找到的线索。这表明《荷马史诗》内容是可靠的，能够作为考古依据。</p>
<p>对此，考古学界是认可的。很多考古学家也开始认真研读古希腊、古罗马时期的古籍，期望能有新的收获。</p>
<p>英国考古学家：阿瑟·埃文斯</p>
<p>阿瑟·埃文斯生于1851年，比施里曼小将近30岁。他的教育背景很扎实，中学就读于英国著名贵族学校——哈罗公学。后来又在英国牛津大学、德国哥廷根大学，攻读历史学和考古学。所以比起施里曼，埃文斯是货真价实的科班出身。</p>
<p>1900年，埃文斯登上克里特岛，本来只想逛一逛，没成想，被大量的废墟和遗迹迷住了。他临时起意，要在岛上进行考古发掘。地点，就选在施里曼当年看中的克诺索斯。</p>
<p>发掘工作出人意料的顺利。挖了几个小时，就发现一堵墙，埃文斯判断，这是一座宫殿的宫墙。过了几周，考古人员清理出了约800平米的建筑遗迹。最终，一座占地2.5万平方米的宫殿，出现在世人面前。</p>
<p>经过深入考察，埃文斯确认，这里就是米诺斯国王的宫殿。随即，他向外界宣布找到了米诺斯文明的遗址。</p>
<p>埃文斯并没有因此满足，而是继续进行发掘和研究。考古人员曾经在米诺斯文明遗址中挖出2000多块陶土板，上面刻着某种线形文字。因年代久远，无人能辨识，埃文斯就把主要精力，投向了对线形文字的破解上。</p>
<p>他首先发现，不同陶土板上的线形文字是不同的。经过比对，埃文斯把线形文字分成A和B两种类型。进一步的研究表明，施里曼从迈锡尼遗址中找到的泥板上刻着的文字，同线形文字B一致。这说明，迈锡尼文明受到米诺斯文明的影响，甚至可能就是它的继承者。</p>
<p><strong>读书笔记</strong></p>
<p>古埃及文明。</p>
<p>很长时间里，欧洲人对埃及的早期历史并不太清楚。1798年5月，拿破仑率军渡过地中海，随同前往的学者们，搜集了大量文物，包括雕塑、石碑、莎草纸等。这在法国乃至整个欧洲，掀起了一股“埃及热”。</p>
<p>人们对古埃及文明的好奇心空前高涨。其中最吸引人的是两大谜团，象形文字之谜和法老陵墓之谜。</p>
<p>我先讲第一个谜团，象形文字之谜。解开这个谜团的，是法国考古学家、语言学家商博良。</p>
<p>法军在埃及的港口城市罗塞塔发现了一块石碑，称为罗塞塔碑。它由玄武岩制成，刻有三种铭文，分为三栏。第一栏是古埃及象形文字；第二栏是古埃及世俗语，就是平民使用的文字；第三栏则为希腊语。</p>
<p>刚开始商博良也是一头雾水。后来他决定，舍弃那种一个符号、一个符号破解的笨办法，而是从整体上把握。他不仅研究罗塞塔碑，还运用其他的古埃及语碑文，不断进行比对。这个过程中，商博良掌握的科普特语起了关键作用。科普特语是从象形文字演变而来的，而且使用至今，堪称古埃及语的活字典。商博良由此入手，破解了象形文字之谜。这对于古埃及考古工作，产生了实质性的推动作用。从此以后，考古学家就能根据存世的象形文字记录，排出古埃及历代王朝和法老的年表。</p>
<p>古埃及文明的第二大谜团，是法老陵墓之谜。揭开这个谜团的，是英国考古学家弗林德斯·皮特里。</p>
<p>1880年，27岁的皮特里来到吉萨，开始勘查。一天晚上，他找到大金字塔的入口，钻了进去，直到深夜才爬出来，已然是汗流浃背、满眼血丝。</p>
<p>皮特里都干了些什么呢？他在考察内部结构，进行测量。令皮特里兴奋的是，他还找到一段铭文，提到了“胡夫”的名字。由此证明，大金字塔的主人，是埃及第四王朝第二位法老——胡夫。大金字塔于是就命名为“胡夫金字塔”。</p>
<p>据皮里特计算，胡夫金字塔耗费了230万块巨石，高136余米，相当于今天的40层楼。埃菲尔铁塔诞生前，它是世界上最高的建筑。在古代，完成如此浩大的工程，需要动用的劳动力是相当惊人的。</p>
<p>那为什么法老宁愿冒着亡国的风险，也要建金字塔呢？为了搞明白这个问题，皮里特深入考察了古埃及人的社会风俗、思想观念。随后指出，建造金字塔是宗教信仰决定的。古埃及人秉持“灵魂不灭”的观念，人死了，生命并没有终结，而是进入另一个世界。在这个世界，人拥有的东西，包括食物、房子、珠宝、奴隶，同活着的时候一样。所以法老们竭尽所能，把生前享受的一切，统统搬进金字塔，甚至更奢侈、更豪华。</p>
<p>两河流域古文明</p>
<p>所谓两河，指幼发拉底河和底格里斯河。下面我就讲一讲，两河流域最重要的两大古文明，亚述文明和巴比伦文明，是如何被考古学家发现的。</p>
<p>先说意大利考古学家保罗·博塔等人发现亚述文明。</p>
<p>博塔1803年生于法国，父亲是著名历史学家。1840年，他被派往法国驻摩苏尔领事馆任职。在摩苏尔郊外，他看到了一些奇怪的土丘。这些土丘顶部平坦、四面陡峭，不像自然形成的。这激起了博塔的好奇心：难道土丘下埋藏着什么秘密吗？</p>
<p>博塔是个急性子，选了个土丘就挖起来。可什么也没有。正当博塔绝望的时候，一个当地人跑来告诉他，离此地十几公里有个叫科尔萨巴德的村子，有好多刻着文字的砖头。</p>
<p>博塔抱着试试看的想法，派下属去打探。一周后下属回来报告，村民所言不虚，他们选了个土丘开挖，不一会儿就挖到一堵墙，上面刻着奇奇怪怪的东西，看样子蛮古老的。博塔一听，骑上马奔向科尔萨巴德村，他倒要看一看，墙上究竟刻的什么。</p>
<p>结果，眼前的景象把博塔惊呆了。那堵墙上刻满壁画、浮雕，而且画面稀奇古怪，有长满络腮胡子的大汉、长着翅膀的走兽，等等。这些形象对欧洲人十分陌生，博塔在其他地方也没见过。他意识到，这堵墙，不简单啊！</p>
<p>于是，博塔把所有人手都召唤过来，集中挖掘。一堵又一堵墙被挖了出来。同时，博塔通知了法国政府。法国政府闻讯后，动员各方力量，支持此次考古行动。</p>
<p>从1843年到1846年，博塔挖了三年，最后呈现的，是一整座宫殿。这座宫殿有70多个房间，摆满了雕塑品。宫墙长约三公里，上面刻有铭文和浮雕，内容，是宫殿的主人是如何生活、狩猎和战斗的。</p>
<p>博塔分析后认为，这是亚述帝国的王宫。而王宫所在地，就是《圣经》提到过的尼尼微。</p>
<p>博塔成功的消息传来，让另一位考古学家奥斯汀·亨利·莱亚德激动不已。他决定到博塔挖过的地方，再去试试。</p>
<p>1849年秋天，莱亚德开始在摩苏尔郊外挖掘。果然，发掘出了一片规模宏大的建筑群，包括王宫、神殿、广场、街道等等。经考证，这是亚述帝国最强悍的统治者——辛那赫里布的居住地。</p>
<p>尽管损毁严重，这些遗迹还是令人叹为观止。不过，要说分量最重的发现，还得是楔形文字。莱亚德的助手，挖出了一座图书馆，里面藏着三万块刻满楔形文字的泥板。</p>
<p>对于考古界可以说是天大的喜讯。英国考古学家亨利·罗林森尤其兴奋。</p>
<p>和博塔、莱亚德一样，罗林森的正式身份也是外交官，做过英国驻巴格达总领事。近水楼台先得月，罗林森第一时间拿到了泥板，进行研究。</p>
<p>罗林森先去学古波斯文，掌握后，再来对照楔形文字，进而成功破解了楔形文字。通过解读楔形文字，并配合出土文物，考古学家们终于梳理出了亚述文明的历史脉络：大约在公元前3000年，亚述文明兴起于底格里斯河中游，经过两千多年发展，才逐渐形成亚述帝国。鼎盛时期，亚述帝国是两河流域的霸主，四处征伐。直至公元前612年，巴比伦联军攻陷尼尼微，亚述灭亡。</p>
<p>那么，覆灭亚述的巴比伦，又是怎么回事呢？下面，我就来讲巴比伦文明的故事。</p>
<p>这里将要出场的，是德国考古学家科尔德维。科德维尔生于1855年，大学学的是考古、建筑和艺术史。毕业后，他先在希腊考古，后来到了两河流域。1899年3月，科尔德维来到巴格达以南约90公里处，传说中的巴比伦古城遗址。</p>
<p>起初，发掘工作的确非常顺利，可接下去越来越艰难。科尔德维率领200多名考古人员，居然整整挖了15年。所谓天道酬勤，科尔德维的付出没有白费。最终清理出的巴比伦古城，比尼尼微还庞大，光是用于防御的塔楼，就修了600多座。城内遍布街道，宫殿和神庙耸立。而其中最具轰动效应的，就是巴别塔遗址。</p>
<p>对巴别塔铭文和巴比伦古城的研究，让考古学家认识到，巴比伦文明非常悠久。它的历史脉络是这样的：距今约5000年前，巴比伦人就已经兴起，并建立了古巴比伦国。它的第六任君主汉谟拉比，统一两河流域，颁布了著名的《汉谟拉比法典》。古巴比伦国达到鼎盛。后来，崛起于小亚细亚的赫梯帝国入侵两河流域，古巴比伦国灭亡。</p>
<p>下面，我将聚焦两位探险家即科尔特斯和斯蒂芬斯的故事，来介绍古老的阿兹特克文明和玛雅文明，是如何进入现代人视野的。</p>
<p>第一个出场的，是西班牙探险家埃尔南·科尔特斯。</p>
<p>1511年，科尔特斯参加了西班牙征服古巴的战争。期间，他听说墨西哥有一个阿兹特克帝国，动起了去探险的念头。凭借先进的武器和高超的政治手腕，科尔特斯率领区区1000多名士兵，击败了阿兹特克帝国的十万大军，攻入墨西哥城。</p>
<p>从考古学的角度来说，科尔特斯以这样的方式“发现”阿兹特克文明，造成的损害远比收益大。后世的考古学家发现，阿兹特克人在天文、医学、建筑等领域，都取得了不亚于古埃及人的成就。只可惜，这个被西班牙殖民者掠夺和损毁的文明，已无法复原。</p>
<p>阿兹特克人是11世纪迁居墨西哥平原的。奇怪的是，考古学家在阿兹特克文明遗址中发现，有些建筑和雕刻，明显起源于几千年前。也就是说，阿兹特克之前，应该有过更古老的文明。那它是什么呢？</p>
<p>这就是我下面要讲的，斯蒂芬斯发现玛雅文明的故事。</p>
<p>约翰·劳埃德·斯蒂芬斯1803年出生于美国，学法律出身，因为热爱历史和旅行，去过埃及、两河流域探险，还出版了两本游记。1839年，斯蒂芬斯进入中美洲。在科潘河流域的丛林中，他隐约看到前方有一堵高墙。谁会在人迹罕至的原始森林里建墙？经验告诉斯蒂芬斯，这可能是一处古文明遗迹。于是，他和同伴披荆斩棘，向高墙前进。</p>
<p>一路上，斯蒂芬斯发现了14座刻着浮雕的石碑，这更坚定了他的判断。最终，在密林深处，斯蒂芬斯发现了一座大城。他是对的。这里是玛雅文明的遗址。</p>
<p>斯蒂芬斯的发现，激起了考古学家的热情。此后，众多的玛雅遗址重见天日。它们从墨西哥东南部，经危地马拉、洪都拉斯延伸到秘鲁，可以说遍布美洲中南部。</p>
<p>经过数十年研究，考古学家逐渐揭开了玛雅文明之谜。考古表明，玛雅文明形成于公元前1500年，也就是距今约3500年前。那时候，玛雅人已经发明了文字，并能建造大型纪念碑和建筑。到4世纪，玛雅文明进入鼎盛期，在建筑、艺术、宗教、天文、数学等领域，都取得了很高成就。著名的玛雅历法，就产生于这个时期。9世纪以后，玛雅文明开始衰落，逐渐被墨西哥中部的阿兹特克文明、秘鲁的印加文明取代。不少玛雅古城遭到遗弃，为原始森林覆盖。</p>
<h1 id="006文学丨《暗店街》：诺奖得主莫迪亚诺的幽暗迷宫"><a class="header-anchor" href="#006文学丨《暗店街》：诺奖得主莫迪亚诺的幽暗迷宫">¶</a>006文学丨《暗店街》：诺奖得主莫迪亚诺的幽暗迷宫</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=250758431&type=red" frameborder="0" allowfullscreen></iframe>
<p>《暗店街》，它的作者是2014年的诺贝尔文学奖得主，法国作家帕特里克·莫迪亚诺。</p>
<p>1997年4月，国内文坛最大的新闻，就是备受瞩目的作家王小波英年早逝。两个月后，王小波生前的最后一部长篇《青铜时代》出版，其中《万寿寺》的开头是这样写的：“莫迪亚诺在《暗店街》里写道：‘我的过去一片朦胧……’这本书就放在窗台上，是本小册子，黑黄两色的封面，纸很糙，清晨微红的阳光正照在它身上。”</p>
<p>当时王小波已是名满天下，对后辈的影响至今犹存。他在小说开头引用莫迪亚诺小说里的句子，当然是种对前辈大师的致敬。而早在那篇名为《小说的艺术》的文章里，这种推崇则表达得更为直接，他说：“现代小说的最高成就是：卡尔维诺、尤瑟纳尔、君特·格拉斯、莫迪亚诺……”而莫迪亚诺之名，也借王小波之力，被国内读者所熟悉。</p>
<p>实际上，在法国，莫迪亚诺早在1968年发表处女作《星形广场》后就已一举成名。1972年他以《环城大道》获“法兰西学院小说大奖”。1978年则更是以《暗店街》摘下了法国最重要的文学奖“龚古尔奖”。1996年他又荣获“法国国家文学奖”。2010年和2012年，他又分别获得“法兰学院奇诺·德尔·杜卡基金会世界奖”和奥地利的“欧洲文学奖”。当然最近的一次获奖，就是2014年的“诺贝尔文学奖”。</p>
<p>莫迪亚诺1945年生于巴黎郊外的布洛涅-比扬古地区，父亲是个犹太金融企业家，母亲是比利时演员。从1968年到现在，他已出版了近三十部小说，还被翻译到三十多个国家。在中国，目前翻译过来的也有近二十部。</p>
<p>比利时著名法语作家让-菲利普·图森，在点评莫迪亚诺跟另一位诺奖得主——法国作家勒克莱齐奥的不同时，这样说过：勒克莱齐奥的小说还是那种很传统主流的写法，但莫迪亚诺则完全不同，他的小说语言简练而又微妙，蕴含着幽深的诗意，尤其是在小说结构的开放性和气氛的营造上，始终有着非常迷人的魅力。接下来，我们就以《暗店街》为例，来具体解读这种魅力究竟是如何形成的。</p>
<p>小说的主人公是一个得了失忆症的男人，背景是二战后的巴黎，主人公被好心的私家老侦探于特收留，在事务所帮他做事。他想不起自己姓甚名谁、来自哪里、有什么身份、经历过什么，正像小说开头所写的那样：“我什么都不是。”侦探于特就想办法帮这个人解决了名字和护照问题，给他起名叫居依·罗朗。</p>
<p>在小说的开篇，这位于特老先生就决定退休不做侦探业务了。十年前，他和主人公刚认识的时候，居依·罗朗原本是想请于特帮忙寻找能够让他想起过去那一切的证人和证据的，但于特告诉他，你还是不要回头看了，想想今天和未来吧。随即就拉他入伙，一起做私家侦探了。这位于特之所以会同情居依·罗朗，主要是因为，于特自己也和主人公一样，丢失了一段过去，文中写到“于特的一部分身世突然间好似石沉大海，没有留下任何指引路径的导线，任何把他与过去联系起来的纽带。”</p>
<p>在《暗店街》这部小说里，除了于特侦探，还有好几个人物，其实都是出自流亡法国的俄罗斯侨民家庭。这也是小说里的一条重要的背景线索。于特之所以说自己的身世也有一部分消失了，主要指的也就是因为流亡所导致的家国不复存在的事实。后来，于特退休隐居，把事务所留给了居依·罗朗，因为里面有多年积累的关于各色人等的信息资料，可供居依·罗朗查阅，希望能够帮助他追寻自己的过去。</p>
<p>后来，从漫无头绪的不是线索的线索里，居依·罗朗先是几经周折找到了一批旧照片，确定了与他有关的三个主要人物，一个是叫作盖·奥尔洛夫的俄裔女子，一个是他的朋友，也是这个女子的丈夫弗雷迪，还有一个是他的妻子德妮丝。没过多久，也是通过对与这些人相关的信息的搜寻，在知道了他们的一些经历背景的同时，他也知道了自己身份，他原来叫佩德罗·麦克埃沃依，曾在多米尼加驻巴黎总领事馆协助总领事做事，那位总领事也是他的朋友。随着线索和信息不断增加，他的记忆也有所恢复。实际上，他的失忆，并不是什么都忘得一干二净，主要遗忘的，是人物、事件以及相应关系的信息。有一些重要的场景，他是还能逐渐回想起来的，只是有点像纯视觉的，处在没有前因后果的无法确认性质的状态。</p>
<p>等到他把搜寻到的那些信息跟他脑海里残留的那些场景记忆结合起来，就基本上勾勒出了他的人生经历中最重要的那个部分的轮廓和脉络。二战中，德军占领法国后，他跟德妮丝、盖·奥尔洛夫、弗雷迪以及另一个好友，共同谋划了一条逃离法国途经葡萄牙去瑞士的路线。在他们抵达法国边境山区里躲下来，伺机寻找越境的机会其间，有两个陌生人提出能帮助他们达成所愿，只是每人要花费五万法郎。急于越境脱险的主人公并没有想到这是个骗局，结果就是他被抛弃在深山雪岭几乎丧命，自己也因此失忆，而他那漂亮的妻子德妮丝和他的全部家当则都被那两个人拐走了。后来他又查到了德妮丝在巴黎留下的蛛丝马迹，但又不知去向，还有那个奥列格投靠德国人后滥杀无辜的恶行。当他怀着最后一丝希望，远渡重洋去太平洋小岛想找到老友弗雷迪，以期找到最为重要的恢复过去记忆的线索时，弗雷迪却出了意外。小说就在这里戛然而止了。</p>
<p>接下来，我们就来讲一下这部小说究竟有什么特别之处。</p>
<p>第一个特点，就是这部小说有个貌似侦探小说的外壳。</p>
<p>差不多有三分之二的篇幅，主人公都是在像一个侦探那样不断搜寻着各种线索，去跟各种可能有关联或知情的人会面，拿到第一手的资料比如照片之类的，还有一些二手资料，也就是这些人口诉的与其他几个人物有关的信息。而在这个过程中，于特跟其它同行也在不时为他提供着各种比较重要的人物资料。这些信息是逐渐浮现的，它们所产生的最直接的作用，就是会让读者会在不知不觉中就陷入了读侦探小说的思维，尤其是在提到主人公的妻子德妮丝时，几次提到她喜欢看侦探小说的细节，这就更进一步地强化了这部小说在结构布局方式上，也就是侦探小说式的感觉。</p>
<p>到了小说的最后部分，当读者觉得，之前发生的那些寻找的过程、陆续浮出水面的各种资料、逐渐恢复的一些记忆场景，就像拼图游戏里的各种形状的碎片那样逐渐拼合起来，即将呈现完整的事件图景时，却忽然发现随着弗雷迪那条线索的中断，之前所有的仿佛已拼合起的那些转眼间就解体了。那个案子又恢复了原来的扑朔迷离的状态，那貌似侦探的过程是完全无效的，不但最重要的结果和答案没有出现，就连此前所做的那一切寻找和信息也都变得可疑了。实际上，之所以主人公所有试图恢复记忆的努力都变成了徒劳无功，真正的原因并不是失忆症本身，而是那人特定的历史时代，也就是二战期间德军占领法国所导致的他所赖以生存的环境与人际关系的崩溃与瓦解，而这一后果意味着，承载记忆的那个世界已是无法恢复的，也就是说，他失去的不只是记忆本身，还有属于他的那个世界。就像主人公最后写给于特的信里所说的那样：</p>
<p>“直到目前，我觉得一切都是那样混乱无序，那样的破碎不全……在寻觅的过程中，我会突然想起一件事的某些细节，某些片段……总之，或许生活正是如此……这确实是我自己的生活呢？还是我潜入了另一个人的生活？”</p>
<p>第二个特点，这部小说的深层结构方式，其实是“纯粹反侦探小说”的迷宫。</p>
<p>这个说法来自评论家珍妮·尤尔特。在她看来，当训练有素的读者随着小说的展开渐渐辨识出侦探小说的结构特征时，就会满怀期待地想象着将要看到的可以推断的关于所有问题的答案，她异常明确地指出：然而，这部小说挫败了读者们寻求解答的欲望，或者说挫败了他们认为在阅读过程中答案会确定呈现的欲望，就这样，这部小说以后现代的不确定性取代了传统的终局：“反侦探小说的拒绝提供终局，以及它乞灵于恐惧而不是笃定，参与了后现代对归纳推理和一个能慰藉人心的线性目的论宇宙之信仰的抗拒。”</p>
<p>这个时候，如果我们还能耐心地返回到小说里，去把那所有的章节里出现的各种线索、浮现的记忆、证人们提供的资料证据统统再仔细过一遍，就会忽然意识到，这所有的一切其实都是充满了不确定性的、都是非常可疑的，它们从来就没有真正联接起来生成所谓的线索逻辑，它们始终都处在最初的线头的状态，从根本上说，就是无解的。当然，也正因如此，它们也为读者提供了近乎无尽的想象的可能性，使得我们在读罢这部小说之后，留下的最深的感受，就是从总体上来说，它就像一个迷宫。就像L·墨菲所说的那样：“不管任何时候，只要迷宫这一象征被唤起，无论是明确地还是隐晦地，这咱张力就得以显现。虽然并不总是被贴上迷宫的标签，但是迷宫这一意象通过文本对如下事物的描写反复不断地被暗示出来：街道、建筑物、锁住的门、门廊、门厅，还有巴黎的公寓，以及后来的那些林中小径、通路，和法国乡下的那些蜿蜒曲折的道路，叙述者在其中迂回穿梭，信步闲庭。”</p>
<p>比如小说里就有一段文字，是关于主人公误以为自己可能就是弗雷迪时，进入弗雷迪的祖父种下的“迷宫式树林”的，这段文字是这样写的：“我们从侧面的一个入口进入迷宫，俯身通过一道由青枝绿叶组成的拱门。多条小径纵横交错，有十字路口、圆形空地、环形弯道或九十度的拐角、死胡同、一个绿树篷以及一条绿色的长木椅……小时候，我一定和祖父或同龄的朋友在这里玩过捉迷藏的游戏，在这散发着女贞树和松树清香的神奇迷宫中，我一定度过了一生中最美好的时光。我们走出迷宫时，我忍不住对我的向导说：‘真怪……这座迷宫使我想起了一些事……’”</p>
<p>在莫迪亚诺笔下，这种迷宫的意象，是会不时以不同方式在不同的地方出现的，比如下面这段文字：“天黑了。窗户开向另一个四周有楼的大院子。远处是塞纳河，左边是皮托桥，以及向前延伸的岛。桥上车辆川流不息。我注视着大楼的一个个正面，照得通明的这一扇扇窗户，它们和我站于其后的窗户一模一样。在这迷宫似的楼梯和电梯中，在这数百个蜂窝中间，我发现了一个人，或许他……”</p>
<p>主人公其实多次出现在让人容易产生幽闭恐慌感的公寓里，透过窗户注视外面的巴黎。这样描写的效果就是，不只是各种空间暗示着迷宫，甚至整个巴黎都是迷宫的象征。就像下面这段文字所呈现的那样：“我一直走到窗前，俯视着蒙玛特尔缆索铁道、圣心花园和更远处的整个巴黎，它的万家灯火、房顶、暗影。在这迷宫般的大街小巷中，有一天，我和德妮丝·库德勒斯萍水相逢。在成千上万的人横穿巴黎的条条路线中，有两条互相交叉，正如在一张巨大的电动台球桌上，成千上万只小球中有时会有两只互相碰撞。但什么也没有留下，连黄萤飞过时的一道闪光也看不见了。”</p>
<p>他始终在努力回忆着，试图更多地回想起巴黎被占领期间的那些时光，并能把相关的一切变成可以使他走出迷宫的“阿里阿德涅线”。这里主人公所说的阿里阿德涅线指的是古希腊神话里克里特岛上阿里阿德涅公主的故事，她为了帮助雅典王子忒修斯战胜迷宫中的怪物并逃脱，便送给了忒修斯一个线团和一把魔刀，指引他用刀杀死怪物并随身释放线团，就能顺着来路走出迷宫。所以阿里阿德涅线之后常用来比喻走出迷宫的方法和路径，解决复杂问题的线索。</p>
<p>但是,这个希腊神话的结局其实是个悲剧，阿里阿德涅公主与忒修斯的感情不被命运女神看好，之后阿里阿德涅与酒神相爱了，然而，阿里阿德涅只是个凡人。终于有一天，她永远地离开了酒神。酒神手捧阿里阿德涅曾经带过的华冠，悲痛欲绝。这就意味着，当小说里的主人公想着要找到助他走出迷宫的“阿里阿德涅线”时，其实很有可能会意识到，与“迷宫”相关的，还有不被神祉祝福的爱情，还有凡人生命有限的悲剧本质——即使拥有了阿里阿德涅之线，也摆脱不了命运。</p>
<p>这部小说的第三个特点，是支离破碎的世界、记忆与简练诗意的文体之美的对应</p>
<p>在《暗店街》里，莫迪亚诺的行文是非常简练的。他很少会使用长句，多数情况下用的都是精练的短句。而且在整部小说里多数段落都不过几行，至多不过七八行，通常都是三两行就是一段。有时候十来行字就是一章，有时候一章只有两行字，甚至一章只有一行字。可是，耐人寻味的是，虽然莫迪亚诺行文简练，多用短句、短段落，但是读起来却丝毫都不会有轻快、迅速的感觉，恰恰相反，从始至终，有的都是缓慢的效果。为什么会有这样的效果呢？因为简练也好，精短也罢，都只是表面的形式。而实际上这里面无论是描写、对话，还是联想思绪，从句子结构上说都是极有层次感的，另外，从段落结构上说也是富有留白的效果的。说到底，莫迪亚诺的目的并不是为了讲好一个故事，而是为了营造深沉而又微妙的氛围，以生成一个充满想象的可能性的、纯然开放的叙事空间。</p>
<p>比如我们来读一段文字，大家体会一下，在书里它只有九行字：</p>
<p>“这天是德妮丝的生日。一个冬季的夜晚，巴黎纷纷扬扬的雪化成了泥泞。人们涌进地铁入口或疾步行走。圣奥诺雷城关的橱窗灯火通明。圣诞节临近了。</p>
<p>我走进一家珠宝店，珠宝商的面孔又浮现在我眼前。他蓄一把胡子，戴着镜片略带颜色的眼镜。我给德妮丝买了一枚戒指。离开商店时，雪仍在下。我担心德妮丝不来赴约，我第一次想到，在这座城市里，在这些急匆匆赶路的人影中间，我们俩有可能再也见不着面。</p>
<p>我记不得这天晚上自己名叫吉米还是佩德罗，斯特恩抑或麦克埃沃依。”</p>
<p>在我们把这段文字读下来的过程中，会发现，整体上的调子就是既简练又是非常缓慢的。无论是场景描写还是叙事或心理活动，几乎都是闪回状态的，可是字里行间始终又都隐约着某种微妙的诗意。我们甚至可以说，要是再多分一下行，那这段文字其实就会变成一首真正的好诗。它的美，似乎既是不言而喻的，又是无法形容的，值得你反复玩味。而且不管你如何玩味，都不会穷尽它的意蕴。</p>
<p>莫迪亚诺的行文总是能给人以不动声色的感觉，常常只是寥寥几笔，就能达成在不经意间深深触动人心的效果。比如下面这段文字：</p>
<p>“这天晚上，我坐在于特带我去过的那家酒吧兼食品杂货铺的一张桌边，它位于尼耶尔林荫道，正对事务所。一个吧台，货架上有些外来货：茶叶、阿拉伯香甜糕点、玫瑰酱、波罗的海鲱鱼。经常光顾此地的是一些原来的赛马骑师，他们在一起回忆往事，传看折了角的照片，照片上的马早已被肢解了。”</p>
<p>前面那些文字看起来都是漫不经心、平平淡淡的状态，直到最后那一句，“照片上的马早已被肢解了”出现，并戛然而止的时候，读者才会猛然意识到，这里面暗示的是多么残酷的事实啊！被肢解的岂止是照片的马，还有人的记忆、人的历史、人的关系，甚至是整个与之相关联的世界都是“早已被肢解了”。</p>
<p>最后，我们还可以再读一段小说里的文字，作为这次解读《暗店街》的收尾。这段文字是这样的：</p>
<p>“古怪的人。所经之处只留下一团迅即消散的水气。我和于特常常谈起这些丧失了踪迹的人。他们某一天从虚无中突然涌现，闪过几道光后又回到虚无中去。美貌女王。小白脸。花蝴蝶。他们当中大多数人，即使在生前，也不比永不会凝结的蒸汽更有质感。于特给我举过一个人的例了，他称此人为海滩人：一生中有四十年在海滩或游泳池边度过，亲切地和避暑者、有钱的闲人聊天。在数千张度假照片的一角或背景中，他身穿游泳衣出现在快活的人群中间，但谁也叫不出他的名字，谁也说不清他为何在那儿。也没有人注意到有一天他从照片上消失了。我不敢对于特说，但我相信这个海滩人就是我。即使我向他承认这件事，他也不会感到惊奇。于特一再说，其实我们大家都是海滩人，我引述他的原话：‘沙子只把我们的脚印保留几秒钟。’”</p>
<p>在这段文字里，莫迪亚诺提出了“海滩人”的概念。无论对于小说的主人公，还是于特老先生跟那些流亡巴黎的俄罗斯人、拉美人，“海滩人”其实都是对那种无根的生命处境和模糊的存在状态的准确概括。可是，即使是放在我们今天的社会里，这种情况不也是很容易发生的么？尤其是在北上广深这些中心大城市里，哪怕我们只是以三、五年为限度，也会发现，其实是有过很多“海滩人”的，某一天忽然出现，后来又忽然消失。于特说的对，“其实我们大家都是海滩人。”而这，在某种意义上也正是现代人，尤其是当代人的最为基本的命运——注定要不断体验失去、个体存在日益模糊的命运，而所谓的失忆、离乡、无根、漂泊之类的概念，不过是这种命运的表征而已。</p>
<h1 id="007文学丨《幸福过了头》门罗：一个男性主导的社会中，女性所受到的压迫"><a class="header-anchor" href="#007文学丨《幸福过了头》门罗：一个男性主导的社会中，女性所受到的压迫">¶</a>007文学丨《幸福过了头》门罗：一个男性主导的社会中，女性所受到的压迫</h1>
<iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=249892511&type=red" frameborder="0" allowfullscreen></iframe>
<p>内容笔记</p>
<p>先来介绍一下爱丽丝·门罗，她是加拿大女作家，当代短篇小说大师，2013年诺贝尔文学奖得主。门罗出生于1931年，从少女时代就开始写作，不过直到37岁才出版第一部作品，可以算是一个“大器晚成”的作家。</p>
<p>对此，她曾经说过：</p>
<p>我其实三十六七岁才出版自己的第一本书。而我二十岁时就开始写作，那时我已结婚，有孩子，做家务。即便在没有洗衣机之类的家电时，写作也不成问题。人只要能控制自己的生活，就总能找到时间。如果我二十五岁时就通过出版小说迅速证明了自己，那说不定倒是件糟糕的事情。</p>
<p>门罗一生都专注于中短篇小说写作，故事主要发生在加拿大一个西临休伦湖，南接伊利湖，北起戈德里奇，东至伦敦市的一小块地方。她几乎所有作品的主人公，从少女到已婚妇女，再到老妇人，都生活在这片地域的小镇上，作品内容也是讲述这片小地方上普通人特别是女性的平常生活。</p>
<p>不过，今年我们要讲的《幸福过了头》这篇小说，却跟她之前这些作品大不相同。小说的女主人公不再是小镇上的平凡女性，而是以19世纪俄国女数学家、小说家索菲娅·科瓦列夫斯基的生平故事为线索，追溯这位不平凡女性的悲剧人生。小说发生地也不是加拿大，而是19世纪的欧洲。但有一点是相同的，就是门罗至始至终对于女性命运的关注，不管这个女人是名人，还是普通人。门罗都会探究社会和体制对于女性造成的束缚和歧视。</p>
<p>值得注意的是，《幸福过了头》发表于2009年，那时门罗已经是78岁高龄了，身患癌症，所以大家都认为这可能是她最后的一部小说作品了。不过没想到的是，之后她依旧笔耕不辍，写出了很多杰作。《幸福过了头》收录在同名小说集子里。这本小说集一共收录了十个中短篇小说，涉及到的内容有谋杀、性侵、暴力等等内容，内容虽然劲爆，但门罗写起来波澜不惊，在平静的叙事下，每一个主人公都有自己的悲欢离合。而压轴的作品就是这篇《幸福过了头》。</p>
<p>下面，我就来讲讲这篇小说。</p>
<p><strong>（一）</strong></p>
<p>小说的主人公是索菲娅·科瓦列夫斯基，她是一个历史上真实存在的人物，有着一系列光彩照人的标签：俄国女数学家，世界上第一位数学女博士，第一位女教授，第一位科学院女院士，同时还是一个小说家……</p>
<p>这样一个优秀的天才女性，有着怎样的人生故事呢？门罗为什么想要写她呢？</p>
<p>1850年，还是沙皇统治时期的圣彼得堡，一个女婴呱呱落地。这位女婴的爸爸是一位脾气特别暴躁的将军，在巴利比诺的郊区拥有庞大的家族庄园。姐姐叫阿纽塔，日后也是一位大名鼎鼎的人物，因为陀思妥耶夫斯基曾经追求过她。</p>
<p>女婴取名叫索菲娅·科瓦列夫斯基，她跟她姐姐就生活在这个恪守东正教传统的贵族庄园里。在这个庄园，索菲娅从一个小女孩出落为一位婷婷少女，热爱数学、天资聪颖。</p>
<p>但是，这座温馨的庄园，并不是一个与世隔绝的桃花源，它也是沙皇统治下的千万个庄园之一，是俄国社会的微观缩影。那时候，俄国还是一个农奴制的国家，女性地位很低，既没有接受教育的权利，也没有自由的选择权。女性只能听命于男性，否则就是大逆不道。一个女性，小的时候要听父亲的话，长大嫁人后要听丈夫的话。哪怕你是一个聪明绝顶的天才，都没有用，最后都必须得嫁人，成为一个只能待在家里的家庭妇女。丈夫说什么就是什么，女性不能去违背，更不要说在社会上抛头露面去谋个职位了。</p>
<p>索菲娅跟她的姐姐阿纽塔虽然是贵族的女儿，但也不能幸免。</p>
<p>先来说姐姐阿纽塔，她喜欢写作，写完后悄悄地把故事投给了一家杂志。这家杂志的编辑就是大名鼎鼎的陀思妥耶夫斯基。陀思妥耶夫斯基看完小说后，发表了这个故事。谁知道这件事情被爸爸知道了。爸爸大发雷霆，问阿纽塔，“现在卖你的故事，还有多久你要卖你自己?”</p>
<p>在这场家庭骚乱中，陀思妥耶夫斯基出现了，不过他在阿纽塔的家人面前表现得特别糟糕，而且提出了一个非分的请求：他想要娶阿纽塔为妻。门不当户不对，你一个穷书生居然想娶我们贵族家的千金，真是癞蛤蟆想吃天鹅肉！阿纽塔爸爸坚决反对。阿纽塔自己也觉得跟这个穷书生生活在一起牺牲太大，所以也拒绝了求婚。陀思妥耶夫斯基虽然求婚失败，但是始终放不下阿纽塔，还把她写进了自己的长篇巨制《白痴》当中。当然，这是后话了。</p>
<p>再来说妹妹索菲娅，她想出国留学，可是在俄罗斯，一个没有结婚的姑娘，如果没得到父母的同意，是不能出国的。索菲娅的父母死活不同意，他们只希望自己的女儿老老实实嫁个好人家，本本分分地过日子。没办法，索菲娅只能通过白色婚姻来摆脱这个困境。</p>
<p>什么是白色婚姻呢？就是两个彼此没有爱情的人结为夫妻。虽然法律意义上，两个人是结婚了。但在实际生活中，他们不会住在一个地方，也不会同居，只是为了欺骗自己的父母而已。</p>
<p>索菲娅的姐姐阿纽塔为了帮助妹妹，物色了一个年轻小伙子，这个小伙子叫弗拉迪米尔·科瓦列夫斯基。小伙子非常地理想主义，富有同情心。他愿意帮助索菲娅。他去了索菲娅的家，拜访了索菲娅的爸爸，并且向索菲娅求婚。索菲娅爸爸很有礼貌，他明白这个小伙子出生于一个良好的家庭。但是，索菲娅爸爸认为索菲娅太年轻了，不能立刻就对他们之间的感情采取行动，必须要过一段时间，而且是足够考虑清楚的时间。这段时间，索菲娅和小伙子可以在庄园里好好相处，互相了解。索菲娅爸爸这样想，是有他根据的。因为这个小伙子并没有给人留下什么好印象，一方面，小伙子从来不掩饰自己的激进观点，另一方面，他对自己的衣着也不加修饰，好像是故意如此。所以索菲娅爸爸想，索菲娅见到这个小伙子的次数越多，她就越不想嫁给他。</p>
<p>但是索菲娅爸爸并不知道女儿是在欺骗自己。索菲娅才不在乎这个小伙子怎么样呢。她只想快一点出国留学。有一天，家里举办了一个重要的酒会。索菲娅就在一片忙乱当中，趁机逃跑了。她找到了小伙子的住处，进屋后，立马给自己的爸爸写信，信里是这样写的：“我亲爱的爸爸，我在弗拉迪米尔这里，而且我打算继续待在这里。我求你，不要再反对我们的婚事。”索菲娅爸爸收到信后，立马来到小伙子的家，并要求他俩立刻和他回去。三个人坐车回到了家中，索菲娅爸爸在餐桌上宣布他的女儿跟小伙子已经正式结婚了。索菲娅的计划终于成功了。他们在庄园里举办了盛大的传统婚礼。这样，索菲娅就可以出国了。等一到了国外，索菲娅和小伙子各奔东西。索菲娅先去了海德堡，然后到柏林，而小伙子去了慕尼黑。</p>
<p>但人生的痛苦就在这里。肉体可以离开祖国，精神上却对祖国魂牵梦绕。那个养育了索菲娅的庄园，终其一生也回不去了。索菲娅只能通过不断地写作来缓解对祖国和庄园的思念之情，门罗在书中这样写道：“索菲娅写下了自己对巴利比诺生活的回忆，回忆洋溢着她对失去一切的热爱，不管是曾经绝望的还是曾经珍爱的。”这就是为了接受先进教育，为了赢得自由、平等和有尊严人生的代价。</p>
<p>逃离了祖国，女性的命运就会好很多吗？索菲娅的经历告诉我们：并没有。索菲娅希望能在欧洲找到自己的安身立命之处，得到社会的认可和尊重，但是太难了。与自己的祖国相比，19世纪的欧洲其他国家对女性的态度并没有实质性的区别。海德堡、慕尼黑、柏林，索菲娅辗转求学，可由于外籍女性的身份，四处碰壁。如果索菲娅没有遇到她的恩师，德国数学家魏尔斯特拉斯教授，她的求学之路恐怕就夭折了。</p>
<p>师生两人的碰面非常有意思。魏尔斯特拉斯教授是一位名满天下的数学家，全世界前来求学的学生特别多。所以当有一个女人突然上门来说想做他学生的时候，这让他非常恼火。他觉得这个叫索菲娅的女人是个误入歧途的家庭女教师，想要借着自己的名号在教师资格证书里添上一门数学而已。不过魏尔斯特拉斯教授虽然恼火，但没有表现出来，他依旧接待了索菲娅。索菲娅出现在教授面前，浑身发抖，特别狼狈。教授想打发她走，就说：“给你几个问题，你回家去解，一个星期以后再来找我。要是我满意，我们再谈吧。”一个星期后，教授早就把索菲娅给忘掉了。所以当索菲娅再次拜访的时候，教授都震惊了。这几个数学问题，索菲娅不仅解答了出来，甚至还用了全新的解法。教授很怀疑索菲娅是找了自己的兄弟或者情人帮她解答的。到这个时候，教授还是不相信一个女人也可以做复杂数学题。教授虽然心里怀疑，但是嘴上没有说。为了确证索菲娅是不是真的能解答，就让索菲娅把每一道题目给自己解释一遍。索菲娅照办了。面对那些别出心裁的漂亮解法，教授一边听，一边极力掩饰自己的震惊。终其一生，教授都在等待这样一个天才的学生走进自己的书房。现在，索菲娅出现了。</p>
<p>教授和索菲娅的关系可以用“良师益友”来形容。一开始，索菲娅跟随教授的课题，后来变成了挑战，一度还跳到了教授的前头。索菲娅常常是教授研究的催化剂。但索菲娅的悲剧就在于：她是一个女性，偏偏又生在一个压制女性的社会。她只能用匿名的身份在知名杂志上发表文章。如果她用真名，立刻就会遭到拒收，甚至会被质疑偷窃了哪个男性的成果。教授为了帮助索菲娅，悄悄瞒着索菲娅把她的著作向法国科学院匿名投稿。索菲娅因此得到了世界瞩目的数学届最顶级的奖项勃丁奖。鲜花和掌声随之而来。</p>
<p>那么，得到了业内最高奖项，会改善一个女性的命运吗？</p>
<p>并没有。索菲娅更加深刻地感受了社会对女性命运的不公。在勃丁奖颁奖典礼上，索菲娅在明亮高雅的房间发表演讲，但是一旦她需要一份工作时，这些男性就对她关上大门。书中说：“脑子里全是旧观念的男人们仍然拘泥于这样的观念:女人的大脑里只有紧身胸衣和名片，和女人一说话，灌进喉咙的全是香水尘雾。”是的，这些男人们虽然给了索菲娅这样的奖项，但是他们无法容忍一位女性可以做出比他们更杰出的成就。</p>
<p>这个时候，又是教授出手相救，他写信求助以前的学生，请学生帮忙在瑞典的一所大学为索菲娅谋得教席。那时候，瑞典是欧洲唯一一个给女性提供大学教职的国家。索菲娅因此成为第一位在北欧获得教授职位的女性，也是第一位在严肃的科学杂志担任编委的女性。即便如此，索菲娅依然得不到社会的认同和家庭的温暖。斯德哥尔摩的太太们也对她怀抱偏见。虽然太太们邀请索菲娅去她们家，请索菲娅参加最重要的酒会和最亲密的晚餐，还一个劲儿地赞美她。但是索菲娅知道自己在这些太太们的眼中就是一个怪物，就像是一只通晓多种语言的鹦鹉，或者是天才儿童，能毫不犹豫、不加思量地背出某个冷门的知识。她得到的社会认可仅仅局限于一个有特殊才能的人，而没有作为普通人被接纳到日常生活当中。这一切都因为她是女人。</p>
<p>在事业方面，索菲娅经历了如此多的曲折和艰难。在爱情方面，索菲娅也没有好到哪里去。前面我们说过，索菲娅跟那个小伙子虽然结了婚，但那只是为了方便出国的假结婚。索菲娅从来没有爱过那个小伙子，他们维持的也只是朋友关系。直到遇到了法学教授马克西姆，索菲娅才觉得自己真正爱上了一个人。马克西姆是一个非常优秀的人，他会说俄语、法语、英语、意大利语，还懂一些古典和中世纪的拉丁语；他的专业是政府法规，能将美国当代政治机构的发展、古代帝国的法律与实践等等说得头头是道，可以说是学识渊博，但为人一点都不老学究，反倒是一个诙谐幽默、受人欢迎，和任何层次的人都能轻松相处的人。</p>
<p>从一开始的惺惺相惜，到后来互相被对方的才华所倾倒，索菲娅满心以为可以和马克西姆共度余生。索菲娅虽然是个数学天才，但她也是一个平常女子，内心渴望着能够与相爱的人相伴到老。而马克西姆看样子就能给她这样的生活，他身上所拥有的那种不可思议的确信态度，让索菲娅觉得很有安全感。他们订婚了，一段美好的姻缘似乎开始了。</p>
<p>但是，他们的婚礼没有如期举行。订婚后不久，马克西姆就给索菲娅写了一封分手信，宣告自己并不爱索菲娅，并请求解除婚约。究其原因，就是马克西姆受不了自己一个大男人，居然要活在一个女人的光环之下。自从索菲娅得了勃丁奖后声名鹊起，到处都是夸奖这个女人的声音，那些鲜花、掌声、鸡尾酒都扑了过来。甚至因为索菲娅和马克西姆有共同的俄罗斯姓氏，马克西姆投稿的文章总会被误认为出自索菲娅之手。对于马克西姆这样一个如此骄傲和自信的人来说，怎么可能受得了呢？在他内心最深处，一个男人的自尊心受到了伤害。所以他选择与索菲娅划清界限，转身离开。这让索菲娅伤心欲绝。</p>
<p>半年后，索菲娅孤身一人，告别了人世。这一辈子，索菲娅都在与幸福擦肩而过，在临终前，她留下了遗言：“幸福过了头。”这真是命运对她开的一个残酷玩笑。就那一点点幸福，她都得不到。在学术领域，她独步天下；在生活上，她却一败涂地。原因全在于她是一个如此优秀的女性，而那时候的社会是不会允许一个女性得到她想要的幸福的。令人感慨的是，在索菲娅的葬礼上，马克西姆匆匆赶过来参加，神态和语气冷酷如冰，“他提起索菲娅，更像是提起一位他相熟的教授。”真是替索菲娅感觉不值。</p>
<p>这就是索菲娅短暂的一生。她就像是一颗璀璨的流星划过历史的天空。她曾经追求过幸福，可是幸福并未眷顾过她。</p>
<p><strong>（二）</strong></p>
<p>说完了这部小说的大致内容，我们再来看看门罗为什么会想到写这部小说。在小说集末尾的致谢中，门罗专门介绍了自己写作的动机，她是这样说的：“某天，我在百科全书上查找资料时，无意中发现了索菲娅·科瓦列夫斯基。她兼有小说家和数学家的身份，立刻吸引了我。于是我开始阅读能找到的有关于她的一切。”越是深入地了解索菲娅的人生际遇，门罗就越能深入到索菲娅的内心中去。因为门罗自己也是一位女性，她同样能感受到身处一个男性主导的社会中女性所受到的压迫。</p>
<p>在开篇，我们提到门罗出生于1931年的加拿大。那个时候的加拿大，整体社会的高等教育程度并不高，大多数女孩在读完高中后，就选择嫁人，成为全职家庭主妇。而门罗成绩非常优秀，她凭借 11 门课程中 9 门第一的优秀成绩拿到了西安大略大学新闻系的奖学金。本来，以她的成绩和努力，完全可以完成大学学业的。但是她的家庭不允许，大学只读了两年，门罗就被迫辍学，选择了结婚生子这条老路，成了三个孩子的妈妈。每天，她都要忙于照顾孩子和做各种家务，写作的时间少得可怜，只能利用一丁点休息的时间，在餐桌边、在洗衣房的小桌前写。</p>
<p>在作家这个领域，门罗也感受到了来自于男性社会的不公正对待。20世纪50 年代，加拿大艺术委员会拒绝了门罗向他们递交的写作项目经费资助申请，原因就是她在申请书上填写了想利用部分经费来雇佣保姆，这样她就可以有更多的时间从事写作。这在委员会的那帮人眼中看来简直是不可思议。那个年代，门罗这样的女性，首要的角色是妻子和母亲，然后才是她的职业。他们不会允许一个女人雇人来帮她完成家务。</p>
<p>门罗一生写了很多女性的小说，她非常关注女性在这个社会上所遭受到的明面上和暗地里的那些伤害。她以自己切身的经历，深切地体会到一个社会的女性期待对女性的生存影响有多大。所以，门罗能够关注到索菲娅，为她单独写一篇小说，并作为一本小说集的压轴作品，是顺理成章的事情。可以说，索菲娅也好，门罗也好，他们都是各自时代最优秀的人才，在那样一个对女性充满歧视和压迫的时代，她们依旧能够绽放出自己最耀眼的光芒。这一点，非常值得我们学习。</p>
]]></content>
      <categories>
        <category>听书笔记</category>
      </categories>
      <tags>
        <tag>电子书</tag>
        <tag>喜马拉雅</tag>
        <tag>读书推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>最近5年183个Java面试问题列表及回答</title>
    <url>/2020/07/12/%E6%9C%80%E8%BF%915%E5%B9%B4183%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8%E5%8F%8A%E5%9B%9E%E7%AD%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>地址：<a href="https://www.bilibili.com/read/cv6572947?from=category_34" target="_blank" rel="noopener">https://www.bilibili.com/read/cv6572947?from=category_34</a></strong></p>
<a id="more"></a>
<p>Java 面试随着时间的改变而改变。在过去的日子里，当你知道 String 和 StringBuilder 的区别（String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象。因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM 的 GC 就会开始工作，影响性能，可以考虑使用可变字符序列StringBuilder）就能让你直接进入第二轮面试，但是现在问题变得越来越高级，面试官问的问题也更深入。</p>
<p>在我初入职场的时候，类似于 Vector 与 Array 的区别、HashMap 与 Hashtable 的区别是最流行的问题，只需要记住它们，就能在面试中获得更好的机会，但这种情形已经不复存在。如今，你将会被问到许多 Java 程序员都没有看过的领域，如 NIO，设计模式，成熟的单元测试，或者那些很难掌握的知识，如并发、算法、数据结构及编码。</p>
<p>由于我喜欢研究面试题，因此我已经收集了许多的面试问题，包括许多许多不同的主题。我已经为这众多的问题准备一段时间了，现在我将它们分享给你们。这里面不但包含经典的面试问题，如线程、集合、equals 和 hashcode、socket，而且还包含了 NIO、数组、字符串、Java 8 等主题。</p>
<p>该列表包含了入门级 Java 程序员和多年经验的高级开发者的问题。无论你是 1、2、3、4、5、6、7、8、9 还是 10 年经验的开发者，你都能在其中找到一些有趣的问题。这里包含了一些超级容易回答的问题，同时包含经验丰富的 Java 程序员也会棘手的问题。</p>
<p>当然你们也是非常幸运的，当今有许多好的书来帮助你准备 Java 面试，其中有一本我觉得特别有用和有趣的是 Markham 的 Java 程序面试揭秘（Java Programming Interview Exposed）。这本书会告诉你一些 Java 和 JEE 面试中最重要的主题，即使你不是准备 Java 面试，也值得一读。</p>
<p>该问题列表特别长，我们有各个地方的问题，所以，答案必须要短小、简洁、干脆，不拖泥带水。因此，除了这一个段落，你只会听到问题与答案，再无其他内容，没有反馈，也没有评价。为此，我已经写好了一些博文，在这些文章中你可以找到我对某些问题的观点，如我为什么喜欢这个问题，这个问题的挑战是什么？期望从面试者那获取到什么样的答案？</p>
<p>这个列表有一点不同，我鼓励你采用类似的方式去分享问题和答案，这样容易温习。我希望这个列表对面试官和候选人都有很好的用处，面试官可以对这些问题上做一些改变以获取新奇和令人惊奇的元素，这对一次好的面试来说非常重要。而候选者，可以扩展和测试 Java 程序语言和平台关键领域的知识。2015 年，会更多的关注并发概念，JVM 内部，32 位 JVM 和 64 JVM的区别，单元测试及整洁的代码。我确信，如果你读过这个庞大的 Java 面试问题列表，无论是电话面试还是面对面的面试，你都能有很好的表现。</p>
<h1 id="Java-面试中的重要话题"><a class="header-anchor" href="#Java-面试中的重要话题">¶</a><strong>Java 面试中的重要话题</strong></h1>
<p>除了你看到的惊人的问题数量，我也尽量保证质量。我不止一次分享各个重要主题中的问题，也确保包含所谓的高级话题，这些话题很多程序员不喜欢准备或者直接放弃，因为他们的工作不会涉及到这些。</p>
<p>Java NIO 和 JVM 底层就是最好的例子。你也可以将设计模式划分到这一类中，但是越来越多有经验的程序员了解 GOF 设计模式并应用这些模式。我也尽量在这个列表中包含 2015 年最新的面试问题，这些问题可能是来年关注的核心。为了给你一个大致的了解,下面列出这份 Java 面试问题列表包含的主题：</p>
<ul>
<li>多线程，并发及线程基础</li>
<li>数据类型转换的基本原则</li>
<li>垃圾回收（GC）</li>
<li>Java 集合框架</li>
<li>数组</li>
<li>字符串</li>
<li>GOF 设计模式</li>
<li>SOLID （单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）设计原则</li>
<li>抽象类与接口</li>
<li>Java 基础，如 equals 和 hashcode</li>
<li>泛型与枚举</li>
<li>Java IO 与 NIO</li>
<li>常用网络协议</li>
<li>Java 中的数据结构和算法</li>
<li>正则表达式</li>
<li>JVM 底层</li>
<li>Java 最佳实践</li>
<li>JDBC</li>
<li>Date, Time 与 Calendar</li>
<li>Java 处理 XML</li>
<li>JUnit</li>
<li>编程</li>
</ul>
<h1 id="120-大-Java-面试题及答案"><a class="header-anchor" href="#120-大-Java-面试题及答案">¶</a><strong>120 大 Java 面试题及答案</strong></h1>
<p>现在是时候给你展示我近 5 年从各种面试中收集来的 120 个问题了。我确定你在自己的面试中见过很多这些问题，很多问题你也能正确回答。</p>
<p>多线程、并发及线程的基础问题</p>
<p><strong>1）Java 中能创建 volatile 数组吗？</strong></p>
<p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p>
<p><strong>2）volatile 能使得一个非原子操作变成原子操作吗？</strong></p>
<p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p>
<p><strong>3）volatile 修饰符的有过什么实践？</strong></p>
<p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。</p>
<p>volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p>
<p><strong>4）volatile 类型变量提供什么保证？</strong></p>
<p>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。</p>
<p><strong>5) 10 个线程和 2 个线程的同步代码，哪个更容易写？</strong></p>
<p>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p>
<p><strong>6）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？</strong></p>
<p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; The standard idiom for using the wait method</span><br><span class="line"></span><br><span class="line">synchronized (obj) &#123;</span><br><span class="line"></span><br><span class="line">while (condition does not hold)</span><br><span class="line"></span><br><span class="line">obj.wait(); &#x2F;&#x2F; (Releases lock, and reacquires on wakeup)</span><br><span class="line"></span><br><span class="line">... &#x2F;&#x2F; Perform action appropriate to condition</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。</p>
<p><strong>7）什么是多线程环境下的伪共享（false sharing）？</strong></p>
<p>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：</p>
<p><img src="/2020/07/12/%E6%9C%80%E8%BF%915%E5%B9%B4183%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8%E5%8F%8A%E5%9B%9E%E7%AD%94/1.png" alt="img"></p>
<p>伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。</p>
<h2 id="有经验程序员的-Java-面试题"><a class="header-anchor" href="#有经验程序员的-Java-面试题">¶</a><strong>有经验程序员的 Java 面试题</strong></h2>
<p><strong>8）什么是 Busy spin？我们为什么要使用它？</strong></p>
<p>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</p>
<p><strong>9）Java 中怎么获取一份线程 dump 文件？</strong></p>
<p>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。</p>
<p><strong>10）Swing 是线程安全的？</strong></p>
<p>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。</p>
<p><strong>11）什么是线程局部变量？</strong></p>
<p>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</p>
<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p>ThreadLocal的方法：void set(T value)、T get()以及T initialValue()。</p>
<p>ThreadLocal是如何为每个线程创建变量的副本的：</p>
<p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p>总结：</p>
<p>a、实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的</p>
<p>b、为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</p>
<p>c、在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法</p>
<p><strong>12）用 wait-notify 写一段代码来解决生产者-消费者问题？</strong></p>
<p>请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。</p>
<p><strong>13) 用 Java 写一个线程安全的单例模式（Singleton）？</strong></p>
<p>请参考答案中的示例代码，这里面一步一步教你创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。</p>
<p><strong>14）Java 中 sleep 方法和 wait 方法的区别？</strong></p>
<p>虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。</p>
<p><strong>15）什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？</strong></p>
<p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。详情参见答案，一步一步指导你在 Java 中创建一个不可变的类。</p>
<p><strong>16）我们能创建一个包含可变对象的不可变对象吗？</strong></p>
<p>是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。</p>
<h2 id="数据类型和-Java-基础面试问题"><a class="header-anchor" href="#数据类型和-Java-基础面试问题">¶</a><strong>数据类型和 Java 基础面试问题</strong></h2>
<p><strong>17）Java 中应该使用什么数据类型来代表价格？</strong></p>
<p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p>
<p><strong>18）怎么将 byte 转换为 String？</strong></p>
<p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p>
<p><strong>19）Java 中怎样将 bytes 转换为 long 类型？</strong></p>
<p>String接收bytes的构造器转成String，再Long.parseLong</p>
<p><strong>20）我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</strong></p>
<p>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。</p>
<p><strong>21）存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = © B；</strong></p>
<p>可以，向下转型。但是不建议使用，容易出现类型转型异常.</p>
<p><strong>22）哪个类包含 clone 方法？是 Cloneable 还是 Object？</strong></p>
<p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p>
<p><strong>23）Java 中 ++ 操作符是线程安全的吗？</strong></p>
<p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p>
<p><strong>24）a = a + b 与 a += b 的区别</strong></p>
<p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p>
<blockquote>
<p>byte a = 127;</p>
<p>byte b = 127;</p>
<p>b = a + b; // error : cannot convert from int to byte</p>
<p>b += a; // ok</p>
</blockquote>
<p>（因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）</p>
<p><strong>25）我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？</strong></p>
<p>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</p>
<p><strong>26）3*0.1 == 0.3 将会返回什么？true 还是 false？</strong></p>
<p>false，因为有些浮点数不能完全精确的表示出来。</p>
<p><strong>27）int 和 Integer 哪个会占用更多的内存？</strong></p>
<p>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p>
<p><strong>28）为什么 Java 中的 String 是不可变的（Immutable）？</strong></p>
<p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。</p>
<p><strong>29）我们能在 Switch 中使用 String 吗？</strong></p>
<p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</p>
<p><strong>30）Java 中的构造器链是什么？</strong></p>
<p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p>
<h2 id="JVM-底层-与-GC（Garbage-Collection）-的面试问题"><a class="header-anchor" href="#JVM-底层-与-GC（Garbage-Collection）-的面试问题">¶</a><strong>JVM 底层 与 GC（Garbage Collection） 的面试问题</strong></h2>
<p><strong>31）64 位 JVM 中，int 的长度是多数？</strong></p>
<p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<p><strong>32）Serial 与 Parallel GC之间的不同之处？</strong></p>
<p>Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。</p>
<p><strong>33）32 位和 64 位的 JVM，int 类型变量的长度是多数？</strong></p>
<p>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。</p>
<p><strong>34）Java 中 WeakReference 与 SoftReference的区别？</strong></p>
<p>Java中一共有四种类型的引用。StrongReference、 SoftReference、 WeakReference 以及 PhantomReference。</p>
<p>StrongReference 是 Java 的默认引用实现, 它会尽可能长时间的存活于 JVM 内，当没有任何对象指向它时将会被GC回收</p>
<p>WeakReference，顾名思义, 是一个弱引用, 当所引用的对象在 JVM 内不再有强引用时, 将被GC回收</p>
<p>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用</p>
<p><strong>35）WeakHashMap 是怎么工作的？</strong></p>
<p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p>
<p><strong>36）JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？</strong></p>
<p>当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。</p>
<p><strong>37）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</strong></p>
<p>你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。</p>
<p><strong>38）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</strong></p>
<p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p>
<p><strong>39）JRE、JDK、JVM 及 JIT 之间有什么不同？</strong></p>
<p>JRE 代表 Java 运行时（Java run-time），是运行 Java 应用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。</p>
<p><img src="/2020/07/12/%E6%9C%80%E8%BF%915%E5%B9%B4183%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8%E5%8F%8A%E5%9B%9E%E7%AD%94/2.png" alt></p>
<h2 id="3-年工作经验的-Java-面试题"><a class="header-anchor" href="#3-年工作经验的-Java-面试题">¶</a><strong>3 年工作经验的 Java 面试题</strong></h2>
<p><strong>40）解释 Java 堆空间及 GC？</strong></p>
<p>当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。</p>
<h2 id="JVM-底层面试题及答案"><a class="header-anchor" href="#JVM-底层面试题及答案">¶</a><strong>JVM 底层面试题及答案</strong></h2>
<p><strong>41）你能保证 GC 执行吗？</strong></p>
<p>不能，虽然你可以调用 System.gc() 或者 Runtime.getRuntime().gc()，但是没有办法保证 GC 的执行。</p>
<p>**42）怎么获取 Java 程序使用的内存？**<strong>堆使用的百分比？</strong></p>
<p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p>
<p><strong>43）Java 中堆和栈有什么区别？</strong></p>
<p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。Difference between stack and heap memory in Java</p>
<h2 id="关于内存的的面试问题和答案"><a class="header-anchor" href="#关于内存的的面试问题和答案">¶</a><strong>关于内存的的面试问题和答案</strong></h2>
<p><strong>Java 基本概念面试题</strong></p>
<p><strong>44）“a==b”和”a.equals(b)”有什么区别？</strong></p>
<p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<p><strong>45）a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</strong></p>
<p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p>
<p><strong>46）final、finalize 和 finally 的不同之处？</strong></p>
<p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p>
<p><strong>47）Java 中的编译期常量是什么？使用它又什么风险？</strong></p>
<p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h2 id="Java-集合框架的面试题"><a class="header-anchor" href="#Java-集合框架的面试题">¶</a><strong>Java 集合框架的面试题</strong></h2>
<p>这部分也包含数据结构、算法及数组的面试问题，对于集合框架，详细可以参考：Java集合框架综述，这篇让你吃透！</p>
<p><strong>48) List、Set、Map 和 Queue 之间的区别(答案)</strong></p>
<p>List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。</p>
<p><strong>49）poll() 方法和 remove() 方法的区别？</strong></p>
<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<p><strong>50）Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？(答案)</strong></p>
<p>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</p>
<p><strong>51）ArrayList 与 LinkedList 的不区别？(答案)</strong></p>
<p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见答案。</p>
<p><strong>52）用哪两种方式来实现集合的排序？(答案)</strong></p>
<p>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。</p>
<p><strong>53）Java 中怎么打印数组？(answer答案)</strong></p>
<p>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。</p>
<p><strong>54）Java 中的 LinkedList 是单向链表还是双向链表？(答案)</strong></p>
<p>是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，直接在编辑器中打开该类。</p>
<p><strong>55）Java 中的 TreeMap 是采用什么树实现的？(答案)</strong></p>
<p>Java 中的 TreeMap 是使用红黑树实现的。</p>
<p><strong>56) Hashtable 与 HashMap 有什么不同之处？(答案)</strong></p>
<p>这两个类有许多不同的地方，下面列出了一部分：a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。更多的不同之处参见答案。</p>
<p><strong>57）Java 中的 HashSet，内部是如何工作的？(answer答案)</strong></p>
<p>HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。</p>
<p><strong>58）写一段代码在遍历 ArrayList 时移除一个元素？(答案)</strong></p>
<p>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</p>
<p><strong>59）我们能自己写一个容器类，然后使用 for-each 循环吗？</strong></p>
<p>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</p>
<p><strong>60）ArrayList 和 HashMap 的默认大小是多数？(答案)</strong></p>
<p>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：</p>
<blockquote>
<p>// from ArrayList.java JDK 1.7<br>
private static final int DEFAULT_CAPACITY = 10;</p>
<p>//from HashMap.java JDK 7</p>
<p>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</p>
</blockquote>
<p><strong>61）有没有可能两个不相等的对象有有相同的 hashcode？</strong></p>
<p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p>
<p><strong>62）两个相同的对象会有不同的的 hash code 吗？</strong></p>
<p>不能，根据 hash code 的规定，这是不可能的。</p>
<p><strong>63）我们可以在 hashcode() 中使用随机数字吗？(答案)</strong></p>
<p>不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。</p>
<p><strong>64）Java 中，Comparator 与 Comparable 有什么不同？(答案)</strong></p>
<p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<p><strong>65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？(答案)</strong></p>
<p>因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>
<h2 id="Java-IO-和-NIO-的面试题"><a class="header-anchor" href="#Java-IO-和-NIO-的面试题">¶</a><strong>Java IO 和 NIO 的面试题</strong></h2>
<p>IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。NIO建议阅读：从实践角度重新理解BIO和NIO</p>
<p><strong>66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？</strong></p>
<p><strong>67）Java 中怎么创建 ByteBuffer？</strong></p>
<p><strong>68）Java 中，怎么读写 ByteBuffer ？</strong></p>
<p><strong>69）Java 采用的是大端还是小端？</strong></p>
<p><strong>70）ByteBuffer 中的字节序是什么？</strong></p>
<p><strong>71）Java 中，直接缓冲区与非直接缓冲器有什么区别？(答案)</strong></p>
<p><strong>72）Java 中的内存映射缓存区是什么？(answer答案)</strong></p>
<p><strong>73）socket 选项 TCP NO DELAY 是指什么？</strong></p>
<p><strong>74）TCP 协议与 UDP 协议有什么区别？(answer答案)</strong></p>
<p><strong>75）Java 中，ByteBuffer 与 StringBuffer有什么区别？(答案)</strong></p>
<h2 id="Java-最佳实践的面试问题"><a class="header-anchor" href="#Java-最佳实践的面试问题">¶</a><strong>Java 最佳实践的面试问题</strong></h2>
<p>包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常处理，设计模式等等。</p>
<p><strong>76）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？(答案)</strong></p>
<p>这是我在写Java 并发程序的时候遵循的一些最佳实践：a）给线程命名，这样可以帮助调试。b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。c）如果可以，更偏向于使用 volatile 而不是 synchronized。d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。</p>
<p><strong>77）说出几点 Java 中使用 Collections 的最佳实践(答案)</strong></p>
<p>这是我在使用 Java 中 Collectionc 类的一些最佳实践：a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。d）使用迭代器来循环集合。e）使用集合的时候使用泛型。</p>
<p><strong>78）说出至少 5 点在 Java 中使用线程的最佳实践。(答案)</strong></p>
<p>这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：a）对线程命名 b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。c）使用线程池</p>
<p><strong>79）说出 5 条 IO 的最佳实践(答案)</strong></p>
<p>IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。b）使用 NIO 和 NIO2 c）在 finally 块中关闭流，或者使用 try-with-resource（Java7） 语句。d）使用内存映射文件获取更快的 IO。</p>
<p><strong>80）列出 5 个应该遵循的 JDBC 最佳实践(答案)</strong></p>
<p>有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：a）使用批量的操作来插入和更新数据 b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。c）使用数据库连接池 d）通过列名来获取结果集，不要使用列的下标来获取。</p>
<p><strong>81）说出几条 Java 中方法重载的最佳实践？(答案)</strong></p>
<p>下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。b）不要重载参数数量一致，而只是参数顺序不同的方法。c）如果重载的方法参数个数多于 5 个，采用可变参数。</p>
<h2 id="Date、Time-及-Calendar-的面试题"><a class="header-anchor" href="#Date、Time-及-Calendar-的面试题">¶</a><strong>Date、Time 及 Calendar 的面试题</strong></h2>
<p><strong>82）在多线程环境下，SimpleDateFormat 是线程安全的吗？(答案)</strong></p>
<p>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<p>**83）Java 中如何格式化一个日期？**<strong>如格式化为 ddMMyyyy 的形式？(答案)</strong></p>
<p>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p>
<p><strong>84）Java 中，怎么在格式化的日期中显示时区？</strong></p>
<p>pattern中加z yyyy-MM-dd HH:mm:ss.SSS Z</p>
<p><strong>85）Java 中 java.util.Date 与 java.sql.Date 有什么区别？</strong></p>
<p>java.sql.Date是针对SQL语句使用的，它只包含日期而没有时间部分,它们都有getTime方法返回毫秒数，自然就可以直接构建。java.util.Date 是 java.sql.Date 的父类，前者是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他，后者之后在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date。</p>
<p><strong>86）Java 中，如何计算两个日期之间的差距？</strong></p>
<blockquote>
<p>public static int dateDiff(Date d1, Date d2) throws Exception {</p>
<p>long n1 = d1.getTime();</p>
<p>long n2 = d2.getTime();</p>
<p>long diff = Math.abs(n1 - n2);</p>
<p>diff /= 3600 * 1000 * 24;</p>
<p>return diff;</p>
<p>}</p>
</blockquote>
<p><strong>87）Java 中，如何将字符串 YYYYMMDD 转换为日期？</strong></p>
<p>SimpleDateFormat的parse方法</p>
<h2 id="单元测试-JUnit-面试题"><a class="header-anchor" href="#单元测试-JUnit-面试题">¶</a><strong>单元测试 JUnit 面试题</strong></h2>
<p><strong>89）如何测试静态方法？(答案)</strong></p>
<p>可以使用 PowerMock 库来测试静态方法。</p>
<p><strong>90）怎么利用 JUnit 来测试一个方法的异常？(答案)</strong></p>
<p><strong>91）你使用过哪个单元测试库来测试你的 Java 程序？(答案)</strong></p>
<p><strong>92）@Before 和 @BeforeClass 有什么区别？(答案)</strong></p>
<h2 id="编程和代码相关的面试题"><a class="header-anchor" href="#编程和代码相关的面试题">¶</a><strong>编程和代码相关的面试题</strong></h2>
<p><strong>93）怎么检查一个字符串只包含数字？(解决方案)</strong></p>
<p><strong>94）Java 中如何利用泛型写一个 LRU 缓存？(答案)</strong></p>
<p><strong>95）写一段 Java 程序将 byte 转换为 long？(答案)</strong></p>
<p><strong>95）在不使用 StringBuffer 的前提下，怎么反转一个字符串？(解决方案)</strong></p>
<p><strong>97）Java 中，怎么获取一个文件中单词出现的最高频率？(解决方案)</strong></p>
<p><strong>98）如何检查出两个给定的字符串是反序的？(解决方案)</strong></p>
<p><strong>99）Java 中，怎么打印出一个字符串的所有排列？(解决方案)</strong></p>
<p><strong>100）Java 中，怎样才能打印出数组中的重复元素？(解决方案)</strong></p>
<p><strong>101）Java 中如何将字符串转换为整数？(解决方案)</strong></p>
<p><strong>102）在没有使用临时变量的情况如何交换两个整数变量的值？(解决方案)</strong></p>
<p>交换两个值，不用临时变量?我们通过位运算中的异或来实现。 //测试代码为C语言代码</p>
<p>前置知识：</p>
<p>1.一个整数自己跟自己异或，结果为0  //因为异或的法则为，相同为0，不同为1，注意这里所说的都是二进制位。</p>
<p>2.任意一个整数跟0异或，结果为本身。//因为1异或0得1,0异或0,得0，所以1还是1,0还是0，没发生变化。</p>
<p>测试代码如下：</p>
<blockquote>
<p>int main(int argc, char* argv[])</p>
<p>{</p>
<p>int a=575,b=667;</p>
<p>a=a^b;</p>
<p>b=a^b;</p>
<p>a=a^b;</p>
<p>printf(“a=%d b=%d \n”,a,b);</p>
<p>getchar();</p>
<p>return 0;</p>
<p>}</p>
</blockquote>
<p><strong>//效果截图如下：</strong></p>
<p><img src="/2020/07/12/%E6%9C%80%E8%BF%915%E5%B9%B4183%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8%E5%8F%8A%E5%9B%9E%E7%AD%94/3.png" alt></p>
<p>分析下a和b发生交换的原因：</p>
<p>根据以上代码不难得出以下表达式:</p>
<blockquote>
<ol>
<li>
<p>b=(a<sup>b)</sup>b=a<sup>b</sup>b=a</p>
</li>
<li>
<p>a=(a<sup>b)</sup>[(a<sup>b)</sup>b]=a<sup>b</sup>[a<sup>b</sup>b]=a<sup>b</sup>a<sup>b</sup>b=a<sup>a</sup>b<sup>b</sup>b=b</p>
</li>
</ol>
</blockquote>
<p>根据前面说的前置知识，不难明白a和b，为什么发生交换了。</p>
<h2 id="关于-OOP-和设计模式的面试题"><a class="header-anchor" href="#关于-OOP-和设计模式的面试题">¶</a><strong>关于 OOP 和设计模式的面试题</strong></h2>
<p>这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。设计模式：可以在Java知音公众号内回复“设计模式聚合”，送你一份超级全面的设计模式资料</p>
<p><strong>103）接口是什么？为什么要使用接口而不是直接使用具体类？</strong></p>
<p>接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。</p>
<p><strong>104）Java 中，抽象类与接口之间有什么不同？(答案)</strong></p>
<p>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。</p>
<p><strong>105）除了单例模式，你在生产环境中还用过什么设计模式？</strong></p>
<p>这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的基于你选择的模式的问题。</p>
<p><strong>106）你能解释一下里氏替换原则吗?(答案)</strong></p>
<p><strong>107) 什么情况下会违反迪米特法则？为什么会有这个问题？(答案)</strong></p>
<p>迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。</p>
<p><strong>108）适配器模式是什么？什么时候使用？</strong></p>
<p>适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。</p>
<p><strong>109）什么是“依赖注入”和“控制反转”？为什么有人使用？(答案)</strong></p>
<p><strong>110）抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？(答案)</strong></p>
<p>抽象方法：由abstract修饰的方法为抽象方法，抽象方法只有方法的定义，没有方法的实现。<br>
抽象类：一个类中如果包含抽象方法，个i类应该用abstract关键字声明为抽象类。<br>
抽象类不可以实例化，即使一个类中没有抽象方法，也可以将其定义为抽象类，同样，该类不可以实例化。<br>
抽象类的意义：<br>
1，为子类提供一个公共的类型；</p>
<p>2，封装子类中重复内容（成员变量和方法）；</p>
<p>3，定义有抽象方法，子类虽然有不同的实现，但该方法的定义是一致的。</p>
<p>抽象类和接口的区别：<br>
抽象类：为了被子类继承，为子类提供了同一的方法入口；<br>
接口：定义了一个标准（特殊的抽象类）。</p>
<p><strong>111）构造器注入和 setter 依赖注入，那种方式更好？(答案)</strong></p>
<p>每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是 setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。</p>
<p><strong>112）依赖注入和工厂模式之间有什么不同？(答案)</strong></p>
<p>虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。关于这个话题的更详细讨论请参见答案。</p>
<p><strong>113）适配器模式和装饰器模式有什么区别？(答案)</strong></p>
<p>虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。</p>
<p><strong>114）适配器模式和代理模式之前有什么不同？(答案)</strong></p>
<p>这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。</p>
<p><strong>115）什么是模板方法模式？(答案)</strong></p>
<p>模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。</p>
<p><strong>116）什么时候使用访问者模式？(答案)</strong></p>
<p>访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。</p>
<p><strong>117）什么时候使用组合模式？(答案)</strong></p>
<p>组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。</p>
<p><strong>118）继承和组合之间有什么不同？(答案)</strong></p>
<p>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</p>
<p><strong>119）描述 Java 中的重载和重写？(答案)</strong></p>
<p>重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。</p>
<p><strong>120）Java 中，嵌套公共静态类与顶级类有什么不同？(答案)</strong></p>
<p>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</p>
<p><strong>121) OOP 中的 组合、聚合和关联有什么区别？(答案)</strong></p>
<p>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</p>
<p><strong>122）给我一个符合开闭原则的设计模式的例子？(答案)</strong></p>
<p>开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。</p>
<p><strong>123）抽象工厂模式和原型模式之间的区别？(答案)</strong></p>
<p><strong>124）什么时候使用享元模式？(答案)</strong></p>
<p>享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。</p>
<h2 id="Java-面试中其他各式各样的问题"><a class="header-anchor" href="#Java-面试中其他各式各样的问题">¶</a><strong>Java 面试中其他各式各样的问题</strong></h2>
<p>这部分包含 Java 中关于 XML 的面试题，JDBC 面试题，正则表达式面试题，Java 错误和异常及序列化面试题</p>
<p><strong>125）嵌套静态类与顶级类有什么区别？(答案)</strong></p>
<p>一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。</p>
<p><strong>126）你能写出一个正则表达式来判断一个字符串是否是一个数字吗？(解决方案)</strong></p>
<p>一个数字字符串，只能包含数字，如 0 到 9 以及 +、- 开头，通过这个信息，你可以下一个如下的正则表达式来判断给定的字符串是不是数字。</p>
<p><strong>127）Java 中，受检查异常 和 不受检查异常的区别？(答案)</strong></p>
<p>受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。</p>
<p><img src alt><img src="/2020/07/12/%E6%9C%80%E8%BF%915%E5%B9%B4183%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8%E5%8F%8A%E5%9B%9E%E7%AD%94/4.png" alt="4"></p>
<h1 id="阿里、头条、腾讯面试必问50道Java线程面试题分析及答案！"><a class="header-anchor" href="#阿里、头条、腾讯面试必问50道Java线程面试题分析及答案！">¶</a>阿里、头条、腾讯面试必问50道Java线程面试题分析及答案！</h1>
<p><strong>128）Java 中，throw 和 throws 有什么区别？(答案)</strong></p>
<p>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：throw new IllegalArgumentException(“size must be multiple of 2″) 而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<p><strong>129）Java 中，Serializable 与 Externalizable 的区别？(答案)</strong></p>
<p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<p><strong>130）Java 中，DOM 和 SAX 解析器有什么不同？(答案)</strong></p>
<p>DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要求更多的内存，不适合于解析大 XML 文件。</p>
<p><strong>131）说出 JDK 1.7 中的三个新特性？(答案)</strong></p>
<p>虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。</p>
<p><strong>132）说出 5 个 JDK 1.8 引入的新特性？(答案)</strong></p>
<p>Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：Lambda 表达式，允许像对象一样传递匿名函数 Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 扩展方法，现在，接口中可以有静态、默认方法。重复注解，现在你可以将相同的注解在同一类型上使用多次。</p>
<p><strong>133）Java 中，Maven 和 ANT 有什么区别？(答案)</strong></p>
<p>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之处请参见答案。</p>
<p>这就是所有的面试题，如此之多，是不是？我可以保证，如果你能回答列表中的所有问题，你就可以很轻松的应付任何核心 Java 或者高级 Java 面试。虽然，这里没有涵盖 Servlet、JSP、JSF、JPA，JMS，EJB 及其它 Java EE 技术，也没有包含主流的框架如 Spring MVC，Struts 2.0，Hibernate，也没有包含 SOAP 和 RESTful web service，但是这份列表对做 Java 开发的、准备应聘 Java web 开发职位的人还是同样有用的，因为所有的 Java 面试，开始的问题都是 Java 基础和 JDK API 相关的。如果你认为我这里有任何应该在这份列表中而被我遗漏了的 Java 流行的问题，你可以自由的给我建议。我的目的是从最近的面试中创建一份最新的、最优的 Java 面试问题列表。</p>
<h1 id="50道Java线程面试题分析及答案"><a class="header-anchor" href="#50道Java线程面试题分析及答案">¶</a>50道Java线程面试题分析及答案</h1>
<p><strong>（线程对应学习资源推荐：BV1oK411V7vE）</strong></p>
<p>下面是Java线程相关的热门面试题，你可以用它来好好准备面试。参考：多线程基础体系知识清单</p>
<p>**1) 什么是线程？<br>
**线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。</p>
<p>**2) 线程和进程有什么区别？<br>
**线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
<p>**3) 如何在Java中实现线程？<br>
**在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。</p>
<p>**4) 用Runnable还是Thread？<br>
**这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。</p>
<p>**5) Thread 类中的start() 和 run() 方法有什么区别？<br>
**这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<p>**6) Java中Runnable和Callable有什么不同？<br>
**Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>
<p>**7）如何强制启动一个线程？<br>
**这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p>
<p>**8) Java中CyclicBarrier 和 CountDownLatch有什么不同？<br>
**CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。</p>
<p>**9) Java内存模型是什么？<br>
**Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：<br>
线程内的代码能够按先后顺序执行，这被称为程序次序规则。<br>
对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。<br>
前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。<br>
一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。<br>
一个线程的所有操作都会在线程终止之前，线程终止规则。<br>
一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。<br>
可传递性</p>
<p><strong>10) Java中的volatile 变量是什么？</strong><br>
volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。点击这里查看更多volatile的相关内容。</p>
<p>**11) 什么是线程安全？Vector是一个线程安全类吗？<br>
**如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>
<p>**12) Java中什么是竞态条件？举个例子说明。<br>
**竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。</p>
<p>**13) Java中如何停止一个线程？<br>
**Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。</p>
<p>**14) 一个线程运行时发生异常会怎样？<br>
**这是我在一次面试中遇到的一个很刁钻的Java面试题, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p>
<p>**15） 如何在两个线程间共享数据？<br>
**你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程《Java线程间通信》(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。</p>
<p>**16) Java中notify 和 notifyAll有什么区别？<br>
**这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p>
<p>**17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？<br>
**这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象你也可以查看这篇文章了解更多。</p>
<p><strong>18) 什么是ThreadLocal变量？</strong><br>
ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。</p>
<p>**19) 什么是FutureTask？<br>
**在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p>
<p>**20) Java中interrupted 和 isInterruptedd方法的区别？<br>
**interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
<p>**21) 为什么wait和notify方法要在同步块中调用？<br>
**主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<p>**22) 为什么你应该在循环中检查等待条件?<br>
**处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p>
<p>**23) Java中的同步集合与并发集合有什么区别？<br>
**同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p>
<p>**24） Java中堆和栈有什么不同？<br>
**为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<p><strong>25） 什么是线程池？为什么要使用它？</strong><br>
创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。</p>
<p>**26） 如何写代码来解决生产者消费者问题？<br>
**在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它。</p>
<p>**27） 如何避免死锁？<br>
**死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：<br>
互斥条件：一个资源每次只能被一个进程使用。<br>
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>
不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>
循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>
最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。这篇教程有代码示例和避免死锁的讨论细节。</p>
<p>**28) Java中活锁和死锁有什么区别<br>
**这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<p>**29） 怎么检测一个线程是否拥有锁？<br>
**我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<p>**30) 你如何在Java中获取线程堆栈？<br>
**对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p>
<p>**31) JVM中哪个参数是用来控制线程的栈堆栈小的<br>
**这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看JVM配置列表来了解这个参数的更多信息。</p>
<p>**32） Java中synchronized 和 ReentrantLock 有什么不同？<br>
**Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。</p>
<p><strong>33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？</strong><br>
在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。</p>
<p>**34) Thread类中的yield方法有什么作用？<br>
**Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<p>**35） Java中ConcurrentHashMap的并发度是什么？<br>
**ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。</p>
<p><strong>36） Java中Semaphore是什么？</strong><br>
Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。</p>
<p>**37）如果你提交任务时，线程池队列已满。会时发会生什么？<br>
**这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。</p>
<p>**38) Java线程池中submit() 和 execute()方法有什么区别？<br>
**两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>
<p>**39) 什么是阻塞式方法？<br>
**阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p>
<p>**40) Swing是线程安全的吗？为什么？<br>
**你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新</p>
<p>**41） Java中invokeAndWait 和 invokeLater有什么区别？<br>
**这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。</p>
<p>**42) Swing API中那些方法是线程安全的？<br>
**这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p>
<p>**43) 如何在Java中创建Immutable对象？<br>
**这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。</p>
<p>**44） Java中的ReadWriteLock是什么？<br>
**一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p>
<p>**45) 多线程中的忙循环是什么?<br>
**忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
<p>​		**46）volatile 变量和 atomic 变量有什么不同？<br>
**这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<p>**47) 如果同步块内的线程抛出异常会发生什么？<br>
**这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。</p>
<p>**48） 单例模式的双检锁是什么？<br>
**这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。</p>
<p>**49） 如何在Java中创建线程安全的Singleton？<br>
**这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。</p>
<p>**50) 写出3条你遵循的多线程最佳实践<br>
**这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：<br>
<strong>给你的线程起个有意义的名字。</strong><br>
这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。<br>
<strong>避免锁定和缩小同步的范围</strong><br>
锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。<br>
<strong>多用同步类少用wait 和 notify</strong><br>
首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。<br>
<strong>多用并发集合少用同步集合</strong><br>
这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础【HOW2J】</title>
    <url>/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>地址：<a href="https://how2j.cn?p=154642" target="_blank" rel="noopener">https://how2j.cn?p=154642</a></strong></p>
<a id="more"></a>
<h1 id="一、HelloWord"><a class="header-anchor" href="#一、HelloWord">¶</a>一、HelloWord</h1>
<h2 id="1、手把手教你做JDK环境变量配置"><a class="header-anchor" href="#1、手把手教你做JDK环境变量配置">¶</a>1、手把手教你做JDK环境变量配置</h2>
<h3 id="步骤-1-首先看配置成功后的效果"><a class="header-anchor" href="#步骤-1-首先看配置成功后的效果">¶</a>步骤 <strong>1</strong> : 首先看配置成功后的效果</h3>
<p>点WIN键-&gt;运行（或者使用win+r)<br>
输入cmd命令<br>
输入java -version</p>
<p><strong>注： -version是小写，不能使用大写，java后面有一个空格</strong></p>
<p>配置成功后，会出现版本信息</p>
<p><strong>java version &quot;1.8.0_231&quot;</strong></p>
<p><strong>注: 这是配置完成后的效果，在配置完成之前是看不到这个效果的</strong></p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/1.png" alt></p>
<h3 id="步骤-2-下载，并解压到E-JDK"><a class="header-anchor" href="#步骤-2-下载，并解压到E-JDK">¶</a>步骤 <strong>2</strong> : 下载，并解压到E:\JDK</h3>
<p>首先下载右上角的jdk.rar, 然后解压。<br>
正确的目录是E:\JDK<br>
<strong>不要复制到e:\jdk\jdk</strong> 这个目录去了<br>
注意目录结构</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/263.png" alt></p>
<h3 id="步骤-3-环境变量配置"><a class="header-anchor" href="#步骤-3-环境变量配置">¶</a>步骤 <strong>3</strong> : 环境变量配置</h3>
<p>右键我的电脑-&gt;属性-&gt;高级-&gt;环境变量-&gt;系统变量<br>
注意：是下面的<strong>系统变量</strong>，不是上面的用户变量<br>
新建变量名 JAVA_HOME，变量值 <strong>E:\JDK</strong><br>
修改变量 Path ，在最前面加上 <strong>%JAVA_HOME%\bin;</strong><br>
注意：&quot;Path&quot;是<strong>首字母大写</strong>，<strong>不要改成&quot;PATH&quot;</strong> bin后面要有<strong>分号</strong>;<br>
注意：系统变量上面的用户变量里，不要有这两个，如果有应该去掉，以避免被干扰。<br>
注意：Win10 下PATH的配置有所不同，按照下个步骤配置即可：[Win10 下环境变量Path的配置]</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/264.png" alt></p>
<h3 id="步骤-4-Win10-下环境变量Path的配置"><a class="header-anchor" href="#步骤-4-Win10-下环境变量Path的配置">¶</a>步骤 <strong>4</strong> : Win10 下环境变量Path的配置</h3>
<p>新增一个，放在最上面即可</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/6560.png" alt></p>
<h3 id="步骤-5-验证是否配置成功"><a class="header-anchor" href="#步骤-5-验证是否配置成功">¶</a>步骤 <strong>5</strong> : 验证是否配置成功</h3>
<p>点击确认关闭刚才的配置页面，这一步一定要做，否则刚才的配置不能生效</p>
<p>点WIN键-&gt;运行（或者使用win+r)<br>
输入cmd命令<br>
输入java -version<br>
如果出现版本信息，表明配置成功<br>
如果失败了，调整前面的配置，然后要<strong>重新启动cmd命令</strong>，而不是在原有的cmd里面输入 java -version</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/1.png" alt></p>
<h3 id="步骤-6-练习-环境变量配置"><a class="header-anchor" href="#步骤-6-练习-环境变量配置">¶</a>步骤 <strong>6</strong> : 练习-环境变量配置</h3>
<p>假设JDK的所在目录是：<strong>C:\Program Files\Java\jdk1.8.0_65</strong>，应该怎么调整配置？</p>
<p>答：新建变量名 JAVA_HOME，变量值<strong>C:\Program Files\Java\jdk1.8.0_65</strong></p>
<p>只需要修改JAVA_HOME的配置即可，其他都不需要发生变化<br>
PATH也不需要发生变化，因为它引用的就是JAVA_HOME的路径</p>
<h2 id="2、用命令行中编写第一个-JAVA-程序"><a class="header-anchor" href="#2、用命令行中编写第一个-JAVA-程序">¶</a>2、用命令行中编写第一个 JAVA 程序</h2>
<h3 id="步骤-1-先看运行效果"><a class="header-anchor" href="#步骤-1-先看运行效果">¶</a>步骤 <strong>1</strong> : 先看运行效果</h3>
<p>在控制台下运行第一个Java程序，可以看到输出了字符串<br>
<strong>hello world</strong></p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2061.png" alt></p>
<h3 id="步骤-2-准备项目目录"><a class="header-anchor" href="#步骤-2-准备项目目录">¶</a>步骤 <strong>2</strong> : 准备项目目录</h3>
<p>通常都会在e: 创建一个project目录<br>
在这个例子里，我们用的是e:/project/j2se目录作为项目目录<br>
所有的java代码都会放在这个项目目录下<br>
并创建一个目录 src用于存放java源代码 .java　文件</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/505.png" alt></p>
<h3 id="步骤-3-创建第一个java-源文件"><a class="header-anchor" href="#步骤-3-创建第一个java-源文件">¶</a>步骤 <strong>3</strong> : 创建第一个java 源文件</h3>
<p>创建第一个java 源文件<br>
在屏幕空白位置，点击鼠标右键-&gt;新建-&gt;文本文件 得到一个文件”新建 文本文档.txt“<br>
右键该文件-&gt;重命名为 HelloWorld.java<br>
在该文件中敲入如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    System.out.println(&quot;hello world&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为java 是<strong>面向对象</strong>的编程语言，所以我们实际上是在<strong>创建一个个的类</strong><br>
class HelloWorld 表示这个<strong>类的名字是</strong>HelloWorld<br>
public static void main(String[] args) 这是<strong>主方法</strong>，所有代码的入口<br>
如果你学过c语言 ，相当于 _main 程序入口<br>
System.out.println(“hello world”); 表示在控制台（黑屏幕）<strong>输出一个字符串</strong>“hello world”</p>
<h3 id="步骤-4-显示扩展名"><a class="header-anchor" href="#步骤-4-显示扩展名">¶</a>步骤 <strong>4</strong> : 显示扩展名</h3>
<p>有时候系统会默认把扩展名隐藏掉，可以通过如下方式显示扩展名，以便于把.txt修改为.java<br>
打开我的电脑-&gt; F10显示菜单栏-&gt;工具-&gt;文件夹选项-&gt;查看-&gt; 去掉 <strong>隐藏已知文件类型的扩展名</strong> 上的勾选</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/4194.png" alt></p>
<h3 id="步骤-5-编译"><a class="header-anchor" href="#步骤-5-编译">¶</a>步骤 <strong>5</strong> : 编译</h3>
<p>.java 文件是java的源文件，但是<strong>不能直接运行</strong>，必须先被编译成为.class文件 才能够执行<br>
java 使用 javac命令进行编译<br>
语法：</p>
<p>javac filename.java</p>
<p>注：必须跟上.java 后缀名<br>
如图 执行如下命令：<br>
运行 win+r,输入 cmd 进入控制台界面<br>
e: 切换盘符为e盘<br>
cd e:\project\j2se\src 切换目录到源文件目录<br>
javac HelloWorld.java 编译命令 javac 文件名大小写必须一致<br>
<strong>如果得到一行空白，就表示成功了</strong>，并且得到一个class文件： HelloWorld.class<br>
<strong>注：</strong> 第一行切换盘符的**e:**不要忘记了</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/507.png" alt></p>
<h3 id="步骤-6-运行"><a class="header-anchor" href="#步骤-6-运行">¶</a>步骤 <strong>6</strong> : 运行</h3>
<p>java的运行命令是</p>
<p>java classname</p>
<p>如图 执行如下命令：<br>
运行 win+r,输入 cmd 进入<strong>控制台界面<br>
e: 切换盘符为e盘<br>
cd e:\project\j2se\src 切换目录到源文件目录<br>
java HelloWorld</strong><br>
注意大小写需要一致，并且<strong>没有后缀名.class</strong><br>
运行成功后会看到字符串 “hello world”</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/508.png" alt></p>
<h3 id="步骤-7-关于类"><a class="header-anchor" href="#步骤-7-关于类">¶</a>步骤 <strong>7</strong> : 关于类</h3>
<p>java所有的代码都是运行在类里面的</p>
<p>public class HelloWorld</p>
<p><strong>public</strong> 表示这是一个可以公开访问的类<br>
<strong>class</strong> 表示这是一个类<br>
<strong>HelloWorld</strong> 表示类的名字，每个单词的首字母大写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-8-主方法"><a class="header-anchor" href="#步骤-8-主方法">¶</a>步骤 <strong>8</strong> : 主方法</h3>
<p>public static void main(String[] args)<br>
你会写很多代码，总有第一行执行的代码，这就是主方法<br>
args 表示运行参数，在本例中没有使用到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-9-控制台输出"><a class="header-anchor" href="#步骤-9-控制台输出">¶</a>步骤 <strong>9</strong> : 控制台输出</h3>
<p>System.out.println(“hello world”);</p>
<p>会在控制台输出字符串<br>
println 表示打印数据到控制台，并且换行</p>
<h2 id="3、下载-ECLIPSE"><a class="header-anchor" href="#3、下载-ECLIPSE">¶</a>3、下载 ECLIPSE</h2>
<h2 id="4、使用ECIPSE创建第一个-JAVA-PROJECT"><a class="header-anchor" href="#4、使用ECIPSE创建第一个-JAVA-PROJECT">¶</a>4、使用ECIPSE创建第一个 JAVA PROJECT</h2>
<h3 id="步骤-1-打开-eclipse"><a class="header-anchor" href="#步骤-1-打开-eclipse">¶</a>步骤 <strong>1</strong> : 打开 eclipse</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/267.png" alt></p>
<h3 id="步骤-2-选择工作区"><a class="header-anchor" href="#步骤-2-选择工作区">¶</a>步骤 <strong>2</strong> : 选择工作区</h3>
<p>使用在命令行Hello World中的项目目录e:\project</p>
<p>除了第一次启动eclipse的时候能够选择工作区之外，还可以在启动之后，通过如下命令进行工作区的选择：<br>
File -&gt; Switch Workspace 选择e:\project作为工作区</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/1064.png" alt></p>
<h3 id="步骤-3-创建java项目"><a class="header-anchor" href="#步骤-3-创建java项目">¶</a>步骤 <strong>3</strong> :创建java项目</h3>
<p>如果是第一次创建Java项目</p>
<p>File-&gt;New-&gt;Other-&gt;Java-&gt;java Project</p>
<p>以后再创建java项目，就只需要</p>
<p>File-&gt;New-&gt;java project</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/268.png" alt></p>
<h3 id="步骤-4-项目名称输入j2se"><a class="header-anchor" href="#步骤-4-项目名称输入j2se">¶</a>步骤 <strong>4</strong> : 项目名称输入j2se</h3>
<p>项目名称输入j2se<br>
点击finish即可</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/269.png" alt></p>
<h3 id="步骤-5-创建成功后看到的界面"><a class="header-anchor" href="#步骤-5-创建成功后看到的界面">¶</a>步骤 <strong>5</strong> : 创建成功后看到的界面</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/509.png" alt></p>
<h2 id="5、在ECLIPSE中运行第一个-JAVA-程序"><a class="header-anchor" href="#5、在ECLIPSE中运行第一个-JAVA-程序">¶</a>5、在ECLIPSE中运行第一个 JAVA 程序</h2>
<h3 id="步骤-1-打开java文件"><a class="header-anchor" href="#步骤-1-打开java文件">¶</a>步骤 <strong>1</strong> : 打开java文件</h3>
<p>直接打开在 命令行Hello World中创建的java 文件<br>
HelloWorld.java</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/510.png" alt></p>
<h3 id="步骤-2-运行"><a class="header-anchor" href="#步骤-2-运行">¶</a>步骤 <strong>2</strong> : 运行</h3>
<p>点击绿色运行按钮，直接运行<br>
在eclipse中，编译过程<strong>自动执行了</strong></p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/511.png" alt></p>
<h3 id="步骤-3-观察运行结果"><a class="header-anchor" href="#步骤-3-观察运行结果">¶</a>步骤 <strong>3</strong> : 观察运行结果</h3>
<p>一旦运行成功，会在下方出现控制台console界面<br>
如果找不到控制台console窗口，使用如下步骤[打开控制台窗口]</p>
<h3 id="步骤-4-打开控制台窗口"><a class="header-anchor" href="#步骤-4-打开控制台窗口">¶</a>步骤 <strong>4</strong> :打开控制台窗口</h3>
<p>在默认情况下，console窗口是打开的，倘若无意关闭了，那么可以通过如下方式打开：<br>
菜单-&gt; Window -&gt; Show View -&gt; Console</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/941.png" alt></p>
<h2 id="6、ECLIPSE常见的使用技巧"><a class="header-anchor" href="#6、ECLIPSE常见的使用技巧">¶</a>6、ECLIPSE常见的使用技巧</h2>
<h3 id="示例-1-批量修改"><a class="header-anchor" href="#示例-1-批量修改">¶</a>示例 <strong>1</strong> : 批量修改</h3>
<p>ALT+SHIFT+R</p>
<h3 id="示例-2-快速输入主方法"><a class="header-anchor" href="#示例-2-快速输入主方法">¶</a>示例 <strong>2</strong> : 快速输入主方法</h3>
<ol>
<li>敲入main</li>
<li>alt+/</li>
</ol>
<h3 id="示例-3-快速输入System-out-println"><a class="header-anchor" href="#示例-3-快速输入System-out-println">¶</a>示例 <strong>3</strong> : 快速输入System.out.println</h3>
<ol>
<li>
<p>敲入syso</p>
</li>
<li>
<p>alt+/</p>
</li>
</ol>
<h3 id="示例-4-快速输入for"><a class="header-anchor" href="#示例-4-快速输入for">¶</a>示例 <strong>4</strong> : 快速输入for</h3>
<ol>
<li>
<p>敲入for</p>
</li>
<li>
<p>alt+/</p>
</li>
</ol>
<h3 id="示例-5-查看java源代码"><a class="header-anchor" href="#示例-5-查看java源代码">¶</a>示例 <strong>5</strong> : 查看java源代码</h3>
<p>JDK里提供的类，比如String,Integer,System都是开源的，免费提供其源代码可以很简便的通过eclipse就查看源码</p>
<ol>
<li>
<p>先选中想要查看的方法，比如System.out.println()的 println</p>
</li>
<li>
<p>敲键F3</p>
</li>
</ol>
<h3 id="示例-6-代码格式化"><a class="header-anchor" href="#示例-6-代码格式化">¶</a>示例 <strong>6</strong> : 代码格式化</h3>
<p>ctrl+shift+f<br>
格式化代码<br>
注意： 这个快捷键和搜狗输入法的切换简繁冲突。 所以最好把搜狗的切换简繁取消掉。</p>
<h3 id="示例-7-快速助手"><a class="header-anchor" href="#示例-7-快速助手">¶</a>示例 <strong>7</strong> : 快速助手</h3>
<p>ctrl+shift+o<br>
import 类<br>
去掉未使用的类 等等都可以使用</p>
<h3 id="示例-8-快速注释"><a class="header-anchor" href="#示例-8-快速注释">¶</a>示例 <strong>8</strong> : 快速注释</h3>
<p>选中一行或者多行代码 ctrl+shift+c</p>
<p>或ctrl+/</p>
<h3 id="示例-9-大小写转换"><a class="header-anchor" href="#示例-9-大小写转换">¶</a>示例 <strong>9</strong> : 大小写转换</h3>
<p>ctrl+shift+x 选中的转换为大写<br>
ctrl+shift+y 选中的转换为小写</p>
<h3 id="示例-10-快速解决办法提示"><a class="header-anchor" href="#示例-10-快速解决办法提示">¶</a>示例 <strong>10</strong> : 快速解决办法提示</h3>
<p>在出错误的行，使用ctrl+1。 比如忘记导入类了，就可以用这个解决</p>
<h3 id="示例-11-toString-getter-setter-构造方法的快速生成"><a class="header-anchor" href="#示例-11-toString-getter-setter-构造方法的快速生成">¶</a>示例 <strong>11</strong> : toString getter setter 构造方法的快速生成</h3>
<ol>
<li>通过菜单-&gt; Source 就可以看到快速生成的选项</li>
<li>直接使用快捷键 shift+alt+s也可以弹出这个选项</li>
</ol>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2613.png" alt></p>
<h2 id="7、找不到类"><a class="header-anchor" href="#7、找不到类">¶</a>7、找不到类</h2>
<h3 id="步骤-1-现象"><a class="header-anchor" href="#步骤-1-现象">¶</a>步骤 <strong>1</strong> : 现象</h3>
<p>有时候会碰到如图所示的问题，分明有Hello这个类，并且也有主方法，可是运行就会出现找不到或者无法加载类Hello,或者Class Not Found 异常。</p>
<p>出现这个状况，有多种原因造成，请按照如下方式一一排查</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/5815.png" alt></p>
<h4 id="原因1-是否自动勾选"><a class="header-anchor" href="#原因1-是否自动勾选">¶</a>原因1-是否自动勾选</h4>
<p>Eclipse是保存后自动编译，但是建立在一个设置的前提上：<br>
菜单-Project-&gt;勾选Build Automatically，如果这里没有勾选，那么是不会自动把Hello.java编译成Hello.class的</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/5816.png" alt></p>
<h4 id="原因2-problems"><a class="header-anchor" href="#原因2-problems">¶</a>原因2-problems</h4>
<p>菜单-&gt;Window-&gt;Show View-&gt;Problems 显示Problems页面<br>
这里会显示当前项目的错误，倘若有错误，那么项目也不会对.java文件进行自动编译。</p>
<p>如图所示的错误是项目所导入的包不存在,导入包的做法请参考：[为项目导入mysql-jdbc的jar包]</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/5817.png" alt></p>
<h1 id="二、面向对象"><a class="header-anchor" href="#二、面向对象">¶</a>二、面向对象</h1>
<h2 id="1、JAVA中的类和对象"><a class="header-anchor" href="#1、JAVA中的类和对象">¶</a>1、JAVA中的类和对象</h2>
<h3 id="步骤-1-设计英雄这个类"><a class="header-anchor" href="#步骤-1-设计英雄这个类">¶</a>步骤 <strong>1</strong> : 设计英雄这个类</h3>
<p>LOL有很多英雄，比如盲僧，团战可以输，提莫必须死，盖伦，琴女<br>
所有这些英雄，<strong>都有一些共同的状态</strong><br>
比如，他们都有名字，hp，护甲，移动速度等等<br>
这样我们就可以设计一种东西，<strong>叫做类，代表英雄</strong>这样一种事物<br>
类： 英雄(Hero)<br>
状态： 名字, 血量，护甲，移动速度</p>
<p><strong>注:</strong> 本例用到了3种数据类型 分别是 String(字符串)，float(浮点数), int(整数)，本章只做简单的使用 ，就不展开了，关于[变量]知识的详细讲解，将在[下个章节]展开.<br>
<strong>注:</strong> 这个类没有主方法，不要试图运行它。 并不是所有的类都是有主方法的。</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/581.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">     </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">     </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">     </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">     </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-创建具体的英雄"><a class="header-anchor" href="#步骤-2-创建具体的英雄">¶</a>步骤 <strong>2</strong> : 创建具体的英雄</h3>
<p><strong>类就像一个模板</strong>，根据这样一个模板，可以创建一个个的具体的英雄<br>
一个个具体的英雄，就叫一个个的<strong>对象</strong><br>
<strong>new Hero()</strong> 就是java中创建一个英雄对象的意思</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/582.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">     </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">     </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">     </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">     </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen &#x3D;  new Hero();</span><br><span class="line">        garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        garen.hp &#x3D; 616.28f;</span><br><span class="line">        garen.armor &#x3D; 27.536f;</span><br><span class="line">        garen.moveSpeed &#x3D; 350;</span><br><span class="line">         </span><br><span class="line">        Hero teemo &#x3D;  new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 383f;</span><br><span class="line">        teemo.armor &#x3D; 14f;</span><br><span class="line">        teemo.moveSpeed &#x3D; 330;</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-类的第一个字母大写"><a class="header-anchor" href="#步骤-3-类的第一个字母大写">¶</a>步骤 <strong>3</strong> : 类的第一个字母大写</h3>
<p>好的编程习惯会让代码看上去更清爽，易读，容易维护<br>
比如<strong>类的第一个字母大写</strong><br>
<strong>H</strong>ero</p>
<h3 id="步骤-4-练习-Item"><a class="header-anchor" href="#步骤-4-练习-Item">¶</a>步骤 <strong>4</strong> : 练习-Item</h3>
<p>设计出物品这种类<br>
类名：<strong>Item</strong><br>
物品有如下属性:<br>
名字 <strong>name</strong> 类型是字符串String<br>
价格 <strong>price</strong> 类型是整型 int</p>
<p>创建(实例化)3件具体物品<br>
名称 价格<br>
血瓶 50<br>
草鞋 300<br>
长剑 350</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">设计出物品这种类</span><br><span class="line">类名：Item</span><br><span class="line">物品有如下属性:</span><br><span class="line">名字 name 类型是字符串String</span><br><span class="line">价格 price 类型是整型 int</span><br><span class="line"> </span><br><span class="line">创建(实例化)3件具体物品</span><br><span class="line">名称 价格</span><br><span class="line">血瓶 50</span><br><span class="line">草鞋 300</span><br><span class="line">长剑 350</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Item &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;名称&quot; + &quot; &quot; + &quot;价格&quot;);</span><br><span class="line">        Iteam i1 &#x3D; new Iteam();</span><br><span class="line">        i1.setName(&quot;血瓶&quot;);</span><br><span class="line">        i1.setPrice(50);</span><br><span class="line">        System.out.println(i1.getName() + &quot; &quot; + i1.getPrice());</span><br><span class="line"> </span><br><span class="line">        Iteam i2 &#x3D; new Iteam();</span><br><span class="line">        i2.setName(&quot;草鞋&quot;);</span><br><span class="line">        i2.setPrice(300);</span><br><span class="line">        System.out.println(i2.getName() + &quot; &quot; + i2.getPrice());</span><br><span class="line"> </span><br><span class="line">        Iteam i3 &#x3D; new Iteam();</span><br><span class="line">        i3.setName(&quot;长剑&quot;);</span><br><span class="line">        i3.setPrice(350);</span><br><span class="line">        System.out.println(i3.getName() + &quot; &quot; + i3.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">    static class Iteam&#123;</span><br><span class="line"> </span><br><span class="line">        String name;</span><br><span class="line">        int price;</span><br><span class="line"> </span><br><span class="line">        public Iteam() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public Iteam(String name, int price) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            this.price &#x3D; price;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public void setPrice(int price) &#123;</span><br><span class="line">            this.price &#x3D; price;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public int getPrice() &#123;</span><br><span class="line">            return price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA类的属性"><a class="header-anchor" href="#2、JAVA类的属性">¶</a>2、JAVA类的属性</h2>
<h3 id="步骤-1-属性的类型"><a class="header-anchor" href="#步骤-1-属性的类型">¶</a>步骤 <strong>1</strong> : 属性的类型</h3>
<p>属性的类型可以是[基本类型]，比如int整数，float 浮点数<br>
也可以是类类型，比如String 字符串</p>
<p>其他类型请参考[基本类型章节]</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/629.png" alt></p>
<h3 id="步骤-2-属性名称"><a class="header-anchor" href="#步骤-2-属性名称">¶</a>步骤 <strong>2</strong> : 属性名称</h3>
<p>属性名称一般来说，都是小写<br>
比如name<br>
如果有多个单词组成，后面的单词的第一个字母大写<br>
比如 moveSpeed<br>
属性也是变量，所以需要满足 [变量的命名规则]</p>
<h3 id="步骤-3-练习-属性"><a class="header-anchor" href="#步骤-3-练习-属性">¶</a>步骤 <strong>3</strong> : 练习-属性</h3>
<p>一个英雄可以有名称，血量，护甲，移动速度，还有 其他你想到的，作为新的属性，加入到英雄上面</p>
<p>比如<br>
送了多少次<br>
杀人次数<br>
助攻次数<br>
金钱<br>
补刀数<br>
攻击速度<br>
杀人后说的话<br>
被杀后说的话<br>
。。。</p>
<p>如果没玩过LOL，可以考虑身边的东西，比如你现在看着的手机，笔记本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test01&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hero&#123;</span><br><span class="line">     </span><br><span class="line">    String name;        &#x2F;&#x2F;名称</span><br><span class="line">    int hp;             &#x2F;&#x2F;血量</span><br><span class="line">    int armor;          &#x2F;&#x2F;护甲</span><br><span class="line">    int moveSpeed;      &#x2F;&#x2F;移动速度</span><br><span class="line">    int beKill          &#x2F;&#x2F;被击杀次数</span><br><span class="line">    int kill            &#x2F;&#x2F;击杀次数</span><br><span class="line">    int assists         &#x2F;&#x2F;助攻次数</span><br><span class="line">    int money           &#x2F;&#x2F;金钱</span><br><span class="line">    int last            &#x2F;&#x2F;补刀数</span><br><span class="line">    int attackSpeed     &#x2F;&#x2F;攻击速度</span><br><span class="line">    String killSaid     &#x2F;&#x2F;杀人后说的话</span><br><span class="line">    String beKillSaid   &#x2F;&#x2F;被杀后说的话</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA类的方法"><a class="header-anchor" href="#3、JAVA类的方法">¶</a>3、JAVA类的方法</h2>
<h3 id="示例-1-什么是方法"><a class="header-anchor" href="#示例-1-什么是方法">¶</a>示例 <strong>1</strong> : 什么是方法</h3>
<p>比如队友残血正在逃跑，你过去把路给别人挡住了，导致他被杀掉。 这就是坑队友<br>
每个英雄。。。。都可以<strong>坑</strong><br>
所以为Hero这个类，设计一个方法: keng</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/632.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">      </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">      </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">      </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;坑队友</span><br><span class="line">    void keng()&#123;</span><br><span class="line">        System.out.println(&quot;坑队友！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-方法返回类型"><a class="header-anchor" href="#示例-2-方法返回类型">¶</a>示例 <strong>2</strong> : 方法返回类型</h3>
<p>有的方法是有返回类型的<br>
比如方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float getArmor()&#123;</span><br><span class="line"></span><br><span class="line">  return armor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用来获取一个英雄有多少护甲的，返回类型是float<br>
有的方法不需要返回值，这个时候就<strong>把返回类型设置为void</strong>,表示该方法不返回任何值<br>
比如方法 “坑队友”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void keng()&#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;坑队友！&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-方法的参数"><a class="header-anchor" href="#示例-3-方法的参数">¶</a>示例 <strong>3</strong> : 方法的参数</h3>
<p>英雄在一些特定情况下，可以增加移动速度<br>
这样我们就通过<strong>addSpeed</strong>这个方法增加移动速度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addSpeed(int speed)&#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;在原来的基础上增加移动速度</span><br><span class="line"></span><br><span class="line">  moveSpeed &#x3D; moveSpeed + speed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int speed 叫做<strong>方法的参数</strong><br>
给盖伦增加100的移动速度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hero garen &#x3D;  new Hero();</span><br><span class="line"></span><br><span class="line">garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line"></span><br><span class="line">garen.moveSpeed &#x3D; 350;</span><br><span class="line"></span><br><span class="line">garen.addSpeed(100);</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-方法的命名"><a class="header-anchor" href="#示例-4-方法的命名">¶</a>示例 <strong>4</strong> : 方法的命名</h3>
<p>方法是一个类的动作行为，所以一般都是<strong>以动词开头</strong>的，比如 <strong>keng …</strong><br>
如果有多个单词，后面的每个单词的第一个字母使用大写<br>
比如 addSpeed</p>
<h3 id="示例-5-练习-方法"><a class="header-anchor" href="#示例-5-练习-方法">¶</a>示例 <strong>5</strong> : 练习-方法</h3>
<p>为英雄类Hero设计几个新的方法：</p>
<ol>
<li>
<p>超神 <strong>legendary()</strong>,无参数，无返回类型</p>
</li>
<li>
<p>获取当前的血量 <strong>getHp()</strong>, 无参数，有float类型的返回值</p>
</li>
<li>
<p>回血 <strong>recovery(float blood)</strong>， 有参数 float类型参数 blood表示本次恢复的血量，无返回类型</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package basic;</span><br><span class="line"> </span><br><span class="line">public class Property &#123;</span><br><span class="line">    String name;</span><br><span class="line">    float hp;</span><br><span class="line">    float agility;</span><br><span class="line">    int blood;</span><br><span class="line">    int blue;</span><br><span class="line">    int violet;</span><br><span class="line">    int lucky;</span><br><span class="line"> </span><br><span class="line">    public void ace()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;哦，你是全程MVP&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public float getHp()</span><br><span class="line">    &#123;</span><br><span class="line">        return hp;</span><br><span class="line">    &#125;</span><br><span class="line">    public void recovery(float blood)</span><br><span class="line">    &#123;</span><br><span class="line">        hp&#x3D;hp+blood;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero turtle &#x3D; new Hero();</span><br><span class="line">        turtle.name&#x3D;&quot;龙龟&quot;;</span><br><span class="line">        turtle.hp&#x3D;5000;</span><br><span class="line">        turtle.recovery(1000);</span><br><span class="line">        System.out.println(turtle.hp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、变量"><a class="header-anchor" href="#三、变量">¶</a>三、变量</h1>
<h2 id="1、什么是变量"><a class="header-anchor" href="#1、什么是变量">¶</a>1、什么是变量</h2>
<h3 id="步骤-1-什么是变量"><a class="header-anchor" href="#步骤-1-什么是变量">¶</a>步骤 <strong>1</strong> : 什么是变量</h3>
<p>变量的定义是： 用来命名一个数据的标识符<br>
1949 这是一个数字，代表某年</p>
<p>如果要命名这个数字，在java里就会写成：</p>
<p>int year = 1949;</p>
<p><strong>int</strong> 是数据类型，表示是整数<br>
<strong>year</strong> 是一个标识符<br>
<strong>=</strong> 是赋值操作符<br>
<strong>1949</strong> 是一个数字类型的值<br>
<strong>;</strong> 表示该行结束</p>
<p>year 这个标识符就是一个变量，它代表1949这个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int year &#x3D; 1949;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA中有八种基本变量类型"><a class="header-anchor" href="#2、JAVA中有八种基本变量类型">¶</a>2、JAVA中有八种基本变量类型</h2>
<h3 id="示例-1-整型"><a class="header-anchor" href="#示例-1-整型">¶</a>示例 <strong>1</strong> : 整型</h3>
<p>整型变量用于存放整数<br>
byte<br>
short<br>
int<br>
long<br>
区别在于不同类型的整型，最大值，最小值不一样<br>
如果试图给byte类型的变量赋予超出其范围的值，就会产生编译错误，这个时候就需要进行[类型转换]，在后面的章节会讲解</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/513.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">    </span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">      byte b &#x3D; 1;</span><br><span class="line">      short s &#x3D; 200;</span><br><span class="line">      int i &#x3D; 300;</span><br><span class="line">      long l &#x3D; 400;</span><br><span class="line"> </span><br><span class="line">      &#x2F;*如果试图给byte类型的变量赋予超出其范围的值，就会产生编译错误*&#x2F;</span><br><span class="line">      byte b2 &#x3D; 200;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-字符型"><a class="header-anchor" href="#示例-2-字符型">¶</a>示例 <strong>2</strong> : 字符型</h3>
<p>char类型用于存放一个字符，值用单引号’表示 (双引号表示字符串)<br>
其长度和short一样，也是16位的<br>
<strong>只能存放一个字符</strong>，超过一个字符就会产生编译错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">    </span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">      char c &#x3D; &#39;中&#39;;</span><br><span class="line">      &#x2F;&#x2F;char 只能存放一个字符，超过一个字符就会产生编译错误</span><br><span class="line">      char c2 &#x3D; &#39;中国&#39;; &#x2F;&#x2F;报错</span><br><span class="line">      char c3 &#x3D; &#39;ab&#39;; &#x2F;&#x2F;报错</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-浮点型"><a class="header-anchor" href="#示例-3-浮点型">¶</a>示例 <strong>3</strong> : 浮点型</h3>
<p>浮点数类型有两种<br>
float 长度为32位<br>
double 长度为64位<br>
<strong>注意： 默认的小数值是double类型的</strong><br>
所以 float f = 54.321会出现编译错误，因为54.321的默认类型是 double，其类型 长度为64，超过了float的长度32<br>
在数字后面<strong>加一个字母f</strong>，直接把该数字声明成float类型<br>
float f2 = 54.321<strong>f</strong>,<br>
这样就不会出错了</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/515.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">     </span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">      double d &#x3D; 123.45;</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F;该行会出现编译错误，因为54.321是double型的</span><br><span class="line">      float f &#x3D; 54.321;</span><br><span class="line">        </span><br><span class="line">      float f2 &#x3D; 54.321f;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-布尔型"><a class="header-anchor" href="#示例-4-布尔型">¶</a>示例 <strong>4</strong> : 布尔型</h3>
<p>布尔型用于表示真假<br>
其长度为1</p>
<p>boolean b1 = true;</p>
<p>boolean b2 = false;</p>
<p>分别代表真假<br>
虽然布尔型真正存放的数据是0(false) 1(true)<br>
但是，不能直接使用0 1 进行赋值</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/516.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        boolean b1 &#x3D; true;</span><br><span class="line">        boolean b2 &#x3D; false;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 虽然布尔型真正存放的数据是0(false) 1(true)</span><br><span class="line">        &#x2F;&#x2F; 但是，不能直接使用0 1 进行赋值</span><br><span class="line">        boolean b3 &#x3D; 1;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-String类型"><a class="header-anchor" href="#示例-5-String类型">¶</a>示例 <strong>5</strong> : String类型</h3>
<p>String类型其实<strong>并不是基本类型</strong>，但是它是如此广泛的被使用，常常被误以为是一种基本类型。<br>
String类型是Immutable的，一旦创建就不能够被改变，更多的关于String的学习，[请参考String]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str &#x3D; &quot;Hello Java&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-练习-变量"><a class="header-anchor" href="#示例-6-练习-变量">¶</a>示例 <strong>6</strong> : 练习-变量</h3>
<p>分别为如下值，找到合适的类型来定义<br>
3.14<br>
2.769343<br>
365<br>
12<br>
‘吃’<br>
false<br>
“不可描述”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double a &#x3D; 3.14;</span><br><span class="line">double b &#x3D; 2.769343</span><br><span class="line">int c &#x3D; 365;</span><br><span class="line">int d &#x3D; 12;</span><br><span class="line">char e &#x3D; &#39;吃&#39;;</span><br><span class="line">boolean f &#x3D; false;</span><br><span class="line">String g &#x3D; &quot;不可描述&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="3、什么是JAVA的字面值"><a class="header-anchor" href="#3、什么是JAVA的字面值">¶</a>3、什么是JAVA的字面值</h2>
<h3 id="示例-1-整数字面值"><a class="header-anchor" href="#示例-1-整数字面值">¶</a>示例 <strong>1</strong> : 整数字面值</h3>
<p>当以l或者L结尾的时候，一个整数字面值是long类型，否则就是int类型。 建议使用<strong>大写的L</strong>而非小写的l，因为容易和1混淆。<br>
byte,short,int和long的值都可以通过int类型的字面值来创建。整数的字面值可以用如下四种进制来表示：<br>
十进制: 基 10, 包含从0-9的数字，<strong>平常用的就是这种</strong><br>
十六进制: 基 16, 包含从0-9的数字，和从A-F的字母。<br>
八进制: 基 8, 包含从0-7的数字<br>
二进制: 基 2, 包含0和1。（从 JAVA7开始就可以创建 二进制的字面值了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long val &#x3D; 26L; &#x2F;&#x2F;以L结尾的字面值表示long型</span><br><span class="line">        int decVal &#x3D; 26; &#x2F;&#x2F;默认就是int型</span><br><span class="line">        int hexVal &#x3D; 0x1a; &#x2F;&#x2F;16进制</span><br><span class="line">        int oxVal &#x3D; 032; &#x2F;&#x2F;8进制</span><br><span class="line">        int binVal &#x3D; 0b11010; &#x2F;&#x2F;2进制</span><br><span class="line">        System.out.println(oxVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-浮点数字面值"><a class="header-anchor" href="#示例-2-浮点数字面值">¶</a>示例 <strong>2</strong> : 浮点数字面值</h3>
<p>当以f或者F结尾的时候，就表示一个float类型的浮点数，否则就是double类型（以d或者D结尾，写不写都可以）。<br>
浮点数还可以用E或者e表示（科学计数法）<br>
e2表示10的二次方，即100<br>
1.234e2 = 1.234x100</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        float f1 &#x3D; 123.4F;&#x2F;&#x2F; 以F结尾的字面值表示float类型</span><br><span class="line">        double d1 &#x3D; 123.4;&#x2F;&#x2F; 默认就是double类型</span><br><span class="line">        double d2 &#x3D; 1.234e2;&#x2F;&#x2F; 科学计数法表示double</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-字符和字符串字面值"><a class="header-anchor" href="#示例-3-字符和字符串字面值">¶</a>示例 <strong>3</strong> : 字符和字符串字面值</h3>
<p>字符的字面值放在单引号中</p>
<p><strong>字符串</strong>的字面值放在双引号中</p>
<p>需要注意的是，\表示转义，比如需要表示制表符，回车换行，双引号等就需要用 \t \r \n &quot; 的方式进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        char a&#x3D; &#39;c&#39;;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;以下是转义字符</span><br><span class="line">        char tab &#x3D; &#39;\t&#39;; &#x2F;&#x2F;制表符</span><br><span class="line">        char carriageReturn &#x3D; &#39;\r&#39;; &#x2F;&#x2F;回车</span><br><span class="line">        char newLine &#x3D; &#39;\n&#39;; &#x2F;&#x2F;换行</span><br><span class="line">        char doubleQuote &#x3D; &#39;\&quot;&#39;; &#x2F;&#x2F;双引号</span><br><span class="line">        char singleQuote &#x3D; &#39;\&#39;&#39;; &#x2F;&#x2F;单引号</span><br><span class="line">        char backslash &#x3D; &#39;\\&#39;; &#x2F;&#x2F;反斜杠</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、在JAVA中进行基本类型的类型转换"><a class="header-anchor" href="#4、在JAVA中进行基本类型的类型转换">¶</a>4、在JAVA中进行基本类型的类型转换</h2>
<h3 id="步骤-1-转换规则"><a class="header-anchor" href="#步骤-1-转换规则">¶</a>步骤 <strong>1</strong> : 转换规则</h3>
<p>转换规则如图所示<br>
<strong>精度高</strong>的数据类型就像<strong>容量大</strong>的杯子，可以<strong>放更大</strong>的数据<br>
<strong>精度低</strong>的数据类型就像<strong>容量小</strong>的杯子，只能<strong>放更小</strong>的数据<br>
小杯子往大杯子里倒东西，大杯子<strong>怎么都放得下</strong><br>
大杯子往小杯子里倒东西，<strong>有的时候放的下</strong>，<strong>有的时候就会有溢出</strong><br>
需要注意的一点是<br>
虽然short和char都是16位的，长度是一样的<br>
但是彼此之间，依然需要进行强制转换</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/519.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        char c &#x3D; &#39;A&#39;;</span><br><span class="line">        short s &#x3D; 80;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;虽然short和char都是16位的，长度是一样的</span><br><span class="line">        &#x2F;&#x2F;但是彼此之间，依然需要进行强制转换</span><br><span class="line">        c &#x3D; (char) s;</span><br><span class="line">        &#x2F;&#x2F;直接进行转换，会出现编译错误</span><br><span class="line">        s &#x3D; c;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-低精度向高精度转换"><a class="header-anchor" href="#步骤-2-低精度向高精度转换">¶</a>步骤 <strong>2</strong> : 低精度向高精度转换</h3>
<p>long l = 50;</p>
<p>int i = 50;<br>
l 是long类型的，其类型长度是64位<br>
i 是int类型的，其类型长度是32位<br>
所以l的精度，比i的精度要高<br>
l = i;<br>
<strong>把i的值赋给l</strong>， 首先l和i彼此的类型是不一样的，那么能否转换就取决于彼此的精度<br>
这个例子，是低精度向高精度转换 是可以正常转换的<br>
换句话说，int比较小，要放进比较大的long,随便怎么样，都放的进去</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/517.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        long l &#x3D; 50;</span><br><span class="line">        int i &#x3D; 50;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;int比较小，要放进比较大的long,随便怎么样，都放的进去</span><br><span class="line">        l &#x3D; i;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-高精度向低精度转换"><a class="header-anchor" href="#步骤-3-高精度向低精度转换">¶</a>步骤 <strong>3</strong> : 高精度向低精度转换</h3>
<p>byte b = 5;</p>
<p>int i1 = 10;</p>
<p>int i2 = 300;</p>
<p>b = i1;</p>
<p>b=i2;</p>
<p>b的类型是byte,其长度是8，<strong>最大只能放127</strong><br>
i1 的类型是int, 其长度是32,最大，反正就是很大了，超过127<br>
所以， 把int类型的数据转成为byte类型的数据，<strong>是有风险的</strong><br>
<strong>有的时候是可以转换的</strong>，比如 b = i1 (i1=10);<br>
<strong>有的时候不可以转换</strong> 比如 b= i2 (i2=300) 因为放不下了<br>
编译器就会提示错误<br>
这个时候就只能采用<strong>强制转换</strong>，强制转换的意思就是，转是可以转的，但是不对转换之后的值负责。 风险自担，后果自负</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/518.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        byte b &#x3D; 5;</span><br><span class="line">        int i1 &#x3D; 10;</span><br><span class="line">        int i2 &#x3D; 300;</span><br><span class="line">          </span><br><span class="line">        b &#x3D; (byte) i1;</span><br><span class="line">        &#x2F;&#x2F;因为i1的值是在byte范围之内，所以即便进行强制转换</span><br><span class="line">        &#x2F;&#x2F;最后得到的值，也是10</span><br><span class="line">        System.out.println(b);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;因为i2的值是在byte范围之外，所以就会按照byte的长度进行截取</span><br><span class="line">        &#x2F;&#x2F;i2的值是300，其对应的二进制数是 100101100</span><br><span class="line">        &#x2F;&#x2F;按照byte的长度8位进行截取后，其值为 00101100 即44</span><br><span class="line">        b &#x3D;(byte) i2;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;查看一个整数对应的二进制的方法：</span><br><span class="line">        System.out.println(Integer.toBinaryString(i2));</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、JAVA的命名规则"><a class="header-anchor" href="#5、JAVA的命名规则">¶</a>5、JAVA的命名规则</h2>
<h3 id="示例-1-命名规则"><a class="header-anchor" href="#示例-1-命名规则">¶</a>示例 <strong>1</strong> : 命名规则</h3>
<p>变量命名只能使用<strong>字母 数字 $ _</strong><br>
变量第一个字符 只能使用 字母 $ _<br>
变量第一个字符 不能使用数字<br>
注：_ 是下划线，不是-减号或者—— 破折号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a&#x3D; 5;</span><br><span class="line">int a_12&#x3D; 5;</span><br><span class="line">int $a43&#x3D; 5;</span><br><span class="line"> </span><br><span class="line">int a434&#x3D; 5;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;第一个是数字，是不行的</span><br><span class="line">int 34a&#x3D; 5;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-使用完整的单词命名，而非缩写"><a class="header-anchor" href="#示例-2-使用完整的单词命名，而非缩写">¶</a>示例 <strong>2</strong> : 使用完整的单词命名，而非缩写</h3>
<p>在命名的时候，尽量使用完整的单词进行命名，比如name,moveSpeed，而不是使用缩写 n,m。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">     &#x2F;&#x2F;使用完整单词命名，易于理解</span><br><span class="line">    String name;</span><br><span class="line">      </span><br><span class="line">    float hp;</span><br><span class="line">      </span><br><span class="line">    float armor;</span><br><span class="line">      </span><br><span class="line">    int moveSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">     &#x2F;&#x2F;使用完整单词命名，易于理解</span><br><span class="line">    String name;</span><br><span class="line">      </span><br><span class="line">    float hp;</span><br><span class="line">      </span><br><span class="line">    float armor;</span><br><span class="line">      </span><br><span class="line">    int moveSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-不能只使用关键字，但是可以包含关键字"><a class="header-anchor" href="#示例-3-不能只使用关键字，但是可以包含关键字">¶</a>示例 <strong>3</strong> : 不能只使用关键字，但是可以包含关键字</h3>
<p>什么是关键字<br>
比如int, short, class 这些单词已经被java 赋予了特殊的含义，这些就是关键字。不能直接用来作为变量名<br>
比如class<br>
int class = 5;<br>
class 是关键字<br>
但是可以包含数字<br>
比如<br>
int class5 = 5;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        int class5 &#x3D; 5;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-关键字列表1"><a class="header-anchor" href="#示例-4-关键字列表1">¶</a>示例 <strong>4</strong> : 关键字列表1</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/523.png" alt></p>
<h3 id="示例-5-关键字列表2"><a class="header-anchor" href="#示例-5-关键字列表2">¶</a>示例 <strong>5</strong> : 关键字列表2</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/522.png" alt></p>
<h3 id="示例-6-中文也是可以用来命名变量的"><a class="header-anchor" href="#示例-6-中文也是可以用来命名变量的">¶</a>示例 <strong>6</strong> : 中文也是可以用来命名变量的</h3>
<p>中文也是可以用来命名变量的<br>
但是在实际工作中。。。<strong>别这么干。。。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class 苍老师 &#123;</span><br><span class="line">    public void 开展教学工作()&#123;</span><br><span class="line">        System.out.println(&quot;雅蠛蝶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        苍老师 苍 &#x3D; new 苍老师();</span><br><span class="line">        苍.开展教学工作();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-7-练习-命名"><a class="header-anchor" href="#示例-7-练习-命名">¶</a>示例 <strong>7</strong> : 练习-命名</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. int a_;合法</span><br><span class="line">2. int a@;不合法</span><br><span class="line">3. int a3;合法</span><br><span class="line">4. int 8@;不合法</span><br><span class="line">5. int 9_;不合法</span><br><span class="line">6. int X$_;合法</span><br><span class="line">7. int y;合法</span><br><span class="line">8. int _$_;合法</span><br><span class="line">9. int $_$;合法</span><br><span class="line">10. int $*$;不合法</span><br><span class="line">11. int $1$;合法</span><br><span class="line">12. int _1_;合法</span><br><span class="line">13. int _@_;不合法</span><br><span class="line">14. int a#;不合法</span><br><span class="line">15. int a&quot;;不合法</span><br><span class="line">16. int 123a&quot;;不合法</span><br><span class="line">17. int 123a_;不合法</span><br><span class="line">18. int $123b_;合法</span><br></pre></td></tr></table></figure>
<h2 id="6、什么是JAVA的作用域"><a class="header-anchor" href="#6、什么是JAVA的作用域">¶</a>6、什么是JAVA的作用域</h2>
<h3 id="示例-1-字段，属性，Field"><a class="header-anchor" href="#示例-1-字段，属性，Field">¶</a>示例 <strong>1</strong> : 字段，属性，Field</h3>
<p>当一个变量被声明在类下面<br>
变量就叫做<strong>字段</strong> 或者<strong>属性</strong>、<strong>成员变量</strong>、<strong>Field</strong><br>
比如变量i,就是一个属性。<br>
那么从第2行这个变量声明的位置开始，整个类都可以访问得到<br>
所以其作用域就是从其声明的位置开始的整个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    int i &#x3D; 1;</span><br><span class="line">    int j &#x3D; i;  &#x2F;&#x2F;其他的属性可以访问i</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        System.out.println(i); &#x2F;&#x2F;方法1里可以访问i</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        System.out.println(i); &#x2F;&#x2F;方法2里可以访问i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-参数"><a class="header-anchor" href="#示例-2-参数">¶</a>示例 <strong>2</strong> : 参数</h3>
<p>如果一个变量，是声明在一个方法上的，就叫做<strong>参数</strong><br>
参数的作用域即为该方法内的所有代码<br>
其他方法不能访问该参数<br>
类里面也不能访问该参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"> </span><br><span class="line">    public void method1(int i)&#123; &#x2F;&#x2F;参数i的作用域即方法method1</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2()&#123;</span><br><span class="line"> </span><br><span class="line">        System.out.println(i); &#x2F;&#x2F;method2 不能访问参数i</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    int j &#x3D; i;  &#x2F;&#x2F;类里面也不能访问参数i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-局部变量"><a class="header-anchor" href="#示例-3-局部变量">¶</a>示例 <strong>3</strong> :局部变量</h3>
<p>声明在方法内的变量，叫做局部变量<br>
其作用域在声明开始的位置，到其所处于的块结束位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"> </span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        int i  &#x3D; 5;  &#x2F;&#x2F;其作用范围是从声明的第4行，到其所处于的块结束12行位置</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        &#123;            &#x2F;&#x2F;子块</span><br><span class="line">            System.out.println(i); &#x2F;&#x2F;可以访问i</span><br><span class="line">            int j &#x3D; 6;</span><br><span class="line">            System.out.println(j); &#x2F;&#x2F;可以访问j</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(j); &#x2F;&#x2F;不能访问j,因为其作用域到第10行就结束了</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-练习-作用域"><a class="header-anchor" href="#示例-4-练习-作用域">¶</a>示例 <strong>4</strong> : 练习-作用域</h3>
<p>属性的作用域在方法中，参数的作用域也在方法中，如果属性和参数命名相同了的话？ 那么到底取哪个值？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    int i &#x3D; 1; &#x2F;&#x2F;属性名是i</span><br><span class="line">    public void method1(int i)&#123; &#x2F;&#x2F;参数也是i</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new HelloWorld().method1(5);</span><br><span class="line">        &#x2F;&#x2F;结果打印出来是 1还是5?</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：5</p>
<h2 id="7、JAVA-中FINAL修饰变量"><a class="header-anchor" href="#7、JAVA-中FINAL修饰变量">¶</a>7、JAVA 中FINAL修饰变量</h2>
<h3 id="示例-1-在声明的时候赋值"><a class="header-anchor" href="#示例-1-在声明的时候赋值">¶</a>示例 <strong>1</strong> : 在声明的时候赋值</h3>
<p>i在第4行已经被赋值过了，所以这里会出现编译错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"> </span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        final int i &#x3D; 5;</span><br><span class="line">         </span><br><span class="line">        i &#x3D; 10; &#x2F;&#x2F;i在第4行已经被赋值过了，所以这里会出现编译错误</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-在声明的时候没有赋值"><a class="header-anchor" href="#示例-2-在声明的时候没有赋值">¶</a>示例 <strong>2</strong> : 在声明的时候没有赋值</h3>
<p>如果在声明的时候未赋值，那么可以在后面代码进行唯一的一次赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"> </span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        final int i;</span><br><span class="line">         </span><br><span class="line">        i &#x3D; 10; &#x2F;&#x2F;i在第4行，只是被声明，但是没有被赋值，所以在这里可以进行第一次赋值</span><br><span class="line">         </span><br><span class="line">        i &#x3D; 11; &#x2F;&#x2F;i在第6行已经被赋值过了，所以这里会出现编译错误</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-final-修饰其他"><a class="header-anchor" href="#示例-3-final-修饰其他">¶</a>示例 <strong>3</strong> : final 修饰其他</h3>
<p>final 除了修饰变量，还可以[修饰类]，[修饰方法]，这些都在后续的章节展开</p>
<h3 id="示例-4-练习-final"><a class="header-anchor" href="#示例-4-练习-final">¶</a>示例 <strong>4</strong> : 练习-final</h3>
<p>如果final修饰的是<strong>参数</strong>，能否在方法里给这个参数赋值？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"> </span><br><span class="line">    public void method1(final int j) &#123;</span><br><span class="line">        j &#x3D; 5; &#x2F;&#x2F;这个能否执行？</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能运行 根据对应的final这个修饰词的功能来看，对这个方法进行调用的时候，把参数放入方法的栈中，已经对这个参数进行了一个赋值操作，无法对其进行二次赋值</p>
<h2 id="8、什么是JAVA的表达式"><a class="header-anchor" href="#8、什么是JAVA的表达式">¶</a>8、什么是JAVA的表达式</h2>
<h3 id="步骤-1-以-结尾的一段代码，即为一个表达式"><a class="header-anchor" href="#步骤-1-以-结尾的一段代码，即为一个表达式">¶</a>步骤 <strong>1</strong> : 以;结尾的一段代码，即为一个表达式</h3>
<p>表达式是由变量、操作符以及方法调用所构成的结构。如下所示：</p>
<p>int i = 5;</p>
<p>System.out.println(5);</p>
<p>都是表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;每一句话都是一个表达式</span><br><span class="line">        int i &#x3D; 5; </span><br><span class="line">        System.out.println(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2"><a class="header-anchor" href="#步骤-2">¶</a>步骤 <strong>2</strong> : ;</h3>
<p>; 也是一个完整的表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;一个空;也是一个表达式</span><br><span class="line">        ;</span><br><span class="line">        ;</span><br><span class="line">        ;      </span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、什么是JAVA的块"><a class="header-anchor" href="#9、什么是JAVA的块">¶</a>9、什么是JAVA的块</h2>
<h3 id="步骤-1-块"><a class="header-anchor" href="#步骤-1-块">¶</a>步骤 <strong>1</strong> :块</h3>
<p>从**{** 开始 到对应的**}** 结束，即一个块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123; &#x2F;&#x2F;类对应的块</span><br><span class="line">    public static void main(String[] args) &#123; &#x2F;&#x2F;主方法对应的块</span><br><span class="line">        System.out.println(&quot;abc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、操作符"><a class="header-anchor" href="#四、操作符">¶</a>四、操作符</h1>
<h2 id="1、JAVA的算数操作符"><a class="header-anchor" href="#1、JAVA的算数操作符">¶</a>1、JAVA的算数操作符</h2>
<h3 id="示例-1-基本算数操作符"><a class="header-anchor" href="#示例-1-基本算数操作符">¶</a>示例 <strong>1</strong> : 基本算数操作符</h3>
<p>+ - * /<br>
基本的加 减 乘 除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 10;</span><br><span class="line">		int j &#x3D; 5;</span><br><span class="line">		int a &#x3D; i+j;</span><br><span class="line">		int b &#x3D; i - j;</span><br><span class="line">		int c &#x3D; i*j;</span><br><span class="line">		int d &#x3D; i &#x2F;j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-练习-求和"><a class="header-anchor" href="#示例-2-练习-求和">¶</a>示例 <strong>2</strong> : 练习-求和</h3>
<p>使用[Scanner]从控制台获取两个数字，然后计算这两个数字的和</p>
<p>如果不会使用Scanner，请参考 [如何使用Scanner读取整数]</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2141.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FinalTest&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">         </span><br><span class="line">        java.util.Scanner s &#x3D; new java.util.Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入第一个整数：&quot;);</span><br><span class="line">        int i &#x3D; s.nextInt();</span><br><span class="line">         </span><br><span class="line">        System.out.print(&quot;请输入第二个整数：&quot;);</span><br><span class="line">        int j &#x3D; s.nextInt();</span><br><span class="line">         </span><br><span class="line">        System.out.print(&quot;两个整数的和是：&quot; + (i + j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-任意运算单元的长度超过int"><a class="header-anchor" href="#示例-3-任意运算单元的长度超过int">¶</a>示例 3 : 任意运算单元的长度超过int</h3>
<p>如果有任何运算单元的长度超过int,那么运算结果就按照最长的长度计算<br>
比如<br>
int a = 5;<br>
long b = 6;<br>
a+b -&gt; 结果类型是long</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        int a &#x3D; 5;</span><br><span class="line">        long b &#x3D; 6;</span><br><span class="line">        int c &#x3D; (int) (a+b); &#x2F;&#x2F;a+b的运算结果是long型，所以要进行强制转换</span><br><span class="line">        long d &#x3D; a+b;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-任意运算单元的长度小于int"><a class="header-anchor" href="#示例-4-任意运算单元的长度小于int">¶</a>示例 <strong>4</strong> : 任意运算单元的长度小于int</h3>
<p>如果任何运算单元的长度都不超过int,那么运算结果就按照int来计算<br>
byte a = 1;<br>
byte b= 2;<br>
a+b -&gt; int 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte a &#x3D; 1;</span><br><span class="line">        byte b&#x3D; 2;</span><br><span class="line">        byte c &#x3D; (byte) (a+b); &#x2F;&#x2F;虽然a b都是byte类型，但是运算结果是int类型，需要进行强制转换</span><br><span class="line">        int d &#x3D; a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-取模"><a class="header-anchor" href="#示例-5-取模">¶</a>示例 5 : %取模</h3>
<p>% 取余数，又叫取模<br>
5除以2，余1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">        int j &#x3D; 2;</span><br><span class="line">        System.out.println(i%j); &#x2F;&#x2F;输出为1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-自增-自减"><a class="header-anchor" href="#示例-6-自增-自减">¶</a>示例 <strong>6</strong> :自增 自减</h3>
<p>++<br>
–<br>
在原来的基础上增加1或者减少1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);&#x2F;&#x2F;输出为6</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-7-自增-自减操作符置前以及置后的区别"><a class="header-anchor" href="#示例-7-自增-自减操作符置前以及置后的区别">¶</a>示例 7 : 自增 自减操作符置前以及置后的区别</h3>
<p>以<ins>为例<br>
int i = 5;<br>
i</ins>; <strong>先取值，再运算</strong><br>
++i; <strong>先运算，再取值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">        System.out.println(i++); &#x2F;&#x2F;输出5</span><br><span class="line">        System.out.println(i);   &#x2F;&#x2F;输出6</span><br><span class="line">         </span><br><span class="line">        int j &#x3D; 5;</span><br><span class="line">        System.out.println(++j); &#x2F;&#x2F;输出6</span><br><span class="line">        System.out.println(j);   &#x2F;&#x2F;输出6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-8-练习-自增"><a class="header-anchor" href="#示例-8-练习-自增">¶</a>示例 8 : 练习-自增</h3>
<p>int i = 1;</p>
<p>int j = <ins>i + i</ins> + ++i + <ins>i + i</ins>;</p>
<p>问 j的结果是多少?<br>
<strong>注:</strong> 先不要放在eclipse中，根据++置前 置后的理解自己先算一遍，然后再看答案</p>
<p>2+2+4+5+5=18</p>
<h3 id="示例-9-练习-BMI"><a class="header-anchor" href="#示例-9-练习-BMI">¶</a>示例 9 : 练习-BMI</h3>
<p>使用[Scanner]收集你的身高体重，并计算出你的BMI值是多少</p>
<p>BMI的计算公式是 体重(kg) / (身高*身高)</p>
<p>比如邱阳波的体重是72kg, 身高是1.69，那么这位同学的BMI就是<br>
72 / (1.69*1.69) = ?</p>
<p>参考: [使用Scanner读取浮点数的办法]</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2155.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">         Scanner S &#x3D; new Scanner(System.in);</span><br><span class="line">         System.out.println(&quot;请输入身高(m)&quot;);</span><br><span class="line">         float a&#x3D;S.nextFloat();</span><br><span class="line">         System.out.println(&quot;请输入体重(kg)&quot;);</span><br><span class="line">         float b&#x3D;S.nextFloat();</span><br><span class="line">         float c;</span><br><span class="line">         c&#x3D;(b&#x2F;(a*a));</span><br><span class="line">         System.out.println(&quot;当前的BMI是:&quot;+ c);</span><br><span class="line">         if (c&lt;18.5)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(&quot;体重过轻&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else if(18.5&lt;&#x3D;c&amp;&amp;c&lt;24)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(&quot;正常范围&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else if(24&lt;&#x3D;c&amp;&amp;c&lt;27)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(&quot;体重过重&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else if(27&lt;&#x3D;c&amp;&amp;c&lt;30)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(&quot;轻度肥胖&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else if(30&lt;&#x3D;c&amp;&amp;c&lt;35)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(&quot;中度肥胖&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else if(c&gt;&#x3D;35)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(&quot;重度肥胖&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA的关系操作符"><a class="header-anchor" href="#2、JAVA的关系操作符">¶</a>2、JAVA的关系操作符</h2>
<h3 id="示例-1-关系操作符"><a class="header-anchor" href="#示例-1-关系操作符">¶</a>示例 <strong>1</strong> : 关系操作符</h3>
<p>&gt; 大于<br>
&gt;= 大于或等于<br>
&lt; 小于<br>
&lt;= 小于或等于<br>
== 是否相等<br>
!= 是否不等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       int a &#x3D; 5;</span><br><span class="line">       int b &#x3D; 6;</span><br><span class="line">       int c &#x3D; 5;</span><br><span class="line">        </span><br><span class="line">       System.out.println(a&gt;b);  &#x2F;&#x2F;返回 false</span><br><span class="line">       System.out.println(a&gt;&#x3D;c);  &#x2F;&#x2F;返回 true</span><br><span class="line">        </span><br><span class="line">       System.out.println(a&#x3D;&#x3D;b); &#x2F;&#x2F;返回false</span><br><span class="line">       System.out.println(a!&#x3D;b);&#x2F;&#x2F;返回true</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-练习-关系操作符"><a class="header-anchor" href="#示例-2-练习-关系操作符">¶</a>示例 <strong>2</strong> : 练习-关系操作符</h3>
<p>借助[Scanner]获取控制台输入的两个任意数字，然后使用<br>
&gt; 大于<br>
&gt;= 大于或等于<br>
&lt; 小于<br>
&lt;= 小于或等于<br>
== 是否相等<br>
!= 是否不等</p>
<p>判断两个值之间的关系</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2147.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[]args) &#123;</span><br><span class="line">		</span><br><span class="line">		java.util.Scanner S &#x3D; new java.util.Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;请输入第一个数字：&quot;);		</span><br><span class="line">		int num1 &#x3D; S.nextInt();</span><br><span class="line"></span><br><span class="line">		System.out.print(&quot;请输入第二个数字：&quot;);</span><br><span class="line">		int num2 &#x3D; S.nextInt();</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;比较&quot; + num1 + &quot;&gt;&quot; + num2 + &quot;:&quot; + (num1 &gt; num2));</span><br><span class="line">		System.out.println(&quot;比较&quot; + num1 + &quot;&gt;&#x3D;&quot; + num2 + &quot;:&quot; + (num1 &gt;&#x3D; num2));</span><br><span class="line">		System.out.println(&quot;比较&quot; + num1 + &quot;&lt;&quot; + num2 + &quot;:&quot; + (num1 &lt; num2));</span><br><span class="line">		System.out.println(&quot;比较&quot; + num1 + &quot;&lt;&#x3D;&quot; + num2 + &quot;:&quot; + (num1 &lt;&#x3D; num2));</span><br><span class="line">		System.out.println(&quot;比较&quot; + num1 + &quot;&#x3D;&#x3D;&quot; + num2 + &quot;:&quot; + (num1 &#x3D;&#x3D; num2));</span><br><span class="line">		System.out.println(&quot;比较&quot; + num1 + &quot;!&#x3D;&quot; + num2 + &quot;:&quot; + (num1 !&#x3D; num2));</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA的逻辑运算符"><a class="header-anchor" href="#3、JAVA的逻辑运算符">¶</a>3、JAVA的逻辑运算符</h2>
<h3 id="示例-1-长路与-和-短路与"><a class="header-anchor" href="#示例-1-长路与-和-短路与">¶</a>示例 <strong>1</strong> : 长路与 和 短路与</h3>
<p>无论长路与还是短路与<br>
两边的运算单元都是布尔值<br>
都为真时，才为真<br>
任意为假，就为假<br>
区别<br>
长路与 两侧，都会被运算<br>
短路与 只要第一个是false，第二个就不进行运算了</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/537.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;长路与  无论第一个表达式的值是true或者false,第二个的值，都会被运算</span><br><span class="line">        int i &#x3D; 2;</span><br><span class="line">        System.out.println( i&#x3D;&#x3D; 1 &amp; i++ &#x3D;&#x3D;2  ); &#x2F;&#x2F;无论如何i++都会被执行，所以i的值变成了3</span><br><span class="line">        System.out.println(i);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;短路与 只要第一个表达式的值是false的，第二个表达式的值，就不需要进行运算了</span><br><span class="line">        int j &#x3D; 2;</span><br><span class="line">        System.out.println( j&#x3D;&#x3D; 1 &amp;&amp; j++ &#x3D;&#x3D;2  );  &#x2F;&#x2F;因为j&#x3D;&#x3D;1返回false,所以右边的j++就没有执行了，所以j的值，还是2</span><br><span class="line">        System.out.println(j);     </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-长路或-和-短路或"><a class="header-anchor" href="#示例-2-长路或-和-短路或">¶</a>示例 <strong>2</strong> : 长路或 和 短路或</h3>
<p>无论长路或还是短路或<br>
两边的运算单元都是布尔值<br>
都为假时，才为假<br>
任意为真，就为真<br>
区别<br>
长路或 两侧都会被运算<br>
短路或 只要第一个是true的，第二个就不进行运算了</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/538.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;长路或  无论第一个表达式的值是true或者false,第二个的值，都会被运算</span><br><span class="line">        int i &#x3D; 2;</span><br><span class="line">        System.out.println( i&#x3D;&#x3D; 1 | i++ &#x3D;&#x3D;2  ); &#x2F;&#x2F;无论如何i++都会被执行，所以i的值变成了3</span><br><span class="line">        System.out.println(i);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;短路或 只要第一个表达式的值是true的，第二个表达式的值，就不需要进行运算了</span><br><span class="line">        int j &#x3D; 2;</span><br><span class="line">        System.out.println( j&#x3D;&#x3D; 2 || j++ &#x3D;&#x3D;2  );  &#x2F;&#x2F;因为j&#x3D;&#x3D;2返回true,所以右边的j++就没有执行了，所以j的值，还是2</span><br><span class="line">        System.out.println(j);     </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-取反"><a class="header-anchor" href="#示例-3-取反">¶</a>示例 <strong>3</strong> : 取反</h3>
<p>取反!<br>
真变为假<br>
假变为真</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        boolean b &#x3D; true;</span><br><span class="line">         </span><br><span class="line">        System.out.println(b); &#x2F;&#x2F;输出true</span><br><span class="line">        System.out.println(!b);&#x2F;&#x2F;输出false</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-异或"><a class="header-anchor" href="#示例-4-异或">¶</a>示例 <strong>4</strong> : 异或^</h3>
<p>异或^<br>
不同，返回真<br>
相同，返回假</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/540.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        boolean a &#x3D; true;</span><br><span class="line">        boolean b &#x3D; false;</span><br><span class="line">         </span><br><span class="line">        System.out.println(a^b); &#x2F;&#x2F;不同返回真</span><br><span class="line">        System.out.println(a^!b); &#x2F;&#x2F;相同返回假</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-练习-逻辑操作符"><a class="header-anchor" href="#示例-5-练习-逻辑操作符">¶</a>示例 <strong>5</strong> : 练习-逻辑操作符</h3>
<p>int i = 1;</p>
<p>boolean b = !(i++ == 3) ^ (i++ ==2) &amp;&amp; (i++==3);</p>
<p>System.out.println(b);</p>
<p>System.out.println(i);</p>
<p>输出结果是？</p>
<p>心算！ 不要丢到ecilpse里面去看结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正确结果是false 3</span><br><span class="line">解析：</span><br><span class="line">i++&#x3D;&#x3D;3 false</span><br><span class="line">!(i++&#x3D;&#x3D;3) true</span><br><span class="line">此时i&#x3D;2</span><br><span class="line">(i++&#x3D;&#x3D;2) true</span><br><span class="line">此时i&#x3D;3</span><br><span class="line">!(i++&#x3D;&#x3D;3)^(i++&#x3D;&#x3D;2) true^true为 false</span><br><span class="line">因为&amp;&amp;是短路与</span><br><span class="line">所以整个结果为false </span><br><span class="line">i++&#x3D;&#x3D;3不用参与运算</span><br><span class="line">!(i++ &#x3D;&#x3D; 3) ^ (i++ &#x3D;&#x3D;2) &amp;&amp; (i++&#x3D;&#x3D;3) 结果为：false</span><br></pre></td></tr></table></figure>
<h2 id="4、JAVA的位操作符"><a class="header-anchor" href="#4、JAVA的位操作符">¶</a>4、JAVA的位操作符</h2>
<h3 id="示例-1-一个整数的二进制表达"><a class="header-anchor" href="#示例-1-一个整数的二进制表达">¶</a>示例 <strong>1</strong> : 一个整数的二进制表达</h3>
<p>位操作都是对二进制而言的，但是我们平常使用的都是十进制比如5。<br>
而5的二进制是101。<br>
所以在开始学习之前，需要掌握一个整数的二进制表达是多少。<br>
通过Integer.toBinaryString() 方法，将一个十进制整数转换为一个二进制字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">        String b &#x3D; (Integer.toBinaryString(i)); &#x2F;&#x2F; 5的二进制的表达101</span><br><span class="line">        System.out.println(i+&quot; 的二进制表达是: &quot;+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-位或"><a class="header-anchor" href="#示例-2-位或">¶</a>示例 <strong>2</strong> : 位或</h3>
<p>5的二进制是101<br>
6的二进制是110<br>
所以 5|6 对每一位进行或运算，得到 111-&gt;7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        int i  &#x3D;5;</span><br><span class="line">        int j &#x3D; 6;</span><br><span class="line">         </span><br><span class="line">        System.out.println(Integer.toBinaryString(i)); &#x2F;&#x2F;5的二进制是101</span><br><span class="line">         </span><br><span class="line">        System.out.println(Integer.toBinaryString(j)); &#x2F;&#x2F;6的二进制是110</span><br><span class="line">         </span><br><span class="line">        System.out.println(i|j); &#x2F;&#x2F;所以 5|6 对每一位进行或运算，得到 111-&gt;7</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-位与"><a class="header-anchor" href="#示例-3-位与">¶</a>示例 <strong>3</strong> : 位与</h3>
<p>5的二进制是101<br>
6的二进制是110<br>
所以 5&amp;6 对每一位进行与运算，得到 100-&gt;4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        int i  &#x3D;5;</span><br><span class="line">        int j &#x3D; 6;</span><br><span class="line">         </span><br><span class="line">        System.out.println(Integer.toBinaryString(i)); &#x2F;&#x2F;5的二进制是101</span><br><span class="line">         </span><br><span class="line">        System.out.println(Integer.toBinaryString(j)); &#x2F;&#x2F;6的二进制是110</span><br><span class="line">         </span><br><span class="line">        System.out.println(i&amp;j); &#x2F;&#x2F;所以 5&amp;6 对每一位进行与运算，得到 100-&gt;4</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-异或-v2"><a class="header-anchor" href="#示例-4-异或-v2">¶</a>示例 <strong>4</strong> : 异或</h3>
<p>5的二进制是101<br>
6的二进制是110<br>
所以 5^6 对每一位进行异或运算，得到 011-&gt;3</p>
<p>一些特别情况：<br>
任何数和自己进行异或 都等于 0<br>
任何数和0 进行异或 都等于自己</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i  &#x3D;5;</span><br><span class="line">        int j &#x3D; 6;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i)); &#x2F;&#x2F;5的二进制是 101</span><br><span class="line">        System.out.println(Integer.toBinaryString(j)); &#x2F;&#x2F;6的二进制是110</span><br><span class="line">        System.out.println(i^j); &#x2F;&#x2F;所以 5^6 对每一位进行或运算，得到 011-&gt;3</span><br><span class="line">         </span><br><span class="line">        System.out.println(i^0);</span><br><span class="line">        System.out.println(i^i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-取非"><a class="header-anchor" href="#示例-5-取非">¶</a>示例 <strong>5</strong> :取非</h3>
<p>5 的二进制是 00000101<br>
所以取反即为 11111010<br>
这个二进制换算成十进制即为-6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte i  &#x3D;5;</span><br><span class="line">         </span><br><span class="line">        System.out.println(Integer.toBinaryString(i)); &#x2F;&#x2F;5的二进制是00000101,所以取非即为11111010,即为-6</span><br><span class="line">         </span><br><span class="line">        System.out.println(~i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-左移-右移"><a class="header-anchor" href="#示例-6-左移-右移">¶</a>示例 <strong>6</strong> : 左移 右移</h3>
<p>左移：根据一个整数的二进制表达，将其每一位都向左移动，最右边一位补0<br>
右移：根据一个整数的二进制表达，将其每一位都向右移动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte i  &#x3D;6;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;6的二进制是110</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line">        &#x2F;&#x2F;6向左移1位后，变成1100，对应的10进制是12</span><br><span class="line">        System.out.println(i&lt;&lt;1);</span><br><span class="line">        &#x2F;&#x2F;6向右移1位后，变成11，对应的10进制是3</span><br><span class="line">        System.out.println(i&gt;&gt;1);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-7-练习-快速计算2x16"><a class="header-anchor" href="#示例-7-练习-快速计算2x16">¶</a>示例 <strong>7</strong> : 练习-快速计算2x16</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i&#x3D;2;</span><br><span class="line">        System.out.println(i&lt;&lt;4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-8-带符号右移与无符号右移"><a class="header-anchor" href="#示例-8-带符号右移与无符号右移">¶</a>示例 8 : 带符号右移与无符号右移</h3>
<p><strong>带符号右移 &gt;&gt;</strong><br>
对于正数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补0<br>
对于负数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补1<br>
<strong>无符号右移&gt;&gt;&gt;</strong><br>
如果是一个负数，那么对应的二进制的第一位是1<br>
无符号右移&gt;&gt;&gt;会把第一位的1也向右移动，导致移动后，第一位变成0<br>
这样就会使得负数在无符号右移后，得到一个正数</p>
<p><strong>简单的说：</strong><br>
<strong>带符号右移 &gt;&gt;</strong> 移动后正的还是正的，负的还是负的,<strong>符号不变</strong><br>
**无符号右移&gt;&gt;&gt;**移动后，<strong>变正的了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i  &#x3D;-10;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;-10的二进制是11111111111111111111111111110110</span><br><span class="line">        &#x2F;&#x2F;第一位是1，即符号位，代表这是一个负数</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;对于正数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补0</span><br><span class="line">        &#x2F;&#x2F;对于负数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补1</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;-10带符号右移1位，移动后前面补齐1</span><br><span class="line">        &#x2F;&#x2F;得到11111111111111111111111111111011</span><br><span class="line">        &#x2F;&#x2F;因为第一位是1，所以依然是一个负数，对应的十进制是-5</span><br><span class="line">        int j &#x3D; i&gt;&gt;1;</span><br><span class="line">        System.out.println(Integer.toBinaryString(j));</span><br><span class="line">        System.out.println(j);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;-10无符号向右移1位，符号位也会向右移，第一位就变成了0</span><br><span class="line">        &#x2F;&#x2F;得到01111111111111111111111111111011，对应的十进制是2147483643</span><br><span class="line">        int k &#x3D; i&gt;&gt;&gt;1;</span><br><span class="line">        System.out.println(Integer.toBinaryString(k));     </span><br><span class="line">         </span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-9-练习-位操作符"><a class="header-anchor" href="#示例-9-练习-位操作符">¶</a>示例 9 : 练习-位操作符</h3>
<p>int i = 3; // 二进制是11</p>
<p>int j = 2; // 二进制是10</p>
<p>int c = ((i | j) ^ (i &amp; j)) &lt;&lt; 2 &gt;&gt;&gt; 1;</p>
<p>心算答案，不要一来就放在eclipse中计算结果</p>
<p>11^10 ==&gt; 01 ==&gt; 100 ==&gt; 10 ==&gt; 2</p>
<h2 id="5、JAVA的赋值操作符"><a class="header-anchor" href="#5、JAVA的赋值操作符">¶</a>5、JAVA的赋值操作符</h2>
<h3 id="示例-1-赋值操作"><a class="header-anchor" href="#示例-1-赋值操作">¶</a>示例 <strong>1</strong> : 赋值操作</h3>
<p>赋值操作的操作顺序是从右到左<br>
int i = 5+5;<br>
首先进行5+5的运算，得到结果10，然后把10这个值，赋给i</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5+5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-对本身进行运算，并赋值"><a class="header-anchor" href="#示例-2-对本身进行运算，并赋值">¶</a>示例 <strong>2</strong> : 对本身进行运算，并赋值</h3>
<p>+=即自加<br>
i+=2;<br>
等同于<br>
i=i+2;<br>
其他的 -= , *= , /= , %= , &amp;= , |= , ^= , &gt;&gt;= , &gt;&gt;&gt;= 都是类似，不做赘述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D;3;</span><br><span class="line">        i+&#x3D;2;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">         </span><br><span class="line">        int j&#x3D;3;</span><br><span class="line">        j&#x3D;j+2;</span><br><span class="line">        System.out.println(j);     </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-练习-赋值操作符"><a class="header-anchor" href="#示例-3-练习-赋值操作符">¶</a>示例 <strong>3</strong> : 练习-赋值操作符</h3>
<p>int i = 1;</p>
<p>i+=++i;</p>
<p>心算i的值是？</p>
<p>i初始值为1 对表达式 i+=++1; 进行展开 展开为 i = i + ++i =&gt; i = 1 + 2 ==&gt; i =3;</p>
<h2 id="6、JAVA的三元操作符"><a class="header-anchor" href="#6、JAVA的三元操作符">¶</a>6、JAVA的三元操作符</h2>
<h3 id="示例-1-三元操作符"><a class="header-anchor" href="#示例-1-三元操作符">¶</a>示例 <strong>1</strong> : 三元操作符</h3>
<p>表达式?值1:值2<br>
如果表达式为真 返回值1<br>
如果表达式为假 返回值2</p>
<p>关于[if语句]的详解讲解在[后面章节]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">        int j &#x3D; 6;</span><br><span class="line"> </span><br><span class="line">        int k &#x3D; i &lt; j ? 99 : 88;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 相当于</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            k &#x3D; 99;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            k &#x3D; 88;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(k);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-练习-判断是否是工作日"><a class="header-anchor" href="#示例-2-练习-判断是否是工作日">¶</a>示例 <strong>2</strong> : 练习-判断是否是工作日</h3>
<p>通过[Scanner]输入一个<strong>1-7</strong>之间的整数，使用三元操作符判断是工作日还是周末？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个整数（1 - 7）&quot;);</span><br><span class="line">        int a &#x3D; input.nextInt();</span><br><span class="line">        String b &#x3D; a &gt;&#x3D; 1 &amp;&amp; a &lt;&#x3D; 7 ? a &lt;&#x3D; 5 ? &quot;工作日&quot; : &quot;周末&quot;: &quot;输入错误&quot;;</span><br><span class="line">        System.out.println(b);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、使用SCANNER读取整数"><a class="header-anchor" href="#7、使用SCANNER读取整数">¶</a>7、使用SCANNER读取整数</h2>
<h3 id="步骤-1-使用Scanner读取整数"><a class="header-anchor" href="#步骤-1-使用Scanner读取整数">¶</a>步骤 <strong>1</strong> : 使用Scanner读取整数</h3>
<p>注意： 使用Scanner类，需要在最前面加上</p>
<p>import java.util.Scanner;</p>
<p>表示导入这个类，才能够正常使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        int a &#x3D; s.nextInt();</span><br><span class="line">        System.out.println(&quot;第一个整数：&quot;+a);</span><br><span class="line">        int b &#x3D; s.nextInt();</span><br><span class="line">        System.out.println(&quot;第二个整数：&quot;+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-使用Scanner读取浮点数"><a class="header-anchor" href="#步骤-2-使用Scanner读取浮点数">¶</a>步骤 <strong>2</strong> :使用Scanner读取浮点数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">  </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        float a &#x3D; s.nextFloat();</span><br><span class="line">        System.out.println(&quot;读取的浮点数的值是：&quot;+a);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-使用Scanner读取字符串"><a class="header-anchor" href="#步骤-3-使用Scanner读取字符串">¶</a>步骤 <strong>3</strong> : 使用Scanner读取字符串</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">  </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        String a &#x3D; s.nextLine();</span><br><span class="line">        System.out.println(&quot;读取的字符串是：&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-读取了整数后，接着读取字符串"><a class="header-anchor" href="#步骤-4-读取了整数后，接着读取字符串">¶</a>步骤 <strong>4</strong> : 读取了整数后，接着读取字符串</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">   </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        int i &#x3D; s.nextInt();</span><br><span class="line">        System.out.println(&quot;读取的整数是&quot;+ i);</span><br><span class="line">        String rn &#x3D; s.nextLine();</span><br><span class="line">        String a &#x3D; s.nextLine();</span><br><span class="line">        System.out.println(&quot;读取的字符串是：&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next在输入有效字符之前输入的空格，换行，tab都是无效的，在输入有效字符之后输入的空格，换行，tab都是它的结束符 nextLint的开始结束都只有换行，中间输入的空格，tab都会照常输出。</p>
<p>此处Scanner用法有一点瑕疵，scanner用完之后要关闭，不然会浪费系统资源 s.close();即可。</p>
<h1 id="五、控制流程"><a class="header-anchor" href="#五、控制流程">¶</a>五、控制流程</h1>
<h2 id="1、JAVA的IF-条件语句"><a class="header-anchor" href="#1、JAVA的IF-条件语句">¶</a>1、JAVA的IF 条件语句</h2>
<h3 id="示例-1-if"><a class="header-anchor" href="#示例-1-if">¶</a>示例 <strong>1</strong> : if</h3>
<p>if(表达式1){</p>
<p>表达式2；</p>
<p>}<br>
如果表达式1的值是true,<br>
就执行表达式2</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/551.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        boolean b &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;如果成立就打印yes</span><br><span class="line">        if(b)&#123;</span><br><span class="line">            System.out.println(&quot;yes&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-多表达式与一个表达式"><a class="header-anchor" href="#示例-2-多表达式与一个表达式">¶</a>示例 <strong>2</strong> : 多表达式与一个表达式</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        boolean b &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;如果有多个表达式，必须用大括弧包括起来</span><br><span class="line">        if(b)&#123;</span><br><span class="line">            System.out.println(&quot;yes1&quot;);</span><br><span class="line">            System.out.println(&quot;yes2&quot;);</span><br><span class="line">            System.out.println(&quot;yes3&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;否则表达式2 3 无论b是否为true都会执行</span><br><span class="line">         </span><br><span class="line">        if(b)</span><br><span class="line">            System.out.println(&quot;yes1&quot;);</span><br><span class="line">            System.out.println(&quot;yes2&quot;);</span><br><span class="line">            System.out.println(&quot;yes3&quot;);</span><br><span class="line">             </span><br><span class="line">        &#x2F;&#x2F;如果只有一个表达式可以不用写括弧，看上去会简约一些</span><br><span class="line">        if(b)&#123;</span><br><span class="line">            System.out.println(&quot;yes1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        if(b)</span><br><span class="line">            System.out.println(&quot;yes1&quot;);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-if-使用过程中可能遇到的坑"><a class="header-anchor" href="#示例-3-if-使用过程中可能遇到的坑">¶</a>示例 <strong>3</strong> : if 使用过程中可能遇到的坑</h3>
<p>在第6行，if后面有一个分号; 而[分号也是一个完整的表达式]<br>
如果b为true，会执行这个分号，然后打印yes<br>
如果b为false，不会执行这个分号，然后打印yes<br>
这样，看上去无论如何都会打印yes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        boolean b &#x3D; false;</span><br><span class="line"> </span><br><span class="line">        if (b);</span><br><span class="line">            System.out.println(&quot;yes&quot;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-if-else"><a class="header-anchor" href="#示例-4-if-else">¶</a>示例 <strong>4</strong> : if else</h3>
<p>else 代表不成立的情况</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/552.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        boolean b &#x3D; false;</span><br><span class="line"> </span><br><span class="line">        if (b)</span><br><span class="line">            System.out.println(&quot;yes&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;no&quot;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-else-if"><a class="header-anchor" href="#示例-5-else-if">¶</a>示例 <strong>5</strong> : else if</h3>
<p>else if 是多条件判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;如果只使用 if,会执行4次判断</span><br><span class="line">        int i &#x3D; 2;</span><br><span class="line">        if (i&#x3D;&#x3D;1)</span><br><span class="line">            System.out.println(1);</span><br><span class="line">        if (i&#x3D;&#x3D;2)</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        if (i&#x3D;&#x3D;3)</span><br><span class="line">            System.out.println(3);</span><br><span class="line">        if (i&#x3D;&#x3D;4)</span><br><span class="line">            System.out.println(4);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;如果使用else if, 一旦在18行，判断成立， 20行和22行的判断就不会执行了，节约了运算资源</span><br><span class="line">        if (i&#x3D;&#x3D;1)</span><br><span class="line">            System.out.println(1);</span><br><span class="line">        else if (i&#x3D;&#x3D;2)</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        else if (i&#x3D;&#x3D;3)</span><br><span class="line">            System.out.println(3);</span><br><span class="line">        else if (i&#x3D;&#x3D;4)</span><br><span class="line">            System.out.println(4);     </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-练习-BMI"><a class="header-anchor" href="#示例-6-练习-BMI">¶</a>示例 <strong>6</strong> : 练习-BMI</h3>
<p>基于前面的[操作符练习-BMI]，做基于判断的改进：</p>
<p>使用[Scanner]收集你的身高体重，并计算出你的BMI值是多少</p>
<p>BMI的计算公式是 体重(kg) / (身高*身高)</p>
<p>比如邱阳波的体重是72kg, 身高是1.69，那么这位同学的BMI就是<br>
72 / (1.69*1.69) = ?</p>
<p>然后通过条件判断BMI的范围，打印出是超重还是正常</p>
<p>参考: [使用Scanner读取浮点数的办法]</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2161.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.print(&quot;请输入您的身高（m）：&quot;);</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        float a &#x3D; s.nextFloat();</span><br><span class="line">        System.out.print(&quot;请输入您的体重（kg）：&quot;);</span><br><span class="line">        float b &#x3D; s.nextFloat();</span><br><span class="line">        final float BMI &#x3D; b &#x2F; (a * a);</span><br><span class="line">        if (BMI &lt; 18.5)&#123;</span><br><span class="line">            System.out.println(String.format(&quot;当前BMI指数为: %.2f\n身体状况： 体重过轻&quot;, BMI));</span><br><span class="line">        &#125;</span><br><span class="line">        else if (BMI &gt;&#x3D; 18.5 &amp;&amp; BMI &lt; 24)&#123;</span><br><span class="line">            System.out.println(String.format(&quot;当前BMI指数为: %.2f\n身体状况： 体重正常&quot;, BMI));</span><br><span class="line">        &#125;</span><br><span class="line">        else if (BMI &gt;&#x3D; 24 &amp;&amp; BMI &lt; 27)&#123;</span><br><span class="line">            System.out.println(String.format(&quot;当前BMI指数为: %.2f\n身体状况： 体重过重&quot;, BMI));</span><br><span class="line">        &#125;</span><br><span class="line">        else if (BMI &gt;&#x3D; 27 &amp;&amp; BMI &lt; 30)&#123;</span><br><span class="line">            System.out.println(String.format(&quot;当前BMI指数为: %.2f\n身体状况： 轻度肥胖&quot;, BMI));</span><br><span class="line">        &#125;</span><br><span class="line">        else if (BMI &gt;&#x3D; 30 &amp;&amp; BMI &lt; 35)&#123;</span><br><span class="line">            System.out.println(String.format(&quot;当前BMI指数为: %.2f\n身体状况： 中度肥胖&quot;, BMI));</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            System.out.println(String.format(&quot;当前BMI指数为: %.2f\n身体状况： 重度肥胖&quot;, BMI));</span><br><span class="line">        &#125;</span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-7-练习-闰年"><a class="header-anchor" href="#示例-7-练习-闰年">¶</a>示例 7 : 练习-闰年</h3>
<p>判断某一年是否为闰年<br>
通过[Scanner] 输入一个年份，然后判断该年是否是闰年</p>
<p>闰年判断标准(满足任何一个)</p>
<ol>
<li>
<p>如果能够被4整除，但是不能被100整除</p>
</li>
<li>
<p>能够被400整除</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">		System.out.println(&quot;请输入年份：&quot;);</span><br><span class="line">		int year &#x3D; scanner.nextInt();</span><br><span class="line">		if (year % 4 &#x3D;&#x3D; 0 &amp; year % 100 !&#x3D; 0 | year % 400 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				System.out.println(year + &quot;是闰年&quot;);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			System.out.println(year + &quot;不是闰年&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA的SWITCH语句"><a class="header-anchor" href="#2、JAVA的SWITCH语句">¶</a>2、JAVA的SWITCH语句</h2>
<h3 id="示例-1-switch"><a class="header-anchor" href="#示例-1-switch">¶</a>示例 <strong>1</strong> : switch</h3>
<p>switch可以使用byte,short,int,char,String,enum</p>
<p><strong>注:</strong> 每个表达式结束，都应该有一个break;<br>
<strong>注:</strong> String在Java1.7之前是不支持的, Java从1.7开始支持switch用String的，编译后是把String转化为hash值，其实还是整数<br>
<strong>注:</strong> enum是枚举类型，在[枚举]章节有详细讲解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;如果使用if else</span><br><span class="line">        int day &#x3D; 5;</span><br><span class="line">        if (day&#x3D;&#x3D;1)</span><br><span class="line">            System.out.println(&quot;星期一&quot;);</span><br><span class="line">              </span><br><span class="line">        else if (day&#x3D;&#x3D;2)</span><br><span class="line">            System.out.println(&quot;星期二&quot;);</span><br><span class="line">        else if (day&#x3D;&#x3D;3)</span><br><span class="line">            System.out.println(&quot;星期三&quot;);</span><br><span class="line">        else if (day&#x3D;&#x3D;4)</span><br><span class="line">            System.out.println(&quot;星期四&quot;);</span><br><span class="line">        else if (day&#x3D;&#x3D;5)</span><br><span class="line">            System.out.println(&quot;星期五&quot;);</span><br><span class="line">        else if (day&#x3D;&#x3D;6)</span><br><span class="line">            System.out.println(&quot;星期六&quot;);</span><br><span class="line">        else if (day&#x3D;&#x3D;7)</span><br><span class="line">            System.out.println(&quot;星期天&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;这个是什么鬼？&quot;);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;如果使用switch</span><br><span class="line">        switch(day)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;星期一&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(&quot;星期二&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                System.out.println(&quot;星期三&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                System.out.println(&quot;星期四&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                System.out.println(&quot;星期五&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 6:</span><br><span class="line">                System.out.println(&quot;星期六&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 7:</span><br><span class="line">                System.out.println(&quot;星期天&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;这个是什么鬼？&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-练习-季节"><a class="header-anchor" href="#示例-2-练习-季节">¶</a>示例 <strong>2</strong> : 练习-季节</h3>
<p>通过[Scanner] 输入月份，然后使用switch 判断季节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		System.out.println(&quot;请输入月份:&quot;);</span><br><span class="line">		int mon &#x3D; sc.nextInt();</span><br><span class="line">		switch (mon) &#123;</span><br><span class="line">		case 1:</span><br><span class="line">		case 2:</span><br><span class="line">		case 3:</span><br><span class="line">			System.out.println(&quot;春天来了&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case 4:</span><br><span class="line">		case 5:</span><br><span class="line">		case 6:</span><br><span class="line">			System.out.println(&quot;夏天来了&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case 7:</span><br><span class="line">		case 8:</span><br><span class="line">		case 9:</span><br><span class="line">			System.out.println(&quot;秋天来了&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case 10:</span><br><span class="line">		case 11:</span><br><span class="line">		case 12:</span><br><span class="line">			System.out.println(&quot;冬天来了&quot;);</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			System.out.println(&quot;这是什么鬼？？？&quot;);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA的WHILE语句"><a class="header-anchor" href="#3、JAVA的WHILE语句">¶</a>3、JAVA的WHILE语句</h2>
<h3 id="示例-1-条件为true时-重复执行"><a class="header-anchor" href="#示例-1-条件为true时-重复执行">¶</a>示例 <strong>1</strong> : 条件为true时 重复执行</h3>
<p>只要while中的表达式成立，就会不断地循环执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;打印0到4    </span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while(i&lt;5)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-条件为true时-重复执行，至少会执行一次"><a class="header-anchor" href="#示例-2-条件为true时-重复执行，至少会执行一次">¶</a>示例 <strong>2</strong> : 条件为true时 重复执行，至少会执行一次</h3>
<p>do{</p>
<p>} while 循环</p>
<p>与while的区别是，无论是否成立，先执行一次，再进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;打印0到4</span><br><span class="line">        &#x2F;&#x2F;与while的区别是，无论是否成立，先执行一次，再进行判断</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        do&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            i++;           </span><br><span class="line">        &#125; while(i&lt;5);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-练习-阶乘"><a class="header-anchor" href="#示例-3-练习-阶乘">¶</a>示例 <strong>3</strong> : 练习-阶乘</h3>
<p>通过[Scanner] 获取一个整数，然后使用while计算这个整数的阶乘</p>
<p>N的阶乘等于 N* (N-1) * (N-2) * … * 1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">		System.out.println(&quot;请输入一个整数：&quot;);</span><br><span class="line">		int a &#x3D; scanner.nextInt();</span><br><span class="line">		if (a &#x3D;&#x3D; 1 | a &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			System.out.println(&quot;阶乘是：1&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		long sum&#x3D;1;</span><br><span class="line">		while (a &gt; 1) &#123;</span><br><span class="line">			sum *&#x3D; (a--);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;阶乘是：&quot;+sum);</span><br><span class="line">		scanner.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、JAVA的FOR循环"><a class="header-anchor" href="#4、JAVA的FOR循环">¶</a>4、JAVA的FOR循环</h2>
<h3 id="示例-1-for"><a class="header-anchor" href="#示例-1-for">¶</a>示例 <strong>1</strong> : for</h3>
<p>比较for和while</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F;使用while打印0到4    </span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while(i&lt;5)&#123;</span><br><span class="line">            System.out.println(&quot;while循环输出的&quot;+i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;使用for打印0到4    </span><br><span class="line">        for (int j &#x3D; 0; j &lt; 5; j++) &#123;</span><br><span class="line">            System.out.println(&quot;for  循环输出的&quot;+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-练习-乞丐"><a class="header-anchor" href="#示例-2-练习-乞丐">¶</a>示例 <strong>2</strong> : 练习-乞丐</h3>
<p>天朝有一个乞丐姓洪，去天桥要钱<br>
第一天要了1块钱<br>
第二天要了2块钱<br>
第三天要了4块钱<br>
第四天要了8块钱<br>
以此类推</p>
<p>问题： 洪乞丐干10天，收入是多少？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">			System.out.println(&quot;第&quot;+(i+1)+&quot;天;收入了&quot;+(1 &lt;&lt; i)+&quot;元&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、JAVA-的-CONTINUE语句"><a class="header-anchor" href="#5、JAVA-的-CONTINUE语句">¶</a>5、JAVA 的 CONTINUE语句</h2>
<h3 id="示例-1-continue"><a class="header-anchor" href="#示例-1-continue">¶</a>示例 <strong>1</strong> : continue</h3>
<p>如果是双数，后面的代码不执行，直接进行下一次循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;打印单数    </span><br><span class="line">        for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">            if(0&#x3D;&#x3D;j%2) </span><br><span class="line">                continue; &#x2F;&#x2F;如果是双数，后面的代码不执行，直接进行下一次循环</span><br><span class="line">             </span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-练习-忽略倍数"><a class="header-anchor" href="#示例-2-练习-忽略倍数">¶</a>示例 <strong>2</strong> : 练习-忽略倍数</h3>
<p>打印 1-100 之间的数，如果这个数，要么是3，要么5的倍数，就忽略掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		for(int i &#x3D;1;i&lt;101;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(i%3&#x3D;&#x3D;0||i%5&#x3D;&#x3D;0)</span><br><span class="line">				continue;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、JAVA的BREAK语句"><a class="header-anchor" href="#6、JAVA的BREAK语句">¶</a>6、JAVA的BREAK语句</h2>
<h3 id="示例-1-break"><a class="header-anchor" href="#示例-1-break">¶</a>示例 <strong>1</strong> : break;</h3>
<p>直接结束当前for循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;打印单数    </span><br><span class="line">        for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">            if(0&#x3D;&#x3D;j%2) </span><br><span class="line">                break; &#x2F;&#x2F;如果是双数，直接结束循环</span><br><span class="line">             </span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-练习-百万富翁"><a class="header-anchor" href="#示例-2-练习-百万富翁">¶</a>示例 <strong>2</strong> : 练习-百万富翁</h3>
<p>假设你月收入是3000，除开平时花销，每个月留下1000块钱进行投资。</p>
<p>然后你认真的钻研了 《股票和基金 21天从入门到精通》，达到了每年20%的投资回报率。</p>
<p>那么问题来了，以每个月投资1000块钱的节奏，持续投资多少年，总收入达到100万<br>
（复利计算按照每年12000投入计算，不按照每月计息）</p>
<p>复利公式：<br>
F = p* ( (1+r)^n );<br>
<strong>F</strong> 最终收入<br>
<strong>p</strong> 本金<br>
<strong>r</strong> 年利率<br>
<strong>n</strong> 存了多少年</p>
<p>假设情景一：<br>
p = 10000<br>
r = 0.05<br>
n = 1</p>
<p>解读：<br>
本金是10000<br>
年利率是5%<br>
存了一年 1次<br>
复利收入 10000*( (1+0.05)^1 ) = 10500</p>
<p>假设情景二：<br>
p = 10000<br>
r = 0.05<br>
n = 2</p>
<p>解读：<br>
本金是10000<br>
年利率是5%<br>
存了两年<br>
复利收入 10000*( (1+0.05)^2 ) = 11025</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		double income&#x3D;0;</span><br><span class="line">		int principal&#x3D;12000;</span><br><span class="line">		float rate&#x3D;0.2f;</span><br><span class="line">		int target&#x3D;1000000;</span><br><span class="line">		int targetYear&#x3D;0;</span><br><span class="line">		for(int i &#x3D; 1 ; i &lt; 10000 ; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			income+&#x3D;principal*(Math.pow((1+rate),i));</span><br><span class="line">			System.out.printf(&quot;第%d年的收入为%.0f%n&quot;,i,income);</span><br><span class="line">			if(income&gt;&#x3D;target)</span><br><span class="line">			&#123;</span><br><span class="line">				targetYear&#x3D;i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(&quot;以10000块做投资，需要投资%d年，才能获得收入超过百万的值为：%.0f&quot;,targetYear,income);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、JAVA-如何结束外部FOR循环"><a class="header-anchor" href="#7、JAVA-如何结束外部FOR循环">¶</a>7、JAVA 如何结束外部FOR循环</h2>
<h3 id="示例-1-结束当前循环"><a class="header-anchor" href="#示例-1-结束当前循环">¶</a>示例 <strong>1</strong> : 结束当前循环</h3>
<p>break; 只能结束当前循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;打印单数    </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">             </span><br><span class="line">            for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">                System.out.println(i+&quot;:&quot;+j);</span><br><span class="line">                if(0&#x3D;&#x3D;j%2) </span><br><span class="line">                    break; &#x2F;&#x2F;如果是双数，结束当前循环</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-使用boolean变量结束外部循环"><a class="header-anchor" href="#示例-2-使用boolean变量结束外部循环">¶</a>示例 <strong>2</strong> : 使用boolean变量结束外部循环</h3>
<p>借助boolean变量结束外部循环<br>
需要在内部循环中修改这个变量值<br>
每次内部循环结束后，都要在外部循环中判断，这个变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        boolean breakout &#x3D; false; &#x2F;&#x2F;是否终止外部循环的标记</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line"> </span><br><span class="line">            for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">                System.out.println(i + &quot;:&quot; + j);</span><br><span class="line">                if (0 &#x3D;&#x3D; j % 2) &#123;</span><br><span class="line">                    breakout &#x3D; true; &#x2F;&#x2F;终止外部循环的标记设置为true</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (breakout) &#x2F;&#x2F;判断是否终止外部循环</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-使用标签结束外部循环"><a class="header-anchor" href="#示例-3-使用标签结束外部循环">¶</a>示例 <strong>3</strong> : 使用标签结束外部循环</h3>
<p>在外部循环的前一行，加上标签<br>
在break的时候使用该标签<br>
即能达到结束外部循环的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;打印单数    </span><br><span class="line">        outloop: &#x2F;&#x2F;outloop这个标示是可以自定义的比如outloop1,ol2,out5</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">             </span><br><span class="line">            for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">                System.out.println(i+&quot;:&quot;+j);</span><br><span class="line">                if(0&#x3D;&#x3D;j%2) </span><br><span class="line">                    break outloop; &#x2F;&#x2F;如果是双数，结束外部循环</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、综合练习"><a class="header-anchor" href="#8、综合练习">¶</a>8、综合练习</h2>
<h3 id="步骤-1-练习-黄金分割点"><a class="header-anchor" href="#步骤-1-练习-黄金分割点">¶</a>步骤 <strong>1</strong> : 练习-黄金分割点</h3>
<p>寻找某两个数相除，其结果 离黄金分割点 0.618最近</p>
<p>分母和分子不能同时为偶数<br>
分母和分子 取值范围在[1-20]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double pmin&#x3D;1.0;</span><br><span class="line">        float a1&#x3D;1f;</span><br><span class="line">        float b1&#x3D;1f;</span><br><span class="line">        for(float a &#x3D; 1.0f; a&lt;&#x3D;20; a++)&#123;</span><br><span class="line">            for(float b &#x3D; 1.0f; b&lt;&#x3D;20; b++)&#123;</span><br><span class="line">                double s &#x3D; a&#x2F;b;</span><br><span class="line">                double p &#x3D; s-0.618;</span><br><span class="line">                p&#x3D;p &lt; 0? 0-p : p;   </span><br><span class="line">                if(p &lt; pmin)&#123;</span><br><span class="line">                    pmin &#x3D; p;</span><br><span class="line">                    a1 &#x3D; a;</span><br><span class="line">                    b1 &#x3D; b;</span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;离黄金分割点0.618最近的两个整数相除是：&quot;+a1+&quot;&#x2F;&quot;+b1+&quot;&#x3D;&quot;+(a1&#x2F;b1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-水仙花数"><a class="header-anchor" href="#步骤-2-练习-水仙花数">¶</a>步骤 2 : 练习-水仙花数</h3>
<p>水仙花数定义：</p>
<ol>
<li>
<p>一定是3位数</p>
</li>
<li>
<p>每一位的立方，加起来恰好是这个数本身，比如153=1*1*1+5*5*5+3*3*3</p>
</li>
</ol>
<p>寻找所有的水仙花数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        int a &#x3D; 0;</span><br><span class="line">        int b &#x3D; 0;</span><br><span class="line">        int c &#x3D; 0;</span><br><span class="line">        int answer &#x3D; 0;</span><br><span class="line">        for (n &#x3D; 100; n &lt; 1000; n++) &#123;</span><br><span class="line">            a &#x3D; (n % 100) % 10;</span><br><span class="line">            b &#x3D; (n % 100) &#x2F; 10;</span><br><span class="line">            c &#x3D; n &#x2F; 100;</span><br><span class="line">            if (n &#x3D;&#x3D; a * a * a + b * b * b + c * c * c) &#123;</span><br><span class="line">                answer &#x3D; n;</span><br><span class="line">                System.out.println(answer + &quot;是水仙花数&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-小学算术题"><a class="header-anchor" href="#步骤-3-练习-小学算术题">¶</a>步骤 3 : 练习-小学算术题</h3>
<p>提示使用多层循环嵌套解决</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/3434.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a;</span><br><span class="line">        int b;</span><br><span class="line">        int c;</span><br><span class="line">        int d;</span><br><span class="line">        for(a &#x3D;0 ;a&lt;20;a++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(b&#x3D;0;b&lt;20;b++)&#123;</span><br><span class="line">                for(c&#x3D;0;c&lt;20;c++)&#123;</span><br><span class="line">                    for(d&#x3D;0;d&lt;20;d++)&#123;</span><br><span class="line">                        if(a+b&#x3D;&#x3D;8&amp;a+c&#x3D;&#x3D;14&amp;b+d&#x3D;&#x3D;10&amp;c-d&#x3D;&#x3D;6)</span><br><span class="line">                        &#123;</span><br><span class="line">                            System.out.printf(&quot;计算得出的a，b,c,d值为:%d,%d,%d,%d&quot;,a,b,c,d);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六、数组"><a class="header-anchor" href="#六、数组">¶</a>六、数组</h1>
<h2 id="1、JAVA-如何创建一个数组"><a class="header-anchor" href="#1、JAVA-如何创建一个数组">¶</a>1、JAVA 如何创建一个数组</h2>
<h3 id="步骤-1-声明数组"><a class="header-anchor" href="#步骤-1-声明数组">¶</a>步骤 <strong>1</strong> : 声明数组</h3>
<p>int[] a; 声明了一个数组变量。<br>
[]表示该变量是一个数组<br>
int 表示数组里的每一个元素都是一个整数<br>
a 是变量名<br>
但是，仅仅是这一句<strong>声明，不会创建数组</strong></p>
<p>有时候也会写成int a[]; 没有任何区别，就是你看哪种顺眼的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 声明一个数组</span><br><span class="line">        int[] a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-创建数组"><a class="header-anchor" href="#步骤-2-创建数组">¶</a>步骤 <strong>2</strong> : 创建数组</h3>
<p>创建数组的时候，要指明数组的长度。<br>
new int[5]<br>
<strong>引用概念：</strong><br>
如果变量代表一个数组，比如a,我们把a叫做<strong>引用</strong><br>
与基本类型不同<br>
int c = 5; 这叫给c<strong>赋值</strong>为5<br>
声明一个引用 int[] a;<br>
a = new int[5];<br>
让a这个引用，<strong>指向</strong>数组</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/567.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;声明一个引用</span><br><span class="line">        int[] a;</span><br><span class="line">        &#x2F;&#x2F;创建一个长度是5的数组，并且使用引用a指向该数组</span><br><span class="line">        a &#x3D; new int[5];</span><br><span class="line">         </span><br><span class="line">        int[] b &#x3D; new int[5]; &#x2F;&#x2F;声明的同时，指向一个数组</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-访问数组"><a class="header-anchor" href="#步骤-3-访问数组">¶</a>步骤 <strong>3</strong> : 访问数组</h3>
<p>数组下标<strong>基0</strong><br>
下标0，代表数组里的第一个数</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/567.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a;</span><br><span class="line">        a &#x3D; new int[5];</span><br><span class="line">         </span><br><span class="line">        a[0]&#x3D; 1;  &#x2F;&#x2F;下标0，代表数组里的第一个数</span><br><span class="line">        a[1]&#x3D; 2;</span><br><span class="line">        a[2]&#x3D; 3;</span><br><span class="line">        a[3]&#x3D; 4;</span><br><span class="line">        a[4]&#x3D; 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-数组长度"><a class="header-anchor" href="#步骤-4-数组长度">¶</a>步骤 <strong>4</strong> : 数组长度</h3>
<p><strong>.length属性</strong>用于访问一个数组的长度<br>
数组访问下标范围是0到长度-1<br>
一旦超过这个范围,就会产生数组下标越界异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a;</span><br><span class="line">        a &#x3D; new int[5];</span><br><span class="line">         </span><br><span class="line">        System.out.println(a.length); &#x2F;&#x2F;打印数组的长度</span><br><span class="line">         </span><br><span class="line">        a[4]&#x3D;100; &#x2F;&#x2F;下标4，实质上是“第5个”，即最后一个</span><br><span class="line">        a[5]&#x3D;101; &#x2F;&#x2F;下标5，实质上是“第6个”，超出范围 ,产生数组下标越界异常</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-数组最小值"><a class="header-anchor" href="#步骤-5-练习-数组最小值">¶</a>步骤 <strong>5</strong> : 练习-数组最小值</h3>
<p>首先创建一个长度是5的数组<br>
然后给数组的每一位赋予随机整数<br>
通过for循环，遍历数组，找出最小的一个值出来</p>
<p>0-100的 随机整数的获取办法有多种，下面是参考办法之一:</p>
<p>(int) (Math.random() * 100)</p>
<p>Math.random() 会得到一个0-1之间的随机浮点数，然后乘以100，并强转为整型即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] a &#x3D; new int[5];</span><br><span class="line">		a[0] &#x3D; (int) (Math.random() * 100);</span><br><span class="line">		a[1] &#x3D; (int) (Math.random() * 100);</span><br><span class="line">		a[2] &#x3D; (int) (Math.random() * 100);</span><br><span class="line">		a[3] &#x3D; (int) (Math.random() * 100);</span><br><span class="line">		a[4] &#x3D; (int) (Math.random() * 100);</span><br><span class="line">		int min &#x3D; a[0];</span><br><span class="line">		System.out.println(&quot;数组中的元素有：&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">			if (min &gt; a[i]) &#123;</span><br><span class="line">				min &#x3D; a[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;\n最小的数为：&quot; + min);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA-如何初始化数组"><a class="header-anchor" href="#2、JAVA-如何初始化数组">¶</a>2、JAVA 如何初始化数组</h2>
<h3 id="步骤-1-分配空间与赋值分步进行"><a class="header-anchor" href="#步骤-1-分配空间与赋值分步进行">¶</a>步骤 <strong>1</strong> : 分配空间与赋值分步进行</h3>
<p>分配空间与赋值分步进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a &#x3D; new int[5]; &#x2F;&#x2F;分配了长度是5的数组，但是没有赋值</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;没有赋值，那么就会使用默认值</span><br><span class="line">        &#x2F;&#x2F;作为int类型的数组，默认值是0</span><br><span class="line">        System.out.println(a[0]);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;进行赋值</span><br><span class="line">     </span><br><span class="line">        a[0] &#x3D; 100;</span><br><span class="line">        a[1] &#x3D; 101;</span><br><span class="line">        a[2] &#x3D; 103;</span><br><span class="line">        a[3] &#x3D; 120;</span><br><span class="line">        a[4] &#x3D; 140;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-分配空间，同时赋值"><a class="header-anchor" href="#步骤-2-分配空间，同时赋值">¶</a>步骤 <strong>2</strong> : 分配空间，同时赋值</h3>
<p>分配空间，同时赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;写法一： 分配空间同时赋值</span><br><span class="line">        int[] a &#x3D; new int[]&#123;100,102,444,836,3236&#125;;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;写法二： 省略了new int[],效果一样</span><br><span class="line">        int[] b &#x3D; &#123;100,102,444,836,3236&#125;;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;写法三：同时分配空间，和指定内容</span><br><span class="line">        &#x2F;&#x2F;在这个例子里，长度是3，内容是5个，产生矛盾了</span><br><span class="line">        &#x2F;&#x2F;所以如果指定了数组的内容，就不能同时设置数组的长度</span><br><span class="line">        int[] c &#x3D; new int[3]&#123;100,102,444,836,3236&#125;;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-数组反转"><a class="header-anchor" href="#步骤-3-练习-数组反转">¶</a>步骤 <strong>3</strong> : 练习-数组反转</h3>
<p>首先创建一个长度是5的数组,并填充随机数。 ([向数组填充随机数]的办法，[参考这里])</p>
<p>使用for循环或者while循环，对这个数组实现反转效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int a[] &#x3D; new int[5];</span><br><span class="line">		for(int i &#x3D; 0 ; i &lt; a.length ; i++) &#123;</span><br><span class="line">			a[i] &#x3D; (int) (Math.random() * 100);</span><br><span class="line">			System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(&quot;数组反转：&quot;);</span><br><span class="line">		for(int x &#x3D; 4 ; x &gt;&#x3D; 0 ; x--)&#123;</span><br><span class="line">			System.out.print(a[x]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA-数组选择法，冒泡法排序"><a class="header-anchor" href="#3、JAVA-数组选择法，冒泡法排序">¶</a>3、JAVA 数组选择法，冒泡法排序</h2>
<h3 id="步骤-1-选择法排序"><a class="header-anchor" href="#步骤-1-选择法排序">¶</a>步骤 <strong>1</strong> : 选择法排序</h3>
<p>选择法排序的思路：<br>
<strong>把第一位</strong>和其他所有的进行比较，只要比第一位小的，就换到第一个位置来<br>
比较完后，<strong>第一位就是最小的</strong><br>
然后再从<strong>第二位</strong>和剩余的其他所有进行比较，只要比第二位小，就换到第二个位置来<br>
比较完后，<strong>第二位就是第二小的</strong><br>
以此类推</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/573.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a [] &#x3D; new int[]&#123;18,62,68,82,65,9&#125;;</span><br><span class="line">        &#x2F;&#x2F;排序前，先把内容打印出来</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; &quot;);</span><br><span class="line">        &#x2F;&#x2F;选择法排序</span><br><span class="line">     </span><br><span class="line">        &#x2F;&#x2F;第一步： 把第一位和其他所有位进行比较</span><br><span class="line">        &#x2F;&#x2F;如果发现其他位置的数据比第一位小，就进行交换</span><br><span class="line">         </span><br><span class="line">        for (int i &#x3D; 1; i &lt; a.length; i++) &#123;</span><br><span class="line">            if(a[i]&lt;a[0])&#123;  </span><br><span class="line">                int temp &#x3D; a[0];</span><br><span class="line">                a[0] &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把内容打印出来</span><br><span class="line">        &#x2F;&#x2F;可以发现，最小的一个数，到了最前面</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; &quot;);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;第二步： 把第二位的和剩下的所有位进行比较</span><br><span class="line">        for (int i &#x3D; 2; i &lt; a.length; i++) &#123;</span><br><span class="line">            if(a[i]&lt;a[1])&#123;  </span><br><span class="line">                int temp &#x3D; a[1];</span><br><span class="line">                a[1] &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把内容打印出来</span><br><span class="line">        &#x2F;&#x2F;可以发现，倒数第二小的数，到了第二个位置</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; &quot;);       </span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;可以发现一个规律</span><br><span class="line">        &#x2F;&#x2F;移动的位置是从0 逐渐增加的</span><br><span class="line">        &#x2F;&#x2F;所以可以在外面套一层循环</span><br><span class="line">         </span><br><span class="line">        for (int j &#x3D; 0; j &lt; a.length-1; j++) &#123;</span><br><span class="line">            for (int i &#x3D; j+1; i &lt; a.length; i++) &#123;</span><br><span class="line">                if(a[i]&lt;a[j])&#123;  </span><br><span class="line">                    int temp &#x3D; a[j];</span><br><span class="line">                    a[j] &#x3D; a[i];</span><br><span class="line">                    a[i] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;把内容打印出来</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; &quot;);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-冒泡法排序"><a class="header-anchor" href="#步骤-2-冒泡法排序">¶</a>步骤 <strong>2</strong> : 冒泡法排序</h3>
<p>冒泡法排序的思路：<br>
第一步：从第一位开始，把相邻两位进行比较<br>
如果发现前面的比后面的大，就把大的数据交换在后面，循环比较完毕后，<strong>最后一位就是最大的</strong><br>
第二步： 再来一次，只不过不用比较最后一位<br>
以此类推</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/574.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a [] &#x3D; new int[]&#123;18,62,68,82,65,9&#125;;</span><br><span class="line">        &#x2F;&#x2F;排序前，先把内容打印出来</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; &quot;);</span><br><span class="line">        &#x2F;&#x2F;冒泡法排序</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F;第一步：从第一位开始，把相邻两位进行比较</span><br><span class="line">        &#x2F;&#x2F;如果发现前面的比后面的大，就把大的数据交换在后面</span><br><span class="line">          </span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length-1; i++) &#123;</span><br><span class="line">            if(a[i]&gt;a[i+1])&#123;  </span><br><span class="line">                int temp &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; a[i+1];</span><br><span class="line">                a[i+1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把内容打印出来</span><br><span class="line">        &#x2F;&#x2F;可以发现，最大的到了最后面</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; &quot;);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;第二步： 再来一次，只不过不用比较最后一位</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length-2; i++) &#123;</span><br><span class="line">            if(a[i]&gt;a[i+1])&#123;  </span><br><span class="line">                int temp &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; a[i+1];</span><br><span class="line">                a[i+1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把内容打印出来</span><br><span class="line">        &#x2F;&#x2F;可以发现，倒数第二大的到了倒数第二个位置</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; &quot;);       </span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;可以发现一个规律</span><br><span class="line">        &#x2F;&#x2F;后边界在收缩</span><br><span class="line">        &#x2F;&#x2F;所以可以在外面套一层循环</span><br><span class="line">          </span><br><span class="line">        for (int j &#x3D; 0; j &lt; a.length; j++) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; a.length-j-1; i++) &#123;</span><br><span class="line">                if(a[i]&gt;a[i+1])&#123;  </span><br><span class="line">                    int temp &#x3D; a[i];</span><br><span class="line">                    a[i] &#x3D; a[i+1];</span><br><span class="line">                    a[i+1] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;把内容打印出来</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; &quot;);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-排序"><a class="header-anchor" href="#步骤-3-练习-排序">¶</a>步骤 <strong>3</strong> : 练习-排序</h3>
<p>首先创建一个长度是5的数组,并填充随机数。 ([向数组填充随机数]的办法，[参考这里])</p>
<p>首先用选择法正排序，然后再对其使用冒泡法倒排序</p>
<p><strong>注</strong> 所谓的正排序就是从小到大排序，倒排序就是从大到小排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">	int [] a&#x3D; new int [5];</span><br><span class="line">	for(int i &#x3D;0;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]&#x3D;(int)(Math.random()*100);</span><br><span class="line">	&#125;</span><br><span class="line">	 &#x2F;&#x2F;把内容打印出来</span><br><span class="line">    for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot; &quot;);    </span><br><span class="line">    System.out.println(&quot;----------------&quot;);</span><br><span class="line">	System.out.println(&quot;首先用选择法正排序&quot;);</span><br><span class="line"></span><br><span class="line">	for(int j &#x3D;0 ; j&lt;a.length-1; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i &#x3D;j+1 ; i &lt;a.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(a[i]&lt;a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				int temp &#x3D; a[j];</span><br><span class="line">				a[j] &#x3D; a[i];</span><br><span class="line">				a[i] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 &#x2F;&#x2F;把内容打印出来</span><br><span class="line">    for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot; &quot;);    </span><br><span class="line">    System.out.println(&quot;----------------&quot;);</span><br><span class="line">	System.out.println(&quot;然后用冒泡法倒排序&quot;);</span><br><span class="line">	</span><br><span class="line">	for (int j &#x3D; 0; j &lt; a.length; j++) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length-j-1; i++) &#123;</span><br><span class="line">            if(a[i]&lt;a[i+1])&#123;  </span><br><span class="line">                int temp &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; a[i+1];</span><br><span class="line">                a[i+1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;把内容打印出来</span><br><span class="line">    for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、JAVA-中如何使用增强FOR循环"><a class="header-anchor" href="#4、JAVA-中如何使用增强FOR循环">¶</a>4、JAVA 中如何使用增强FOR循环</h2>
<h3 id="步骤-1-增强型for循环"><a class="header-anchor" href="#步骤-1-增强型for循环">¶</a>步骤 <strong>1</strong> : 增强型for循环</h3>
<p>注：增强型for循环只能用来取值，却不能用来修改数组里的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int values [] &#x3D; new int[]&#123;18,62,68,82,65,9&#125;;</span><br><span class="line">        &#x2F;&#x2F;常规遍历</span><br><span class="line">        for (int i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            int each &#x3D; values[i];</span><br><span class="line">            System.out.println(each);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;增强型for循环遍历</span><br><span class="line">        for (int each : values) &#123;</span><br><span class="line">            System.out.println(each);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-最大值"><a class="header-anchor" href="#步骤-2-练习-最大值">¶</a>步骤 <strong>2</strong> : 练习-最大值</h3>
<p>用增强型for循环找出最大的那个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">		public static void main(String[] args) &#123;</span><br><span class="line">			int a[] &#x3D; new int[5];</span><br><span class="line">			for (int i &#x3D; 0 ; i &lt; a.length ; i++) &#123;</span><br><span class="line">				a[i] &#x3D; (int) (Math.random() * 100);</span><br><span class="line">				System.out.println(a[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			int max &#x3D; a[0];</span><br><span class="line">			int min &#x3D; a[0];</span><br><span class="line">			for(int x : a)&#123;</span><br><span class="line">				if(max &lt; x)&#123;</span><br><span class="line">					max &#x3D; x;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			for(int y : a)&#123;</span><br><span class="line">				if(min &gt; y)&#123;</span><br><span class="line">					min &#x3D; y;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;a[]数组的最大值为：&quot; +max);</span><br><span class="line">			System.out.println(&quot;a[]数组的最小值为：&quot; +min);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、JAVA-如何复制数组"><a class="header-anchor" href="#5、JAVA-如何复制数组">¶</a>5、JAVA 如何复制数组</h2>
<h3 id="步骤-1-复制数组"><a class="header-anchor" href="#步骤-1-复制数组">¶</a>步骤 <strong>1</strong> : 复制数组</h3>
<p>把一个数组的值，复制到另一个数组中</p>
<p>System.arraycopy(src, srcPos, dest, destPos, length)</p>
<p>src: 源数组<br>
srcPos: 从源数组复制数据的起始位置<br>
dest: 目标数组<br>
destPos: 复制到目标数组的起始位置<br>
length: 复制的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a [] &#x3D; new int[]&#123;18,62,68,82,65,9&#125;;</span><br><span class="line">         </span><br><span class="line">        int b[] &#x3D; new int[3];&#x2F;&#x2F;分配了长度是3的空间，但是没有赋值</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;通过数组赋值把，a数组的前3位赋值到b数组</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;方法一： for循环</span><br><span class="line">         </span><br><span class="line">        for (int i &#x3D; 0; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] &#x3D; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;方法二: System.arraycopy(src, srcPos, dest, destPos, length)</span><br><span class="line">        &#x2F;&#x2F;src: 源数组</span><br><span class="line">        &#x2F;&#x2F;srcPos: 从源数组复制数据的起始位置</span><br><span class="line">        &#x2F;&#x2F;dest: 目标数组</span><br><span class="line">        &#x2F;&#x2F;destPos: 复制到目标数组的启始位置</span><br><span class="line">        &#x2F;&#x2F;length: 复制的长度       </span><br><span class="line">        System.arraycopy(a, 0, b, 0, 3);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;把内容打印出来</span><br><span class="line">        for (int i &#x3D; 0; i &lt; b.length; i++) &#123;</span><br><span class="line">            System.out.print(b[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-合并数组"><a class="header-anchor" href="#步骤-2-练习-合并数组">¶</a>步骤 <strong>2</strong> : 练习-合并数组</h3>
<p>首先准备两个数组，他俩的长度是5-10之间的随机数，并使用随机数初始化这两个数组<br>
([向数组填充随机数]的办法，[参考这里])</p>
<p>然后准备第三个数组，第三个数组的长度是前两个的和<br>
通过System.arraycopy 把前两个数组合并到第三个数组中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int a[] &#x3D; new int[(int) (Math.random()*5+5)];</span><br><span class="line">		int b[] &#x3D; new int[(int) (Math.random()*5+5)];</span><br><span class="line">		int c[] &#x3D; new int[(a.length+b.length)];</span><br><span class="line">		System.out.println(&quot;数组a[]的内容为：&quot;);</span><br><span class="line">		for(int x &#x3D; 0 ; x &lt; a.length ; x++)&#123;</span><br><span class="line">			a[x] &#x3D;(int) (Math.random()*100);</span><br><span class="line">			System.out.print(a[x]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot; &quot;);</span><br><span class="line">		System.out.println(&quot;数组b[]的内容为：&quot;);</span><br><span class="line">		for(int y &#x3D; 0 ; y &lt; b.length ; y++)&#123;</span><br><span class="line">			b[y] &#x3D;(int) (Math.random()*100);</span><br><span class="line">			System.out.print(b[y]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot; &quot;);</span><br><span class="line">		System.out.println(&quot;数组c[]的内容为：&quot;);</span><br><span class="line">		System.arraycopy(a,0,c,0,a.length);</span><br><span class="line">		System.arraycopy(b,0,c,a.length,b.length);</span><br><span class="line">		for(int z &#x3D; 0 ; z &lt; (a.length+b.length) ; z++)&#123;</span><br><span class="line">			System.out.print(c[z]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、JAVA-如何使用二维数组"><a class="header-anchor" href="#6、JAVA-如何使用二维数组">¶</a>6、JAVA 如何使用二维数组</h2>
<h3 id="步骤-1-初始化二维数组"><a class="header-anchor" href="#步骤-1-初始化二维数组">¶</a>步骤 <strong>1</strong> : 初始化二维数组</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤 2 : 练习-二维数组public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F;初始化二维数组，</span><br><span class="line">       int[][] a &#x3D; new int[2][3]; &#x2F;&#x2F;有两个一维数组，每个一维数组的长度是3</span><br><span class="line">       a[1][2] &#x3D; 5;  &#x2F;&#x2F;可以直接访问一维数组，因为已经分配了空间</span><br><span class="line">          </span><br><span class="line">       &#x2F;&#x2F;只分配了二维数组</span><br><span class="line">       int[][] b &#x3D; new int[2][]; &#x2F;&#x2F;有两个一维数组，每个一维数组的长度暂未分配</span><br><span class="line">       b[0]  &#x3D;new int[3]; &#x2F;&#x2F;必须事先分配长度，才可以访问</span><br><span class="line">       b[0][2] &#x3D; 5;</span><br><span class="line">        </span><br><span class="line">       &#x2F;&#x2F;指定内容的同时，分配空间</span><br><span class="line">       int[][] c &#x3D; new int[][]&#123;</span><br><span class="line">               &#123;1,2,4&#125;,</span><br><span class="line">               &#123;4,5&#125;,</span><br><span class="line">               &#123;6,7,8,9&#125;</span><br><span class="line">       &#125;;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-二维数组"><a class="header-anchor" href="#步骤-2-练习-二维数组">¶</a>步骤 <strong>2</strong> : 练习-二维数组</h3>
<p>定义一个5X5的二维数组。 然后使用随机数填充该二维数组。<br>
找出这个二维数组里，最大的那个值，并打印出其二维坐标</p>
<p>0-100的 随机整数的获取办法有多种，下面是参考办法之一:</p>
<p>(int) (Math.random() * 100)</p>
<p>Math.random() 会得到一个0-1之间的随机浮点数，然后乘以100，并强转为整型即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a[][] &#x3D; new int[5][5];</span><br><span class="line">		for (int x &#x3D; 0; x &lt; 5; x++) &#123;</span><br><span class="line">			for (int y &#x3D; 0; y &lt; 5; y++) &#123;</span><br><span class="line">				a[x][y] &#x3D; (int) (Math.random() * 100);</span><br><span class="line">				System.out.print(a[x][y] + &quot;\t&quot;);</span><br><span class="line">				if (y &#x3D;&#x3D; 4) &#123;</span><br><span class="line">					System.out.println(&quot;\t&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int max &#x3D; a[0][0];</span><br><span class="line">		for(int i[] : a)&#123;</span><br><span class="line">			for(int m : i)&#123;</span><br><span class="line">				if(max &lt; m)&#123;</span><br><span class="line">					max &#x3D; m;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;找出最大的值为：&quot;+max);</span><br><span class="line">		for (int x &#x3D; 0; x &lt; 5; x++) &#123;</span><br><span class="line">			for (int y &#x3D; 0; y &lt; 5; y++) &#123;</span><br><span class="line">				int n &#x3D; a[x][y];</span><br><span class="line">				if(max &#x3D;&#x3D; n)&#123;</span><br><span class="line">					System.out.println(&quot;其坐标是：&quot;+&quot;[&quot;+x+&quot;]&quot;+&quot;[&quot;+y+&quot;]&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、JAVA-UTIL-ARRAYS类常用方法"><a class="header-anchor" href="#7、JAVA-UTIL-ARRAYS类常用方法">¶</a>7、JAVA.UTIL.ARRAYS类常用方法</h2>
<h3 id="步骤-1-数组复制"><a class="header-anchor" href="#步骤-1-数组复制">¶</a>步骤 <strong>1</strong> : 数组复制</h3>
<p>与[使用System.arraycopy进行数组复制]类似的， Arrays提供了一个copyOfRange方法进行数组复制。<br>
不同的是System.arraycopy，需要事先准备好目标数组，并分配长度。 copyOfRange 只需要源数组就就可以了，通过返回值，就能够得到目标数组了。<br>
除此之外，需要注意的是 copyOfRange 的<strong>第3个参数</strong>，表示源数组的结束位置，是<strong>取不到的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"> </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a[] &#x3D; new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; copyOfRange(int[] original, int from, int to)</span><br><span class="line">        &#x2F;&#x2F; 第一个参数表示源数组</span><br><span class="line">        &#x2F;&#x2F; 第二个参数表示开始位置(取得到)</span><br><span class="line">        &#x2F;&#x2F; 第三个参数表示结束位置(取不到)</span><br><span class="line">        int[] b &#x3D; Arrays.copyOfRange(a, 0, 3);</span><br><span class="line"> </span><br><span class="line">        for (int i &#x3D; 0; i &lt; b.length; i++) &#123;</span><br><span class="line">            System.out.print(b[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-转换为字符串"><a class="header-anchor" href="#步骤-2-转换为字符串">¶</a>步骤 <strong>2</strong> : 转换为字符串</h3>
<p>如果要打印一个数组的内容，就需要通过for循环来挨个遍历，逐一打印</p>
<p>但是Arrays提供了一个toString()方法，直接把一个数组，转换为字符串，这样方便观察数组的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">  </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a[] &#x3D; new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;;</span><br><span class="line">        String content &#x3D; Arrays.toString(a);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-排序"><a class="header-anchor" href="#步骤-3-排序">¶</a>步骤 <strong>3</strong> : 排序</h3>
<p>在前面章节学习了 [选择法排序] 和 [冒泡法排序]，Arrays工具类提供了一个sort方法，只需要一行代码即可完成排序功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">  </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a[] &#x3D; new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;;</span><br><span class="line">        System.out.println(&quot;排序之前 :&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        System.out.println(&quot;排序之后:&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-搜索"><a class="header-anchor" href="#步骤-4-搜索">¶</a>步骤 <strong>4</strong> : 搜索</h3>
<p>查询元素出现的位置<br>
需要注意的是，使用binarySearch进行查找之前，必须使用sort进行排序<br>
如果数组中有多个相同的元素，查找结果是不确定的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"> </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a[] &#x3D; new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;;</span><br><span class="line"> </span><br><span class="line">        Arrays.sort(a);</span><br><span class="line"> </span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        &#x2F;&#x2F;使用binarySearch之前，必须先使用sort进行排序</span><br><span class="line">        System.out.println(&quot;数字 62出现的位置:&quot;+Arrays.binarySearch(a, 62));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-判断是否相同"><a class="header-anchor" href="#步骤-5-判断是否相同">¶</a>步骤 <strong>5</strong> : 判断是否相同</h3>
<p>比较两个数组的内容是否一样<br>
第二个数组的最后一个元素<strong>是8</strong>，和第一个数组不一样，所以比较结果是false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"> </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a[] &#x3D; new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;;</span><br><span class="line">        int b[] &#x3D; new int[] &#123; 18, 62, 68, 82, 65, 8 &#125;;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Arrays.equals(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-填充"><a class="header-anchor" href="#步骤-6-填充">¶</a>步骤 <strong>6</strong> : 填充</h3>
<p>使用同一个值，填充整个数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">  </span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a[] &#x3D; new int[10];</span><br><span class="line">  </span><br><span class="line">        Arrays.fill(a, 5);</span><br><span class="line">  </span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-练习-二维数组排序"><a class="header-anchor" href="#步骤-7-练习-二维数组排序">¶</a>步骤 <strong>7</strong> : 练习-二维数组排序</h3>
<p>首先定义一个5X8的二维数组，然后使用随机数填充满。<br>
借助Arrays的方法对二维数组进行排序。<br>
<strong>参考思路：</strong><br>
先把二维数组[使用System.arraycopy进行数组复制]到一个一维数组<br>
然后使用sort进行排序<br>
最后再复制回到二维数组。</p>
<p><strong>关于随机数</strong><br>
0-100的 随机整数的获取办法有多种，下面是参考办法之一:</p>
<p>(int) (Math.random() * 100)</p>
<p>Math.random() 会得到一个0-1之间的随机浮点数，然后乘以100，并强转为整型即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		int [][] a&#x3D; new int[5][8];</span><br><span class="line">		for(int i&#x3D;0;i&lt;a.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j &#x3D;0; j&lt;a[i].length;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				a[i][j]&#x3D;(int)(Math.random()*100);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;排序前：&quot;);</span><br><span class="line">		for(int[] row :a)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int c:row)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.print(c+&quot;\t&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;--------------&quot;);</span><br><span class="line">		int[]b &#x3D; new int[5*8];</span><br><span class="line">		for(int i &#x3D;0 ; i &lt;a.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.arraycopy(a[i],0,b,a[i].length*i,a[i].length);</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(b);</span><br><span class="line"></span><br><span class="line">		for(int i&#x3D;0;i&lt;a.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.arraycopy(b,a[i].length*i,a[i],0,a[i].length);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;排序后：&quot;);</span><br><span class="line">		for(int[] row :a)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int c:row)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.print(c+&quot;\t&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七、类和对象"><a class="header-anchor" href="#七、类和对象">¶</a>七、类和对象</h1>
<h2 id="1、什么是JAVA中的引用？"><a class="header-anchor" href="#1、什么是JAVA中的引用？">¶</a>1、什么是JAVA中的引用？</h2>
<h3 id="步骤-1-引用和指向"><a class="header-anchor" href="#步骤-1-引用和指向">¶</a>步骤 <strong>1</strong> : 引用和指向</h3>
<p>new Hero();</p>
<p>代表<strong>创建</strong>了一个Hero对象<br>
但是也仅仅是创建了一个对象，没有办法访问它<br>
为了访问这个对象，会使用<strong>引用</strong>来<strong>代表</strong>这个对象</p>
<p>Hero h = new Hero();</p>
<p>h这个变量是Hero类型，又叫做引用<br>
=的意思指的h这个引用<strong>代表</strong>右侧创建的对象<br>
“<strong>代表</strong>” 在面向对象里，又叫做“<strong>指向</strong>”</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/618.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">      </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">      </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">      </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">      </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个对象</span><br><span class="line">        new Hero();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;使用一个引用来指向这个对象</span><br><span class="line">        Hero h &#x3D; new Hero();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-多个引用，一个对象"><a class="header-anchor" href="#步骤-2-多个引用，一个对象">¶</a>步骤 <strong>2</strong> : 多个引用，一个对象</h3>
<p>引用有多个，但是对象只有一个。<br>
在这个例子里，所有引用都指向了同一个对象。<br>
对象就像 “房产”， 引用就像&quot;房产证&quot;<br>
房产证的复印件可以有多张，但是真正的&quot;房产&quot; 只有这么一处</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/617.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">      </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">      </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">      </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">      </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;使用一个引用来指向这个对象</span><br><span class="line">        Hero h1 &#x3D; new Hero();</span><br><span class="line">        Hero h2 &#x3D; h1;  &#x2F;&#x2F;h2指向h1所指向的对象</span><br><span class="line">        Hero h3 &#x3D; h1;</span><br><span class="line">        Hero h4 &#x3D; h1;</span><br><span class="line">        Hero h5 &#x3D; h4;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;h1,h2,h3,h4,h5 五个引用，都指向同一个对象</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-一个引用，多个对象"><a class="header-anchor" href="#步骤-3-一个引用，多个对象">¶</a>步骤 <strong>3</strong> : 一个引用，多个对象</h3>
<p>第8行，引用garen指向新创建的对象（对象1）<br>
第9行，同一个引用garen指向新创建的对象（对象2）<br>
这个时候，对象1，就没有任何引用指向了<br>
换句话说，就没有任何手段控制和访问该对象，那么该对象就变得没有意义。</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/619.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           Hero garen &#x3D;  new Hero();</span><br><span class="line">           garen &#x3D;  new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-引用"><a class="header-anchor" href="#步骤-4-练习-引用">¶</a>步骤 <strong>4</strong> : 练习-引用</h3>
<p>如代码，问题:<br>
h4所指向的对象和h2所指向的对象，是否是同一个对象？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           Hero h1 &#x3D;  new Hero();</span><br><span class="line">           Hero h2 &#x3D;  new Hero();</span><br><span class="line">           Hero h3;</span><br><span class="line">           Hero h4;</span><br><span class="line">           h3 &#x3D; h1;</span><br><span class="line">           h4 &#x3D; h3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不是同一对象，h1和h2是Hero的两个不同的对象，h4指向的是h1,因此h2和h4是两个不同的对象</p>
<h2 id="2、什么是-JAVA的-继承"><a class="header-anchor" href="#2、什么是-JAVA的-继承">¶</a>2、什么是 JAVA的 继承 ?</h2>
<h3 id="步骤-1-物品类Item"><a class="header-anchor" href="#步骤-1-物品类Item">¶</a>步骤 <strong>1</strong> : 物品类Item</h3>
<p>物品类Item 有属性 name,price</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Item &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-武器类Weapon（不继承）"><a class="header-anchor" href="#步骤-2-武器类Weapon（不继承）">¶</a>步骤 <strong>2</strong> : 武器类Weapon（不继承）</h3>
<p>武器类： Weapon<strong>不继承Item</strong>的写法<br>
独立设计 name和price属性<br>
同时多了一个属性 damage 攻击力</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Weapon&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int price;</span><br><span class="line">    int damage; &#x2F;&#x2F;攻击力</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-武器类Weapon（继承类Item）"><a class="header-anchor" href="#步骤-3-武器类Weapon（继承类Item）">¶</a>步骤 <strong>3</strong> : 武器类Weapon（继承类Item）</h3>
<p>这一次Weapon<strong>继承Item</strong><br>
虽然Weapon自己没有设计name和price,但是通过继承Item类，也具备了name和price属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Weapon extends Item&#123;</span><br><span class="line">    int damage; &#x2F;&#x2F;攻击力</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Weapon infinityEdge &#x3D; new Weapon();</span><br><span class="line">        infinityEdge.damage &#x3D; 65; &#x2F;&#x2F;damage属性在类Weapon中新设计的</span><br><span class="line">         </span><br><span class="line">        infinityEdge.name &#x3D; &quot;无尽之刃&quot;;&#x2F;&#x2F;name属性，是从Item中继承来的，就不需要重复设计了</span><br><span class="line">        infinityEdge.price &#x3D; 3600;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-护甲"><a class="header-anchor" href="#步骤-4-练习-护甲">¶</a>步骤 <strong>4</strong> : 练习-护甲</h3>
<p>设计一个类Armor护甲<br>
继承Item类，并且额外提供一个属性ac: 护甲等级 int类型</p>
<p>实例化出两件护甲<br>
名称 价格 护甲等级<br>
布甲 300 15<br>
锁子甲 500 40</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Item1&#123;</span><br><span class="line">	public String name;</span><br><span class="line">	public int price;</span><br><span class="line">&#125;</span><br><span class="line">class Weapon extends Item1&#123;</span><br><span class="line">	public int grade;</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;名称:&quot;+name+&quot;\t&quot;+&quot;价格:&quot;+price+&quot; 等级:&quot;+grade;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Weapon A&#x3D;new Weapon();</span><br><span class="line">		A.name&#x3D;&quot;布甲&quot;;</span><br><span class="line">		A.price&#x3D;300;</span><br><span class="line">		A.grade&#x3D;15;</span><br><span class="line">		Weapon B&#x3D;new Weapon();</span><br><span class="line">		B.name&#x3D;&quot;锁子甲&quot;;</span><br><span class="line">		B.price&#x3D;500;</span><br><span class="line">		B.grade&#x3D;40;</span><br><span class="line">		System.out.println(A);</span><br><span class="line">		System.out.println(B);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	&#x2F;&#x2F;名称 价格 护甲等级布甲 300 15锁子甲 500 40</span><br></pre></td></tr></table></figure>
<h2 id="3、什么是JAVA-方法重载"><a class="header-anchor" href="#3、什么是JAVA-方法重载">¶</a>3、什么是JAVA 方法重载</h2>
<h3 id="步骤-1-attack方法的重载"><a class="header-anchor" href="#步骤-1-attack方法的重载">¶</a>步骤 <strong>1</strong> : attack方法的重载</h3>
<p>有一种英雄，叫做物理攻击英雄 ADHero<br>
为ADHero 提供三种方法</p>
<p>public void attack()</p>
<p>public void attack(Hero h1)</p>
<p>public void attack(Hero h1, Hero h2)</p>
<p>方法名是一样的，但是参数类型不一样<br>
在调用方法attack的时候，会根据传递的参数类型以及数量，自动调用对应的方法</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/590.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ADHero extends Hero &#123;</span><br><span class="line">    public void attack() &#123;</span><br><span class="line">        System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void attack(Hero h1) &#123;</span><br><span class="line">        System.out.println(name + &quot;对&quot; + h1.name + &quot;进行了一次攻击 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void attack(Hero h1, Hero h2) &#123;</span><br><span class="line">        System.out.println(name + &quot;同时对&quot; + h1.name + &quot;和&quot; + h2.name + &quot;进行了攻击 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero bh &#x3D; new ADHero();</span><br><span class="line">        bh.name &#x3D; &quot;赏金猎人&quot;;</span><br><span class="line"> </span><br><span class="line">        Hero h1 &#x3D; new Hero();</span><br><span class="line">        h1.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        Hero h2 &#x3D; new Hero();</span><br><span class="line">        h2.name &#x3D; &quot;提莫&quot;;</span><br><span class="line"> </span><br><span class="line">        bh.attack(h1);</span><br><span class="line">        bh.attack(h1, h2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-可变数量的参数"><a class="header-anchor" href="#步骤-2-可变数量的参数">¶</a>步骤 <strong>2</strong> : 可变数量的参数</h3>
<p>如果要攻击更多的英雄，就需要设计更多的方法，这样类会显得很累赘，像这样：</p>
<p>public void attack(Hero h1)</p>
<p>public void attack(Hero h1,Hero h2)</p>
<p>public void attack(Hero h1,Hero h2,Hero h3)</p>
<p>这时，可以采用可变数量的参数<br>
<strong>只需要设计一个方法</strong><br>
public void attack(Hero **…**heros)<br>
即可代表上述所有的方法了<br>
在方法里，使用操作数组的方式处理参数heros即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ADHero extends Hero &#123;</span><br><span class="line"> </span><br><span class="line">    public void attack() &#123;</span><br><span class="line">        System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 可变数量的参数</span><br><span class="line">    public void attack(Hero... heros) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; heros.length; i++) &#123;</span><br><span class="line">            System.out.println(name + &quot; 攻击了 &quot; + heros[i].name);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero bh &#x3D; new ADHero();</span><br><span class="line">        bh.name &#x3D; &quot;赏金猎人&quot;;</span><br><span class="line"> </span><br><span class="line">        Hero h1 &#x3D; new Hero();</span><br><span class="line">        h1.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        Hero h2 &#x3D; new Hero();</span><br><span class="line">        h2.name &#x3D; &quot;提莫&quot;;</span><br><span class="line"> </span><br><span class="line">        bh.attack(h1);</span><br><span class="line">        bh.attack(h1, h2);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-治疗"><a class="header-anchor" href="#步骤-3-练习-治疗">¶</a>步骤 <strong>3</strong> : 练习-治疗</h3>
<p>设计一个类Support (辅助英雄)继承Hero，提供一个heal(治疗)方法<br>
对Support的heal方法进行重载<br>
heal()<br>
heal(Hero h) //为指定的英雄加血<br>
heal(Hero h, int hp) //为指定的英雄加了hp的血</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Hero1&#123;</span><br><span class="line">	public String name;</span><br><span class="line">	public int hp;</span><br><span class="line">&#125;</span><br><span class="line">class Support extends Hero1&#123;</span><br><span class="line">	public void heal()&#123;</span><br><span class="line">		System.out.println(&quot;辅助英雄&quot;+name);</span><br><span class="line">	&#125;</span><br><span class="line">	public void heal(Hero1 h)&#123;</span><br><span class="line">		System.out.println(&quot;辅助英雄&quot;+name+&quot;为&quot;+h.name+&quot;加血&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void heal(Hero1 h,Hero1 p)&#123;</span><br><span class="line">		System.out.println(&quot;辅助英雄&quot;+name+&quot;为&quot;+h.name+&quot;加了&quot;+p.hp+&quot;血&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Support sp&#x3D;new Support();</span><br><span class="line">		sp.name&#x3D;&quot;猫咪&quot;;</span><br><span class="line"></span><br><span class="line">		Hero1 h1&#x3D;new Hero1();</span><br><span class="line">		h1.name&#x3D;&quot;路径&quot;;</span><br><span class="line">		Hero1 p&#x3D;new Hero1();</span><br><span class="line">		p.hp&#x3D;500;</span><br><span class="line"></span><br><span class="line">		sp.heal();</span><br><span class="line">		sp.heal(h1);</span><br><span class="line">		sp.heal(h1,p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、怎么使用-JAVA-构造方法？"><a class="header-anchor" href="#4、怎么使用-JAVA-构造方法？">¶</a>4、怎么使用 JAVA 构造方法？</h2>
<h3 id="步骤-1-什么是构造方法"><a class="header-anchor" href="#步骤-1-什么是构造方法">¶</a>步骤 <strong>1</strong> : 什么是构造方法</h3>
<p>方法名和类名一样（包括大小写）<br>
<strong>没有返回类型</strong><br>
实例化一个对象的时候，必然调用构造方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line"> </span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    float hp;</span><br><span class="line"> </span><br><span class="line">    float armor;</span><br><span class="line"> </span><br><span class="line">    int moveSpeed;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 方法名和类名一样（包括大小写）</span><br><span class="line">    &#x2F;&#x2F; 没有返回类型</span><br><span class="line">    public Hero() &#123;</span><br><span class="line">        System.out.println(&quot;实例化一个对象的时候，必然调用构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;实例化一个对象的时候，必然调用构造方法</span><br><span class="line">        Hero h &#x3D; new Hero();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-隐式的构造方法"><a class="header-anchor" href="#步骤-2-隐式的构造方法">¶</a>步骤 <strong>2</strong> : 隐式的构造方法</h3>
<p>Hero类的构造方法是</p>
<p>public Hero(){</p>
<p>}</p>
<p>这个无参的构造方法，如果不写，就会默认提供一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">     </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">     </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">     </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">     </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;这个无参的构造方法，如果不写，</span><br><span class="line">    &#x2F;&#x2F;就会默认提供一个无参的构造方法</span><br><span class="line">    &#x2F;&#x2F;  public Hero()&#123; </span><br><span class="line">    &#x2F;&#x2F;      System.out.println(&quot;调用Hero的构造方法&quot;);</span><br><span class="line">    &#x2F;&#x2F;  &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen &#x3D;  new Hero();</span><br><span class="line">        garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        garen.hp &#x3D; 616.28f;</span><br><span class="line">        garen.armor &#x3D; 27.536f;</span><br><span class="line">        garen.moveSpeed &#x3D; 350;</span><br><span class="line">         </span><br><span class="line">        Hero teemo &#x3D;  new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 383f;</span><br><span class="line">        teemo.armor &#x3D; 14f;</span><br><span class="line">        teemo.moveSpeed &#x3D; 330;</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-如果提供了一个有参的构造方法"><a class="header-anchor" href="#步骤-3-如果提供了一个有参的构造方法">¶</a>步骤 <strong>3</strong> : 如果提供了一个有参的构造方法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">      </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">      </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">      </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">      </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;有参的构造方法</span><br><span class="line">    &#x2F;&#x2F;默认的无参的构造方法就失效了</span><br><span class="line">    public Hero(String heroname)&#123; </span><br><span class="line">        name &#x3D; heroname;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen &#x3D;  new Hero(&quot;盖伦&quot;); </span><br><span class="line">          </span><br><span class="line">        Hero teemo &#x3D;  new Hero(); &#x2F;&#x2F;无参的构造方法“木有了”</span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-构造方法的重载"><a class="header-anchor" href="#步骤-4-构造方法的重载">¶</a>步骤 <strong>4</strong> : 构造方法的重载</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">       </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">       </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">       </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">       </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F;带一个参数的构造方法</span><br><span class="line">    public Hero(String heroname)&#123; </span><br><span class="line">        name &#x3D; heroname;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;带两个参数的构造方法</span><br><span class="line">    public Hero(String heroname,float herohp)&#123; </span><br><span class="line">        name &#x3D; heroname;</span><br><span class="line">        hp &#x3D; herohp;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen &#x3D;  new Hero(&quot;盖伦&quot;); </span><br><span class="line">        Hero teemo &#x3D;  new Hero(&quot;提莫&quot;,383);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-构造方法"><a class="header-anchor" href="#步骤-5-练习-构造方法">¶</a>步骤 <strong>5</strong> : 练习-构造方法</h3>
<p>为Hero设计4个参数的构造方法<br>
这四个参数分别是<br>
String heroName<br>
float heroHP<br>
float heroArmor<br>
int heroMoveSpeed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero1 &#123;</span><br><span class="line">    String Name;</span><br><span class="line">    float Hp;</span><br><span class="line">    float Armor;</span><br><span class="line">    int MoveSpeed;</span><br><span class="line">    public Hero1(String heroName,float heroHP,float heroArmor,int heroMoveSpeed)&#123;</span><br><span class="line">        Name &#x3D; heroName;</span><br><span class="line">        Hp &#x3D; heroHP;</span><br><span class="line">        Armor &#x3D; heroArmor;</span><br><span class="line">        MoveSpeed &#x3D; heroMoveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero1 ganlun &#x3D; new Hero1(&quot;盖伦&quot;,40,50,500);</span><br><span class="line">        System.out.print(ganlun.Name+&quot;的血量：&quot;+ganlun.Hp+&quot;,他的护甲：&quot;+ganlun.Armor+&quot;,他的移速：&quot;+ganlun.MoveSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、JAVA-中的THIS-是什么意思？"><a class="header-anchor" href="#5、JAVA-中的THIS-是什么意思？">¶</a>5、JAVA 中的THIS 是什么意思？</h2>
<h3 id="步骤-1-this代表当前对象"><a class="header-anchor" href="#步骤-1-this代表当前对象">¶</a>步骤 <strong>1</strong> : this代表当前对象</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">     </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">     </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">     </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">     </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;打印内存中的虚拟地址</span><br><span class="line">    public void showAddressInMemory()&#123;</span><br><span class="line">        System.out.println(&quot;打印this看到的虚拟地址：&quot;+this);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen &#x3D;  new Hero();</span><br><span class="line">        garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        &#x2F;&#x2F;直接打印对象，会显示该对象在内存中的虚拟地址</span><br><span class="line">        &#x2F;&#x2F;格式：Hero@c17164 c17164即虚拟地址，每次执行，得到的地址不一定一样</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;打印对象看到的虚拟地址：&quot;+garen);</span><br><span class="line">        &#x2F;&#x2F;调用showAddressInMemory，打印该对象的this，显示相同的虚拟地址</span><br><span class="line">        garen.showAddressInMemory();</span><br><span class="line">         </span><br><span class="line">        Hero teemo &#x3D;  new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        System.out.println(&quot;打印对象看到的虚拟地址：&quot;+teemo);</span><br><span class="line">        teemo.showAddressInMemory();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/597.png" alt></p>
<h3 id="步骤-2-通过this访问属性"><a class="header-anchor" href="#步骤-2-通过this访问属性">¶</a>步骤 <strong>2</strong> : 通过this访问属性</h3>
<p>通过this关键字访问对象的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">     </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">     </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">     </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">     </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;参数名和属性名一样</span><br><span class="line">    &#x2F;&#x2F;在方法体中，只能访问到参数name</span><br><span class="line">    public void setName1(String name)&#123;</span><br><span class="line">        name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;为了避免setName1中的问题，参数名不得不使用其他变量名</span><br><span class="line">    public void setName2(String heroName)&#123;</span><br><span class="line">        name &#x3D; heroName;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;通过this访问属性</span><br><span class="line">    public void setName3(String name)&#123;</span><br><span class="line">        &#x2F;&#x2F;name代表的是参数name</span><br><span class="line">        &#x2F;&#x2F;this.name代表的是属性name</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero  h &#x3D;new Hero();</span><br><span class="line">         </span><br><span class="line">        h.setName1(&quot;teemo&quot;);</span><br><span class="line">        System.out.println(h.name);</span><br><span class="line">         </span><br><span class="line">        h.setName2(&quot;garen&quot;);</span><br><span class="line">        System.out.println(h.name);    </span><br><span class="line">         </span><br><span class="line">        h.setName3(&quot;死歌&quot;);</span><br><span class="line">        System.out.println(h.name);    </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">garen</span><br><span class="line">死歌</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-通过this调用其他的构造方法"><a class="header-anchor" href="#步骤-3-通过this调用其他的构造方法">¶</a>步骤 <strong>3</strong> : 通过this调用其他的构造方法</h3>
<p>如果要在一个构造方法中，调用另一个构造方法，可以使用this()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F;带一个参数的构造方法</span><br><span class="line">    public Hero(String name)&#123;</span><br><span class="line">        System.out.println(&quot;一个参数的构造方法&quot;);</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;带两个参数的构造方法</span><br><span class="line">    public Hero(String name,float hp)&#123;</span><br><span class="line">        this(name);</span><br><span class="line">        System.out.println(&quot;两个参数的构造方法&quot;);</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero teemo &#x3D;  new Hero(&quot;提莫&quot;,383);</span><br><span class="line">         </span><br><span class="line">        System.out.println(teemo.name);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个参数的构造方法</span><br><span class="line">两个参数的构造方法</span><br><span class="line">提莫</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-构造方法-this"><a class="header-anchor" href="#步骤-4-练习-构造方法-this">¶</a>步骤 <strong>4</strong> : 练习-构造方法(this)</h3>
<p>参考[练习-构造方法]设计一个构造方法,但是参数名称不太一样，分别是<br>
String name<br>
float hp<br>
float armor<br>
int moveSpeed</p>
<p>不仅如此，在这个构造方法中，调用这个构造方法</p>
<p>public Hero(String name,float hp)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">	String name; &#x2F;&#x2F;姓名</span><br><span class="line"></span><br><span class="line">	float hp; &#x2F;&#x2F;血量</span><br><span class="line"></span><br><span class="line">	float armor; &#x2F;&#x2F;护甲</span><br><span class="line"></span><br><span class="line">	int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">	public Hero(String name,float hp, float armor,int moveSpeed) &#123;</span><br><span class="line">		this.name&#x3D;name;</span><br><span class="line">		this.hp&#x3D;hp;</span><br><span class="line">		this.armor&#x3D;armor;</span><br><span class="line">		this.moveSpeed&#x3D;moveSpeed;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[]args) &#123;</span><br><span class="line">		Hero teemo &#x3D; new Hero(&quot;提莫&quot;,56.4f,67.5f,77);</span><br><span class="line">		System.out.println(teemo);</span><br><span class="line">		System.out.println(teemo.name+&quot;,&quot;+teemo.hp+&quot;,&quot;+teemo.armor+&quot;,&quot;+teemo.moveSpeed);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、JAVA中的传参详解"><a class="header-anchor" href="#6、JAVA中的传参详解">¶</a>6、JAVA中的传参详解</h2>
<h3 id="步骤-1-基本类型传参"><a class="header-anchor" href="#步骤-1-基本类型传参">¶</a>步骤 <strong>1</strong> : 基本类型传参</h3>
<p>基本类型传参<br>
在方法内，无法修改方法外的基本类型参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;回血</span><br><span class="line">    public void huixue(int xp)&#123;</span><br><span class="line">        hp &#x3D; hp + xp;</span><br><span class="line">        &#x2F;&#x2F;回血完毕后，血瓶&#x3D;0</span><br><span class="line">        xp&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public Hero(String name,float hp)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero teemo &#x3D;  new Hero(&quot;提莫&quot;,383);</span><br><span class="line">        &#x2F;&#x2F;血瓶，其值是100</span><br><span class="line">        int xueping &#x3D; 100;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;提莫通过这个血瓶回血</span><br><span class="line">         </span><br><span class="line">        teemo.huixue(xueping);</span><br><span class="line">         </span><br><span class="line">        System.out.println(xueping);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;&#x2F;&#x2F;100</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-引用与"><a class="header-anchor" href="#步骤-2-引用与">¶</a>步骤 <strong>2</strong> : 引用与=</h3>
<p>如果一个变量是基本类型<br>
比如 int hp = 50;<br>
我们就直接管hp叫变量<br>
<strong>=表示赋值的意思</strong>。<br>
如果一个变量是类类型<br>
比如 Hero h = new Hero();<br>
我们就管h叫做<strong>引用</strong>。<br>
<strong>=不再是赋值的意思</strong><br>
<strong>=表示指向的意思</strong><br>
比如 Hero h = new Hero();<br>
这句话的意思是<br>
引用h，指向一个Hero对象</p>
<h3 id="步骤-3-类类型传参"><a class="header-anchor" href="#步骤-3-类类型传参">¶</a>步骤 <strong>3</strong> : 类类型传参</h3>
<p><strong>类类型又叫引用</strong><br>
第24行的引用 <strong>teemo</strong>与 第17行的引用<strong>hero</strong>，<strong>是不同的引用</strong><br>
通过调用garen.attack(teemo, 100); 使得这<strong>两个引用都指向了同一个对象</strong><br>
所以在第18行hero.hp = hero.hp - damage; 就使得该对象的hp值，发生了变化<br>
因此第25行，打印该对象的Hp值就是变化后的值</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/595.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line"> </span><br><span class="line">    String name; &#x2F;&#x2F; 姓名</span><br><span class="line"> </span><br><span class="line">    float hp; &#x2F;&#x2F; 血量</span><br><span class="line"> </span><br><span class="line">    float armor; &#x2F;&#x2F; 护甲</span><br><span class="line"> </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F; 移动速度</span><br><span class="line"> </span><br><span class="line">    public Hero(String name, float hp) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 攻击一个英雄，并让他掉damage点血</span><br><span class="line">    public void attack(Hero hero, int damage) &#123;</span><br><span class="line">        hero.hp &#x3D; hero.hp - damage;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero teemo &#x3D; new Hero(&quot;提莫&quot;, 383);</span><br><span class="line">        Hero garen &#x3D; new Hero(&quot;盖伦&quot;, 616);</span><br><span class="line">        garen.attack(teemo, 100);</span><br><span class="line">        System.out.println(teemo.hp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;&#x2F;&#x2F;283.0</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-传参"><a class="header-anchor" href="#步骤-4-练习-传参">¶</a>步骤 <strong>4</strong> :练习-传参</h3>
<p>在方法中，使参数引用指向一个新的对象</p>
<p>外面的引用是指向原来的对象？还是新的对象？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero(String name,float hp)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;复活</span><br><span class="line">    public void revive(Hero h)&#123;</span><br><span class="line">        h &#x3D; new Hero(&quot;提莫&quot;,383);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero teemo &#x3D;  new Hero(&quot;提莫&quot;,383);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;受到400伤害，挂了</span><br><span class="line">        teemo.hp &#x3D; teemo.hp - 400;</span><br><span class="line">         </span><br><span class="line">        teemo.revive(teemo);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;问题： System.out.println(teemo.hp); 输出多少？ 怎么理解？</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-17.0</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Hero revive(Hero h)&#123;</span><br><span class="line">        return  h &#x3D; new Hero(&quot;提莫&quot;,383);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero teemo &#x3D;  new Hero(&quot;提莫&quot;,383);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;受到400伤害，挂了</span><br><span class="line">        teemo.hp &#x3D; teemo.hp - 400;</span><br><span class="line">          </span><br><span class="line">        teemo &#x3D; teemo.revive(teemo);</span><br><span class="line">          </span><br><span class="line">         System.out.println(teemo.hp); &#x2F;&#x2F;输出多少？ 怎么理解？</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">383.0</span><br></pre></td></tr></table></figure>
<h2 id="7、JAVA中的包-PACKAGE"><a class="header-anchor" href="#7、JAVA中的包-PACKAGE">¶</a>7、JAVA中的包 PACKAGE</h2>
<h3 id="步骤-1-把比较接近的类，规划在同一个包下"><a class="header-anchor" href="#步骤-1-把比较接近的类，规划在同一个包下">¶</a>步骤 <strong>1</strong> : 把比较接近的类，规划在同一个包下</h3>
<p>Hero,ADHero 规划在一个包，叫做charactor（角色）<br>
Item,Weapon规划在另一个包下，叫做 property(道具)<br>
在最开始的地方声明该类所处于的包名</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/600.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor; &#x2F;&#x2F;在最开始的地方声明该类所处于的包名</span><br><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-使用其他包下的类，必须import"><a class="header-anchor" href="#步骤-2-使用其他包下的类，必须import">¶</a>步骤 <strong>2</strong> : 使用其他包下的类，必须import</h3>
<p>使用同一个包下的其他类，直接使用即可<br>
但是要使用其他包下的类，必须import</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;Weapon类在其他包里，使用必须进行import</span><br><span class="line">import property.Weapon;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;装备一把武器</span><br><span class="line">    public void equip(Weapon w)&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、JAVA的四种访问修饰符"><a class="header-anchor" href="#8、JAVA的四种访问修饰符">¶</a>8、JAVA的四种访问修饰符</h2>
<h3 id="示例-1-类之间的关系"><a class="header-anchor" href="#示例-1-类之间的关系">¶</a>示例 <strong>1</strong> : 类之间的关系</h3>
<p>类和类之间的关系有如下几种:<br>
以Hero为例<br>
<strong>自身：<strong>指的是Hero自己<br>
<strong>同包子类：<strong>ADHero这个类是Hero的子类，并且和Hero处于</strong>同一个包下</strong><br>
<strong>不同包子类：<strong>Support这个类是Hero的子类，但是在</strong>另一个包下</strong><br>
<strong>同包类：</strong> GiantDragon 这个类和Hero是</strong>同一个包</strong>，但是彼此<strong>没有继承关系</strong><br>
**其他类：**Item这个类，<strong>在不同包</strong>，也没有继承关系的类</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/605.png" alt></p>
<h3 id="示例-2-private-私有的"><a class="header-anchor" href="#示例-2-private-私有的">¶</a>示例 <strong>2</strong> : private 私有的</h3>
<p>使用private修饰属性<br>
自身：是可以访问的<br>
同包子类：不能继承<br>
不同包子类：不能继承<br>
同包类：不能访问<br>
其他包类：不能访问</p>
<p><strong>注：</strong> 红色字体，表示不可行</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/604.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Weapon;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;属性id是private的，只有Hero自己可以访问</span><br><span class="line">    &#x2F;&#x2F;子类不能继承</span><br><span class="line">    &#x2F;&#x2F;其他类也不能访问</span><br><span class="line">    private int id;</span><br><span class="line">     </span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    float hp;</span><br><span class="line"> </span><br><span class="line">    float armor;</span><br><span class="line"> </span><br><span class="line">    int moveSpeed;</span><br><span class="line"> </span><br><span class="line">    public void equip(Weapon w) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-package-friendly-default-不写"><a class="header-anchor" href="#示例-3-package-friendly-default-不写">¶</a>示例 <strong>3</strong> : package/friendly/default 不写</h3>
<p>没有修饰符即代表package/friendly/default<br>
float maxHP; 血量上限</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/609.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Weapon;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    private int id;</span><br><span class="line"> </span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 无修饰符的属性 hp</span><br><span class="line">    &#x2F;&#x2F; 自己可以访问</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 同包子类可以继承</span><br><span class="line">    &#x2F;&#x2F; 不同包子类不能继承</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 同包类可以访问</span><br><span class="line">    &#x2F;&#x2F; 不同包类不能访问</span><br><span class="line">    float hp;</span><br><span class="line"> </span><br><span class="line">    float armor;</span><br><span class="line"> </span><br><span class="line">    int moveSpeed;</span><br><span class="line"> </span><br><span class="line">    public void equip(Weapon w) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-protected-受保护的"><a class="header-anchor" href="#示例-4-protected-受保护的">¶</a>示例 <strong>4</strong> : protected 受保护的</h3>
<p>受保护的修饰符<br>
protected float hp; 血量</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/610.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Weapon;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    private int id;</span><br><span class="line"> </span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; protected饰符的属性 hp</span><br><span class="line">    &#x2F;&#x2F; 自己可以访问</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 同包子类可以继承</span><br><span class="line">    &#x2F;&#x2F; 不同包子类可以继承</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 同包类可以访问</span><br><span class="line">    &#x2F;&#x2F; 不同包类不能访问</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    float armor;</span><br><span class="line"> </span><br><span class="line">    int moveSpeed;</span><br><span class="line"> </span><br><span class="line">    public void equip(Weapon w) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-public-公共的"><a class="header-anchor" href="#示例-5-public-公共的">¶</a>示例 <strong>5</strong> :public 公共的</h3>
<p>公共的修饰符<br>
public String name; 姓名<br>
任何地方，都可以访问</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/611.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Weapon;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    private int id;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; public的属性 name</span><br><span class="line">    &#x2F;&#x2F; 自己可以访问</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 同包子类可以继承</span><br><span class="line">    &#x2F;&#x2F; 不同包子类可以继承</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 同包类可以访问</span><br><span class="line">    &#x2F;&#x2F; 不同包类可以访问</span><br><span class="line">    public String name;</span><br><span class="line"> </span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    float armor;</span><br><span class="line"> </span><br><span class="line">    int moveSpeed;</span><br><span class="line"> </span><br><span class="line">    public void equip(Weapon w) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-总结"><a class="header-anchor" href="#示例-6-总结">¶</a>示例 <strong>6</strong> : 总结</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/612.png" alt></p>
<h3 id="示例-7-那么什么情况该用什么修饰符呢？"><a class="header-anchor" href="#示例-7-那么什么情况该用什么修饰符呢？">¶</a>示例 <strong>7</strong> : 那么什么情况该用什么修饰符呢？</h3>
<p>那么什么情况该用什么修饰符呢？<br>
从作用域来看，public能够使用所有的情况。 但是大家在工作的时候，又不会真正全部都使用public,那么到底什么情况该用什么修饰符呢？</p>
<ol>
<li>
<p>属性通常使用private封装起来</p>
</li>
<li>
<p>方法一般使用public用于被调用</p>
</li>
<li>
<p>会被子类继承的方法，通常使用protected</p>
</li>
<li>
<p>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</p>
</li>
</ol>
<p>再就是<strong>作用范围最小原则</strong><br>
简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。 这样就能把数据尽量的封装起来，没有必要<strong>露出来的</strong>，就不用<strong>露出来</strong>了</p>
<h2 id="9、JAVA的类属性，静态属性"><a class="header-anchor" href="#9、JAVA的类属性，静态属性">¶</a>9、JAVA的类属性，静态属性</h2>
<h3 id="步骤-1-类属性"><a class="header-anchor" href="#步骤-1-类属性">¶</a>步骤 <strong>1</strong> : 类属性</h3>
<p><strong>类属性：</strong> 又叫做静态属性<br>
<strong>对象属性：</strong> 又叫实例属性，非静态属性<br>
如果一个属性声明成类属性，那么所有的对象，都共享这么一个值<br>
给英雄设置一个类属性叫做“版权&quot; (copyright), 无论有多少个具体的英雄，所有的英雄的版权都属于 Riot Games公司。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name; &#x2F;&#x2F;实例属性，对象属性，非静态属性</span><br><span class="line">    protected float hp;</span><br><span class="line">    static String copyright;&#x2F;&#x2F;类属性,静态属性</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           Hero garen &#x3D;  new Hero();</span><br><span class="line">           garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">            </span><br><span class="line">           Hero.copyright &#x3D; &quot;版权由Riot Games公司所有&quot;;</span><br><span class="line">            </span><br><span class="line">           System.out.println(garen.name);</span><br><span class="line">           System.out.println(garen.copyright);</span><br><span class="line">            </span><br><span class="line">           Hero teemo &#x3D;  new Hero();</span><br><span class="line">           teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">           System.out.println(teemo.name);    </span><br><span class="line">           System.out.println(teemo.copyright);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">盖伦</span><br><span class="line">版权由Riot Games公司所有</span><br><span class="line">提莫</span><br><span class="line">版权由Riot Games公司所有</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-访问类属性"><a class="header-anchor" href="#步骤-2-访问类属性">¶</a>步骤 <strong>2</strong> : 访问类属性</h3>
<p>访问类属性有两种方式</p>
<ol>
<li>对象.类属性</li>
</ol>
<p>teemo.copyright</p>
<ol start="2">
<li>类.类属性</li>
</ol>
<p>Hero.copyright</p>
<p>这两种方式都可以访问类属性，访问即修改和获取，但是建议使用第二种 <strong>类.类属性</strong> 的方式进行，这样更符合语义上的理解</p>
<h3 id="步骤-3-什么时候使用对象属性，什么时候使用类属性"><a class="header-anchor" href="#步骤-3-什么时候使用对象属性，什么时候使用类属性">¶</a>步骤 <strong>3</strong> : 什么时候使用对象属性，什么时候使用类属性</h3>
<p>如果一个属性，每个英雄都不一样，比如name，这样的属性就应该设计为对象属性，因为它是<strong>跟着对象走的</strong>，每个对象的name都是不同的</p>
<p>如果一个属性，<strong>所有的英雄都共享</strong>，都是一样的，那么就应该设计为类属性。比如血量上限，所有的英雄的血量上限都是 9999，不会因为英雄不同，而取不同的值。 这样的属性，就适合设计为类属性</p>
<h3 id="步骤-4-练习-类属性"><a class="header-anchor" href="#步骤-4-练习-类属性">¶</a>步骤 <strong>4</strong> : 练习-类属性</h3>
<p>通过garen.copyright修改其值</p>
<p>garen.copyright = “Blizzard Entertainment Enterprise”;</p>
<p>然后打印teemo.copyright，观察是否有变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">	public String name; &#x2F;&#x2F;实例属性，对象属性，非静态属性</span><br><span class="line">	protected float hp;</span><br><span class="line">	static String copyright;&#x2F;&#x2F;类属性,静态属性</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">			Hero garen &#x3D; new Hero();</span><br><span class="line">			garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line"></span><br><span class="line">			Hero.copyright &#x3D; &quot;版权由Riot Games公司所有&quot;;</span><br><span class="line"></span><br><span class="line">			System.out.println(garen.name);</span><br><span class="line">			System.out.println(garen.copyright);</span><br><span class="line"></span><br><span class="line">			garen.copyright &#x3D; &quot;Blizzard Entertainment Enterprise&quot;; &#x2F;&#x2F;这里修改的是类属性，是所有对象共有的，所以修改过后</span><br><span class="line">&#x2F;&#x2F;teemo.copyright会改变</span><br><span class="line">			Hero teemo &#x3D; new Hero();</span><br><span class="line">			teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">			System.out.println(teemo.name);</span><br><span class="line">			System.out.println(teemo.copyright);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">盖伦</span><br><span class="line">版权由Riot Games公司所有</span><br><span class="line">提莫</span><br><span class="line">Blizzard Entertainment Enterprise</span><br></pre></td></tr></table></figure>
<h2 id="10、JAVA的类方法，静态方法"><a class="header-anchor" href="#10、JAVA的类方法，静态方法">¶</a>10、JAVA的类方法，静态方法</h2>
<h3 id="步骤-1-类方法"><a class="header-anchor" href="#步骤-1-类方法">¶</a>步骤 <strong>1</strong> : 类方法</h3>
<p><strong>类方法：</strong> 又叫做静态方法</p>
<p><strong>对象方法：</strong> 又叫实例方法，非静态方法</p>
<p>访问一个对象方法，必须<strong>建立在有一个对象</strong>的前提的基础上<br>
访问类方法，<strong>不需要对象</strong>的存在，直接就访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;实例方法,对象方法，非静态方法</span><br><span class="line">    &#x2F;&#x2F;必须有对象才能够调用</span><br><span class="line">    public void die()&#123;</span><br><span class="line">        hp &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;类方法，静态方法</span><br><span class="line">    &#x2F;&#x2F;通过类就可以直接调用</span><br><span class="line">    public static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;battle win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           Hero garen &#x3D;  new Hero();</span><br><span class="line">           garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">           &#x2F;&#x2F;必须有一个对象才能调用</span><br><span class="line">           garen.die();</span><br><span class="line">            </span><br><span class="line">           Hero teemo &#x3D;  new Hero();</span><br><span class="line">           teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">            </span><br><span class="line">           &#x2F;&#x2F;无需对象，直接通过类调用</span><br><span class="line">           Hero.battleWin();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-调用类方法"><a class="header-anchor" href="#步骤-2-调用类方法">¶</a>步骤 <strong>2</strong> : 调用类方法</h3>
<p>和[访问类属性]一样，调用类方法也有两种方式</p>
<ol>
<li>对象.类方法</li>
</ol>
<p>garen.battleWin();</p>
<ol start="2">
<li>类.类方法</li>
</ol>
<p>Hero.battleWin();</p>
<p>这两种方式都可以调用类方法，但是建议使用第二种 类.类方法 的方式进行，这样更符合语义上的理解。<br>
并且在很多时候，并没有实例，比如在前面练习的时候用到的[随机数的获取办法]</p>
<p>Math.random()</p>
<p>random()就是一个类方法，直接通过类Math进行调用，并没有一个Math的实例存在。</p>
<h3 id="步骤-3-什么时候设计对象方法，什么时候设计类方法"><a class="header-anchor" href="#步骤-3-什么时候设计对象方法，什么时候设计类方法">¶</a>步骤 <strong>3</strong> : 什么时候设计对象方法，什么时候设计类方法</h3>
<p>如果在某一个方法里，调用了对象属性，比如</p>
<p>​    public String getName(){</p>
<p>​    	return name;</p>
<p>​    }</p>
<p>name属性是对象属性，只有存在一个具体对象的时候，name才有意义。 如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法</p>
<p>如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法，比如</p>
<p>​    public static void printGameDuration(){</p>
<p>​    	System.out.println(“已经玩了10分50秒”);</p>
<p>​    }</p>
<p>printGameDuration 打印当前玩了多长时间了，不和某一个具体的英雄关联起来，所有的英雄都是一样的。 这样的方法，更带有<strong>功能性</strong>色彩<br>
就像取随机数一样，random()是一个功能用途的方法</p>
<p>Math.random()</p>
<h3 id="步骤-4-练习-类方法"><a class="header-anchor" href="#步骤-4-练习-类方法">¶</a>步骤 <strong>4</strong> : 练习-类方法</h3>
<p>在一个类方法中，直接调用一个对象方法，<br>
比如在battleWin中调用die()<br>
能否直接调用？ 为什么？</p>
<p>不可以，因为静态方法是不需要实例化，非静态方法是必须实例化的。</p>
<h2 id="11、如何进行JAVA的属性初始化"><a class="header-anchor" href="#11、如何进行JAVA的属性初始化">¶</a>11、如何进行JAVA的属性初始化</h2>
<h3 id="步骤-1-对象属性初始化"><a class="header-anchor" href="#步骤-1-对象属性初始化">¶</a>步骤 <strong>1</strong> : 对象属性初始化</h3>
<p>对象属性初始化有3种</p>
<ol>
<li>
<p>声明该属性的时候初始化</p>
</li>
<li>
<p>构造方法中初始化</p>
</li>
<li>
<p>初始化块</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name &#x3D; &quot;some hero&quot;; &#x2F;&#x2F;声明该属性的时候初始化</span><br><span class="line">    protected float hp;</span><br><span class="line">    float maxHP;</span><br><span class="line">     </span><br><span class="line">    &#123;</span><br><span class="line">        maxHP &#x3D; 200; &#x2F;&#x2F;初始化块</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        hp &#x3D; 100; &#x2F;&#x2F;构造方法中初始化</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-类属性初始化"><a class="header-anchor" href="#步骤-2-类属性初始化">¶</a>步骤 <strong>2</strong> : 类属性初始化</h3>
<p>类属性初始化有2种</p>
<ol>
<li>
<p>声明该属性的时候初始化</p>
</li>
<li>
<p>静态初始化块</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">    float maxHP;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;物品栏的容量</span><br><span class="line">    public static int itemCapacity&#x3D;8; &#x2F;&#x2F;声明的时候 初始化</span><br><span class="line">     </span><br><span class="line">    static&#123;</span><br><span class="line">        itemCapacity &#x3D; 6;&#x2F;&#x2F;静态初始化块 初始化</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Hero.itemCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-属性初始化"><a class="header-anchor" href="#步骤-3-练习-属性初始化">¶</a>步骤 <strong>3</strong> : 练习-属性初始化</h3>
<p>对象属性的初始化有三种方式<br>
故意把初始化块，放在构造方法下面，问题：</p>
<p>这三种方式，谁先执行？谁后执行？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name &#x3D; &quot;some hero&quot;; </span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        name &#x3D; &quot;one hero&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        name &#x3D; &quot;the hero&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.先所有数据域被初始化为默认值</span><br><span class="line">b.按照在类声明中出现的次序,依次执行所有域初始化语句和初始化块</span><br><span class="line">c.如果构造器第一行调用了第二个构造器(子类默认调用父类的无参构造函数super,this),则执行第二个构造器主体.</span><br><span class="line">d.执行这个构造器的主体</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">属性初始化顺序</span><br><span class="line">属性声明</span><br><span class="line">初始化块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure>
<h2 id="12、怎么写一个JAVA的饿汉式与懒汉式单例模式"><a class="header-anchor" href="#12、怎么写一个JAVA的饿汉式与懒汉式单例模式">¶</a>12、怎么写一个JAVA的饿汉式与懒汉式单例模式</h2>
<h3 id="步骤-1-单例模式"><a class="header-anchor" href="#步骤-1-单例模式">¶</a>步骤 <strong>1</strong> : 单例模式</h3>
<p>单例模式又叫做 Singleton模式，指的是一个类，在一个JVM里，只有一个实例存在。</p>
<h3 id="步骤-2-饿汉式单例模式"><a class="header-anchor" href="#步骤-2-饿汉式单例模式">¶</a>步骤 <strong>2</strong> : 饿汉式单例模式</h3>
<p>GiantDragon 应该只有一只，通过私有化其构造方法，使得外部无法通过new 得到新的实例。<br>
GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。 从而达到单例的目的。<br>
这种单例模式又叫做<strong>饿汉式</strong>单例模式，无论如何都会创建一个实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;GiantDragon.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class GiantDragon &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span><br><span class="line"> </span><br><span class="line">    private static GiantDragon instance &#x3D; new GiantDragon();</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;public static 方法，提供给调用者获取12行定义的对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;TestGiantDragon.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class TestGiantDragon &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;通过new实例化会报错</span><br><span class="line">&#x2F;&#x2F;      GiantDragon g &#x3D; new GiantDragon();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;只能通过getInstance得到对象</span><br><span class="line">         </span><br><span class="line">        GiantDragon g1 &#x3D; GiantDragon.getInstance();</span><br><span class="line">        GiantDragon g2 &#x3D; GiantDragon.getInstance();</span><br><span class="line">        GiantDragon g3 &#x3D; GiantDragon.getInstance();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;都是同一个对象</span><br><span class="line">        System.out.println(g1&#x3D;&#x3D;g2);</span><br><span class="line">        System.out.println(g1&#x3D;&#x3D;g3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-懒汉式单例模式"><a class="header-anchor" href="#步骤-3-懒汉式单例模式">¶</a>步骤 <strong>3</strong> : 懒汉式单例模式</h3>
<p><strong>懒汉式</strong>单例模式与<strong>饿汉式</strong>单例模式不同，只有在调用getInstance的时候，才会创建实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class GiantDragon &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span><br><span class="line">    private static GiantDragon instance;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;public static 方法，返回实例对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        &#x2F;&#x2F;第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span><br><span class="line">        if(null&#x3D;&#x3D;instance)&#123;</span><br><span class="line">            instance &#x3D; new GiantDragon();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回 instance指向的对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class TestGiantDragon &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;通过new实例化会报错</span><br><span class="line">&#x2F;&#x2F;      GiantDragon g &#x3D; new GiantDragon();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;只能通过getInstance得到对象</span><br><span class="line">         </span><br><span class="line">        GiantDragon g1 &#x3D; GiantDragon.getInstance();</span><br><span class="line">        GiantDragon g2 &#x3D; GiantDragon.getInstance();</span><br><span class="line">        GiantDragon g3 &#x3D; GiantDragon.getInstance();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;都是同一个对象</span><br><span class="line">        System.out.println(g1&#x3D;&#x3D;g2);</span><br><span class="line">        System.out.println(g1&#x3D;&#x3D;g3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-什么时候使用饿汉式，什么时候使用懒汉式"><a class="header-anchor" href="#步骤-4-什么时候使用饿汉式，什么时候使用懒汉式">¶</a>步骤 <strong>4</strong> :什么时候使用饿汉式，什么时候使用懒汉式</h3>
<p><strong>饿汉式</strong>是立即加载的方式，无论是否会用到这个对象，都会加载。<br>
如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</p>
<p><strong>懒汉式</strong>，是延迟加载的方式，只有使用的时候才会加载。 并且有[线程安全]的考量(鉴于同学们学习的进度，暂时不对线程的章节做展开)。</p>
<p>使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。</p>
<p>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式</p>
<h3 id="步骤-5-单例模式三元素"><a class="header-anchor" href="#步骤-5-单例模式三元素">¶</a>步骤 <strong>5</strong> : 单例模式三元素</h3>
<p>这个是面试的时候经常会考的点，面试题通常的问法是:</p>
<p>什么是单例模式？</p>
<p>回答的时候，要答到三元素</p>
<ol>
<li>
<p>构造方法私有化</p>
</li>
<li>
<p>静态属性指向实例</p>
</li>
<li>
<p>public static的 getInstance方法，返回第二步的静态属性</p>
</li>
</ol>
<h3 id="步骤-6-练习-单例模式"><a class="header-anchor" href="#步骤-6-练习-单例模式">¶</a>步骤 <strong>6</strong> : 练习-单例模式</h3>
<p>使用饿汉式单例模式, 把Hero类改造成为单例模式</p>
<p>使用懒汉式单例模式，把Item类改造成为单例模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;饿汉式</span><br><span class="line">public class Hero &#123;</span><br><span class="line">    private Hero() &#123;    &#x2F;&#x2F;私有化构造方法</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    private static Hero instance &#x3D; new Hero();  &#x2F;&#x2F;私有化一个类属性指向实例对象（并且共用这一个）</span><br><span class="line">     </span><br><span class="line">    public static Hero getInstance() &#123;          &#x2F;&#x2F;提供公共的getInstance方法</span><br><span class="line">        return instance;                        &#x2F;&#x2F;返回实例对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;懒汉式</span><br><span class="line">public class Hero &#123;</span><br><span class="line">    private Hero() &#123;    &#x2F;&#x2F;私有化构造方法</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    private static Hero instance;               &#x2F;&#x2F;私有化一个类属性声明实例对象（但是占时不创建）</span><br><span class="line">     </span><br><span class="line">    public static Hero getInstance() &#123;          &#x2F;&#x2F;提供公共的getInstance方法</span><br><span class="line">        if(instance&#x3D;&#x3D;null)&#123;                     &#x2F;&#x2F;如果没有创建对象，则执行</span><br><span class="line">            instance &#x3D; new Hero();              &#x2F;&#x2F;创建一个Hero的对象用instance引用</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;                        &#x2F;&#x2F;返回实例对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13、枚举类型"><a class="header-anchor" href="#13、枚举类型">¶</a>13、枚举类型</h2>
<h3 id="步骤-1-预先定义的常量"><a class="header-anchor" href="#步骤-1-预先定义的常量">¶</a>步骤 <strong>1</strong> : 预先定义的常量</h3>
<p>枚举enum是一种特殊的类(还是类)，使用枚举可以很方便的定义常量<br>
比如设计一个枚举类型 季节，里面有4种常量</p>
<p>public enum Season {</p>
<p>​	SPRING,SUMMER,AUTUMN,WINTER</p>
<p>}</p>
<p>一个常用的场合就是[switch]语句中，使用枚举来进行判断</p>
<p>**注：**因为是常量，所以一般都是全大写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;HelloWorld.java</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Season season &#x3D; Season.SPRING;</span><br><span class="line">        switch (season) &#123;</span><br><span class="line">        case SPRING:</span><br><span class="line">            System.out.println(&quot;春天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case SUMMER:</span><br><span class="line">            System.out.println(&quot;夏天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case AUTUMN:</span><br><span class="line">            System.out.println(&quot;秋天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case WINTER:</span><br><span class="line">            System.out.println(&quot;冬天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Season.java</span><br><span class="line">public enum Season &#123;</span><br><span class="line">    SPRING,SUMMER,AUTUMN,WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">春天</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-使用枚举的好处"><a class="header-anchor" href="#步骤-2-使用枚举的好处">¶</a>步骤 <strong>2</strong> : 使用枚举的好处</h3>
<p>假设在使用[switch]的时候，不是使用枚举，而是使用int，而int的取值范围就不只是1-4，有可能取一个超出1-4之间的值，这样判断结果就似是而非了。（因为只有4个季节）</p>
<p>但是使用枚举，就能把范围死死的限定在这四个当中</p>
<p>SPRING,SUMMER,AUTUMN,WINTER</p>
<p>而不会出现奇怪的 <strong>第5季</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int season &#x3D; 5;</span><br><span class="line">        switch (season) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            System.out.println(&quot;春天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            System.out.println(&quot;夏天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            System.out.println(&quot;秋天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            System.out.println(&quot;冬天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-遍历枚举"><a class="header-anchor" href="#步骤-3-遍历枚举">¶</a>步骤 <strong>3</strong> : 遍历枚举</h3>
<p>借助[增强型for循环]，可以很方便的遍历一个枚举都有哪些常量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Season s : Season.values()) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-枚举"><a class="header-anchor" href="#步骤-4-练习-枚举">¶</a>步骤 <strong>4</strong> : 练习-枚举</h3>
<p>英雄联盟中有这么一些分类<br>
TANK (坦克)<br>
WIZARD (法师 )<br>
ASSASSIN (刺客)<br>
ASSIST (辅助)<br>
WARRIOR (近战)<br>
RANGED (远程 )<br>
PUSH (推进)<br>
FARMING (打野)<br>
设计一个枚举类型HeroType,使用上述分类作为常量</p>
<p>再编写一段switch语句，把每种枚举常量输出为中文字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum HeroType &#123;</span><br><span class="line">    TANK,WIZARD,ASSASSIN,ASSIST,WARRIOR,RANGED,PUSH,FARMING</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestHero &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (HeroType a : HeroType.values()) &#123;</span><br><span class="line">            System.out.print(a+&quot;&#x3D;&quot;);</span><br><span class="line">            switch (a) &#123;</span><br><span class="line">            case TANK :</span><br><span class="line">                System.out.println(&quot;坦克&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case WIZARD  :</span><br><span class="line">                System.out.println(&quot;法师&quot; );</span><br><span class="line">                break;</span><br><span class="line">            case ASSASSIN  :</span><br><span class="line">                System.out.println(&quot;刺客&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case ASSIST  :</span><br><span class="line">                System.out.println(&quot;辅助&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case WARRIOR  :</span><br><span class="line">                System.out.println(&quot;近战&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case RANGED  :</span><br><span class="line">                System.out.println(&quot;远程&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case PUSH  :</span><br><span class="line">                System.out.println(&quot;推进&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case FARMING   :</span><br><span class="line">                System.out.println(&quot;打野&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、接口与继承"><a class="header-anchor" href="#八、接口与继承">¶</a>八、接口与继承</h1>
<h2 id="1、如何设计JAVA的接口？"><a class="header-anchor" href="#1、如何设计JAVA的接口？">¶</a>1、如何设计JAVA的接口？</h2>
<h3 id="步骤-1-物理攻击接口"><a class="header-anchor" href="#步骤-1-物理攻击接口">¶</a>步骤 <strong>1</strong> : 物理攻击接口</h3>
<p>创建一个接口 File-&gt;New-&gt;Interface<br>
AD ，声明一个方法 physicAttack 物理攻击，但是没有方法体，是一个“<strong>空</strong>”方法</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/586.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public interface AD &#123;</span><br><span class="line">        &#x2F;&#x2F;物理伤害</span><br><span class="line">    public void physicAttack();</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-设计一类英雄，能够使用物理攻击"><a class="header-anchor" href="#步骤-2-设计一类英雄，能够使用物理攻击">¶</a>步骤 <strong>2</strong> :设计一类英雄，能够使用物理攻击</h3>
<p>设计一类英雄，能够使用物理攻击，这类英雄在LOL中被叫做AD类：ADHero<br>
继承了Hero 类，所以继承了name,hp,armor等属性</p>
<p><strong>实现某个接口，就相当于承诺了某种约定</strong></p>
<p>所以，<strong>实现</strong>了<strong>AD</strong>这个接口，就<strong>必须</strong>提供AD接口中声明的方法<strong>physicAttack()</strong><br>
<strong>实现</strong>在语法上使用关键字 <strong>implements</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-魔法攻击接口"><a class="header-anchor" href="#步骤-3-魔法攻击接口">¶</a>步骤 <strong>3</strong> : 魔法攻击接口</h3>
<p>创建一个接口 File-&gt;New-&gt;Interface<br>
AP ，声明一个方法 magicAttack 魔法攻击，但是没有方法体，是一个“空”方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public interface AP &#123;</span><br><span class="line"> </span><br><span class="line">    public void magicAttack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-设计一类英雄，只能使用魔法攻击"><a class="header-anchor" href="#步骤-4-设计一类英雄，只能使用魔法攻击">¶</a>步骤 <strong>4</strong> : 设计一类英雄，只能使用魔法攻击</h3>
<p>设计一类英雄，只能使用魔法攻击，这类英雄在LOL中被叫做AP 类：APHero<br>
继承了Hero 类，所以继承了name,hp,armor等属性<br>
同时，实现了<strong>AP</strong>这个接口，就<strong>必须</strong>提供AP接口中声明的方法magicAttack()<br>
<strong>实现</strong>在语法上使用关键字 <strong>implements</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class APHero extends Hero implements AP&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void magicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行魔法攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-设计一类英雄，既能进行物理攻击，又能进行魔法攻击"><a class="header-anchor" href="#步骤-5-设计一类英雄，既能进行物理攻击，又能进行魔法攻击">¶</a>步骤 <strong>5</strong> : 设计一类英雄，既能进行物理攻击，又能进行魔法攻击</h3>
<p>一种英雄，能够同时进行物理攻击和魔法攻击<br>
比如伊泽瑞尔，皮城女警凯特琳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;同时能进行物理和魔法伤害的英雄</span><br><span class="line">public class ADAPHero extends Hero implements AD,AP&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void magicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行魔法攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-什么样的情况下该使用接口"><a class="header-anchor" href="#步骤-6-什么样的情况下该使用接口">¶</a>步骤 <strong>6</strong> : 什么样的情况下该使用接口?</h3>
<p>如上的例子，似乎要接口，不要接口，都一样的，那么接口的意义是什么呢</p>
<p>学习一个知识点，是由浅入深得进行的。 这里呢，只是引入了接口的概念，要真正理解接口的好处，需要更多的实践，以及在较为复杂的系统中进行大量运用之后，才能够真正理解，比如在学习了[多态]之后就能进一步加深理解。</p>
<p>刚刚接触一个概念，就希望达到炉火纯青的学习效果，这样的学习目标是不科学的。</p>
<h3 id="步骤-7-练习-接口"><a class="header-anchor" href="#步骤-7-练习-接口">¶</a>步骤 <strong>7</strong> : 练习-接口</h3>
<p>设计一个治疗者接口：Healer</p>
<p>该接口声明有方法： heal()</p>
<p>设计一个Support类，代表辅助英雄，继承Hero类，同时实现了Healer这个接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package game;</span><br><span class="line"></span><br><span class="line">public interface Healer &#123;</span><br><span class="line">    public void heal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package game;</span><br><span class="line"></span><br><span class="line">public class Support extends Hero implements Healer &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void heal() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		System.out.println(&quot;Heal&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA中的对象转型"><a class="header-anchor" href="#2、JAVA中的对象转型">¶</a>2、JAVA中的对象转型</h2>
<h3 id="示例-1-明确引用类型与对象类型的概念"><a class="header-anchor" href="#示例-1-明确引用类型与对象类型的概念">¶</a>示例 <strong>1</strong> : 明确引用类型与对象类型的概念</h3>
<p>首先，明确引用类型与对象类型的概念<br>
在这个例子里，有一个对象 new ADHero(), 同时也有一个引用ad<br>
对象是有类型的， 是ADHero<br>
引用也是有类型的，是ADHero<br>
通常情况下，引用类型和对象类型是一样的<br>
接下来要讨论的类型转换的问题，指的是<strong>引用类型和对象类型</strong>不一致的情况下的转换问题</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/636.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-子类转父类-向上转型"><a class="header-anchor" href="#示例-2-子类转父类-向上转型">¶</a>示例 <strong>2</strong> : 子类转父类(向上转型)</h3>
<p>所谓的转型，是指当<strong>引用类型</strong>和<strong>对象类型</strong>不一致的时候，才需要进行类型转换<br>
类型转换有时候会成功，有时候会失败(参考[基本类型的类型转换])</p>
<p>到底能否转换成功？ 教大家一个很简单的判别办法<br>
<strong>把右边的当做左边来用</strong>，看说得通不</p>
<p>Hero h = new Hero();</p>
<p>ADHero ad = new ADHero();</p>
<p>h = ad;</p>
<p>右边ad<strong>引用所指向的对象的类型</strong>是 物理攻击英雄<br>
左边h<strong>引用的类型</strong>是 普通英雄<br>
把物理攻击英雄 当做 普通英雄，说不说得通？ 说得通，就可以转</p>
<p>所有的<strong>子类转换为父类</strong>，都是说得通的。比如你身边的例子</p>
<p>苹果手机 继承了 手机，把苹果手机当做普通手机使用<br>
怡宝纯净水 继承了 饮品， 把怡宝纯净水 当做饮品来使用<br>
苍老师 继承了动物， 把苍老师 。。。</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/624.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero h &#x3D; new Hero();</span><br><span class="line">         </span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;类型转换指的是把一个引用所指向的对象的类型，转换为另一个引用的类型</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;把ad引用所指向的对象的类型是ADHero</span><br><span class="line">        &#x2F;&#x2F;h引用的类型是Hero</span><br><span class="line">        &#x2F;&#x2F;把ADHero当做Hero使用，一定可以</span><br><span class="line">         </span><br><span class="line">        h &#x3D; ad;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-父类转子类-向下转型"><a class="header-anchor" href="#示例-3-父类转子类-向下转型">¶</a>示例 <strong>3</strong> : 父类转子类(向下转型)</h3>
<p>父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。<br>
强制转换的意思就是 转换有风险，风险自担。</p>
<p><strong>什么时候行呢？</strong></p>
<ol>
<li>
<p>Hero h =new Hero();</p>
</li>
<li>
<p>ADHero ad = new ADHero();</p>
</li>
<li>
<p>h = ad;</p>
</li>
<li>
<p>ad = (ADHero) h;</p>
</li>
</ol>
<p>第3行，是子类转父类，一定可以的<br>
第4行，就是父类转子类，所以要进行强转。<br>
h这个引用，所指向的对象是ADHero, 所以第4行，就会把ADHero转换为ADHero，就能转换成功。</p>
<p><strong>什么时候转换不行呢？</strong></p>
<ol>
<li>
<p>Hero h =new Hero();</p>
</li>
<li>
<p>ADHero ad = new ADHero();</p>
</li>
<li>
<p>Support s =new Support();</p>
</li>
<li>
<p>h = s;</p>
</li>
<li>
<p>ad = (ADHero)h;</p>
</li>
</ol>
<p>第4行，是子类转父类，是可以转换成功的<br>
第5行，是把h引用所指向的对象 Support，转换为ad引用的类型ADHero。 从语义上讲，把物理攻击英雄，当成辅助英雄来用，说不通，所以会强制转换失败，并且抛出[异常]</p>
<p><strong>以下是对完整的代码的关键行分析</strong><br>
14行： 把ad当做Hero使用，一定可以<br>
转换之后，h引用指向一个ad对象<br>
15行： h引用有可能指向一个ad对象，也有可能指向一个support对象<br>
所以把h引用转换成AD类型的时候，就有可能成功，有可能失败<br>
因此要进行强制转换，换句话说转换后果自负<br>
到底能不能转换成功，要看引用<strong>h到底指向的是哪种对象</strong><br>
在这个例子里，h指向的是一个ad对象，所以转换成ADHero类型，是可以的<br>
16行：把一个support对象当做Hero使用，一定可以<br>
转换之后，h引用指向一个support对象<br>
17行：这个时候，h指向的是一个support对象，所以转换成ADHero类型，会失败。<br>
失败的表现形式是抛出异常 ClassCastException 类型转换异常</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/625.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">import charactor1.Support;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h &#x3D;new Hero();</span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line">        Support s &#x3D;new Support();</span><br><span class="line">          </span><br><span class="line">        h &#x3D; ad;</span><br><span class="line">        ad &#x3D; (ADHero) h;</span><br><span class="line">        h &#x3D; s;</span><br><span class="line">        ad &#x3D; (ADHero)h;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-没有继承关系的两个类，互相转换"><a class="header-anchor" href="#示例-4-没有继承关系的两个类，互相转换">¶</a>示例 <strong>4</strong> : 没有继承关系的两个类，互相转换</h3>
<p>没有继承关系的两个类，互相转换，一定会失败<br>
虽然ADHero和APHero都继承了Hero，但是彼此没有互相继承关系<br>
“<strong>把魔法英雄当做物理英雄来用</strong>”,在语义上也是说不通的</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/626.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line"> </span><br><span class="line">        APHero ap &#x3D; new APHero();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 没有继承关系的类型进行互相转换一定会失败，所以会出现编译错误</span><br><span class="line">        ad &#x3D; (ADHero) ap;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-实现类转换成接口-向上转型"><a class="header-anchor" href="#示例-5-实现类转换成接口-向上转型">¶</a>示例 <strong>5</strong> : 实现类转换成接口(向上转型)</h3>
<p>引用ad指向的对象是ADHero类型，这个类型实现了AD接口<br>
10行： 把一个ADHero类型转换为AD接口<br>
从语义上来讲，把一个ADHero当做AD来使用，而AD接口只有一个physicAttack方法，这就意味着转换后就有可能要调用physicAttack方法，而ADHero一定是有physicAttack方法的，所以转换是能成功的。</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/627.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line">          </span><br><span class="line">        AD adi &#x3D; ad;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-接口转换成实现类-向下转型"><a class="header-anchor" href="#示例-6-接口转换成实现类-向下转型">¶</a>示例 <strong>6</strong> : 接口转换成实现类(向下转型)</h3>
<p>10行： ad引用指向ADHero， 而adi引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功<br>
12行: adi实际上是指向一个ADHero的，所以能够转换成功<br>
14行： adi引用所指向的对象是一个ADHero，要转换为ADAPHero就会失败。</p>
<p><strong>假设能够转换成功</strong>，那么就可以使用<strong>magicAttack</strong>方法，而adi引用所指向的对象<strong>ADHero是没有magicAttack</strong>方法的。</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/628.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">     </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">         </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line">            </span><br><span class="line">        AD adi &#x3D; ad;</span><br><span class="line">   </span><br><span class="line">        ADHero adHero &#x3D; (ADHero) adi;</span><br><span class="line">            </span><br><span class="line">        ADAPHero adapHero &#x3D; (ADAPHero) adi;</span><br><span class="line">        adapHero.magicAttack();</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-7-instanceof"><a class="header-anchor" href="#示例-7-instanceof">¶</a>示例 <strong>7</strong> : instanceof</h3>
<p>instanceof Hero 判断一个引用所指向的对象，是否是Hero类型，或者Hero的子类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line">        APHero ap &#x3D; new APHero();</span><br><span class="line">         </span><br><span class="line">        Hero h1&#x3D; ad;</span><br><span class="line">        Hero h2&#x3D; ap;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;判断引用h1指向的对象，是否是ADHero类型</span><br><span class="line">        System.out.println(h1 instanceof ADHero);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;判断引用h2指向的对象，是否是APHero类型</span><br><span class="line">        System.out.println(h2 instanceof APHero);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;判断引用h1指向的对象，是否是Hero的子类型</span><br><span class="line">        System.out.println(h1 instanceof Hero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<h3 id="示例-8-练习-类型转换"><a class="header-anchor" href="#示例-8-练习-类型转换">¶</a>示例 <strong>8</strong> : 练习-类型转换</h3>
<p>如下转换能否成功？<br>
如果不能，是哪一行会出错？<br>
为什么会出错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line">        Hero h &#x3D; ad;</span><br><span class="line">        AD adi &#x3D; (AD) h;</span><br><span class="line">        APHero ap &#x3D; (APHero) adi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2269.png" alt></p>
<h2 id="3、JAVA-重写方法"><a class="header-anchor" href="#3、JAVA-重写方法">¶</a>3、JAVA 重写方法</h2>
<h3 id="步骤-1-父类Item"><a class="header-anchor" href="#步骤-1-父类Item">¶</a>步骤 <strong>1</strong> : 父类Item</h3>
<p>父类Item有一个方法，叫做effect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class Item &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int price;</span><br><span class="line"> </span><br><span class="line">    public void buy()&#123;</span><br><span class="line">        System.out.println(&quot;购买&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void effect() &#123;</span><br><span class="line">        System.out.println(&quot;物品使用后，可以有效果&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-子类LifePotion"><a class="header-anchor" href="#步骤-2-子类LifePotion">¶</a>步骤 <strong>2</strong> : 子类LifePotion</h3>
<p>子类LifePotion继承Item,同时也提供了方法effect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class LifePotion extends Item&#123;</span><br><span class="line">     </span><br><span class="line">    public void effect()&#123;</span><br><span class="line">        System.out.println(&quot;血瓶使用后，可以回血&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-调用重写的方法"><a class="header-anchor" href="#步骤-3-调用重写的方法">¶</a>步骤 <strong>3</strong> : 调用重写的方法</h3>
<p>调用重写的方法<br>
调用就会执行重写的方法，而不是从父类的方法<br>
所以LifePotion的effect会打印：<br>
“血瓶使用后，可以回血”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class Item &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int price;</span><br><span class="line">     </span><br><span class="line">    public void effect()&#123;</span><br><span class="line">        System.out.println(&quot;物品使用后，可以有效果&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Item i &#x3D; new Item();</span><br><span class="line">        i.effect();</span><br><span class="line">         </span><br><span class="line">        LifePotion lp &#x3D;new LifePotion();</span><br><span class="line">        lp.effect();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-如果没有重写这样的机制怎么样？"><a class="header-anchor" href="#步骤-4-如果没有重写这样的机制怎么样？">¶</a>步骤 <strong>4</strong> :如果没有重写这样的机制怎么样？</h3>
<p>如果没有重写这样的机制，也就是说LifePotion这个类，一旦继承了Item，所有方法都不能修改了。</p>
<p>但是LifePotion又希望提供一点不同的功能，为了达到这个目的，只能<strong>放弃继承Item</strong>,重新编写所有的属性和方法，然后在编写effect的时候，做一点小改动.</p>
<p>这样就增加了开发时间和维护成本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Item.java</span><br><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class Item &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int price;</span><br><span class="line"> </span><br><span class="line">    public void buy()&#123;</span><br><span class="line">        System.out.println(&quot;购买&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void effect() &#123;</span><br><span class="line">        System.out.println(&quot;物品使用后，可以有效果&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;LifePotion.java</span><br><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class LifePotion &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int price;</span><br><span class="line"> </span><br><span class="line">    public void buy()&#123;</span><br><span class="line">        System.out.println(&quot;购买&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void effect()&#123;</span><br><span class="line">        System.out.println(&quot;血瓶使用后，可以回血&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-重写"><a class="header-anchor" href="#步骤-5-练习-重写">¶</a>步骤 <strong>5</strong> : 练习-重写</h3>
<p>设计一个类MagicPotion 蓝瓶，继承Item, 重写effect方法<br>
并输出 “蓝瓶使用后，可以回魔法”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package property;</span><br><span class="line"></span><br><span class="line">public class MagicPotion &#123;</span><br><span class="line">	public void effect()&#123;</span><br><span class="line">        System.out.println(&quot;蓝瓶使用后，可以回复魔法值&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Item i &#x3D; new Item();</span><br><span class="line">        i.buy();</span><br><span class="line">        i.effect();</span><br><span class="line"> </span><br><span class="line">        MagicPotion magicPotion &#x3D; new MagicPotion();</span><br><span class="line">        magicPotion.effect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、什么是JAVA的多态？"><a class="header-anchor" href="#4、什么是JAVA的多态？">¶</a>4、什么是JAVA的多态？</h2>
<h3 id="示例-1-操作符的多态"><a class="header-anchor" href="#示例-1-操作符的多态">¶</a>示例 <strong>1</strong> : 操作符的多态</h3>
<p>同一个操作符在不同情境下，具备不同的作用<br>
如果+号两侧都是整型，那么**+代表 数字相加**<br>
如果+号两侧，任意一个是字符串，那么**+代表字符串连接**</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">        int j &#x3D; 6;</span><br><span class="line">        int k &#x3D; i+j; &#x2F;&#x2F;如果+号两侧都是整型，那么+代表 数字相加</span><br><span class="line">         </span><br><span class="line">        System.out.println(k);</span><br><span class="line">         </span><br><span class="line">        int a &#x3D; 5;</span><br><span class="line">        String b &#x3D; &quot;5&quot;;</span><br><span class="line">         </span><br><span class="line">        String c &#x3D; a+b; &#x2F;&#x2F;如果+号两侧，任意一个是字符串，那么+代表字符串连接</span><br><span class="line">        System.out.println(c);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-观察类的多态现象"><a class="header-anchor" href="#示例-2-观察类的多态现象">¶</a>示例 <strong>2</strong> : 观察类的多态现象</h3>
<p>观察类的多态现象：</p>
<ol>
<li>
<p>i1和i2都是Item类型</p>
</li>
<li>
<p>都调用effect方法</p>
</li>
<li>
<p>输出不同的结果</p>
</li>
</ol>
<p>多态: 都是同一个类型，调用同一个方法，却能呈现不同的状态</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2272.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Item.java</span><br><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class Item &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int price;</span><br><span class="line"> </span><br><span class="line">    public void buy()&#123;</span><br><span class="line">        System.out.println(&quot;购买&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void effect() &#123;</span><br><span class="line">        System.out.println(&quot;物品使用后，可以有效果 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Item i1&#x3D; new LifePotion();</span><br><span class="line">        Item i2 &#x3D; new MagicPotion();</span><br><span class="line">        System.out.print(&quot;i1  是Item类型，执行effect打印:&quot;);</span><br><span class="line">        i1.effect();</span><br><span class="line">        System.out.print(&quot;i2也是Item类型，执行effect打印:&quot;);</span><br><span class="line">        i2.effect();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;LifePotion.java</span><br><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class LifePotion extends Item &#123;</span><br><span class="line">    public void effect()&#123;</span><br><span class="line">        System.out.println(&quot;血瓶使用后，可以回血&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MagicPotion.java</span><br><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class MagicPotion extends Item&#123;</span><br><span class="line"> </span><br><span class="line">    public void effect()&#123;</span><br><span class="line">        System.out.println(&quot;蓝瓶使用后，可以回魔法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-类的多态条件"><a class="header-anchor" href="#示例-3-类的多态条件">¶</a>示例 <strong>3</strong> : 类的多态条件</h3>
<p>要实现类的多态，需要如下条件</p>
<ol>
<li>
<p>父类（接口）引用指向子类对象</p>
</li>
<li>
<p>调用的方法有[重写]<br>
那么多态有什么作用呢？ 通过比较[不使用多态]与[使用多态]来进一步了解</p>
</li>
</ol>
<h3 id="示例-4-类的多态-不使用多态"><a class="header-anchor" href="#示例-4-类的多态-不使用多态">¶</a>示例 <strong>4</strong> : 类的多态-不使用多态</h3>
<p><strong>如果不使用多态</strong>，<br>
假设英雄要使用血瓶和魔瓶，就需要为Hero设计两个方法<br>
useLifePotion<br>
useMagicPotion</p>
<p>除了血瓶和魔瓶还有很多种物品，那么就需要设计很多很多个方法，比如<br>
usePurityPotion 净化药水<br>
useGuard 守卫<br>
useInvisiblePotion 使用隐形药水<br>
等等等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.LifePotion;</span><br><span class="line">import property.MagicPotion;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public void useLifePotion(LifePotion lp)&#123;</span><br><span class="line">        lp.effect();</span><br><span class="line">    &#125;</span><br><span class="line">    public void useMagicPotion(MagicPotion mp)&#123;</span><br><span class="line">        mp.effect();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero garen &#x3D;  new Hero();</span><br><span class="line">        garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">     </span><br><span class="line">        LifePotion lp &#x3D;new LifePotion();</span><br><span class="line">        MagicPotion mp &#x3D;new MagicPotion();</span><br><span class="line">         </span><br><span class="line">        garen.useLifePotion(lp);</span><br><span class="line">        garen.useMagicPotion(mp);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-类的多态-使用多态"><a class="header-anchor" href="#示例-5-类的多态-使用多态">¶</a>示例 <strong>5</strong> : 类的多态-使用多态</h3>
<p>如果物品的种类特别多，那么就需要设计很多的方法<br>
比如useArmor,useWeapon等等</p>
<p>这个时候采用多态来解决这个问题<br>
设计一个方法叫做useItem，其参数类型是Item<br>
如果是使用血瓶，调用该方法<br>
如果是使用魔瓶，还是调用该方法<br>
无论英雄要使用什么样的物品，<strong>只需要一个方法</strong>即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line">import property.LifePotion;</span><br><span class="line">import property.MagicPotion;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero garen &#x3D;  new Hero();</span><br><span class="line">        garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">     </span><br><span class="line">        LifePotion lp &#x3D;new LifePotion();</span><br><span class="line">        MagicPotion mp &#x3D;new MagicPotion();</span><br><span class="line">         </span><br><span class="line">        garen.useItem(lp);</span><br><span class="line">        garen.useItem(mp);     </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-练习-多态"><a class="header-anchor" href="#示例-6-练习-多态">¶</a>示例 <strong>6</strong> : 练习-多态</h3>
<p>immortal是不朽的，不死的意思</p>
<p>mortal就是终有一死的，凡人的意思</p>
<ol>
<li>
<p>设计一个接口<br>
接口叫做Mortal,其中有一个方法叫做die</p>
</li>
<li>
<p>实现接口<br>
分别让ADHero,APHero,ADAPHero这三个类，实现Mortal接口，不同的类实现die方法的时候，都打印出不一样的字符串</p>
</li>
<li>
<p>为Hero类，添加一个方法,在这个方法中调用 m的die方法。</p>
</li>
</ol>
<p>public void kill(Mortal m)</p>
<ol start="4">
<li>在主方法中<br>
首先实例化出一个Hero对象:盖伦<br>
然后实例化出3个对象，分别是ADHero,APHero,ADAPHero的实例<br>
然后让盖伦 kill 这3个对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Mortal.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public interface Mortal &#123;</span><br><span class="line">    public void die();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ADHero.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class ADHero extends Hero implements AD ,Mortal&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void die() &#123;</span><br><span class="line">        System.out.println(name+ &quot; 这个物理英雄挂了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;APHero.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class APHero extends Hero implements AP,Mortal &#123;</span><br><span class="line">    public void magicAttack() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void die() &#123;</span><br><span class="line">            System.out.println(name+ &quot; 这个魔法英雄挂了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ADAPHero.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class ADAPHero extends Hero implements AD,AP,Mortal&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void magicAttack() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void die() &#123;</span><br><span class="line">        System.out.println(name+ &quot; 这个混合英雄挂了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Hero.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">     </span><br><span class="line">    public void kill(Mortal m)&#123;</span><br><span class="line">        System.out.println(name + &quot; 放了一个大招&quot; );</span><br><span class="line">        m.die();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h &#x3D;new Hero();</span><br><span class="line">        h.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">         </span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line">        ad.name &#x3D; &quot;艾希&quot;;</span><br><span class="line">         </span><br><span class="line">        APHero ap &#x3D; new APHero();</span><br><span class="line">        ap.name &#x3D; &quot;安妮&quot;;</span><br><span class="line">         </span><br><span class="line">        ADAPHero adap &#x3D; new ADAPHero();</span><br><span class="line">        adap.name &#x3D; &quot;库奇&quot;;</span><br><span class="line">         </span><br><span class="line">        h.kill(ad);</span><br><span class="line">        h.kill(ap);</span><br><span class="line">        h.kill(adap);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;AD.java</span><br><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public interface AD &#123;</span><br><span class="line">    public void physicAttack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;AP.java</span><br><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public interface AP &#123;</span><br><span class="line">  </span><br><span class="line">    public void magicAttack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2274.png" alt></p>
<h2 id="5、JAVA中的方法隐藏"><a class="header-anchor" href="#5、JAVA中的方法隐藏">¶</a>5、JAVA中的方法隐藏</h2>
<h3 id="步骤-1-父类"><a class="header-anchor" href="#步骤-1-父类">¶</a>步骤 <strong>1</strong> : 父类</h3>
<p>父类有一个类方法 ：battleWin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;类方法，静态方法</span><br><span class="line">    &#x2F;&#x2F;通过类就可以直接调用</span><br><span class="line">    public static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;hero battle win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-子类隐藏父类的类方法"><a class="header-anchor" href="#步骤-2-子类隐藏父类的类方法">¶</a>步骤 <strong>2</strong> : 子类隐藏父类的类方法</h3>
<p>子类隐藏父类的类方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;隐藏父类的battleWin方法</span><br><span class="line">    public static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;ad hero battle win&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero.battleWin();</span><br><span class="line">        ADHero.battleWin();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-隐藏"><a class="header-anchor" href="#步骤-3-练习-隐藏">¶</a>步骤 <strong>3</strong> : 练习-隐藏</h3>
<p>Hero h =new ADHero();</p>
<p>h.battleWin(); //battleWin是一个类方法<br>
h是父类类型的引用<br>
但是指向一个子类对象<br>
h.battleWin(); 会调用父类的方法？还是子类的方法？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hero h &#x3D;new ADHero();</span><br><span class="line">本质上还是Hero类</span><br><span class="line">public static void battleWin()是一个类方法所以只能类本身去使用，而h的类型是Hero并不是ADHero所以会调用到父类方法</span><br></pre></td></tr></table></figure>
<h2 id="6、JAVA的SUPER关键字"><a class="header-anchor" href="#6、JAVA的SUPER关键字">¶</a>6、JAVA的SUPER关键字</h2>
<h3 id="步骤-1-准备一个显式提供无参构造方法的父类"><a class="header-anchor" href="#步骤-1-准备一个显式提供无参构造方法的父类">¶</a>步骤 1 : 准备一个显式提供无参构造方法的父类</h3>
<p>准备显式提供无参构造方法的父类<br>
在实例化Hero对象的时候，其构造方法会打印<br>
“Hero的构造方法 &quot;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        System.out.println(&quot;hero use item&quot;);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        System.out.println(&quot;Hero的构造方法 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-实例化子类，父类的构造方法一定会被调用"><a class="header-anchor" href="#步骤-2-实例化子类，父类的构造方法一定会被调用">¶</a>步骤 <strong>2</strong> : 实例化子类，父类的构造方法一定会被调用</h3>
<p>实例化一个ADHero(), 其构造方法会被调用<br>
其<strong>父类的构造方法也会被调用</strong><br>
并且是父类构造方法<strong>先调用</strong><br>
子类构造方法会默认调用父类的 无参的构造方法</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/662.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public ADHero()&#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        new ADHero();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-父类显式提供两个构造方法"><a class="header-anchor" href="#步骤-3-父类显式提供两个构造方法">¶</a>步骤 <strong>3</strong> : 父类显式提供两个构造方法</h3>
<p>分别是无参的构造方法和带一个参数的构造方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        System.out.println(&quot;hero use item&quot;);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        System.out.println(&quot;Hero的无参的构造方法 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero(String name)&#123;</span><br><span class="line">        System.out.println(&quot;Hero的有一个参数的构造方法 &quot;);</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;&#x2F;&#x2F;Hero的无参的构造方法</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-子类显式调用父类带参构造方法"><a class="header-anchor" href="#步骤-4-子类显式调用父类带参构造方法">¶</a>步骤 <strong>4</strong> : 子类显式调用父类带参构造方法</h3>
<p>使用关键字<strong>super</strong> 显式调用父类带参的构造方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public ADHero(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ADHero(&quot;德莱文&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-调用父类属性"><a class="header-anchor" href="#步骤-5-调用父类属性">¶</a>步骤 5 : 调用父类属性</h3>
<p>通过super调用父类的moveSpeed属性<br>
ADHero也提供了属性moveSpeed</p>
<p>public int getMoveSpeed(){</p>
<p>return this.moveSpeed;</p>
<p>}</p>
<p>public int getMoveSpeed2(){</p>
<p>return super.moveSpeed;</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line"> </span><br><span class="line">    int moveSpeed&#x3D;400; &#x2F;&#x2F;移动速度</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public int getMoveSpeed()&#123;</span><br><span class="line">        return this.moveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public int getMoveSpeed2()&#123;</span><br><span class="line">        return super.moveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero h&#x3D; new ADHero();</span><br><span class="line">         </span><br><span class="line">        System.out.println(h.getMoveSpeed());</span><br><span class="line">        System.out.println(h.getMoveSpeed2());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hero的无参的构造方法 </span><br><span class="line">400</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-调用父类方法"><a class="header-anchor" href="#步骤-6-调用父类方法">¶</a>步骤 6 : 调用父类方法</h3>
<p>ADHero重写了useItem方法，并且在useItem中<strong>通过super调用父类的useItem方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line">import property.LifePotion;</span><br><span class="line"> </span><br><span class="line">public class ADHero extends Hero implements AD &#123;</span><br><span class="line"> </span><br><span class="line">    int moveSpeed &#x3D; 400; &#x2F;&#x2F; 移动速度</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getMoveSpeed() &#123;</span><br><span class="line">        return this.moveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getMoveSpeed2() &#123;</span><br><span class="line">        return super.moveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 重写useItem，并在其中调用父类的userItem方法</span><br><span class="line">    public void useItem(Item i) &#123;</span><br><span class="line">        System.out.println(&quot;adhero use item&quot;);</span><br><span class="line">        super.useItem(i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero h &#x3D; new ADHero();</span><br><span class="line"> </span><br><span class="line">        LifePotion lp &#x3D; new LifePotion();</span><br><span class="line">        </span><br><span class="line">        h.useItem(lp);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hero的无参的构造方法 </span><br><span class="line">adhero use item</span><br><span class="line">hero use item</span><br><span class="line">血瓶使用后，可以回血</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-练习-super"><a class="header-anchor" href="#步骤-7-练习-super">¶</a>步骤 7 : 练习-super</h3>
<p>父类Hero提供了一个有参的构造方法:</p>
<p>public Hero(String name){</p>
<p><a href="http://this.name" target="_blank" rel="noopener">this.name</a> = name;</p>
<p>}</p>
<p>但是没有提供无参的构造方法<br>
子类应该怎么处理？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">   </span><br><span class="line">    public Hero(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#x2F;&#x2F;    故意不提供无参的构造方法</span><br><span class="line">&#x2F;&#x2F;    public Hero()&#123;</span><br><span class="line">&#x2F;&#x2F;     </span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由于作为子类，无论如何 都会调用父类的构造方法。默认情况下，会调用父类的无参的构造方法。 但是，当父类没有无参构造方法的时候( 提供了有参构造方法，并且不显示提供无参构造方法)，子类就会抛出异常，因为它尝试去调用父类的无参构造方法。</span><br><span class="line">这个时候，子类应该必须通过super去调用父类声明的，存在的，有参的构造方法。</span><br></pre></td></tr></table></figure>
<h2 id="7、JAVA中的超类-OBJECT"><a class="header-anchor" href="#7、JAVA中的超类-OBJECT">¶</a>7、JAVA中的超类 OBJECT</h2>
<h3 id="步骤-1-Object类是所有类的父类"><a class="header-anchor" href="#步骤-1-Object类是所有类的父类">¶</a>步骤 1 : Object类是所有类的父类</h3>
<p>声明一个类的时候，默认是继承了Object<br>
public class Hero <strong>extends Object</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line"> </span><br><span class="line">public class Hero extends Object &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        System.out.println(&quot;hero use item&quot;);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        System.out.println(&quot;Hero的无参的构造方法 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero(String name)&#123;</span><br><span class="line">        System.out.println(&quot;Hero的有一个参数的构造方法 &quot;);</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-toString"><a class="header-anchor" href="#步骤-2-toString">¶</a>步骤 2 : toString()</h3>
<p>Object类提供一个toString方法，所以所有的类都有toString方法<br>
toString()的意思是返回当前对象的<strong>字符串表达</strong><br>
通过 System.out.println 打印对象就是打印该对象的toString()返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">      </span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero h &#x3D; new Hero();</span><br><span class="line">        h.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        System.out.println(h.toString());</span><br><span class="line">        &#x2F;&#x2F;直接打印对象就是打印该对象的toString()返回值</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;盖伦</span><br><span class="line">&#x2F;&#x2F;盖伦</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-finalize"><a class="header-anchor" href="#步骤-3-finalize">¶</a>步骤 3 : finalize()</h3>
<p>当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件</p>
<p>当它被垃圾回收的时候，它的finalize() 方法就会被调用。</p>
<p>finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的。</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2285.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">      </span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void finalize()&#123;</span><br><span class="line">        System.out.println(&quot;这个英雄正在被回收&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;只有一引用</span><br><span class="line">        Hero h;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;不断生成新的对象</span><br><span class="line">            &#x2F;&#x2F;每创建一个对象，前一个对象，就没有引用指向了</span><br><span class="line">            &#x2F;&#x2F;那些对象，就满足垃圾回收的条件</span><br><span class="line">            &#x2F;&#x2F;当，垃圾堆积的比较多的时候，就会触发垃圾回收</span><br><span class="line">            &#x2F;&#x2F;一旦这个对象被回收，它的finalize()方法就会被调用</span><br><span class="line">            h &#x3D; new Hero();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-equals"><a class="header-anchor" href="#步骤-4-equals">¶</a>步骤 4 : equals()</h3>
<p>equals() 用于判断两个对象的内容是否相同</p>
<p>假设，当两个英雄的hp相同的时候，我们就认为这两个英雄相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">      </span><br><span class="line">    public boolean equals(Object o)&#123;</span><br><span class="line">        if(o instanceof Hero)&#123;</span><br><span class="line">            Hero h &#x3D; (Hero) o;</span><br><span class="line">            return this.hp &#x3D;&#x3D; h.hp;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1&#x3D; new Hero();</span><br><span class="line">        h1.hp &#x3D; 300;</span><br><span class="line">        Hero h2&#x3D; new Hero();</span><br><span class="line">        h2.hp &#x3D; 400;</span><br><span class="line">        Hero h3&#x3D; new Hero();</span><br><span class="line">        h3.hp &#x3D; 300;</span><br><span class="line">         </span><br><span class="line">        System.out.println(h1.equals(h2));</span><br><span class="line">        System.out.println(h1.equals(h3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x2F;&#x2F;false true</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5"><a class="header-anchor" href="#步骤-5">¶</a>步骤 5 : ==</h3>
<p>这不是Object的方法，但是用于判断两个对象是否相同<br>
<strong>更准确的讲</strong>，用于判断两个引用，是否指向了同一个对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">      </span><br><span class="line">    public boolean equals(Object o)&#123;</span><br><span class="line">        if(o instanceof Hero)&#123;</span><br><span class="line">            Hero h &#x3D; (Hero) o;</span><br><span class="line">            return this.hp &#x3D;&#x3D; h.hp;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1&#x3D; new Hero();</span><br><span class="line">        h1.hp &#x3D; 300;</span><br><span class="line">        Hero h2&#x3D; new Hero();</span><br><span class="line">        h2.hp &#x3D; 400;</span><br><span class="line">        Hero h3&#x3D; new Hero();</span><br><span class="line">        h3.hp &#x3D; 300;</span><br><span class="line">         </span><br><span class="line">        System.out.println(h1&#x3D;&#x3D;h2);</span><br><span class="line">        System.out.println(h1&#x3D;&#x3D;h3);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x2F;&#x2F;false false</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-hashCode"><a class="header-anchor" href="#步骤-6-hashCode">¶</a>步骤 6 : hashCode()</h3>
<p>hashCode方法返回一个对象的哈希值，但是在了解哈希值的意义之前，讲解这个方法没有意义。</p>
<p>hashCode的意义，将放在[hashcode 原理]章节讲解</p>
<h3 id="步骤-7-线程同步相关方法"><a class="header-anchor" href="#步骤-7-线程同步相关方法">¶</a>步骤 7 : 线程同步相关方法</h3>
<p>Object还提供线程同步相关方法<br>
wait()<br>
notify()<br>
notifyAll()<br>
这部分内容的理解需要建立在对线程安全有足够的理解的基础之上，所以会放在[线程交互]的章节讲解</p>
<h3 id="步骤-8-getClass"><a class="header-anchor" href="#步骤-8-getClass">¶</a>步骤 8 : getClass()</h3>
<p>getClass()会返回一个对象的[类对象]，属于高级内容，不适合初学者过早接触，关于类对象的详细内容请参考[反射机制]</p>
<h3 id="步骤-9-练习-Object"><a class="header-anchor" href="#步骤-9-练习-Object">¶</a>步骤 9 : 练习-Object</h3>
<p>重写Item的 toString(), finalize()和equals()方法<br>
toString() 返回Item的name + price<br>
finalize() 输出当前对象正在被回收<br>
equals(Object o) 首先判断o是否是Item类型，然后比较两个Item的price是否相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class Item extends Object &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int price;</span><br><span class="line"> </span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;叫做 &quot; + name + &quot; 的物品，其价格是 &quot; + price;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void finalize() &#123;</span><br><span class="line">        System.out.println(&quot;回收叫做 &quot; + name + &quot; 的物品&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o instanceof Item) &#123;</span><br><span class="line">            Item i &#x3D; (Item) o;</span><br><span class="line">            if (i.price &#x3D;&#x3D; this.price)</span><br><span class="line">                return true;</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、JAVA的修饰符FINAL详解"><a class="header-anchor" href="#8、JAVA的修饰符FINAL详解">¶</a>8、JAVA的修饰符FINAL详解</h2>
<h3 id="示例-1-final修饰类"><a class="header-anchor" href="#示例-1-final修饰类">¶</a>示例 1 : final修饰类</h3>
<p>当Hero被修饰成final的时候，表示Hero不能够被继承<br>
其子类会出现编译错误</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/653.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public final class Hero extends Object &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-final修饰方法"><a class="header-anchor" href="#示例-2-final修饰方法">¶</a>示例 2 : final修饰方法</h3>
<p>Hero的useItem方法被修饰成final,那么该方法在ADHero中，不能够被重写</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/654.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line"> </span><br><span class="line">public class Hero extends Object &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public final void useItem(Item i)&#123;</span><br><span class="line">        System.out.println(&quot;hero use item&quot;);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        System.out.println(&quot;Hero的无参的构造方法 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero(String name)&#123;</span><br><span class="line">        System.out.println(&quot;Hero的有一个参数的构造方法 &quot;);</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-final修饰基本类型变量"><a class="header-anchor" href="#示例-3-final修饰基本类型变量">¶</a>示例 3 : final修饰基本类型变量</h3>
<p>final修饰基本类型变量，表示该变量只有一次赋值机会<br>
16行进行了赋值，17行就不可以再进行赋值了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero extends Object &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        final int hp;</span><br><span class="line">        hp &#x3D; 5;</span><br><span class="line">        hp &#x3D; 6;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-final修饰引用"><a class="header-anchor" href="#示例-4-final修饰引用">¶</a>示例 4 : final修饰引用</h3>
<p>final修饰引用<br>
h引用被修饰成final，表示该引用只有<strong>1</strong>次指向对象的机会<br>
所以17行会出现编译错误<br>
但是，依然通过h引用修改对象的属性值hp，因为hp并没有final修饰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero extends Object &#123;</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        final Hero h;</span><br><span class="line">        h  &#x3D;new Hero();</span><br><span class="line">        h  &#x3D;new Hero();</span><br><span class="line">         </span><br><span class="line">        h.hp &#x3D; 5;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-常量"><a class="header-anchor" href="#示例-5-常量">¶</a>示例 5 : 常量</h3>
<p>常量指的是可以公开，直接访问，不会变化的值<br>
比如 itemTotalNumber 物品栏的数量是6个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero extends Object &#123;</span><br><span class="line">     </span><br><span class="line">    public static final int itemTotalNumber &#x3D; 6;&#x2F;&#x2F;物品栏的数量</span><br><span class="line">        </span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">        </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">        </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        final Hero h;</span><br><span class="line">        h  &#x3D;new Hero();</span><br><span class="line">         </span><br><span class="line">        h.hp &#x3D; 5;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-练习-final"><a class="header-anchor" href="#示例-6-练习-final">¶</a>示例 6 : 练习-final</h3>
<p>设计一个类SomeString,继承 String类。 能否继承？</p>
<p>答：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">肯定不能被继承，String类是被final修饰的</span><br><span class="line"></span><br><span class="line">final 修饰类  类不行被继承</span><br><span class="line">final 修饰方法 方法不能重写</span><br><span class="line">final 修饰变量 变量只有一次赋值的机会</span><br><span class="line">final 修饰引用 应用只有一次指向的机会</span><br><span class="line">final 修饰 只有一次赋值的机会， 所以是常量</span><br></pre></td></tr></table></figure>
<h2 id="9、JAVA-抽象类详解"><a class="header-anchor" href="#9、JAVA-抽象类详解">¶</a>9、JAVA 抽象类详解</h2>
<h3 id="步骤-1-抽象类"><a class="header-anchor" href="#步骤-1-抽象类">¶</a>步骤 1 : 抽象类</h3>
<p>为Hero增加一个<strong>抽象方法 attack</strong>，并且把Hero声明为abstract的。<br>
APHero,ADHero,ADAPHero是Hero的子类，继承了Hero的属性和方法。<br>
但是各自的攻击手段是不一样的，所以继承Hero类后，这些<strong>子类就必须提供</strong>不一样的attack方法实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Hero.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    float hp;</span><br><span class="line"> </span><br><span class="line">    float armor;</span><br><span class="line"> </span><br><span class="line">    int moveSpeed;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 抽象方法attack</span><br><span class="line">    &#x2F;&#x2F; Hero的子类会被要求实现attack方法</span><br><span class="line">    public abstract void attack();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ADHero.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class ADHero extends Hero implements AD &#123;</span><br><span class="line"> </span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void attack() &#123;</span><br><span class="line">        physicAttack();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;APHero.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class APHero extends Hero implements AP &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void magicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行魔法攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void attack() &#123;</span><br><span class="line">        magicAttack();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ADAPHero.java</span><br><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class ADAPHero extends Hero implements AD, AP &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void attack() &#123;</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;既可以进行物理攻击，也可以进行魔法攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void magicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行魔法攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-抽象类可以没有抽象方法"><a class="header-anchor" href="#步骤-2-抽象类可以没有抽象方法">¶</a>步骤 2 : 抽象类可以没有抽象方法</h3>
<p>Hero类可以在不提供抽象方法的前提下，声明为抽象类<br>
一旦一个类被声明为抽象类，就不能够被直接实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line">    String name;</span><br><span class="line">          </span><br><span class="line">    float hp;</span><br><span class="line">          </span><br><span class="line">    float armor;</span><br><span class="line">          </span><br><span class="line">    int moveSpeed;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;虽然没有抽象方法，但是一旦被声明为了抽象类，就不能够直接被实例化</span><br><span class="line">        Hero h&#x3D; new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-抽象类和接口的区别"><a class="header-anchor" href="#步骤-3-抽象类和接口的区别">¶</a>步骤 3 : 抽象类和接口的区别</h3>
<p>区别1：<br>
子类只能继承一个抽象类，不能继承多个<br>
子类可以实现<strong>多个</strong>接口<br>
区别2：<br>
抽象类可以定义<br>
public,protected,package,private<br>
静态和非静态属性<br>
final和非final属性<br>
但是接口中声明的属性，只能是<br>
public<br>
静态<br>
final的<br>
即便没有显式的声明<br>
<strong>注:</strong> 抽象类和接口都可以有实体方法。 接口中的实体方法，叫做[默认方法]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public interface AP &#123;</span><br><span class="line">  </span><br><span class="line">    public static final int resistPhysic &#x3D; 100;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;resistMagic即便没有显式的声明为 public static final</span><br><span class="line">    &#x2F;&#x2F;但依然默认为public static final</span><br><span class="line">    int resistMagic &#x3D; 0;</span><br><span class="line">     </span><br><span class="line">    public void magicAttack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-抽象类"><a class="header-anchor" href="#步骤-4-练习-抽象类">¶</a>步骤 4 : 练习-抽象类</h3>
<p>有的物品使用之后就消失了，比如血瓶</p>
<p>有的物品使用了之后还会继续存在，比如武器</p>
<p>为Item类设计一个抽象方法</p>
<p>public abstract boolean disposable()</p>
<p>不同的子类，实现disposable后，会返回不同的值。<br>
比如LifePotion就会返回true，因为是会消失了。<br>
而Weapon,Armor 就会返回false,因为是不会消失了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Item &#123;</span><br><span class="line">    String xueping;</span><br><span class="line">    String wuqi;</span><br><span class="line">     </span><br><span class="line">    public abstract  boolean disposable();</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class LifePotion extends Item &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public boolean disposable() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">        super.xueping &#x3D; &quot;已使用血瓶&quot;;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LifePotion h &#x3D; new LifePotion() ;</span><br><span class="line">        System.out.println(h.disposable()+h.xueping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class Weapon extends Item &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public boolean disposable() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">        super.wuqi&#x3D;&quot;子弹已消耗&quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Weapon h &#x3D; new Weapon() ;</span><br><span class="line">        System.out.println(h.disposable()+h.wuqi);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、JAVA-内部类详解"><a class="header-anchor" href="#10、JAVA-内部类详解">¶</a>10、JAVA 内部类详解</h2>
<h3 id="步骤-1-非静态内部类"><a class="header-anchor" href="#步骤-1-非静态内部类">¶</a>步骤 1 : 非静态内部类</h3>
<p>非静态内部类 BattleScore “战斗成绩”<br>
非静态内部类可以直接在一个类里面定义</p>
<p>比如：<br>
战斗成绩只有在一个英雄对象存在的时候才有意义<br>
所以实例化BattleScore 的时候，必须建立在一个存在的英雄的基础上<br>
语法: <strong>new 外部类().new 内部类()</strong><br>
作为Hero的非静态内部类，是可以直接访问外部类的<strong>private</strong>实例属性name的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    private String name; &#x2F;&#x2F; 姓名</span><br><span class="line"> </span><br><span class="line">    float hp; &#x2F;&#x2F; 血量</span><br><span class="line"> </span><br><span class="line">    float armor; &#x2F;&#x2F; 护甲</span><br><span class="line"> </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F; 移动速度</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class="line">    &#x2F;&#x2F; 战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class="line">    class BattleScore &#123;</span><br><span class="line">        int kill;</span><br><span class="line">        int die;</span><br><span class="line">        int assit;</span><br><span class="line"> </span><br><span class="line">        public void legendary() &#123;</span><br><span class="line">            if (kill &gt;&#x3D; 8)</span><br><span class="line">                System.out.println(name + &quot;超神！&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen &#x3D; new Hero();</span><br><span class="line">        garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        &#x2F;&#x2F; 实例化内部类</span><br><span class="line">        &#x2F;&#x2F; BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class="line">        &#x2F;&#x2F; 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class="line">        BattleScore score &#x3D; garen.new BattleScore();</span><br><span class="line">        score.kill &#x3D; 9;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-静态内部类"><a class="header-anchor" href="#步骤-2-静态内部类">¶</a>步骤 2 : 静态内部类</h3>
<p>在一个类里面声明一个静态内部类<br>
比如敌方水晶，当敌方水晶没有血的时候，己方所有英雄都取得胜利，而不只是某一个具体的英雄取得胜利。<br>
与非静态内部类不同，<strong>静态内部类</strong>水晶类的实例化 <strong>不需要一个外部类的实例为基础</strong>，可以直接实例化<br>
语法：<strong>new 外部类.静态内部类();</strong><br>
因为没有一个外部类的实例，所以在静态内部类里面<strong>不可以访问外部类的实例属性和方法</strong><br>
除了可以访问外部类的<strong>私有静态成员外</strong>，静态内部类和普通类没什么大的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">  </span><br><span class="line">    private static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;battle win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;敌方的水晶</span><br><span class="line">    static class EnemyCrystal&#123;</span><br><span class="line">        int hp&#x3D;5000;</span><br><span class="line">        String name &#x3D; &quot;red term&quot;;</span><br><span class="line">        &#x2F;&#x2F;如果水晶的血量为0，则宣布胜利</span><br><span class="line">        public void checkIfVictory()&#123;</span><br><span class="line">            if(hp&#x3D;&#x3D;0)&#123;</span><br><span class="line">                Hero.battleWin();</span><br><span class="line">                 </span><br><span class="line">                &#x2F;&#x2F;静态内部类不能直接访问外部类的对象属性</span><br><span class="line">                System.out.println(name + &quot; win this game&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;实例化静态内部类</span><br><span class="line">        Hero.EnemyCrystal crystal &#x3D; new Hero.EnemyCrystal();</span><br><span class="line">        </span><br><span class="line">        crystal.hp&#x3D;0;</span><br><span class="line">        crystal.checkIfVictory();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-匿名类"><a class="header-anchor" href="#步骤-3-匿名类">¶</a>步骤 3 : 匿名类</h3>
<p>匿名类指的是在<strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练<br>
通常情况下，要使用一个接口或者抽象类，都必须创建一个子类</p>
<p>有的时候，为了快速使用，直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。<br>
既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。<br>
这样的类，叫做匿名类</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/687.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">          </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">          </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">          </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">      </span><br><span class="line">    public abstract void attack();</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        ADHero adh&#x3D;new ADHero();</span><br><span class="line">        &#x2F;&#x2F;通过打印adh，可以看到adh这个对象属于ADHero类</span><br><span class="line">        adh.attack();</span><br><span class="line">        System.out.println(adh);</span><br><span class="line">          </span><br><span class="line">        Hero h &#x3D; new Hero()&#123;</span><br><span class="line">            &#x2F;&#x2F;当场实现attack方法</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                System.out.println(&quot;新的进攻手段&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        &#x2F;&#x2F;通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span><br><span class="line">          </span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-本地类"><a class="header-anchor" href="#步骤-4-本地类">¶</a>步骤 4 : 本地类</h3>
<p>本地类可以理解为有名字的匿名类<br>
内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。<br>
本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line">    String name; &#x2F;&#x2F;姓名</span><br><span class="line">          </span><br><span class="line">    float hp; &#x2F;&#x2F;血量</span><br><span class="line">          </span><br><span class="line">    float armor; &#x2F;&#x2F;护甲</span><br><span class="line">          </span><br><span class="line">    int moveSpeed; &#x2F;&#x2F;移动速度</span><br><span class="line">      </span><br><span class="line">    public abstract void attack();</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;与匿名类的区别在于，本地类有了自定义的类名</span><br><span class="line">        class SomeHero extends Hero&#123;</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                System.out.println( name+ &quot; 新的进攻手段&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        SomeHero h &#x3D; new SomeHero();</span><br><span class="line">        h.name &#x3D;&quot;地卜师&quot;;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-在匿名类中使用外部的局部变量"><a class="header-anchor" href="#步骤-5-在匿名类中使用外部的局部变量">¶</a>步骤 5 : 在匿名类中使用外部的局部变量</h3>
<p>在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final</p>
<p>为什么要声明为final，其机制比较复杂，请参考第二个Hero代码中的解释</p>
<p><strong>注：<strong>在jdk8中，已经不需要强制修饰成final了，如果没有写final，不会报错，因为编译器</strong>偷偷的</strong>帮你加上了看不见的final</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Hero.java</span><br><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line"> </span><br><span class="line">    public abstract void attack();</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final</span><br><span class="line">        final int damage &#x3D; 5;</span><br><span class="line">         </span><br><span class="line">        Hero h &#x3D; new Hero()&#123;</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                System.out.printf(&quot;新的进攻手段，造成%d点伤害&quot;,damage );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Hero.java</span><br><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line"> </span><br><span class="line">    public abstract void attack();</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;在匿名类中使用外部的局部变量damage 必须修饰为final</span><br><span class="line">        int damage &#x3D; 5;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;这里使用本地类AnonymousHero来模拟匿名类的隐藏属性机制</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;事实上的匿名类，会在匿名类里声明一个damage属性，并且使用构造方法初始化该属性的值</span><br><span class="line">        &#x2F;&#x2F;在attack中使用的damage，真正使用的是这个内部damage，而非外部damage</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;假设外部属性不需要声明为final</span><br><span class="line">        &#x2F;&#x2F;那么在attack中修改damage的值，就会被暗示为修改了外部变量damage的值</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;但是他们俩是不同的变量，是不可能修改外部变量damage的</span><br><span class="line">        &#x2F;&#x2F;所以为了避免产生误导，外部的damage必须声明为final,&quot;看上去&quot;就不能修改了</span><br><span class="line">        class AnonymousHero extends Hero&#123;</span><br><span class="line">            int damage;</span><br><span class="line">            public AnonymousHero(int damage)&#123;</span><br><span class="line">                this.damage &#x3D; damage;</span><br><span class="line">            &#125;</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                damage &#x3D; 10;</span><br><span class="line">                System.out.printf(&quot;新的进攻手段，造成%d点伤害&quot;,this.damage );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Hero h &#x3D; new AnonymousHero(damage);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-练习-内部类"><a class="header-anchor" href="#步骤-6-练习-内部类">¶</a>步骤 6 : 练习-内部类</h3>
<p>创建一个Item的匿名类</p>
<p>Item有抽象方法disposable(), 就像[抽象类练习]中要求的那样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package property;</span><br><span class="line"></span><br><span class="line">public abstract class Item &#123;</span><br><span class="line">	String name;</span><br><span class="line">	int price;</span><br><span class="line"></span><br><span class="line">	public abstract boolean disposable();</span><br><span class="line">	public String toString()</span><br><span class="line">	&#123;</span><br><span class="line">		return name+price;</span><br><span class="line">	&#125;</span><br><span class="line">	public void finalize()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;当前对象正在被回收&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public boolean equals(Object o)</span><br><span class="line">	&#123;</span><br><span class="line">		if(o instanceof Item)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			return this.price&#x3D;&#x3D;((Item) o).price;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	public void effect()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;可以恢复&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Item i &#x3D; new Item()&#123;</span><br><span class="line">			@Override</span><br><span class="line">			public boolean disposable()&#123;</span><br><span class="line">				super.name&#x3D;&quot;子弹已消耗&quot;;</span><br><span class="line">				System.out.println(&quot;测试&quot;);</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i.disposable()+i.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11、默认方法"><a class="header-anchor" href="#11、默认方法">¶</a>11、默认方法</h2>
<h3 id="步骤-1-什么是默认方法"><a class="header-anchor" href="#步骤-1-什么是默认方法">¶</a>步骤 1 : 什么是默认方法</h3>
<p>默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法</p>
<p>Mortal 这个接口，增加了一个<strong>默认方法</strong> revive，这个方法有实现体，并且被声明为了<strong>default</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public interface Mortal &#123;</span><br><span class="line">    public void die();</span><br><span class="line"> </span><br><span class="line">    default public void revive() &#123;</span><br><span class="line">        System.out.println(&quot;本英雄复活了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-为什么会有默认方法"><a class="header-anchor" href="#步骤-2-为什么会有默认方法">¶</a>步骤 2 : 为什么会有默认方法</h3>
<p>假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动。</p>
<p>但是引入了默认方法后，原来的类，不需要做任何改动，并且还能<strong>得到</strong>这个默认方法</p>
<p>通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类</p>
<h3 id="步骤-3-练习-默认方法"><a class="header-anchor" href="#步骤-3-练习-默认方法">¶</a>步骤 3 : 练习-默认方法</h3>
<p>为AD接口增加一个默认方法 attack()<br>
为AP接口也增加一个默认方法 attack()<br>
问： ADAPHero同时实现了AD,AP接口，那么 ADAPHero 对象调用attack()的时候，是调用哪个接口的attack()?</p>
<p>答：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AD &#123;</span><br><span class="line">    public void physicalAttack();</span><br><span class="line">    default public void attack() &#123;</span><br><span class="line">        System.out.println(&quot;AD英雄攻击了~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">public interface AP &#123;</span><br><span class="line">    public void magicAttack();</span><br><span class="line">    default public void attack() &#123;</span><br><span class="line">        System.out.println(&quot;AP英雄攻击了~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">public class ADAPHero extends Hero implements AD,AP&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void magicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;使用魔法攻击~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void physicalAttack() &#123;</span><br><span class="line">        System.out.println(&quot;使用物理攻击~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 默认方法</span><br><span class="line"> * @author Chen</span><br><span class="line"> * 默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IndexController &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADAPHero dp &#x3D; new ADAPHero();</span><br><span class="line">        dp.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">&#x2F;* 假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,</span><br><span class="line"> * 那么所有实现了Mortal接口的类，都需要做改动。</span><br><span class="line"> * 但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法</span><br><span class="line"> * 通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个类继承的多个接口有重名的默认方法，要使用  xx（你想要调用的那个接口）.super.(方法名)</span><br><span class="line">哪个重写先写就执行哪个。</span><br></pre></td></tr></table></figure>
<h2 id="12、综合练习"><a class="header-anchor" href="#12、综合练习">¶</a>12、综合练习</h2>
<h3 id="步骤-1-UML-图-——-类之间的关系"><a class="header-anchor" href="#步骤-1-UML-图-——-类之间的关系">¶</a>步骤 1 : UML 图 —— 类之间的关系</h3>
<p>UML-Unified Module Language<br>
统一建模语言，可以很方便的用于描述类的属性，方法，以及类和类之间的关系</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2305.png" alt></p>
<h3 id="步骤-2-解释UML-类图"><a class="header-anchor" href="#步骤-2-解释UML-类图">¶</a>步骤 2 : 解释UML-类图</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2318.png" alt></p>
<h3 id="步骤-3-解释UML-接口图"><a class="header-anchor" href="#步骤-3-解释UML-接口图">¶</a>步骤 3 : 解释UML-接口图</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2319.png" alt></p>
<h3 id="步骤-4-解释UML-继承关系"><a class="header-anchor" href="#步骤-4-解释UML-继承关系">¶</a>步骤 4 : 解释UML-继承关系</h3>
<p>带箭头的实线，表示 Spider，Cat, Fish都继承于Animal这个父类.<br>
<strong>注：</strong> 模糊是表示，此时不需要关注模糊的那部分内容。 请不要再发图片是模糊的纠正信息了，站长特意这么做的。。。</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2320.png" alt></p>
<h3 id="步骤-5-解释UML-实现关系"><a class="header-anchor" href="#步骤-5-解释UML-实现关系">¶</a>步骤 5 : 解释UML-实现关系</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2321.png" alt></p>
<h3 id="步骤-6-练习-Animal类"><a class="header-anchor" href="#步骤-6-练习-Animal类">¶</a>步骤 6 : 练习-Animal类</h3>
<ol>
<li>
<p>创建Animal类，它是所有动物的抽象父类。</p>
</li>
<li>
<p>声明一个受保护的整数类型属性legs，它记录动物的腿的数目。</p>
</li>
<li>
<p>定义一个受保护的构造器，用来初始化legs属性。</p>
</li>
<li>
<p>声明抽象方法eat。</p>
</li>
<li>
<p>声明具体方法walk来打印动物是如何行走的（包括腿的数目）</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">public abstract class Animal &#123;</span><br><span class="line">protected int legs;</span><br><span class="line">protected  Animal(int legs) &#123;</span><br><span class="line">this.legs &#x3D; legs;</span><br><span class="line">&#125;</span><br><span class="line">public void walk() &#123;</span><br><span class="line">System.out.println(&quot;这个动物是用&quot; + this.legs + &quot;腿走路&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public abstract void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-练习-Spider类"><a class="header-anchor" href="#步骤-7-练习-Spider类">¶</a>步骤 7 : 练习-Spider类</h3>
<ol>
<li>
<p>Spider继承Animal类。</p>
</li>
<li>
<p>定义默认构造器，它调用父类构造器来指明所有蜘蛛都是8条腿。</p>
</li>
<li>
<p>实现eat方法</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">public class Spider extends Animal &#123;</span><br><span class="line">public Spider() &#123;</span><br><span class="line">super(8);</span><br><span class="line">&#125;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;蜘蛛吃大虫子&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-8-练习-Pet接口"><a class="header-anchor" href="#步骤-8-练习-Pet接口">¶</a>步骤 8 : 练习-Pet接口</h3>
<p>根据UML类创建pet（宠物）接口</p>
<ol>
<li>
<p>提供getName() 返回该宠物的名字</p>
</li>
<li>
<p>提供setName(String name) 为该宠物命名</p>
</li>
<li>
<p>提供 play()方法</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">public interface Pet &#123;</span><br><span class="line">public String getName();</span><br><span class="line">public void setName(String name);</span><br><span class="line">public void play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-9-练习-Cat类"><a class="header-anchor" href="#步骤-9-练习-Cat类">¶</a>步骤 9 : 练习-Cat类</h3>
<ol>
<li>
<p>该类必须包含String属性来存宠物的名字。</p>
</li>
<li>
<p>定义一个构造器，它使用String参数指定猫的名字；该构造器必须调用超类构造器来指明所有的猫都是四条腿。</p>
</li>
<li>
<p>另定义一个无参的构造器。该构造器调用前一个构造器（用this关键字）并传递一个空字符串作为参数</p>
</li>
<li>
<p>实现Pet接口方法。</p>
</li>
<li>
<p>实现eat方法。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">public class Cat extends Animal implements Pet &#123;</span><br><span class="line">String name;</span><br><span class="line">public Cat(String name) &#123;</span><br><span class="line">super(4);</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">public Cat() &#123;</span><br><span class="line">this(null);</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line">public void play() &#123;</span><br><span class="line">System.out.println(this.name + &quot;在愉快的玩耍&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(this.name + &quot;在愉快的吃饭&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-10-练习-Fish类"><a class="header-anchor" href="#步骤-10-练习-Fish类">¶</a>步骤 10 : 练习-Fish类</h3>
<ol>
<li>
<p>创建Fish类，它继承Animal类</p>
</li>
<li>
<p>重写Animal的walk方法以表明鱼不能走且没有腿。</p>
</li>
<li>
<p>实现Pet接口</p>
</li>
<li>
<p>无参构造方法</p>
</li>
<li>
<p>提供一个private 的name属性</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">public class Fish extends Animal implements Pet &#123;</span><br><span class="line">public Fish() &#123;</span><br><span class="line">super(0);</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">private String name;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String Name) &#123;</span><br><span class="line">&#125;</span><br><span class="line">public void play() &#123;</span><br><span class="line">System.out.println(&quot;鱼在水里追蝌蚪&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void walk() &#123;</span><br><span class="line">System.out.println(&quot;鱼不能走且没有腿&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;鱼吃草&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九、数字与字符串"><a class="header-anchor" href="#九、数字与字符串">¶</a>九、数字与字符串</h1>
<h2 id="1、JAVA中基本类型的装箱和拆箱"><a class="header-anchor" href="#1、JAVA中基本类型的装箱和拆箱">¶</a>1、JAVA中基本类型的装箱和拆箱</h2>
<h3 id="步骤-1-封装类"><a class="header-anchor" href="#步骤-1-封装类">¶</a>步骤 1 : 封装类</h3>
<p>所有的<strong>基本类型</strong>，都有对应的<strong>类类型</strong><br>
比如int对应的类是Integer<br>
这种类就叫做封装类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;把一个基本类型的变量,转换为Integer对象</span><br><span class="line">        Integer it &#x3D; new Integer(i);</span><br><span class="line">        &#x2F;&#x2F;把一个Integer对象，转换为一个基本类型的int</span><br><span class="line">        int i2 &#x3D; it.intValue();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-Number类"><a class="header-anchor" href="#步骤-2-Number类">¶</a>步骤 2 : Number类</h3>
<p>数字封装类有<br>
Byte,Short,Integer,Long,Float,Double<br>
这些类都是抽象类Number的子类</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/672.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">         </span><br><span class="line">        Integer it &#x3D; new Integer(i);</span><br><span class="line">        &#x2F;&#x2F;Integer是Number的子类，所以打印true</span><br><span class="line">        System.out.println(it instanceof Number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-基本类型转封装类"><a class="header-anchor" href="#步骤-3-基本类型转封装类">¶</a>步骤 3 : 基本类型转封装类</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;基本类型转换成封装类型</span><br><span class="line">        Integer it &#x3D; new Integer(i);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-封装类转基本类型"><a class="header-anchor" href="#步骤-4-封装类转基本类型">¶</a>步骤 4 : 封装类转基本类型</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;基本类型转换成封装类型</span><br><span class="line">        Integer it &#x3D; new Integer(i);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;封装类型转换成基本类型</span><br><span class="line">        int i2 &#x3D; it.intValue();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-自动装箱"><a class="header-anchor" href="#步骤-5-自动装箱">¶</a>步骤 5 : 自动装箱</h3>
<p>不需要调用构造方法，**通过=符号	自动	**把 基本类型 转换为 类类型 就叫装箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;基本类型转换成封装类型</span><br><span class="line">        Integer it &#x3D; new Integer(i);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;自动转换就叫装箱</span><br><span class="line">        Integer it2 &#x3D; i;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-自动拆箱"><a class="header-anchor" href="#步骤-6-自动拆箱">¶</a>步骤 6 : 自动拆箱</h3>
<p>不需要调用Integer的intValue方法，通过=就自动转换成int类型，就叫拆箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">  </span><br><span class="line">        Integer it &#x3D; new Integer(i);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;封装类型转换成基本类型</span><br><span class="line">        int i2 &#x3D; it.intValue();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;自动转换就叫拆箱</span><br><span class="line">        int i3 &#x3D; it;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-int的最大值，最小值"><a class="header-anchor" href="#步骤-7-int的最大值，最小值">¶</a>步骤 7 : int的最大值，最小值</h3>
<p>int的最大值可以通过其对应的封装类Integer.MAX_VALUE获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;int的最大值</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line">        &#x2F;&#x2F;int的最小值      </span><br><span class="line">        System.out.println(Integer.MIN_VALUE);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-8-练习-装箱拆箱"><a class="header-anchor" href="#步骤-8-练习-装箱拆箱">¶</a>步骤 8 : 练习-装箱拆箱</h3>
<ol>
<li>
<p>对byte,short,float,double进行自动拆箱和自动装箱</p>
</li>
<li>
<p>byte和Integer之间能否进行自动拆箱和自动装箱</p>
</li>
<li>
<p>通过Byte获取byte的最大值</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test2()</span><br><span class="line">    &#123;</span><br><span class="line">        byte i &#x3D; 1;</span><br><span class="line">        short j &#x3D; 2;</span><br><span class="line">        float k &#x3D; 7.62f;</span><br><span class="line">        double l &#x3D; 5.56;</span><br><span class="line">        int m &#x3D; 128;</span><br><span class="line">        Integer n &#x3D; -128;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;byte的自动装箱和自动拆箱</span><br><span class="line">        Byte i1 &#x3D; i;</span><br><span class="line">        byte i2 &#x3D; i1;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;short的自动装箱和自动拆箱</span><br><span class="line">        Short j1 &#x3D; j;</span><br><span class="line">        short j2 &#x3D; j1;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;float的自动装箱和自动拆箱</span><br><span class="line">        Float k1 &#x3D; k;</span><br><span class="line">        float k2 &#x3D; k1;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;double的自动装箱和自动拆箱</span><br><span class="line">        Double l1 &#x3D; l;</span><br><span class="line">        double l2 &#x3D; l1;</span><br><span class="line">         </span><br><span class="line">&#x2F;&#x2F;      Integer i3 &#x3D; i;</span><br><span class="line">        Byte i4 &#x3D; (byte)m;  &#x2F;&#x2F;byte和Integer之间不能自动拆装箱，但可以通过强转类型，如 Integer i3 &#x3D; (int)i;    Byte i4 &#x3D; (byte)m; </span><br><span class="line">                            &#x2F;&#x2F;不过这有可能导致数据丢失</span><br><span class="line">        System.out.println(i4);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        System.out.println(Byte.MAX_VALUE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int i&#x3D;5;</span><br><span class="line">        Integer it&#x3D;new Integer(i);</span><br><span class="line">        int i2&#x3D;it.intValue();</span><br><span class="line">        int i3&#x3D;it;  &#x2F;&#x2F;拆箱</span><br><span class="line">        int i4&#x3D;i; &#x2F;&#x2F;装箱</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 装箱：&#x3D;号右边基本数据类型， &#x3D;号左边对象</span><br><span class="line">         * 拆箱：&#x3D;号右边对象， &#x3D;号左边基本数据类型</span><br><span class="line">         *&#x2F;</span><br><span class="line">        byte b&#x3D;2;</span><br><span class="line">        Byte bt&#x3D;new Byte(b);</span><br><span class="line">        byte b1&#x3D;bt.byteValue();</span><br><span class="line">        byte b2&#x3D;bt;  &#x2F;&#x2F;byte拆箱</span><br><span class="line">        Byte bt2&#x3D;b;   &#x2F;&#x2F;装箱</span><br><span class="line">        byte b3&#x3D;Byte.MAX_VALUE;  &#x2F;&#x2F;这是一个static属性</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        Byte btt&#x3D;new Byte(b);</span><br><span class="line">        byte bb&#x3D;btt.byteValue();</span><br><span class="line">&#x2F;&#x2F;      byte bb1&#x3D;it;  &#x2F;&#x2F;it拆箱成byte数据类型 不行</span><br><span class="line">        int ii&#x3D;btt;    &#x2F;&#x2F;btt拆箱成int数据类型是可以的</span><br><span class="line">&#x2F;&#x2F;      Byte btt1&#x3D;  ii;&#x2F;&#x2F; int 基本数据类型直接装箱成Byte是不行的</span><br><span class="line">&#x2F;&#x2F;      Integer itt&#x3D;  bb;&#x2F;&#x2F;byte装箱为Integer也是不行的</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拆箱的时候：</span><br><span class="line"> Byte bt 可拆成 int 类型</span><br><span class="line">Integer it不可拆成 byte 类型</span><br><span class="line"></span><br><span class="line">装箱的时候：</span><br><span class="line">不管是int装箱成Byte，还是byte装箱成Integer都需要强转</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package demo;</span><br><span class="line">&#x2F;&#x2F;byte转int需要强转，反之不需要！</span><br><span class="line">public class Test01 &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte b&#x3D;1;</span><br><span class="line">        short s&#x3D;2;</span><br><span class="line">        float f&#x3D;3f;</span><br><span class="line">        double d&#x3D;4.0;</span><br><span class="line">        &#x2F;&#x2F;自动装箱</span><br><span class="line">        Byte b1&#x3D; b;</span><br><span class="line">        Short s1&#x3D;s;</span><br><span class="line">        Float f1&#x3D; f;</span><br><span class="line">        Double d1&#x3D;d;</span><br><span class="line">        Integer i1&#x3D;(int) b;</span><br><span class="line">        &#x2F;&#x2F;自动拆箱</span><br><span class="line">        byte b2&#x3D;b1;</span><br><span class="line">        short s2&#x3D;s1;</span><br><span class="line">        float f2&#x3D;f1;</span><br><span class="line">        double d2&#x3D;d1;</span><br><span class="line">        int i&#x3D;b1;</span><br><span class="line">        System.out.println(b2+&quot;--&quot;+s2+&quot;--&quot;+f2+&quot;--&quot;+d2+&quot;---&quot;+i);</span><br><span class="line">        &#x2F;&#x2F;通过Byte获取byte最大值！</span><br><span class="line">        System.out.println(Byte.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA中把数字转换为字符"><a class="header-anchor" href="#2、JAVA中把数字转换为字符">¶</a>2、JAVA中把数字转换为字符</h2>
<h3 id="步骤-1-数字转字符串"><a class="header-anchor" href="#步骤-1-数字转字符串">¶</a>步骤 1 : 数字转字符串</h3>
<p>方法1： 使用String类的静态方法valueOf<br>
方法2： 先把基本类型装箱为对象，然后调用对象的toString</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;方法1</span><br><span class="line">        String str &#x3D; String.valueOf(i);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;方法2</span><br><span class="line">        Integer it &#x3D; i;</span><br><span class="line">        String str2 &#x3D; it.toString();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-字符串转数字"><a class="header-anchor" href="#步骤-2-字符串转数字">¶</a>步骤 2 : 字符串转数字</h3>
<p>调用Integer的静态方法parseInt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        String str &#x3D; &quot;999&quot;;</span><br><span class="line">         </span><br><span class="line">        int i&#x3D; Integer.parseInt(str);</span><br><span class="line">         </span><br><span class="line">        System.out.println(i);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-字符串转换"><a class="header-anchor" href="#步骤-3-练习-字符串转换">¶</a>步骤 3 : 练习-字符串转换</h3>
<p>参考上述步骤<br>
把浮点数 3.14 转换为 字符串 “3.14”<br>
再把字符串 “3.14” 转换为 浮点数 3.14</p>
<p>如果字符串是 3.1a4，转换为浮点数会得到什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数字转换为字符串</span><br><span class="line">       float f1 &#x3D; 3.14f;</span><br><span class="line">       String string &#x3D; String.valueOf(f1);</span><br><span class="line">       System.out.println(f1);</span><br><span class="line">       Float f2 &#x3D; f1;</span><br><span class="line">       String string2 &#x3D; f2.toString();</span><br><span class="line">       System.out.println(f2);</span><br><span class="line"> </span><br><span class="line">       &#x2F;&#x2F;字符串转换为数字</span><br><span class="line">       String string3 &#x3D; &quot;3.1415&quot;;</span><br><span class="line">       float f3 &#x3D; Float.parseFloat(string3);</span><br><span class="line">       System.out.println(f3);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;3.1a4&quot;</span><br><span class="line">       String string4&#x3D;&quot;3.1a4&quot;;</span><br><span class="line">       float f4&#x3D;Float.parseFloat(string4);</span><br><span class="line">       System.out.println(f4);</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F;会抛出转型异常</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA-MATH类常用方法"><a class="header-anchor" href="#3、JAVA-MATH类常用方法">¶</a>3、JAVA MATH类常用方法</h2>
<h3 id="步骤-1-四舍五入-随机数，开方，次方，π，自然常数"><a class="header-anchor" href="#步骤-1-四舍五入-随机数，开方，次方，π，自然常数">¶</a>步骤 1 : 四舍五入, 随机数，开方，次方，π，自然常数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        float f1 &#x3D; 5.4f;</span><br><span class="line">        float f2 &#x3D; 5.5f;</span><br><span class="line">        &#x2F;&#x2F;5.4四舍五入即5</span><br><span class="line">        System.out.println(Math.round(f1));</span><br><span class="line">        &#x2F;&#x2F;5.5四舍五入即6</span><br><span class="line">        System.out.println(Math.round(f2));</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;得到一个0-1之间的随机浮点数（取不到1）</span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;得到一个0-10之间的随机整数 （取不到10）</span><br><span class="line">        System.out.println((int)( Math.random()*10));</span><br><span class="line">        &#x2F;&#x2F;开方</span><br><span class="line">        System.out.println(Math.sqrt(9));</span><br><span class="line">        &#x2F;&#x2F;次方（2的4次方）</span><br><span class="line">        System.out.println(Math.pow(2,4));</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;π</span><br><span class="line">        System.out.println(Math.PI);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;自然常数</span><br><span class="line">        System.out.println(Math.E);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-数学方法"><a class="header-anchor" href="#步骤-2-练习-数学方法">¶</a>步骤 2 : 练习-数学方法</h3>
<p>这个图是自然对数的计算方式。<br>
借助Math的方法，把自然对数计算出来，看看经过自己计算的自然对数和Math.E的区别有多大</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2326.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int n&#x3D;100000;</span><br><span class="line">        double di&#x3D; ((double)1)&#x2F;n+1;</span><br><span class="line">        System.out.println(di);</span><br><span class="line">        System.out.println(Math.pow( di,n));</span><br><span class="line">        System.out.println(Math.E);</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-质数"><a class="header-anchor" href="#步骤-3-练习-质数">¶</a>步骤 3 : 练习-质数</h3>
<p>统计找出一千万以内，一共有多少质数</p>
<p>质数概念: 只能被1和自己整除的数<br>
举例:<br>
5只能被 1和5整除，所以是质数<br>
8可以被2整除，所以不是质数</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2331.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        int n &#x3D; 100000;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        int j;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            for (j &#x3D; 1; j &lt; i; j++) &#123;</span><br><span class="line">                if(i%j&#x3D;&#x3D;0&amp;&amp;j!&#x3D;1)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&#x3D;&#x3D;j&amp;&amp;i!&#x3D;1)</span><br><span class="line">                sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、JAVA-使用PRINTF或FORMAT-进行格式化输出"><a class="header-anchor" href="#4、JAVA-使用PRINTF或FORMAT-进行格式化输出">¶</a>4、JAVA 使用PRINTF或FORMAT 进行格式化输出</h2>
<h3 id="步骤-1-格式化输出"><a class="header-anchor" href="#步骤-1-格式化输出">¶</a>步骤 1 : 格式化输出</h3>
<p>如果不使用格式化输出，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐<br>
使用格式化输出，就可以简洁明了</p>
<p>%s 表示字符串<br>
%d 表示数字<br>
%n 表示换行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        String name &#x3D;&quot;盖伦&quot;;</span><br><span class="line">        int kill &#x3D; 8;</span><br><span class="line">        String title&#x3D;&quot;超神&quot;;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;直接使用+进行字符串连接，编码感觉会比较繁琐，并且维护性差,易读性差</span><br><span class="line">        String sentence &#x3D; name+ &quot; 在进行了连续 &quot; + kill + &quot; 次击杀后，获得了 &quot; + title +&quot; 的称号&quot;;</span><br><span class="line">         </span><br><span class="line">        System.out.println(sentence);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;使用格式化输出</span><br><span class="line">        &#x2F;&#x2F;%s表示字符串，%d表示数字,%n表示换行</span><br><span class="line">        String sentenceFormat &#x3D;&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;</span><br><span class="line">        System.out.printf(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-printf和format"><a class="header-anchor" href="#步骤-2-printf和format">¶</a>步骤 2 : printf和format</h3>
<p>printf和format能够达到一模一样的效果，[如何通过eclipse查看java源代码]可以看到，在printf中直接调用了format</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/680.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        String name &#x3D;&quot;盖伦&quot;;</span><br><span class="line">        int kill &#x3D; 8;</span><br><span class="line">        String title&#x3D;&quot;超神&quot;;</span><br><span class="line">         </span><br><span class="line">        String sentenceFormat &#x3D;&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;</span><br><span class="line">        &#x2F;&#x2F;使用printf格式化输出</span><br><span class="line">        System.out.printf(sentenceFormat,name,kill,title);</span><br><span class="line">        &#x2F;&#x2F;使用format格式化输出</span><br><span class="line">        System.out.format(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-换行符"><a class="header-anchor" href="#步骤-3-换行符">¶</a>步骤 3 : 换行符</h3>
<p><strong>换行符</strong>就是另起一行 — ‘\n’ 换行（newline）<br>
<strong>回车符</strong>就是回到一行的开头 — ‘\r’ 回车（return）<br>
在eclipse里敲一个回车，实际上是<strong>回车换行符</strong><br>
Java是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如Windows,Linux,Mac<br>
然而在不同的操作系统，换行符是不一样的<br>
（1）在DOS和Windows中，每行结尾是 “\r\n”；<br>
（2）Linux系统里，每行结尾只有 “\n”；<br>
（3）Mac系统里，每行结尾是只有 “\r”。<br>
为了使得同一个java程序的换行符在所有的操作系统中都有一样的表现，使用%n，就可以做到平台无关的换行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        System.out.printf(&quot;这是换行符%n&quot;);</span><br><span class="line">        System.out.printf(&quot;这是换行符%n&quot;);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达"><a class="header-anchor" href="#步骤-4-总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达">¶</a>步骤 4 : 总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</h3>
<p>其他常用的格式化方式</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/683.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">import java.util.Locale;</span><br><span class="line">   </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int year &#x3D; 2020;</span><br><span class="line">        &#x2F;&#x2F;总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;直接打印数字</span><br><span class="line">        System.out.format(&quot;%d%n&quot;,year);</span><br><span class="line">        &#x2F;&#x2F;总长度是8,默认右对齐</span><br><span class="line">        System.out.format(&quot;%8d%n&quot;,year);</span><br><span class="line">        &#x2F;&#x2F;总长度是8,左对齐</span><br><span class="line">        System.out.format(&quot;%-8d%n&quot;,year);</span><br><span class="line">        &#x2F;&#x2F;总长度是8,不够补0</span><br><span class="line">        System.out.format(&quot;%08d%n&quot;,year);</span><br><span class="line">        &#x2F;&#x2F;千位分隔符</span><br><span class="line">        System.out.format(&quot;%,8d%n&quot;,year*10000);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;小数点位数</span><br><span class="line">        System.out.format(&quot;%.2f%n&quot;,Math.PI);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;不同国家的千位分隔符</span><br><span class="line">        System.out.format(Locale.FRANCE,&quot;%,.2f%n&quot;,Math.PI*10000);</span><br><span class="line">        System.out.format(Locale.US,&quot;%,.2f%n&quot;,Math.PI*10000);</span><br><span class="line">        System.out.format(Locale.UK,&quot;%,.2f%n&quot;,Math.PI*10000);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-黄鹤"><a class="header-anchor" href="#步骤-5-练习-黄鹤">¶</a>步骤 5 : 练习-黄鹤</h3>
<p>借助[Scanner]读取字符串数据，然后用格式化输出下面</p>
<p><strong>浙江温州</strong>最大<strong>皮革厂   江南皮革厂</strong>倒闭了，王八蛋老板<strong>黄鹤</strong>吃喝嫖赌，欠下了<strong>3.5</strong>个亿，带着他的小姨子跑了!我们没有办法，拿着<strong>钱包</strong>抵工资!原价都是一<strong>百</strong>多、两<strong>百</strong>多、三<strong>百</strong>多的<strong>钱包</strong>，现在全部只卖二十块，统统只要二十块!<strong>黄鹤</strong>王八蛋，你不是人!我们辛辛苦苦给你干了大半年，你不发工资，你还我血汗钱，还我血汗钱!</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2199.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class LeagueSwitch &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner&#x3D;new Scanner(System.in);</span><br><span class="line"> </span><br><span class="line">       System.out.println(&quot;请输入地名：&quot;);</span><br><span class="line">        String city&#x3D;scanner.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入公司类型：&quot;);</span><br><span class="line">        String com&#x3D;scanner.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入公司名称：&quot;);</span><br><span class="line">        String name&#x3D;scanner.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入老板名称：&quot;);</span><br><span class="line">        String boss&#x3D;scanner.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入金额：&quot;);</span><br><span class="line">        String money&#x3D;scanner.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入产品：&quot;);</span><br><span class="line">        String product&#x3D;scanner.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入价格计量单位：&quot;);</span><br><span class="line">        String danwei&#x3D;scanner.nextLine();</span><br><span class="line">        String string&#x3D;&quot;%s最大%s %s倒闭了，王八蛋老板%s吃喝嫖赌，欠下了%s个亿，带着他的小姨子跑了!%n我们没有办法，拿着&quot;</span><br><span class="line">                + &quot;%s抵工资!原价都是一%s多、两%s多、三%s多的%s，现在全部只卖二十块，统统只要二十块!%n%s王八蛋，你不是人!我们辛辛苦苦给你干了大半年，你不发工资，你还我血汗钱，还我血汗钱! &quot;;</span><br><span class="line">        System.out.printf(string,city,com,name,boss,money,product,danwei,danwei,danwei,product,boss);</span><br><span class="line">    scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、JAVA中的字符详解"><a class="header-anchor" href="#5、JAVA中的字符详解">¶</a>5、JAVA中的字符详解</h2>
<h3 id="示例-1-保存一个字符的时候使用char"><a class="header-anchor" href="#示例-1-保存一个字符的时候使用char">¶</a>示例 1 : 保存一个字符的时候使用char</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class TestChar &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char c1 &#x3D; &#39;a&#39;;</span><br><span class="line">        char c2 &#x3D; &#39;1&#39;;&#x2F;&#x2F;字符1,而非数字1</span><br><span class="line">        char c3 &#x3D; &#39;中&#39;;&#x2F;&#x2F;汉字字符</span><br><span class="line">        char c4 &#x3D; &#39;ab&#39;; &#x2F;&#x2F;只能放一个字符</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-char对应的封装类"><a class="header-anchor" href="#示例-2-char对应的封装类">¶</a>示例 2 : char对应的封装类</h3>
<p>char对应的封装类是Character<br>
装箱拆箱概念，参考 [拆箱装箱]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class TestChar &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char c1 &#x3D; &#39;a&#39;;</span><br><span class="line">        Character c &#x3D; c1; &#x2F;&#x2F;自动装箱</span><br><span class="line">        c1 &#x3D; c;&#x2F;&#x2F;自动拆箱</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-Character常见方法"><a class="header-anchor" href="#示例-3-Character常见方法">¶</a>示例 3 : Character常见方法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class TestChar &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.isLetter(&#39;a&#39;));&#x2F;&#x2F;判断是否为字母</span><br><span class="line">        System.out.println(Character.isDigit(&#39;a&#39;)); &#x2F;&#x2F;判断是否为数字</span><br><span class="line">        System.out.println(Character.isWhitespace(&#39; &#39;)); &#x2F;&#x2F;是否是空白</span><br><span class="line">        System.out.println(Character.isUpperCase(&#39;a&#39;)); &#x2F;&#x2F;是否是大写</span><br><span class="line">        System.out.println(Character.isLowerCase(&#39;a&#39;)); &#x2F;&#x2F;是否是小写</span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.toUpperCase(&#39;a&#39;)); &#x2F;&#x2F;转换为大写</span><br><span class="line">        System.out.println(Character.toLowerCase(&#39;A&#39;)); &#x2F;&#x2F;转换为小写</span><br><span class="line"> </span><br><span class="line">        String a &#x3D; &#39;a&#39;; &#x2F;&#x2F;不能够直接把一个字符转换成字符串</span><br><span class="line">        String a2 &#x3D; Character.toString(&#39;a&#39;); &#x2F;&#x2F;转换为字符串</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-常见转义"><a class="header-anchor" href="#示例-4-常见转义">¶</a>示例 4 : 常见转义</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/696.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public class TestChar &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;使用空格无法达到对齐的效果&quot;);</span><br><span class="line">        System.out.println(&quot;abc def&quot;);</span><br><span class="line">        System.out.println(&quot;ab def&quot;);</span><br><span class="line">        System.out.println(&quot;a def&quot;);</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;使用\\t制表符可以达到对齐的效果&quot;);</span><br><span class="line">        System.out.println(&quot;abc\tdef&quot;);</span><br><span class="line">        System.out.println(&quot;ab\tdef&quot;);</span><br><span class="line">        System.out.println(&quot;a\tdef&quot;);</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;一个\\t制表符长度是8&quot;);</span><br><span class="line">        System.out.println(&quot;12345678def&quot;);</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;换行符 \\n&quot;);</span><br><span class="line">        System.out.println(&quot;abc\ndef&quot;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;单引号 \\&#39;&quot;);</span><br><span class="line">        System.out.println(&quot;abc\&#39;def&quot;);</span><br><span class="line">        System.out.println(&quot;双引号 \\\&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;abc\&quot;def&quot;);</span><br><span class="line">        System.out.println(&quot;反斜杠本身 \\&quot;);</span><br><span class="line">        System.out.println(&quot;abc\\def&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-练习-Character"><a class="header-anchor" href="#示例-5-练习-Character">¶</a>示例 5 : 练习-Character</h3>
<p>通过[Scanner]从控制台读取字符串，然后把[字符串转换为字符数组]<br>
参考的转换方式:</p>
<p>String str = “abc123”;</p>
<p>char[] cs = str.toCharArray();</p>
<p>转换为字符数组后，筛选出控制台读取到的字符串中的大写字母和数字，并打印出来</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2328.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class TestChar &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner ac &#x3D; new Scanner(System.in);</span><br><span class="line">		String abc &#x3D; ac.nextLine();</span><br><span class="line">		char[] cs &#x3D; abc.toCharArray();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; cs.length; i++) &#123;</span><br><span class="line">			if (Character.isUpperCase(cs[i]) || Character.isDigit(cs[i]))</span><br><span class="line">				System.out.print(cs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、JAVA中的字符串STRING详解"><a class="header-anchor" href="#6、JAVA中的字符串STRING详解">¶</a>6、JAVA中的字符串STRING详解</h2>
<h3 id="示例-1-创建字符串"><a class="header-anchor" href="#示例-1-创建字符串">¶</a>示例 1 : 创建字符串</h3>
<p>字符串即字符的组合，在Java中，字符串是一个类，所以我们见到的字符串都是对象<br>
常见创建字符串手段：</p>
<ol>
<li>
<p>每当有一个<strong>字面值</strong>出现的时候，虚拟机就会创建一个字符串</p>
</li>
<li>
<p>调用String的构造方法创建一个字符串对象</p>
</li>
<li>
<p>通过+加号进行字符串拼接也会创建新的字符串对象</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class TestString &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String garen &#x3D;&quot;盖伦&quot;; &#x2F;&#x2F;字面值,虚拟机碰到字面值就会创建一个字符串对象</span><br><span class="line">         </span><br><span class="line">        String teemo &#x3D; new String(&quot;提莫&quot;); &#x2F;&#x2F;创建了两个字符串对象</span><br><span class="line">         </span><br><span class="line">        char[] cs &#x3D; new char[]&#123;&#39;崔&#39;,&#39;斯&#39;,&#39;特&#39;&#125;;</span><br><span class="line">         </span><br><span class="line">        String hero &#x3D; new String(cs);&#x2F;&#x2F;  通过字符数组创建一个字符串对象</span><br><span class="line">         </span><br><span class="line">        String hero3 &#x3D; garen + teemo;&#x2F;&#x2F;  通过+加号进行字符串拼接</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-final"><a class="header-anchor" href="#示例-2-final">¶</a>示例 2 : final</h3>
<p>String 被修饰为final,所以是不能被继承的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class TestString &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyString str &#x3D; new MyString();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">        &#x2F;*这里会报错，因为String不能被继承*&#x2F;</span><br><span class="line">    static class MyString extends String&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-immutable"><a class="header-anchor" href="#示例-3-immutable">¶</a>示例 3 : immutable</h3>
<p>immutable 是指不可改变的<br>
比如创建了一个字符串对象<br>
String garen =“盖伦”;<br>
<strong>不可改变</strong>的具体含义是指：<br>
不能增加长度<br>
不能减少长度<br>
不能插入字符<br>
不能删除字符<br>
不能修改字符<br>
一旦创建好这个字符串，里面的内容 <strong>永远</strong> 不能改变</p>
<p>String 的表现就像是一个<strong>常量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public  class TestString &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String garen &#x3D;&quot;盖伦&quot;;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-字符串格式化"><a class="header-anchor" href="#示例-4-字符串格式化">¶</a>示例 4 : 字符串格式化</h3>
<p>如果不使用字符串格式化，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐<br>
使用<strong>字符串格式化</strong>，就可以<strong>简洁明了</strong><br>
更多的格式化规则，参考[格式化输出]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">   </span><br><span class="line">public class TestString &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        String name &#x3D;&quot;盖伦&quot;;</span><br><span class="line">        int kill &#x3D; 8;</span><br><span class="line">        String title&#x3D;&quot;超神&quot;;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;直接使用+进行字符串连接，编码感觉会比较繁琐，并且维护性差,易读性差</span><br><span class="line">        String sentence &#x3D; name+ &quot; 在进行了连续 &quot; + kill + &quot; 次击杀后，获得了 &quot; + title +&quot; 的称号&quot;;</span><br><span class="line">          </span><br><span class="line">        System.out.println(sentence);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;格式化字符串</span><br><span class="line">        &#x2F;&#x2F;%s表示字符串，%d表示数字,%n表示换行</span><br><span class="line">        String sentenceFormat &#x3D;&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;</span><br><span class="line">         </span><br><span class="line">        String sentence2 &#x3D; String.format(sentenceFormat, name,kill,title);</span><br><span class="line">         </span><br><span class="line">        System.out.println(sentence2);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-字符串长度"><a class="header-anchor" href="#示例-5-字符串长度">¶</a>示例 5 : 字符串长度</h3>
<p>length方法返回当前字符串的长度<br>
可以有长度为0的字符串,即空字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">   </span><br><span class="line">public class TestString &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        String name &#x3D;&quot;盖伦&quot;;</span><br><span class="line">         </span><br><span class="line">        System.out.println(name.length());</span><br><span class="line">         </span><br><span class="line">        String unknowHero &#x3D; &quot;&quot;;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;可以有长度为0的字符串,即空字符串</span><br><span class="line">        System.out.println(unknowHero.length());</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-练习-随机字符串"><a class="header-anchor" href="#示例-6-练习-随机字符串">¶</a>示例 6 : 练习-随机字符串</h3>
<p>创建一个长度是5的随机字符串，随机字符有可能是数字，大写字母或者小写字母</p>
<p><strong>给点提示:</strong> 数字和字符之间可以通过互相转换</p>
<p>char c = ‘A’;</p>
<p>short s = (short) c;</p>
<p>通过这个手段就能够知道字符 a-z A-Z 0-9 所对应的数字的区间了</p>
<p>需要用到[ASCII码]对照表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        char []cs&#x3D;new char [5];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; cs.length; i++) &#123;</span><br><span class="line">            int c&#x3D;(int) (Math.random()*(126-33)+33);</span><br><span class="line">            cs[i]&#x3D;(char)c;</span><br><span class="line">            System.out.print(cs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-7-练习-字符串数组排序"><a class="header-anchor" href="#示例-7-练习-字符串数组排序">¶</a>示例 7 : 练习-字符串数组排序</h3>
<p>创建一个长度是8的字符串数组<br>
使用8个长度是5的随机字符串初始化这个数组<br>
对这个数组进行排序，按照每个字符串的首字母排序(无视大小写)</p>
<p><strong>注</strong>1： 不能使用Arrays.sort() 要自己写<br>
<strong>注</strong>2： 无视大小写，即 Axxxx 和 axxxxx 没有先后顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">&#x2F;*创建一个长度是8的字符串数组</span><br><span class="line">使用8个长度是5的随机字符串初始化这个数组</span><br><span class="line">对这个数组进行排序，按照每个字符串的首字母排序(无视大小写)*&#x2F;</span><br><span class="line">public class TestString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建长度是8的字符串数组</span><br><span class="line">        String s[]&#x3D;new String[8];</span><br><span class="line">        createString(s);</span><br><span class="line">        show(s);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;展示结果</span><br><span class="line">    private static void show(String[] s) &#123;</span><br><span class="line">        toLowercase(s);</span><br><span class="line">        System.out.println(&quot;排序后的字符串：&quot;);</span><br><span class="line">        bubbleSort(s);</span><br><span class="line">        for(String str:s)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;忽略大写字母</span><br><span class="line">    private static void toLowercase(String[] s) &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;s.length;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;将字符串里的字母转换为小写字母</span><br><span class="line">            s[i]&#x3D;s[i].toLowerCase();</span><br><span class="line">            &#x2F;&#x2F;打印转换为小写后的字符串</span><br><span class="line">            System.out.println(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;冒泡排序  对这个数组进行排序</span><br><span class="line">    private static void bubbleSort(String[] s) &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;s.length;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;s.length-i-1;j++)&#123;</span><br><span class="line">                if(s[j].compareTo(s[j+1])&gt;0)&#123;&#x2F;&#x2F;compareTo:将两个数进行比较</span><br><span class="line">                    String temp&#x3D;s[j];</span><br><span class="line">                    s[j]&#x3D;s[j+1];</span><br><span class="line">                    s[j+1]&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;生成字符串    使用8个长度是5的随机字符串初始化这个数组</span><br><span class="line">    private static void createString(String[] s) &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;8;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;Stringbuilder搜索类是直接用于字符串操作的类</span><br><span class="line">            StringBuilder stringBuilder&#x3D;new StringBuilder();</span><br><span class="line">            for(int j&#x3D;0;j&lt;5;j++)&#123;</span><br><span class="line">                stringBuilder.append(creatChar());</span><br><span class="line">            &#125;</span><br><span class="line">            s[i]&#x3D;String.valueOf(stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;生成[a-z|A-Z]字符</span><br><span class="line">    private static Object creatChar() &#123;</span><br><span class="line">        boolean flag&#x3D;Math.floor(Math.random()*(2-1+1)+1)&#x3D;&#x3D;1?true:false;</span><br><span class="line">        if(flag)</span><br><span class="line">            return (char)Math.floor(Math.random()*(90-65+1)+65);&#x2F;&#x2F;A-Z  65-90</span><br><span class="line">        else</span><br><span class="line">            return (char)Math.floor(Math.random()*(122-97+1)+97);&#x2F;&#x2F;a-z  97-122</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-8-练习-穷举法破解密码"><a class="header-anchor" href="#示例-8-练习-穷举法破解密码">¶</a>示例 8 : 练习-穷举法破解密码</h3>
<ol>
<li>
<p>生成一个长度是3的[随机字符串]，把这个字符串作为当做密码</p>
</li>
<li>
<p>使用穷举法生成长度是3个字符串，匹配上述生成的密码</p>
</li>
</ol>
<p>要求： 分别使用多层for循环 和 递归解决上述问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class TestArray &#123;</span><br><span class="line">	 public static void main(String[] args) &#123;</span><br><span class="line">	        &#x2F;&#x2F;生成一个长度是3的随机字符串，把这个字符串作为当做密码</span><br><span class="line">	        String str &#x3D; getString();</span><br><span class="line">	        System.out.println(str);</span><br><span class="line">	         </span><br><span class="line">	        &#x2F;&#x2F;将数字，大小写字母放入数组</span><br><span class="line">	        int count &#x3D; 0;</span><br><span class="line">	        char[] ch &#x3D; new char[62];</span><br><span class="line">	        for(int i &#x3D; 48; i&lt;&#x3D; 122; i++) &#123;</span><br><span class="line">	            if(Character.isDigit(i)) &#123;</span><br><span class="line">	                ch[count] &#x3D;(char) i;</span><br><span class="line">	                count++;</span><br><span class="line">	            &#125;else if(Character.isUpperCase(i)) &#123;</span><br><span class="line">	                ch[count] &#x3D; (char) i;</span><br><span class="line">	                count++;</span><br><span class="line">	            &#125;else if(Character.isLowerCase(i)) &#123;</span><br><span class="line">	                ch[count] &#x3D; (char) i;</span><br><span class="line">	                count++;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	         </span><br><span class="line">	        &#x2F;&#x2F;创建三个字符串，将上面数组的元素循环分别赋给三个字符，三个字符转成字符串，字符串相加赋给str2</span><br><span class="line">	        &#x2F;&#x2F;再判断两个字符串是否相等，如果相等结束循环，打印密码。</span><br><span class="line">	        String s1 &#x3D; null,s2 &#x3D; null,s3 &#x3D; null;</span><br><span class="line">	        for(int i&#x3D;0; i&lt;ch.length; i++) &#123;</span><br><span class="line">	            System.out.println(&quot;密码破译中~~~~~&quot;);</span><br><span class="line">	            for(int j&#x3D;0; j&lt;ch.length; j++) &#123;</span><br><span class="line">	                for(int h&#x3D;0; h&lt;ch.length; h++) &#123;</span><br><span class="line">	                    s1 &#x3D; String.valueOf(ch[i]);</span><br><span class="line">	                    s2 &#x3D; String.valueOf(ch[j]);</span><br><span class="line">	                    s3 &#x3D; String.valueOf(ch[h]);                 </span><br><span class="line">	                    String str2 &#x3D; s1+s2+s3;</span><br><span class="line">	                    if(str.equals(str2)) &#123;</span><br><span class="line">	                        System.out.println(&quot;破译成功！密码为：&quot;+str2);</span><br><span class="line">	                        return;</span><br><span class="line">	                    &#125;       </span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">	     </span><br><span class="line">	    &#x2F;&#x2F;得到三位随机字符串的方法</span><br><span class="line">	    private static String getString() &#123;</span><br><span class="line">	        Random random &#x3D; new Random();</span><br><span class="line">	        char[] cha &#x3D; new char[3];</span><br><span class="line">	        int[] in1 &#x3D; new int[3];</span><br><span class="line">	        for(int i &#x3D;0; i&lt;in1.length; i++) &#123;</span><br><span class="line">	            in1[i] &#x3D; random.nextInt(3);</span><br><span class="line">	            if(in1[i]&#x3D;&#x3D;0) &#123;</span><br><span class="line">	                cha[i] &#x3D; (char)(&#39;0&#39;+random.nextInt(10));</span><br><span class="line">	            &#125;else if(in1[i]&#x3D;&#x3D;1) &#123;</span><br><span class="line">	                cha[i] &#x3D; (char)(random.nextInt(26)+65);</span><br><span class="line">	            &#125;else if(in1[i]&#x3D;&#x3D;2) &#123;</span><br><span class="line">	                cha[i] &#x3D; (char)(random.nextInt(26)+97); </span><br><span class="line">	            &#125;       </span><br><span class="line">	        &#125;</span><br><span class="line">	        String str &#x3D; new String(cha);       </span><br><span class="line">	        return str; </span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、JAVA常见字符串方法"><a class="header-anchor" href="#7、JAVA常见字符串方法">¶</a>7、JAVA常见字符串方法</h2>
<h3 id="示例-1-获取字符"><a class="header-anchor" href="#示例-1-获取字符">¶</a>示例 1 : 获取字符</h3>
<p>charAt(int index)获取指定位置的字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence &#x3D; &quot;盖伦,在进行了连续8次击杀后,获得了 超神 的称号&quot;;</span><br><span class="line">         </span><br><span class="line">        char c &#x3D; sentence.charAt(0);</span><br><span class="line">         </span><br><span class="line">        System.out.println(c);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-获取对应的字符数组"><a class="header-anchor" href="#示例-2-获取对应的字符数组">¶</a>示例 2 : 获取对应的字符数组</h3>
<p>toCharArray()<br>
获取对应的字符数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence &#x3D; &quot;盖伦,在进行了连续8次击杀后,获得了超神 的称号&quot;;</span><br><span class="line"> </span><br><span class="line">        char[] cs &#x3D; sentence.toCharArray(); &#x2F;&#x2F;获取对应的字符数组</span><br><span class="line">         </span><br><span class="line">        System.out.println(sentence.length() &#x3D;&#x3D; cs.length);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-截取子字符串"><a class="header-anchor" href="#示例-3-截取子字符串">¶</a>示例 3 : 截取子字符串</h3>
<p>subString<br>
截取子字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence &#x3D; &quot;盖伦,在进行了连续8次击杀后,获得了 超神 的称号&quot;;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;截取从第3个开始的字符串 （基0）</span><br><span class="line">        String subString1 &#x3D; sentence.substring(3);</span><br><span class="line">         </span><br><span class="line">        System.out.println(subString1);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;截取从第3个开始的字符串 （基0）</span><br><span class="line">        &#x2F;&#x2F;到5-1的位置的字符串</span><br><span class="line">        &#x2F;&#x2F;左闭右开</span><br><span class="line">        String subString2 &#x3D; sentence.substring(3,5);</span><br><span class="line">         </span><br><span class="line">        System.out.println(subString2);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-分隔"><a class="header-anchor" href="#示例-4-分隔">¶</a>示例 4 : 分隔</h3>
<p>split<br>
根据分隔符进行分隔</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence &#x3D; &quot;盖伦,在进行了连续8次击杀后,获得了 超神 的称号&quot;;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;根据,进行分割，得到3个子字符串</span><br><span class="line">        String subSentences[] &#x3D; sentence.split(&quot;,&quot;);</span><br><span class="line">        for (String sub : subSentences) &#123;</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-去掉首尾空格"><a class="header-anchor" href="#示例-5-去掉首尾空格">¶</a>示例 5 : 去掉首尾空格</h3>
<p>trim<br>
去掉首尾空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence &#x3D; &quot;        盖伦,在进行了连续8次击杀后,获得了 超神 的称号      &quot;;</span><br><span class="line">         </span><br><span class="line">        System.out.println(sentence);</span><br><span class="line">        &#x2F;&#x2F;去掉首尾空格</span><br><span class="line">        System.out.println(sentence.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-大小写"><a class="header-anchor" href="#示例-6-大小写">¶</a>示例 6 : 大小写</h3>
<p>toLowerCase 全部变成小写<br>
toUpperCase 全部变成大写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence &#x3D; &quot;Garen&quot;;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;全部变成小写</span><br><span class="line">        System.out.println(sentence.toLowerCase());</span><br><span class="line">        &#x2F;&#x2F;全部变成大写</span><br><span class="line">        System.out.println(sentence.toUpperCase());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-7-定位"><a class="header-anchor" href="#示例-7-定位">¶</a>示例 7 : 定位</h3>
<p>indexOf 判断字符或者子字符串出现的位置<br>
contains 是否包含子字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">     </span><br><span class="line">public class TestString &#123;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">        String sentence &#x3D; &quot;盖伦,在进行了连续8次击杀后,获得了超神 的称号&quot;;</span><br><span class="line">  </span><br><span class="line">        System.out.println(sentence.indexOf(&#39;8&#39;)); &#x2F;&#x2F;字符第一次出现的位置</span><br><span class="line">          </span><br><span class="line">        System.out.println(sentence.indexOf(&quot;超神&quot;)); &#x2F;&#x2F;字符串第一次出现的位置</span><br><span class="line">          </span><br><span class="line">        System.out.println(sentence.lastIndexOf(&quot;了&quot;)); &#x2F;&#x2F;字符串最后出现的位置</span><br><span class="line">          </span><br><span class="line">        System.out.println(sentence.indexOf(&#39;,&#39;,5)); &#x2F;&#x2F;从位置5开始，出现的第一次,的位置</span><br><span class="line">          </span><br><span class="line">        System.out.println(sentence.contains(&quot;击杀&quot;)); &#x2F;&#x2F;是否包含字符串&quot;击杀&quot;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-8-替换"><a class="header-anchor" href="#示例-8-替换">¶</a>示例 8 : 替换</h3>
<p>replaceAll 替换所有的<br>
replaceFirst 只替换第一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence &#x3D; &quot;盖伦,在进行了连续8次击杀后,获得了超神 的称号&quot;;</span><br><span class="line"> </span><br><span class="line">        String temp &#x3D; sentence.replaceAll(&quot;击杀&quot;, &quot;被击杀&quot;); &#x2F;&#x2F;替换所有的</span><br><span class="line">         </span><br><span class="line">        temp &#x3D; temp.replaceAll(&quot;超神&quot;, &quot;超鬼&quot;);</span><br><span class="line">         </span><br><span class="line">        System.out.println(temp);</span><br><span class="line">         </span><br><span class="line">        temp &#x3D; sentence.replaceFirst(&quot;,&quot;,&quot;&quot;);&#x2F;&#x2F;只替换第一个</span><br><span class="line">         </span><br><span class="line">        System.out.println(temp);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-9-练习-每个单词的首字母都转换为大写"><a class="header-anchor" href="#示例-9-练习-每个单词的首字母都转换为大写">¶</a>示例 9 : 练习-每个单词的首字母都转换为大写</h3>
<p>给出一句英文句子： “let there be light”<br>
得到一个新的字符串，每个单词的首字母都转换为大写</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2360.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        String s &#x3D;&quot;let there be light&quot;;</span><br><span class="line">        String[] temp &#x3D;s.split(&quot; &quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;temp.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            String str &#x3D;  temp[i];</span><br><span class="line">            char firstC &#x3D; Character.toUpperCase(str.charAt(0));</span><br><span class="line">            String a &#x3D; str.substring(1);</span><br><span class="line">            String b &#x3D;firstC+a;</span><br><span class="line">            temp[i]&#x3D;b;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        String test&#x3D;&quot;&quot;;</span><br><span class="line">        for (String str:temp)</span><br><span class="line">        &#123;</span><br><span class="line">            test+&#x3D;str+&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-10-练习-英文绕口令"><a class="header-anchor" href="#示例-10-练习-英文绕口令">¶</a>示例 10 : 练习-英文绕口令</h3>
<p>英文绕口令<br>
peter piper picked a peck of pickled peppers<br>
统计这段绕口令有多少个以p开头的单词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		 </span><br><span class="line">        String statistic &#x3D;&quot;peter piper picked a peck of pickled peppers&quot;;</span><br><span class="line">        String [] str &#x3D;statistic.split(&quot; &quot;);</span><br><span class="line">        int pNumber&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.length;i++)&#123;</span><br><span class="line">            if(str[i].charAt(0)&#x3D;&#x3D;&#39;p&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                pNumber++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;这个字符串共有%d个p开头的单词&quot;,pNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-11-练习-间隔大写小写模式"><a class="header-anchor" href="#示例-11-练习-间隔大写小写模式">¶</a>示例 11 : 练习-间隔大写小写模式</h3>
<p>把 lengendary 改成间隔大写小写模式，即 LeNgEnDaRy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		 </span><br><span class="line">        String str &#x3D;&quot;lengendary&quot;;</span><br><span class="line">        char[] ch &#x3D; str.toCharArray();</span><br><span class="line">        for(int i&#x3D;0 ;i&lt;ch.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%2&#x3D;&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                ch[i]&#x3D;Character.toUpperCase(ch[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String s&#x3D;new String(ch);</span><br><span class="line">        System.out.println(&quot;以偶数为间隔修改字符串:&quot;+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-12-练习-最后一个字母变大写"><a class="header-anchor" href="#示例-12-练习-最后一个字母变大写">¶</a>示例 12 : 练习-最后一个字母变大写</h3>
<p>把 lengendary 最后一个字母变大写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		 </span><br><span class="line">        String str &#x3D;&quot;lengendary&quot;;</span><br><span class="line">        char[] ch &#x3D; str.toCharArray();</span><br><span class="line">        for(int i&#x3D;0 ;i&lt;ch.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&#x3D;&#x3D;ch.length-1)</span><br><span class="line">            &#123;</span><br><span class="line">                ch[i]&#x3D;Character.toUpperCase(ch[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String s&#x3D;new String(ch);</span><br><span class="line">        System.out.println(&quot;最后一个字母变大写:&quot;+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-13-练习-把最后一个two单词首字母大写"><a class="header-anchor" href="#示例-13-练习-把最后一个two单词首字母大写">¶</a>示例 13: 练习-把最后一个two单词首字母大写</h3>
<p>Nature has given us that two ears, two eyes, and but one tongue, to the end that we should hear and see more than we speak<br>
把最后一个two单词首字母大写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">	 public static void main(String[] args) &#123;</span><br><span class="line">		 </span><br><span class="line">	        String str &#x3D;&quot;Nature has given us that two ears, two eyes, and but one tongue, to the end that we should hear and see more than we speak&quot;;</span><br><span class="line">	        int index &#x3D; str.lastIndexOf(&quot;two&quot;);</span><br><span class="line">	        char[] ch &#x3D; str.toCharArray();</span><br><span class="line">	        ch[index]&#x3D;Character.toUpperCase(ch[index]);</span><br><span class="line">	        String s&#x3D;new String(ch);</span><br><span class="line">	        System.out.println(&quot;把最后一个two单词首字母大写:&quot;+s);</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、JAVA-比较字符串详解"><a class="header-anchor" href="#8、JAVA-比较字符串详解">¶</a>8、JAVA 比较字符串详解</h2>
<h3 id="示例-1-是否是同一个对象"><a class="header-anchor" href="#示例-1-是否是同一个对象">¶</a>示例 1 : 是否是同一个对象</h3>
<p>str1和str2的内容一定是一样的！<br>
但是，并不是同一个字符串对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class TestString &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        String str1 &#x3D; &quot;the light&quot;;</span><br><span class="line">         </span><br><span class="line">        String str2 &#x3D; new String(str1);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;&#x3D;&#x3D;用于判断是否是同一个字符串对象</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        System.out.println( str1  &#x3D;&#x3D;  str2);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-是否是同一个对象-特例"><a class="header-anchor" href="#示例-2-是否是同一个对象-特例">¶</a>示例 2 : 是否是同一个对象-特例</h3>
<p>str1 = “the light”;</p>
<p>str3 = “the light”;</p>
<p>一般说来，编译器每碰到一个字符串的字面值，就会创建一个新的对象<br>
所以在第6行会创建了一个新的字符串&quot;the light&quot;<br>
但是在第7行，编译器发现已经存在现成的&quot;the light&quot;，那么就直接拿来使用，而没有进行重复创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class TestString &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 &#x3D; &quot;the light&quot;;</span><br><span class="line">        String str3 &#x3D; &quot;the light&quot;;</span><br><span class="line">        System.out.println( str1  &#x3D;&#x3D;  str3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-内容是否相同"><a class="header-anchor" href="#示例-3-内容是否相同">¶</a>示例 3 : 内容是否相同</h3>
<p>使用equals进行字符串内容的比较，必须大小写一致<br>
equalsIgnoreCase，忽略大小写判断内容是否一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public class TestString &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        String str1 &#x3D; &quot;the light&quot;;</span><br><span class="line">          </span><br><span class="line">        String str2 &#x3D; new String(str1);</span><br><span class="line">         </span><br><span class="line">        String str3 &#x3D; str1.toUpperCase();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;&#x3D;&#x3D;用于判断是否是同一个字符串对象</span><br><span class="line">        System.out.println( str1  &#x3D;&#x3D;  str2);</span><br><span class="line">         </span><br><span class="line">        System.out.println(str1.equals(str2));&#x2F;&#x2F;完全一样返回true</span><br><span class="line">         </span><br><span class="line">        System.out.println(str1.equals(str3));&#x2F;&#x2F;大小写不一样，返回false</span><br><span class="line">        System.out.println(str1.equalsIgnoreCase(str3));&#x2F;&#x2F;忽略大小写的比较，返回true</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-是否以子字符串开始或者结束"><a class="header-anchor" href="#示例-4-是否以子字符串开始或者结束">¶</a>示例 4 : 是否以子字符串开始或者结束</h3>
<p>startsWith //以…开始</p>
<p>endsWith //以…结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public class TestString &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 &#x3D; &quot;the light&quot;;</span><br><span class="line">         </span><br><span class="line">        String start &#x3D; &quot;the&quot;;</span><br><span class="line">        String end &#x3D; &quot;Ight&quot;;</span><br><span class="line">         </span><br><span class="line">        System.out.println(str1.startsWith(start));&#x2F;&#x2F;以...开始</span><br><span class="line">        System.out.println(str1.endsWith(end));&#x2F;&#x2F;以...结束</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-练习-比较字符串"><a class="header-anchor" href="#示例-5-练习-比较字符串">¶</a>示例 5 : 练习-比较字符串</h3>
<p>创建一个长度是100的字符串数组<br>
使用长度是2的随机字符填充该字符串数组<br>
统计这个字符串数组里<strong>重复的字符串有多少种</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class StringCompare &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		Random r &#x3D; new Random();</span><br><span class="line">		String standard &#x3D; &quot;&quot;;</span><br><span class="line">		for (int i &#x3D; &#39;0&#39;; i &lt;&#x3D; &#39;9&#39;; i++) &#123;</span><br><span class="line">			standard +&#x3D; (char) i;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; &#39;A&#39;; i &lt;&#x3D; &#39;Z&#39;; i++) &#123;</span><br><span class="line">			standard +&#x3D; (char) i;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; &#39;a&#39;; i &lt;&#x3D; &#39;z&#39;; i++) &#123;</span><br><span class="line">			standard +&#x3D; (char) i;</span><br><span class="line">		&#125;</span><br><span class="line">		String[] strArr &#x3D; new String[100];</span><br><span class="line">		for (int k &#x3D; 0; k &lt; strArr.length; k++) &#123;</span><br><span class="line">			strArr[k] &#x3D; &quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 2; j++) &#123;</span><br><span class="line">				strArr[i] +&#x3D; standard.charAt(r.nextInt(standard.length()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; strArr.length; i++) &#123;</span><br><span class="line">			if (i &#x3D;&#x3D; 19 || i &#x3D;&#x3D; 39 || i &#x3D;&#x3D; 59 || i &#x3D;&#x3D; 79 || i &#x3D;&#x3D; 99)</span><br><span class="line">				System.out.println(strArr[i]);</span><br><span class="line">			else</span><br><span class="line">				System.out.print(strArr[i] + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		int count &#x3D; 0;</span><br><span class="line">		int count1 &#x3D; 0;</span><br><span class="line">		int count3 &#x3D; 0;</span><br><span class="line">		ArrayList&lt;String&gt; al &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; strArr.length - 1; i++) &#123;</span><br><span class="line">			count &#x3D; 0;</span><br><span class="line">			for (int j &#x3D; i + 1; j &lt; strArr.length; j++) &#123;</span><br><span class="line">				if (strArr[i].equalsIgnoreCase(strArr[j])) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					count3++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (count &gt; 0) &#123;</span><br><span class="line">				for (int k &#x3D; 0; k &lt; al.size(); k++) &#123;</span><br><span class="line">					if (strArr[i].equalsIgnoreCase(al.get(k))) &#123;</span><br><span class="line">						flag &#x3D; true;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (!flag) &#123;</span><br><span class="line">					al.add(strArr[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (count &gt; 1) &#123;</span><br><span class="line">				count1 +&#x3D; count;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int typeNum &#x3D; count3 - count1;</span><br><span class="line">		System.out.println(&quot;总共有&quot; + typeNum + &quot;种重复的字符串&quot;);</span><br><span class="line">		System.out.println(&quot;分别是：&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; al.size(); i++) &#123;</span><br><span class="line">			System.out.print(al.get(i) + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public class TestString &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String[]sa&#x3D;new String [100];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; sa.length; i++) &#123;&#x2F;&#x2F;生成随机字符串</span><br><span class="line">			char[] tmp&#x3D;new char[2];</span><br><span class="line">			while(true) &#123;</span><br><span class="line">				int c&#x3D;(int)(Math.random()*(&#39;z&#39;-&#39;0&#39;)+&#39;0&#39;);</span><br><span class="line">				if(Character.isLetter(c)||Character.isDigit(c)) &#123;</span><br><span class="line">					tmp[0]&#x3D;(char) c;</span><br><span class="line">					break;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			while(true) &#123;</span><br><span class="line">				int c1&#x3D;(int)(Math.random()*(&#39;z&#39;-&#39;0&#39;)+&#39;0&#39;);</span><br><span class="line">				if(Character.isLetter(c1)||Character.isDigit(c1)) &#123;</span><br><span class="line">					tmp[1]&#x3D;(char) c1;</span><br><span class="line">					break;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sa[i]&#x3D;String.copyValueOf(tmp);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; sa.length; i++) &#123;</span><br><span class="line">			System.out.printf(&quot;%s &quot;,sa[i]);</span><br><span class="line">			if((i+1)%20&#x3D;&#x3D;0)&#x2F;&#x2F;输出每20个为1行</span><br><span class="line">				System.out.println(&quot;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">			String result &#x3D; &quot;&quot;;</span><br><span class="line">			int n&#x3D;0;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; sa.length-1; i++) &#123;</span><br><span class="line">				for (int j &#x3D; i+1; j &lt; sa.length; j++) &#123;</span><br><span class="line">					if (sa[j].equals(sa[i])) &#123;</span><br><span class="line">						if (!result.contains(sa[i])) &#123;&#x2F;&#x2F;比较是否有重复字符串</span><br><span class="line">							result&#x3D;result+sa[i]+&quot; &quot;;</span><br><span class="line">							n++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;总共有&quot; + n + &quot;种重复的字符串&quot;);</span><br><span class="line">			System.out.println(&quot;分别是：&quot; + result);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、JAVA-STRINGBUFFER常见方法"><a class="header-anchor" href="#9、JAVA-STRINGBUFFER常见方法">¶</a>9、JAVA STRINGBUFFER常见方法</h2>
<h3 id="示例-1-追加-删除-插入-反转"><a class="header-anchor" href="#示例-1-追加-删除-插入-反转">¶</a>示例 1 : 追加 删除 插入 反转</h3>
<p>append追加<br>
delete 删除<br>
insert 插入<br>
reverse 反转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public class TestString &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 &#x3D; &quot;let there &quot;;</span><br><span class="line"> </span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer(str1); &#x2F;&#x2F;根据str1创建一个StringBuffer对象</span><br><span class="line">        sb.append(&quot;be light&quot;); &#x2F;&#x2F;在最后追加</span><br><span class="line">         </span><br><span class="line">        System.out.println(sb);</span><br><span class="line">         </span><br><span class="line">        sb.delete(4, 10);&#x2F;&#x2F;删除4-10之间的字符</span><br><span class="line">         </span><br><span class="line">        System.out.println(sb);</span><br><span class="line">         </span><br><span class="line">        sb.insert(4, &quot;there &quot;);&#x2F;&#x2F;在4这个位置插入 there</span><br><span class="line">         </span><br><span class="line">        System.out.println(sb);</span><br><span class="line">         </span><br><span class="line">        sb.reverse(); &#x2F;&#x2F;反转</span><br><span class="line">         </span><br><span class="line">        System.out.println(sb);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let there be light</span><br><span class="line">let be light</span><br><span class="line">let there be light</span><br><span class="line">thgil eb ereht tel</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-长度-容量"><a class="header-anchor" href="#示例-2-长度-容量">¶</a>示例 2 : 长度 容量</h3>
<p>为什么StringBuffer可以变长？<br>
和String<strong>内部是一个字符数组</strong>一样，StringBuffer也维护了一个字符数组。 但是，这个字符数组，<strong>留有冗余长度</strong><br>
比如说new StringBuffer(“the”)，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。<br>
如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，<strong>看上去</strong> 数组长度就变长了 参考[MyStringBuffer]<br>
length: “the”的长度 3<br>
capacity: 分配的总空间 19</p>
<p><strong>注：</strong> 19这个数量，不同的JDK数量是不一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public class TestString &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 &#x3D; &quot;the&quot;;</span><br><span class="line"> </span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer(str1);</span><br><span class="line">         </span><br><span class="line">        System.out.println(sb.length()); &#x2F;&#x2F;内容长度</span><br><span class="line">         </span><br><span class="line">        System.out.println(sb.capacity());&#x2F;&#x2F;总空间</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-练习-StringBuffer性能"><a class="header-anchor" href="#示例-3-练习-StringBuffer性能">¶</a>示例 3 : 练习-StringBuffer性能</h3>
<p>String与StringBuffer的性能区别?</p>
<p>生成10位长度的随机字符串<br>
然后,先使用String的+,连接10000个随机字符串,计算消耗的时间<br>
然后,再使用StringBuffer连接10000个随机字符串,计算消耗的时间</p>
<p>提示: 使用[System.currentTimeMillis() ]获取当前时间(毫秒)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class TestStringBuffer &#123;</span><br><span class="line">	static Random random &#x3D; new Random();</span><br><span class="line">	static String temp &#x3D; new String();&#x2F;&#x2F; 随机生成的长度为10的字符串</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String t1 &#x3D; new String(&quot;&quot;);</span><br><span class="line">		StringBuffer b1 &#x3D; new StringBuffer(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 测试普通String用时</span><br><span class="line">		long start_time &#x3D; System.currentTimeMillis();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">			t1 &#x3D; t1 + randomString();</span><br><span class="line">		&#125;</span><br><span class="line">		long end_time &#x3D; System.currentTimeMillis();</span><br><span class="line">		long used_time &#x3D; end_time - start_time;</span><br><span class="line">		&#x2F;&#x2F; System.out.println(start_time);</span><br><span class="line">		&#x2F;&#x2F; System.out.println(end_time);</span><br><span class="line">		System.out.printf(&quot;String循环添加10000次用时: %d毫秒&quot;, used_time);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 测试StringBuffer用时</span><br><span class="line">		start_time &#x3D; System.currentTimeMillis();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">			b1 &#x3D; b1.append(randomString());</span><br><span class="line">		&#125;</span><br><span class="line">		end_time &#x3D; System.currentTimeMillis();</span><br><span class="line">		used_time &#x3D; end_time - start_time;</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line">		System.out.printf(&quot;StringBuffer循环添加1000000次用时: %d毫秒&quot;, used_time);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String randomString() &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">			char[] c &#x3D; new char[10];</span><br><span class="line">			c[j] &#x3D; (char) (random.nextInt(58) + 65);</span><br><span class="line">			temp &#x3D; String.valueOf(c);</span><br><span class="line">		&#125;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String循环添加10000次用时: 530毫秒</span><br><span class="line">StringBuffer循环添加1000000次用时: 370毫秒</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-练习-MyStringBuffer"><a class="header-anchor" href="#示例-4-练习-MyStringBuffer">¶</a>示例 4 : 练习-MyStringBuffer</h3>
<p>根据接口IStringBuffer ，自己做一个MyStringBuffer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;IStringBuffer.java</span><br><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public interface IStringBuffer &#123;</span><br><span class="line">    public void append(String str); &#x2F;&#x2F;追加字符串</span><br><span class="line">    public void append(char c);  &#x2F;&#x2F;追加字符</span><br><span class="line">    public void insert(int pos,char b); &#x2F;&#x2F;指定位置插入字符</span><br><span class="line">    public void insert(int pos,String b); &#x2F;&#x2F;指定位置插入字符串</span><br><span class="line">    public void delete(int start); &#x2F;&#x2F;从开始位置删除剩下的</span><br><span class="line">    public void delete(int start,int end); &#x2F;&#x2F;从开始位置删除结束位置-1</span><br><span class="line">    public void reverse(); &#x2F;&#x2F;反转</span><br><span class="line">    public int length(); &#x2F;&#x2F;返回长度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IStringBuffer &#123;</span><br><span class="line">    public void append(String str); &#x2F;&#x2F;追加字符串</span><br><span class="line">    public void append(char c);  &#x2F;&#x2F;追加字符</span><br><span class="line">    public void insert(int pos,char b); &#x2F;&#x2F;指定位置插入字符</span><br><span class="line">    public void insert(int pos,String b); &#x2F;&#x2F;指定位置插入字符串</span><br><span class="line">    public void delete(int start); &#x2F;&#x2F;从开始位置删除剩下的</span><br><span class="line">    public void delete(int start,int end); &#x2F;&#x2F;从开始位置删除结束位置-1</span><br><span class="line">    public void reverse(); &#x2F;&#x2F;反转</span><br><span class="line">    public int length(); &#x2F;&#x2F;返回长度</span><br><span class="line">&#125;</span><br><span class="line">class MyStringBuffer implements IStringBuffer&#123;</span><br><span class="line">    private String str&#x3D;&quot;&quot;;</span><br><span class="line">    public String tostring()&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    public  MyStringBuffer(String str)&#123;</span><br><span class="line">        append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    public void append(String str) &#123;</span><br><span class="line">        String s&#x3D;this.str+str;</span><br><span class="line">        this.str&#x3D;s;</span><br><span class="line">    &#125;</span><br><span class="line">    public void append(char c) &#123;</span><br><span class="line">        char c1[]&#x3D;new char[1];</span><br><span class="line">        c1[0]&#x3D;c;</span><br><span class="line">        String s&#x3D;new String(c1);</span><br><span class="line">        String str&#x3D;this.str+s;</span><br><span class="line">        this.str&#x3D;str;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(int pos, char b) &#123;</span><br><span class="line">        String s&#x3D;this.str+b;</span><br><span class="line">        char c[]&#x3D;s.toCharArray();</span><br><span class="line">        for(int i&#x3D;c.length-1;i&gt;pos;i--)</span><br><span class="line">            c[i]&#x3D;c[i-1];</span><br><span class="line">        c[pos]&#x3D;b;</span><br><span class="line">        String str&#x3D;new String(c);</span><br><span class="line">        this.str&#x3D;str;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(int pos, String b) &#123;</span><br><span class="line">        String s&#x3D;this.str+b;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        char c[]&#x3D;s.toCharArray();</span><br><span class="line">        char B[]&#x3D;b.toCharArray();</span><br><span class="line">        for(int i&#x3D;c.length-1;i&gt;(pos);i--)</span><br><span class="line">            &#123;c[i]&#x3D;c[i-B.length];</span><br><span class="line">            if(i&#x3D;&#x3D;pos+B.length)</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        for(int i&#x3D;pos;i&lt;pos+b.length();i++)</span><br><span class="line">            &#123;c[i]&#x3D;B[j];</span><br><span class="line">            j++;</span><br><span class="line">            &#125;</span><br><span class="line">        String str&#x3D;new String(c);</span><br><span class="line">        this.str&#x3D;str;</span><br><span class="line">    &#125;</span><br><span class="line">    public void delete(int start) &#123;</span><br><span class="line">        char c[]&#x3D;this.str.toCharArray();</span><br><span class="line">        char c1[]&#x3D;new char[start];</span><br><span class="line">        for(int i&#x3D;0;i&lt;start;i++)</span><br><span class="line">            c1[i]&#x3D;c[i];</span><br><span class="line">        String str&#x3D;new String(c1);</span><br><span class="line">        this.str&#x3D;str;</span><br><span class="line">    &#125;</span><br><span class="line">    public void delete(int start, int end) &#123;</span><br><span class="line">        char c[]&#x3D;this.str.toCharArray();</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        char c1[]&#x3D;new char[c.length-(end-1-start)];</span><br><span class="line">        for(int i&#x3D;0;i&lt;start;i++)</span><br><span class="line">            c1[i]&#x3D;c[i];j&#x3D;end-1;</span><br><span class="line">        for(int i&#x3D;start;i&lt;c1.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            c1[i]&#x3D;c[j];j++;</span><br><span class="line">            &#125;</span><br><span class="line">        String str&#x3D;new String(c1);</span><br><span class="line">        this.str&#x3D;str;</span><br><span class="line">    &#125;</span><br><span class="line">    public void reverse() &#123;</span><br><span class="line">        char c[]&#x3D;this.str.toCharArray();</span><br><span class="line">        char t;</span><br><span class="line">        for(int i&#x3D;0;i&lt;c.length&#x2F;2;i++)</span><br><span class="line">            &#123;t&#x3D;c[i];</span><br><span class="line">            c[i]&#x3D;c[c.length-i-1];</span><br><span class="line">            c[c.length-i-1]&#x3D;t;</span><br><span class="line">            &#125;</span><br><span class="line">        String str&#x3D;new String(c);</span><br><span class="line">        this.str&#x3D;str;</span><br><span class="line">    &#125;</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        return this.str.length();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">public class Item &#123;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        MyStringBuffer msb&#x3D;new MyStringBuffer(&quot;123&quot;);</span><br><span class="line">        msb.append(&#39;4&#39;);</span><br><span class="line">        System.out.println(msb.tostring());</span><br><span class="line">        msb.insert(1,&#39;5&#39;);</span><br><span class="line">        System.out.println(msb.tostring());</span><br><span class="line">        msb.insert(2,&quot;123&quot;);</span><br><span class="line">        System.out.println(msb.tostring());</span><br><span class="line">        msb.delete(5,7);</span><br><span class="line">        System.out.println(msb.tostring());</span><br><span class="line">        msb.reverse();</span><br><span class="line">        System.out.println(msb.tostring());</span><br><span class="line">        System.out.println(msb.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、自己开发一个JAVA-STRINGBUFFER"><a class="header-anchor" href="#10、自己开发一个JAVA-STRINGBUFFER">¶</a>10、自己开发一个JAVA STRINGBUFFER</h2>
<h3 id="步骤-1-IStringBuffer接口"><a class="header-anchor" href="#步骤-1-IStringBuffer接口">¶</a>步骤 1 : IStringBuffer接口</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public interface IStringBuffer &#123;</span><br><span class="line">    public void append(String str); &#x2F;&#x2F;追加字符串</span><br><span class="line">    public void append(char c);  &#x2F;&#x2F;追加字符</span><br><span class="line">    public void insert(int pos,char b); &#x2F;&#x2F;指定位置插入字符</span><br><span class="line">    public void insert(int pos,String b); &#x2F;&#x2F;指定位置插入字符串</span><br><span class="line">    public void delete(int start); &#x2F;&#x2F;从开始位置删除剩下的</span><br><span class="line">    public void delete(int start,int end); &#x2F;&#x2F;从开始位置删除结束位置-1</span><br><span class="line">    public void reverse(); &#x2F;&#x2F;反转</span><br><span class="line">    public int length(); &#x2F;&#x2F;返回长度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-value和capacity"><a class="header-anchor" href="#步骤-2-value和capacity">¶</a>步骤 2 : value和capacity</h3>
<p>value：用于存放字符数组<br>
capacity： 容量<br>
无参构造方法：	根据容量初始化value</p>
<p>public MyStringBuffer(){</p>
<p>​	value = new char[capacity];</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class MyStringBuffer implements IStringBuffer&#123;</span><br><span class="line"> </span><br><span class="line">    int capacity &#x3D; 16;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    char[] value;</span><br><span class="line">    public MyStringBuffer()&#123;</span><br><span class="line">        value &#x3D; new char[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void append(String str) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void append(char c) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int pos, char b) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void reverse() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-带参构造方法"><a class="header-anchor" href="#步骤-3-带参构造方法">¶</a>步骤 3 : 带参构造方法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class MyStringBuffer implements IStringBuffer&#123;</span><br><span class="line"> </span><br><span class="line">    int capacity &#x3D; 16;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    char[] value;</span><br><span class="line">    public MyStringBuffer()&#123;</span><br><span class="line">        value &#x3D; new char[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;有参构造方法</span><br><span class="line">    public MyStringBuffer(String str)&#123;</span><br><span class="line">        if(null!&#x3D;str)</span><br><span class="line">            value &#x3D;str.toCharArray();</span><br><span class="line">         </span><br><span class="line">        length &#x3D; value.length;</span><br><span class="line">         </span><br><span class="line">        if(capacity&lt;value.length)</span><br><span class="line">            capacity  &#x3D; value.length*2;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void append(String str) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void append(char c) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int pos, char b) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void reverse() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int pos, String b) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-反转-reverse"><a class="header-anchor" href="#步骤-4-反转-reverse">¶</a>步骤 4 : 反转 reverse</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class MyStringBuffer implements IStringBuffer &#123;</span><br><span class="line"> </span><br><span class="line">    int capacity &#x3D; 16;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    char[] value;</span><br><span class="line"> </span><br><span class="line">    public MyStringBuffer() &#123;</span><br><span class="line">        value &#x3D; new char[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 有参构造方法</span><br><span class="line">    public MyStringBuffer(String str) &#123;</span><br><span class="line">        this();</span><br><span class="line">        if (null &#x3D;&#x3D; str)</span><br><span class="line">            return;</span><br><span class="line"> </span><br><span class="line">        if (capacity &lt; str.length()) &#123;</span><br><span class="line">            capacity &#x3D; value.length * 2;</span><br><span class="line">            value &#x3D; new char[capacity];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (capacity &gt;&#x3D; str.length())</span><br><span class="line">            System.arraycopy(str.toCharArray(), 0, value, 0, str.length());</span><br><span class="line"> </span><br><span class="line">        length &#x3D; str.length();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void reverse() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length &#x2F; 2; i++) &#123;</span><br><span class="line">            char temp &#x3D; value[i];</span><br><span class="line">            value[i] &#x3D; value[length - i - 1];</span><br><span class="line">            value[length - i - 1] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void append(String str) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void append(char c) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int pos, char b) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int pos, String b) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        char[] realValue &#x3D; new char[length];</span><br><span class="line"> </span><br><span class="line">        System.arraycopy(value, 0, realValue, 0, length);</span><br><span class="line"> </span><br><span class="line">        return new String(realValue);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyStringBuffer sb &#x3D; new MyStringBuffer(&quot;there light&quot;);</span><br><span class="line"> </span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-插入insert-和-append"><a class="header-anchor" href="#步骤-5-插入insert-和-append">¶</a>步骤 5 : 插入insert 和 append</h3>
<p><strong>边界条件判断</strong><br>
插入之前，首先要判断的是一些边界条件。 比如插入位置是否合法，插入的字符串是否为空</p>
<p><strong>扩容</strong></p>
<ol>
<li>
<p>要判断是否需要<strong>扩容</strong>。 如果插入的字符串加上已经存在的内容的总长度超过了容量，那么就需要扩容。</p>
</li>
<li>
<p>数组的长度是固定的，不能改变的，数组本身不支持<strong>扩容</strong>。 我们使用变通的方式来解决这个问题。</p>
</li>
<li>
<p>根据需要插入的字符串的长度和已经存在的内容的长度，计算出一个新的容量。 然后根据这个容量，创建一个新的数组，接着把原来的数组的内容，复制到这个新的数组中来。并且让value这个引用，指向新的数组，从而达到<strong>扩容</strong>的效果。</p>
</li>
</ol>
<p><strong>插入字符串</strong></p>
<ol>
<li>
<p>找到要插入字符串的位置，从这个位置开始，把原数据<strong>看成两段</strong>，把后半段向后挪动一个距离，这个距离刚好是插入字符串的长度</p>
</li>
<li>
<p>然后把要插入的数据，插入这个挪出来的，刚刚好的位置里。</p>
</li>
</ol>
<p><strong>修改length的值</strong><br>
最后修改length的值，是原来的值加上插入字符串的长度</p>
<p><strong>insert(int, char)</strong><br>
参数是字符的insert方法，通过调用insert(int, String) 也就实现了。</p>
<p><strong>append</strong><br>
追加，就是在最后位置插入。 所以不需要单独开发方法，直接调用insert方法，就能达到最后位置插入的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line">public class MyStringBuffer implements IStringBuffer&#123;</span><br><span class="line">  </span><br><span class="line">    int capacity &#x3D; 16;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    char[] value;</span><br><span class="line">    public MyStringBuffer()&#123;</span><br><span class="line">        value &#x3D; new char[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;有参构造方法</span><br><span class="line">    public MyStringBuffer(String str)&#123;</span><br><span class="line">        this();</span><br><span class="line">        if(null&#x3D;&#x3D;str)</span><br><span class="line">            return;</span><br><span class="line">          </span><br><span class="line">        if(capacity&lt;str.length())&#123;</span><br><span class="line">            capacity  &#x3D; value.length*2;</span><br><span class="line">            value&#x3D;new char[capacity];</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        if(capacity&gt;&#x3D;str.length())</span><br><span class="line">            System.arraycopy(str.toCharArray(), 0, value, 0, str.length());</span><br><span class="line">          </span><br><span class="line">        length &#x3D; str.length();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    @Override</span><br><span class="line">    public void append(String str) &#123;</span><br><span class="line">        insert(length,str);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void append(char c) &#123;</span><br><span class="line">        append(String.valueOf(c));</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int pos, char b) &#123;</span><br><span class="line">        insert(pos,String.valueOf(b));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void reverse() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length&#x2F;2; i++) &#123;</span><br><span class="line">            char temp &#x3D; value[i];</span><br><span class="line">            value[i] &#x3D; value[length-i-1];</span><br><span class="line">            value[length-i-1] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int pos, String b) &#123;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;边界条件判断</span><br><span class="line">        if(pos&lt;0)</span><br><span class="line">            return;</span><br><span class="line">          </span><br><span class="line">        if(pos&gt;length)</span><br><span class="line">            return;</span><br><span class="line">          </span><br><span class="line">        if(null&#x3D;&#x3D;b)</span><br><span class="line">            return;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;扩容</span><br><span class="line">        while(length+b.length()&gt;capacity)&#123;</span><br><span class="line">            capacity &#x3D; (int) ((length+b.length())*1.5f);</span><br><span class="line">            char[] newValue &#x3D; new char[capacity];</span><br><span class="line">            System.arraycopy(value, 0, newValue, 0, length);</span><br><span class="line">            value &#x3D; newValue;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        char[] cs &#x3D; b.toCharArray();</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;先把已经存在的数据往后移</span><br><span class="line">          </span><br><span class="line">        System.arraycopy(value, pos, value,pos+ cs.length, length-pos);</span><br><span class="line">        &#x2F;&#x2F;把要插入的数据插入到指定位置</span><br><span class="line">        System.arraycopy(cs, 0, value, pos, cs.length);</span><br><span class="line">          </span><br><span class="line">        length &#x3D; length+cs.length;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public String toString()&#123;</span><br><span class="line">          </span><br><span class="line">        char[] realValue &#x3D; new char[length];</span><br><span class="line">  </span><br><span class="line">        System.arraycopy(value, 0, realValue, 0, length);</span><br><span class="line">          </span><br><span class="line">        return new String(realValue);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyStringBuffer sb &#x3D; new MyStringBuffer(&quot;there light&quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.insert(0, &quot;let &quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">  </span><br><span class="line">        sb.insert(10, &quot;be &quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.insert(0, &quot;God Say:&quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.append(&quot;!&quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.append(&#39;?&#39;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-删除-delete"><a class="header-anchor" href="#步骤-6-删除-delete">¶</a>步骤 6 : 删除 delete</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/733.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package character;</span><br><span class="line"> </span><br><span class="line">public class MyStringBuffer implements IStringBuffer&#123;</span><br><span class="line"> </span><br><span class="line">    int capacity &#x3D; 16;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    char[] value;</span><br><span class="line">    public MyStringBuffer()&#123;</span><br><span class="line">        value &#x3D; new char[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;有参构造方法</span><br><span class="line">    public MyStringBuffer(String str)&#123;</span><br><span class="line">        this();</span><br><span class="line">        if(null&#x3D;&#x3D;str)</span><br><span class="line">            return;</span><br><span class="line">         </span><br><span class="line">        if(capacity&lt;str.length())&#123;</span><br><span class="line">            capacity  &#x3D; value.length*2;</span><br><span class="line">            value&#x3D;new char[capacity];</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        if(capacity&gt;&#x3D;str.length())</span><br><span class="line">            System.arraycopy(str.toCharArray(), 0, value, 0, str.length());</span><br><span class="line">         </span><br><span class="line">        length &#x3D; str.length();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void append(String str) &#123;</span><br><span class="line"> </span><br><span class="line">        insert(length,str);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void append(char c) &#123;</span><br><span class="line">        append(String.valueOf(c));</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int pos, char b) &#123;</span><br><span class="line">        insert(pos,String.valueOf(b));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start) &#123;</span><br><span class="line">         </span><br><span class="line">        delete(start,length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F;边界条件判断</span><br><span class="line">        if(start&lt;0)</span><br><span class="line">            return;</span><br><span class="line">         </span><br><span class="line">        if(start&gt;length)</span><br><span class="line">            return;</span><br><span class="line">         </span><br><span class="line">        if(end&lt;0)</span><br><span class="line">            return;</span><br><span class="line">         </span><br><span class="line">        if(end&gt;length)</span><br><span class="line">            return;</span><br><span class="line">         </span><br><span class="line">        if(start&gt;&#x3D;end)</span><br><span class="line">            return;</span><br><span class="line">         </span><br><span class="line">        System.arraycopy(value, end, value, start, length- end);</span><br><span class="line">        length-&#x3D;end-start;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void reverse() &#123;</span><br><span class="line"> </span><br><span class="line">        for (int i &#x3D; 0; i &lt; length&#x2F;2; i++) &#123;</span><br><span class="line">             </span><br><span class="line">            char temp &#x3D; value[i];</span><br><span class="line">            value[i] &#x3D; value[length-i-1];</span><br><span class="line">            value[length-i-1] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int pos, String b) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;边界条件判断</span><br><span class="line">        if(pos&lt;0)</span><br><span class="line">            return;</span><br><span class="line">         </span><br><span class="line">        if(pos&gt;length)</span><br><span class="line">            return;</span><br><span class="line">         </span><br><span class="line">        if(null&#x3D;&#x3D;b)</span><br><span class="line">            return;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;扩容</span><br><span class="line">        while(length+b.length()&gt;capacity)&#123;</span><br><span class="line">            capacity &#x3D; (int) ((length+b.length())*1.5f);</span><br><span class="line">            char[] newValue &#x3D; new char[capacity];</span><br><span class="line">            System.arraycopy(value, 0, newValue, 0, length);</span><br><span class="line">            value &#x3D; newValue;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        char[] cs &#x3D; b.toCharArray();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;先把已经存在的数据往后移</span><br><span class="line">         </span><br><span class="line">        System.arraycopy(value, pos, value,pos+ cs.length, length-pos);</span><br><span class="line">        &#x2F;&#x2F;把要插入的数据插入到指定位置</span><br><span class="line">        System.arraycopy(cs, 0, value, pos, cs.length);</span><br><span class="line">         </span><br><span class="line">        length &#x3D; length+cs.length;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public String toString()&#123;</span><br><span class="line">         </span><br><span class="line">        char[] realValue &#x3D; new char[length];</span><br><span class="line"> </span><br><span class="line">        System.arraycopy(value, 0, realValue, 0, length);</span><br><span class="line">         </span><br><span class="line">        return new String(realValue);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyStringBuffer sb &#x3D; new MyStringBuffer(&quot;there light&quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.insert(0, &quot;let &quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line"> </span><br><span class="line">        sb.insert(10, &quot;be &quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.insert(0, &quot;God Say:&quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.append(&quot;!&quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.append(&#39;?&#39;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">         </span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">         </span><br><span class="line">        sb.delete(0,4);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.delete(4);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-练习-性能比较"><a class="header-anchor" href="#步骤-7-练习-性能比较">¶</a>步骤 7 : 练习-性能比较</h3>
<p>使用Java自带的 StringBuffer 和 这个我们自己开发的MyStringBuffer性能比较。<br>
参考比较方案:</p>
<ol>
<li>
<p>生成长度是10的随机字符串</p>
</li>
<li>
<p>使用StringBuffer追加1000000次统计时间</p>
</li>
<li>
<p>使用MyStringBuffer追加1000000次统计时间</p>
</li>
</ol>
<p>性能统计办法 参考 [比较StringBuffer和String的性能]<br>
如果追加的次数太大，会导致内存不够使用(默认情况下是分配16m)，你会看到<strong>OutOfMemoryError</strong>这样的错误。 调整的方式参考 [JVM调试与设置 设置最大内存]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MyStringBuffer.java</span><br><span class="line">public class MyStringBuffer implements IStringBuffer &#123;</span><br><span class="line"></span><br><span class="line">	int capacity &#x3D;16;</span><br><span class="line">	int length&#x3D;0;</span><br><span class="line">	char[] value;</span><br><span class="line">	public MyStringBuffer()</span><br><span class="line">	&#123;</span><br><span class="line">		value&#x3D;new char[capacity];</span><br><span class="line">	&#125;</span><br><span class="line">	public MyStringBuffer(String str)&#123;</span><br><span class="line">		this();</span><br><span class="line">		if(str&#x3D;&#x3D;null)</span><br><span class="line">			return;</span><br><span class="line">		if(capacity&lt;str.length())</span><br><span class="line">		&#123;</span><br><span class="line">			capacity&#x3D;value.length*2;</span><br><span class="line">			value&#x3D;new char[capacity];</span><br><span class="line">		&#125;</span><br><span class="line">		if(capacity&gt;&#x3D;str.length())</span><br><span class="line">		&#123;</span><br><span class="line">			System.arraycopy(str.toCharArray(),0,value,0,str.length());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		length&#x3D;str.length();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void append(String str) &#123;</span><br><span class="line">	insert(length,str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void append(char c) &#123;</span><br><span class="line">	append(String.valueOf(c));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void insert(int pos, char b) &#123;</span><br><span class="line">	insert(pos,String.valueOf(b));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void insert(int pos, String b) &#123;</span><br><span class="line"></span><br><span class="line">		if(pos&lt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(pos&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(b&#x3D;&#x3D;null)</span><br><span class="line">		&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		while(length+b.length()&gt;capacity)</span><br><span class="line">		&#123;</span><br><span class="line">			capacity&#x3D;(int)((length+b.length())*1.5f);</span><br><span class="line">			char [] newV &#x3D;new char[capacity];</span><br><span class="line">			System.arraycopy(value,0,newV,0,length);</span><br><span class="line">			value&#x3D;newV;</span><br><span class="line">		&#125;</span><br><span class="line">		char[] cs &#x3D;b.toCharArray();</span><br><span class="line">		System.arraycopy(value,pos,value,pos+cs.length,length-pos);</span><br><span class="line">		System.arraycopy(cs,0,value,pos,cs.length);</span><br><span class="line">		length&#x3D;length+cs.length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void delete(int start) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void delete(int start, int end) &#123;</span><br><span class="line"></span><br><span class="line">		if(start&lt;0)</span><br><span class="line">			return;</span><br><span class="line">		if(start&gt;length)</span><br><span class="line">			return;</span><br><span class="line">		if(end&lt;0)</span><br><span class="line">			return;</span><br><span class="line">		if(end&gt;length)</span><br><span class="line">			return;</span><br><span class="line">		if(start&gt;end)</span><br><span class="line">			return;</span><br><span class="line">		System.arraycopy(value,end,value,start,length-end);</span><br><span class="line">		length-&#x3D;end-start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void reverse() &#123;</span><br><span class="line"></span><br><span class="line">		for(int i &#x3D;0 ; i &lt;length&#x2F;2;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			char temp &#x3D; value[i];</span><br><span class="line">			value[i]&#x3D;value[length-i-1];</span><br><span class="line">			value[length-i-1]&#x3D;temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int length()&#123;</span><br><span class="line">		return length;</span><br><span class="line">	&#125;</span><br><span class="line">	public String toString()</span><br><span class="line">	&#123;</span><br><span class="line">		char[] rV &#x3D; new char[length];</span><br><span class="line">		System.arraycopy(value,0,rV,0,length);</span><br><span class="line">		return new String(rV);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		long startT&#x3D;System.currentTimeMillis();</span><br><span class="line">		int number&#x3D;1000000;</span><br><span class="line">		MyStringBuffer msb &#x3D; new MyStringBuffer();</span><br><span class="line">		for(int i &#x3D;0 ; i&lt;number;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			msb.append(randomString(10));</span><br><span class="line">		&#125;</span><br><span class="line">		long endT&#x3D;System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;通过MSB的方式，共用时:&quot;+(endT-startT) + &quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">		long startTT&#x3D;System.currentTimeMillis();</span><br><span class="line">		StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">		for(int i &#x3D;0 ; i&lt;number;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sb.append(randomString(10));</span><br><span class="line">		&#125;</span><br><span class="line">		long endTT&#x3D;System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;通过StringBuffer的方式，共用时:&quot;+(endTT-startTT) + &quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	public static String randomString(int length)</span><br><span class="line">	&#123;</span><br><span class="line">		String pool&#x3D;&quot; &quot;;</span><br><span class="line">		for(short i&#x3D;&#39;0&#39;;i&lt;&#x3D;&#39;9&#39;;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			pool+&#x3D;(char)i;</span><br><span class="line">		&#125;</span><br><span class="line">		for(short i&#x3D;&#39;a&#39;;i&lt;&#x3D;&#39;z&#39;;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			pool+&#x3D;(char)i;</span><br><span class="line">		&#125;</span><br><span class="line">		for(short i&#x3D;&#39;A&#39;;i&lt;&#x3D;&#39;Z&#39;;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			pool+&#x3D;(char)i;</span><br><span class="line">		&#125;</span><br><span class="line">		char[] chars&#x3D;new char[length];</span><br><span class="line">		for(int i&#x3D;0;i&lt;length;i++)&#123;</span><br><span class="line">			int index &#x3D; (int)(Math.random()*pool.length());</span><br><span class="line">			chars[i] &#x3D; pool.charAt(index);</span><br><span class="line">		&#125;</span><br><span class="line">		String result &#x3D; new String(chars);</span><br><span class="line">		return result;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过MSB的方式，共用时:3338毫秒</span><br><span class="line">通过StringBuffer的方式，共用时:2985毫秒</span><br></pre></td></tr></table></figure>
<h1 id="十、日期"><a class="header-anchor" href="#十、日期">¶</a>十、日期</h1>
<h2 id="1、JAVA的日期类DATE"><a class="header-anchor" href="#1、JAVA的日期类DATE">¶</a>1、JAVA的日期类DATE</h2>
<h3 id="示例-1-时间原点概念"><a class="header-anchor" href="#示例-1-时间原点概念">¶</a>示例 1 : 时间原点概念</h3>
<p>所有的数据类型，无论是整数，布尔，浮点数还是字符串，最后都需要以数字的形式表现出来。</p>
<p>日期类型也不例外，换句话说，一个日期，比如2020年10月1日，在计算机里，会用一个数字来代替。</p>
<p>那么最特殊的一个数字，就是零. 零这个数字，就代表Java中的时间原点，其对应的日期是1970年1月1日 8点0分0秒 。 (为什么是8点，因为中国的太平洋时区是UTC-8，刚好和格林威治时间差8个小时)</p>
<p>为什么对应1970年呢？ 因为1969年发布了第一个 UNIX 版本：AT&amp;T，综合考虑，当时就把1970年当做了时间原点。</p>
<p>所有的日期，都是以为这个0点为基准，每过一毫秒，就+1。</p>
<h3 id="示例-2-创建日期对象"><a class="header-anchor" href="#示例-2-创建日期对象">¶</a>示例 2 : 创建日期对象</h3>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2374.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class TestDate &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 当前时间</span><br><span class="line">        Date d1 &#x3D; new Date();</span><br><span class="line">        System.out.println(&quot;当前时间:&quot;);</span><br><span class="line">        System.out.println(d1);</span><br><span class="line">        System.out.println();</span><br><span class="line">        &#x2F;&#x2F; 从1970年1月1日 早上8点0分0秒 开始经历的毫秒数</span><br><span class="line">        Date d2 &#x3D; new Date(5000);</span><br><span class="line">        System.out.println(&quot;从1970年1月1日 早上8点0分0秒 开始经历了5秒的时间&quot;);</span><br><span class="line">        System.out.println(d2);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-getTime"><a class="header-anchor" href="#示例-3-getTime">¶</a>示例 3 : getTime</h3>
<p>getTime() 得到一个long型的整数<br>
这个整数代表 从<strong>1970.1.1 08:00:00:000</strong> 开始 每经历一毫秒，增加1<br>
直接打印对象，会看到 “Tue Jan 05 09:51:48 CST 2016” 这样的格式，可读性比较差，为了获得“2016/1/5 09:51:48”这样的格式 请参考[日期格式化]</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/749.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class TestDate &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;注意：是java.util.Date;</span><br><span class="line">		&#x2F;&#x2F;而非 java.sql.Date，此类是给数据库访问的时候使用的</span><br><span class="line">		Date now&#x3D; new Date();</span><br><span class="line">		&#x2F;&#x2F;打印当前时间</span><br><span class="line">		System.out.println(&quot;当前时间:&quot;+now.toString());</span><br><span class="line">		&#x2F;&#x2F;getTime() 得到一个long型的整数</span><br><span class="line">		&#x2F;&#x2F;这个整数代表 1970.1.1 08:00:00:000，每经历一毫秒，增加1</span><br><span class="line">		System.out.println(&quot;当前时间getTime()返回的值是：&quot;+now.getTime());</span><br><span class="line"></span><br><span class="line">		Date zero &#x3D; new Date(0);</span><br><span class="line">		System.out.println(&quot;用0作为构造方法，得到的日期是:&quot;+zero);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-System-currentTimeMillis"><a class="header-anchor" href="#示例-4-System-currentTimeMillis">¶</a>示例 4 : System.currentTimeMillis()</h3>
<p>当前日期的毫秒数<br>
new Date().getTime() 和 System.currentTimeMillis() 是一样的<br>
不过由于机器性能的原因，可能会相差几十毫秒，毕竟每执行一行代码，都是需要时间的</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/754.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line">   </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">import java.util.Date;</span><br><span class="line">   </span><br><span class="line">public class TestDate &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date now&#x3D; new Date();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;当前日期的毫秒数</span><br><span class="line">        System.out.println(&quot;Date.getTime() \t\t\t返回值: &quot;+now.getTime());</span><br><span class="line">        &#x2F;&#x2F;通过System.currentTimeMillis()获取当前日期的毫秒数</span><br><span class="line">        System.out.println(&quot;System.currentTimeMillis() \t返回值: &quot;+System.currentTimeMillis());</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-练习-日期"><a class="header-anchor" href="#示例-5-练习-日期">¶</a>示例 5 : 练习-日期</h3>
<p>借助[随机数]，创建一个从1995.1.1 00:00:00 到 1995.12.31 23:59:59 之间的随机日期</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2375.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class TestDate &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		&#x2F;&#x2F;y95算到1995年 y96 96年</span><br><span class="line">		long y95 &#x3D;(long)25*365*24*60*60*1000+(long)6*24*60*60*1000-(long)8*60*60*1000;</span><br><span class="line">		long y96 &#x3D;(long)26*365*24*60*60*1000+(long)6*24*60*60*1000-(long)8*60*60*1000;</span><br><span class="line">		Date d1 &#x3D; new Date(y95);</span><br><span class="line">		Date d2 &#x3D; new Date(y96-1);</span><br><span class="line">		Date d3 &#x3D; new Date(y95+(long)(Math.random()*365*24*60*60*1000));</span><br><span class="line">		System.out.println(&quot;1995年的第一天：&quot;+d1);</span><br><span class="line">		System.out.println(&quot;1995年最后一天: &quot;+d2);</span><br><span class="line">		System.out.println(&quot;1995年的随机时间：&quot;+d3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 借助随机数，创建一个从1995.1.1 00:00:00 到 1995.12.31 23:59:59 之间的随机日期</span><br><span class="line">*&#x2F;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">public class TestDate</span><br><span class="line">&#123;</span><br><span class="line">    public static void main (String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个</span><br><span class="line">        Date [] dd &#x3D; new Date[1];</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        String st1 &#x3D; &quot;1995-1-1 00:00:00&quot;;</span><br><span class="line">        String st2 &#x3D; &quot;1995-12-31 23:59:59&quot;;</span><br><span class="line">        SimpleDateFormat si &#x3D; new SimpleDateFormat (&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">         </span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Date d1 &#x3D; si.parse(st1);</span><br><span class="line">            Date d2 &#x3D; si.parse(st2);</span><br><span class="line">            for (int i&#x3D;0;i&lt;dd.length;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                long j &#x3D; (long)(d1.getTime()+(Math.random()*(d2.getTime()-d1.getTime())));</span><br><span class="line">                dd[count++] &#x3D; new Date (j);</span><br><span class="line">                String ss &#x3D; si.format(dd[i]);</span><br><span class="line">                System.out.println(&quot;随机日期为：\n&quot;+ss);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA中使用SIMPLEDATEFORMAT-进行日期格式化类"><a class="header-anchor" href="#2、JAVA中使用SIMPLEDATEFORMAT-进行日期格式化类">¶</a>2、JAVA中使用SIMPLEDATEFORMAT 进行日期格式化类</h2>
<h3 id="示例-1-日期转字符串"><a class="header-anchor" href="#示例-1-日期转字符串">¶</a>示例 1 : 日期转字符串</h3>
<table>
<thead>
<tr>
<th style="text-align:center">y 代表年</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M 代表月</td>
</tr>
<tr>
<td style="text-align:center">d 代表日</td>
</tr>
<tr>
<td style="text-align:center">H 代表24进制的小时</td>
</tr>
<tr>
<td style="text-align:center">h 代表12进制的小时</td>
</tr>
<tr>
<td style="text-align:center">m 代表分钟</td>
</tr>
<tr>
<td style="text-align:center">s 代表秒</td>
</tr>
<tr>
<td style="text-align:center">S 代表毫秒</td>
</tr>
</tbody>
</table>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/750.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">  </span><br><span class="line">public class TestDate &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;y 代表年</span><br><span class="line">        &#x2F;&#x2F;M 代表月</span><br><span class="line">        &#x2F;&#x2F;d 代表日</span><br><span class="line">        &#x2F;&#x2F;H 代表24进制的小时</span><br><span class="line">        &#x2F;&#x2F;h 代表12进制的小时</span><br><span class="line">        &#x2F;&#x2F;m 代表分钟</span><br><span class="line">        &#x2F;&#x2F;s 代表秒</span><br><span class="line">        &#x2F;&#x2F;S 代表毫秒</span><br><span class="line">        SimpleDateFormat sdf &#x3D;new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot; );</span><br><span class="line">        Date d&#x3D; new Date();</span><br><span class="line">        String str &#x3D; sdf.format(d);</span><br><span class="line">        System.out.println(&quot;当前时间通过 yyyy-MM-dd HH:mm:ss SSS 格式化后的输出: &quot;+str);</span><br><span class="line">         </span><br><span class="line">        SimpleDateFormat sdf1 &#x3D;new SimpleDateFormat(&quot;yyyy-MM-dd&quot; );</span><br><span class="line">        Date d1&#x3D; new Date();</span><br><span class="line">        String str1 &#x3D; sdf1.format(d1);</span><br><span class="line">        System.out.println(&quot;当前时间通过 yyyy-MM-dd 格式化后的输出: &quot;+str1);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-字符串转日期"><a class="header-anchor" href="#示例-2-字符串转日期">¶</a>示例 2 : 字符串转日期</h3>
<p>模式（yyyy/MM/dd HH:mm:ss）需要和字符串格式保持一致，如果不一样就会抛出解析异常ParseException</p>
<p>关于异常的详细讲解在[Java 异常 Exception]章节展开</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/751.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">  </span><br><span class="line">public class TestDate &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SimpleDateFormat sdf &#x3D;new SimpleDateFormat(&quot;yyyy&#x2F;MM&#x2F;dd HH:mm:ss&quot; );</span><br><span class="line">  </span><br><span class="line">        String str &#x3D; &quot;2016&#x2F;1&#x2F;5 12:12:12&quot;;</span><br><span class="line">          </span><br><span class="line">        try &#123;</span><br><span class="line">            Date d &#x3D; sdf.parse(str);</span><br><span class="line">            System.out.printf(&quot;字符串 %s 通过格式  yyyy&#x2F;MM&#x2F;dd HH:mm:ss %n转换为日期对象: %s&quot;,str,d.toString());</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-练习-日期格式化"><a class="header-anchor" href="#示例-3-练习-日期格式化">¶</a>示例 3 : 练习-日期格式化</h3>
<p>准备一个长度是9的日期数组<br>
使用1970年-2000年之间的随机日期初始化该数组<br>
按照这些日期的<strong>时间</strong>进行升序排序<br>
比如 1988-1-21 <strong>12:33:22</strong> 就会排在 1978-4-21 <strong>19:07:23</strong> 前面，因为它的时间更小，虽然日期更大</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2376.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class TestDate &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">		&#x2F;&#x2F;计算出1970年1月1日早上8点到2000年12月30号晚上11点59分的毫秒数</span><br><span class="line">		long s &#x3D; 1000;</span><br><span class="line">		long m &#x3D; s * 60;</span><br><span class="line">		long h &#x3D; m * 60;</span><br><span class="line">		long day &#x3D; h * 24;</span><br><span class="line">		long year &#x3D; day * 365;</span><br><span class="line">		long max &#x3D; (2000 - 1970 + 1) * year + (2000-1970 + 1)&#x2F;4 * day - 1;</span><br><span class="line">		max -&#x3D; h * 8;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;长度为9的日期数组</span><br><span class="line">		int count &#x3D; 0;</span><br><span class="line">		String[] arr &#x3D; new String[9];</span><br><span class="line">		System.out.println(&quot;得到的随机日期数组：&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">			long random1 &#x3D; (long)(Math.random()*max);</span><br><span class="line">			Date random2 &#x3D; new Date(random1);</span><br><span class="line">			String str &#x3D; sdf.format(random2);</span><br><span class="line">			arr[i] &#x3D; str;</span><br><span class="line">			System.out.printf(str + &quot; &quot;);</span><br><span class="line">			count ++;</span><br><span class="line">			if(count % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">				System.out.println(&quot;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;排序后的随机日期数组：&quot;);</span><br><span class="line">		int count1 &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 8; j &gt; i; j--) &#123;</span><br><span class="line">				int number &#x3D; arr[i].substring(11,13).compareTo(arr[j].substring(11,13));</span><br><span class="line">				if(number &gt;&#x3D; 0)&#123;</span><br><span class="line">					String temp &#x3D; arr[j];</span><br><span class="line">					arr[j] &#x3D; arr[i];</span><br><span class="line">					arr[i] &#x3D; temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			count1++;</span><br><span class="line">			System.out.print(arr[i]+ &quot; &quot;);</span><br><span class="line">			if(count1 % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">				System.out.println(&quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、如何使用JAVA的CALENDAR类"><a class="header-anchor" href="#3、如何使用JAVA的CALENDAR类">¶</a>3、如何使用JAVA的CALENDAR类</h2>
<h3 id="示例-1-Calendar与Date进行转换"><a class="header-anchor" href="#示例-1-Calendar与Date进行转换">¶</a>示例 1 : Calendar与Date进行转换</h3>
<p>采用[单例模式]获取日历对象Calendar.getInstance();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line">  </span><br><span class="line">public class TestDate &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;采用单例模式获取日历对象Calendar.getInstance();</span><br><span class="line">        Calendar c &#x3D; Calendar.getInstance();</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;通过日历对象得到日期对象</span><br><span class="line">        Date d &#x3D; c.getTime();</span><br><span class="line">  </span><br><span class="line">        Date d2 &#x3D; new Date(0);</span><br><span class="line">        c.setTime(d2); &#x2F;&#x2F;把这个日历，调成日期 : 1970.1.1 08:00:00</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-翻日历3"><a class="header-anchor" href="#示例-2-翻日历3">¶</a>示例 2 : 翻日历3</h3>
<p>add方法，在原日期上增加年/月/日<br>
set方法，直接设置年/月/日</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/755.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line"> </span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class TestDate &#123;</span><br><span class="line"> </span><br><span class="line">    private static SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Calendar c &#x3D; Calendar.getInstance();</span><br><span class="line">        Date now &#x3D; c.getTime();</span><br><span class="line">        &#x2F;&#x2F; 当前日期</span><br><span class="line">        System.out.println(&quot;当前日期：\t&quot; + format(c.getTime()));</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 下个月的今天</span><br><span class="line">        c.setTime(now);</span><br><span class="line">        c.add(Calendar.MONTH, 1);</span><br><span class="line">        System.out.println(&quot;下个月的今天:\t&quot; +format(c.getTime()));</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 去年的今天</span><br><span class="line">        c.setTime(now);</span><br><span class="line">        c.add(Calendar.YEAR, -1);</span><br><span class="line">        System.out.println(&quot;去年的今天:\t&quot; +format(c.getTime()));</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 上个月的第三天</span><br><span class="line">        c.setTime(now);</span><br><span class="line">        c.add(Calendar.MONTH, -1);</span><br><span class="line">        c.set(Calendar.DATE, 3);</span><br><span class="line">        System.out.println(&quot;上个月的第三天:\t&quot; +format(c.getTime()));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static String format(Date time) &#123;</span><br><span class="line">        return sdf.format(time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-练习-Calendar"><a class="header-anchor" href="#示例-3-练习-Calendar">¶</a>示例 3 : 练习-Calendar</h3>
<p>找出下个月的倒数第3天是哪天</p>
<p><img src="/2020/06/27/Java%E5%9F%BA%E7%A1%80%E3%80%90HOW2J%E3%80%91/2372.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package date;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class TestDate &#123;</span><br><span class="line">	private static String toString(Calendar c) &#123;</span><br><span class="line">		Date d &#x3D; c.getTime();</span><br><span class="line">		SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">		String s &#x3D; sdf.format(d);</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Calendar c &#x3D; Calendar.getInstance();</span><br><span class="line">		Date now &#x3D; c.getTime();</span><br><span class="line">		c.setTime(now);</span><br><span class="line">		c.add(Calendar.MONTH, 2);</span><br><span class="line">		c.set(Calendar.DATE, -2);</span><br><span class="line">		System.out.println(toString(c));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十一、Java书籍"><a class="header-anchor" href="#十一、Java书籍">¶</a>十一、Java书籍</h1>
<h3 id="步骤1：两本书籍"><a class="header-anchor" href="#步骤1：两本书籍">¶</a>步骤1：两本书籍</h3>
<p>本站的学习是基于实践和练习为主，在理论知识的讲解方面有欠缺。 所以辅以相应的书籍学习，会双管齐下，两条腿走路，取得更好的效果。<br>
关于辅助书籍，</p>
<p><strong>只推荐两本</strong></p>
<p>Core Java</p>
<p><strong>字典</strong></p>
<p>地址：</p>
<p>比如学习完了IO的知识，觉得意犹未尽，那么就通过这本字典一样的Java书籍，把IO的知识更丰满的刷一遍，因为已经通过本站做了很多实践操作了，所以这个时候，看这些知识就会触类旁通，比较好消化了。</p>
<p>Effective Java</p>
<p><strong>零食，提升代码质量</strong></p>
<p><strong>地址：<a href="https://pan.baidu.com/s/1dDK6cE1#list/path=%2Fsharelink2805246133-1097964938384009%2FEffective%20Java&amp;parentPath=%2Fsharelink2805246133-1097964938384009" target="_blank" rel="noopener">https://pan.baidu.com/s/1dDK6cE1#list/path=%2Fsharelink2805246133-1097964938384009%2FEffective Java&amp;parentPath=%2Fsharelink2805246133-1097964938384009</a></strong></p>
<p>作为初学者，首要任务不是提升质量，而是掌握完成功能的基本手法。这本书就像零食一样，只要主食吃了，你不吃零食也没关系，但是吃点零食会觉得生活质量得到了提升。 本书可以帮你写出更优质的代码，空隙时间可以拿出来看看，不用通看，碰到什么，看什么，一次也不应该看太多，当做有益的课外补充。</p>
<h3 id="步骤2：关于其他书籍的评论"><a class="header-anchor" href="#步骤2：关于其他书籍的评论">¶</a>步骤2：关于其他书籍的评论</h3>
<p>Thinking in Java</p>
<p><strong>提升功力</strong><br>
太早看不合适，里面有些概念需要相当的基础才能理解，否则消化不好。 1年左右看，可以提高不少功力，相当于一个十人副本，在你有了一些基本装备之后，去一趟。为以后去25人团队副本添砖加瓦。</p>
<p>Head First Java</p>
<p><strong>这是给幼儿园小朋友看的</strong><br>
适合完全外行的人看看，页面很多，包含的知识量较少，学习效率较低。</p>
<p>官方出的 Java Tutorial</p>
<p><strong>BEST OF THE BEST</strong><br>
曾经心中的最好的Java入门教程，没有之一，当然，现在被本站代替了，哇哈哈哈。 本站的建设从这个教程里得到很多启发，比如基于代码的学习方式，有兴趣的可以过一过，前提是你的英语还不错。 缺点是，有些概念翻来覆去地讲，我曾经翻译过Java Tutorial，但是一部分翻来覆去倒腾的理论讲解，让我的胃翻腾了很久。</p>
<h3 id="步骤3：关于书籍下载"><a class="header-anchor" href="#步骤3：关于书籍下载">¶</a>步骤3：关于书籍下载</h3>
<p>以上书籍随便百度一下就有pdf下载，本站不提供pdf下载，建议经济压力小的同学购买实体书籍。</p>
]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中级【HOW2J】</title>
    <url>/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>地址：<a href="https://how2j.cn?p=154642" target="_blank" rel="noopener">https://how2j.cn?p=154642</a></strong></p>
<a id="more"></a>
<h1 id="一、异常处理"><a class="header-anchor" href="#一、异常处理">¶</a>一、异常处理</h1>
<h2 id="1、JAVA-异常-EXCEPTION"><a class="header-anchor" href="#1、JAVA-异常-EXCEPTION">¶</a>1、JAVA 异常 EXCEPTION</h2>
<h3 id="步骤-1-文件不存在异常"><a class="header-anchor" href="#步骤-1-文件不存在异常">¶</a>步骤 1 : 文件不存在异常</h3>
<p>比如要打开d盘的LOL.exe文件，这个文件是有可能不存在的<br>
Java中通过 new FileInputStream(f) 试图打开某文件，就有可能抛出<strong>文件不存在异常FileNotFoundException</strong><br>
如果不处理该异常，就会有编译错误<br>
处理办法参见 [异常处理]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">  </span><br><span class="line">public class TestException &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        File f&#x3D; new File(&quot;d:&#x2F;LOL.exe&quot;);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;试图打开文件LOL.exe，会抛出FileNotFoundException，如果不处理该异常，就会有编译错误</span><br><span class="line">        new FileInputStream(f);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-异常"><a class="header-anchor" href="#步骤-2-练习-异常">¶</a>步骤 2 : 练习-异常</h3>
<p>罗列出学习到目前为止，都接触过了哪些异常，分别在什么情况下会出现</p>
<p>![](Java中级【HOW2J】/57538 .png)</p>
<h2 id="2、JAVA的异常处理办法-TRY-CATCH-THROWS"><a class="header-anchor" href="#2、JAVA的异常处理办法-TRY-CATCH-THROWS">¶</a>2、JAVA的异常处理办法 TRY CATCH THROWS</h2>
<h3 id="步骤-1-try-catch"><a class="header-anchor" href="#步骤-1-try-catch">¶</a>步骤 1 : try catch</h3>
<p>1.将可能抛出FileNotFoundException <strong>文件不存在异常</strong>的代码放在try里</p>
<p>2.如果文件存在，就会顺序往下执行，并且不执行catch块中的代码</p>
<ol start="3">
<li>
<p>如果文件不存在，try 里的代码会立即终止，程序流程会运行到对应的catch块中</p>
</li>
<li>
<p>e.printStackTrace(); 会打印出方法的调用痕迹，如此例，会打印出异常开始于TestException的第16行，这样就便于定位和分析到底哪里出了异常</p>
</li>
</ol>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/735.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"> </span><br><span class="line">public class TestException &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        File f&#x3D; new File(&quot;d:&#x2F;LOL.exe&quot;);</span><br><span class="line">         </span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;试图打开 d:&#x2F;LOL.exe&quot;);</span><br><span class="line">            new FileInputStream(f);</span><br><span class="line">            System.out.println(&quot;成功打开&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(&quot;d:&#x2F;LOL.exe不存在&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-使用异常的父类进行catch"><a class="header-anchor" href="#步骤-2-使用异常的父类进行catch">¶</a>步骤 2 : 使用异常的父类进行catch</h3>
<p>FileNotFoundException是Exception的子类，使用Exception也可以catch住FileNotFoundException</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">  </span><br><span class="line">public class TestException &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        File f&#x3D; new File(&quot;d:&#x2F;LOL.exe&quot;);</span><br><span class="line">          </span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;试图打开 d:&#x2F;LOL.exe&quot;);</span><br><span class="line">            new FileInputStream(f);</span><br><span class="line">            System.out.println(&quot;成功打开&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        catch(Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;d:&#x2F;LOL.exe不存在&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-多异常捕捉办法1"><a class="header-anchor" href="#步骤-3-多异常捕捉办法1">¶</a>步骤 3 : 多异常捕捉办法1</h3>
<p>有的时候一段代码会抛出多种异常，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new FileInputStream(f);</span><br><span class="line"></span><br><span class="line">Date d &#x3D; sdf.parse(&quot;2016-06-03&quot;);</span><br></pre></td></tr></table></figure>
<p>这段代码，会抛出 文件不存在异常 FileNotFoundException 和 解析异常ParseException<br>
解决办法之一是分别进行catch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catch (FileNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;d:&#x2F;LOL.exe不存在&quot;);</span><br><span class="line"></span><br><span class="line">	e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; catch (ParseException e) &#123;</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;日期格式解析错误&quot;);</span><br><span class="line"></span><br><span class="line">	e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class TestException &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;LOL.exe&quot;);</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;试图打开 d:&#x2F;LOL.exe&quot;);</span><br><span class="line">            new FileInputStream(f);</span><br><span class="line">            System.out.println(&quot;成功打开&quot;);</span><br><span class="line">            SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">            Date d &#x3D; sdf.parse(&quot;2016-06-03&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(&quot;d:&#x2F;LOL.exe不存在&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            System.out.println(&quot;日期格式解析错误&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-多异常捕捉办法2"><a class="header-anchor" href="#步骤-4-多异常捕捉办法2">¶</a>步骤 4 : 多异常捕捉办法2</h3>
<p>另一个种办法是把多个异常，放在一个catch里统一捕捉</p>
<p>catch (FileNotFoundException | ParseException e) {</p>
<p>这种方式从 JDK7开始支持，好处是捕捉的代码<strong>更紧凑</strong>，不足之处是，一旦发生异常，<strong>不能确定到底是哪种异常</strong>，需要通过instanceof 进行判断具体的异常类型</p>
<p>if (e instanceof FileNotFoundException)</p>
<p>​	System.out.println(“d:/LOL.exe不存在”);</p>
<p>if (e instanceof ParseException)</p>
<p>​	System.out.println(“日期格式解析错误”);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class TestException &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;LOL.exe&quot;);</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;试图打开 d:&#x2F;LOL.exe&quot;);</span><br><span class="line">            new FileInputStream(f);</span><br><span class="line">            System.out.println(&quot;成功打开&quot;);</span><br><span class="line">            SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">            Date d &#x3D; sdf.parse(&quot;2016-06-03&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException | ParseException e) &#123;</span><br><span class="line">            if (e instanceof FileNotFoundException)</span><br><span class="line">                System.out.println(&quot;d:&#x2F;LOL.exe不存在&quot;);</span><br><span class="line">            if (e instanceof ParseException)</span><br><span class="line">                System.out.println(&quot;日期格式解析错误&quot;);</span><br><span class="line"> </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-finally"><a class="header-anchor" href="#步骤-5-finally">¶</a>步骤 5 : finally</h3>
<p>无论是否出现异常，finally中的代码都会被执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"> </span><br><span class="line">public class TestException &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        File f&#x3D; new File(&quot;d:&#x2F;LOL.exe&quot;);</span><br><span class="line">         </span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;试图打开 d:&#x2F;LOL.exe&quot;);</span><br><span class="line">            new FileInputStream(f);</span><br><span class="line">            System.out.println(&quot;成功打开&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(&quot;d:&#x2F;LOL.exe不存在&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">            System.out.println(&quot;无论文件是否存在， 都会执行的代码&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-throws"><a class="header-anchor" href="#步骤-6-throws">¶</a>步骤 6 : throws</h3>
<p>考虑如下情况：<br>
主方法调用method1<br>
method1调用method2<br>
method2中打开文件</p>
<p>method2中需要进行异常处理<br>
但是method2<strong>不打算处理</strong>，而是把这个异常通过<strong>throws 抛出去</strong><br>
那么method1就会<strong>接到该异常</strong>。 处理办法也是两种，要么是try catch处理掉，要么也是<strong>抛出去</strong>。<br>
method1选择本地try catch住 一旦try catch住了，就相当于把这个异常消化掉了，主方法在调用method1的时候，就不需要进行异常处理了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"> </span><br><span class="line">public class TestException &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method1();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void method1() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void method2() throws FileNotFoundException &#123;</span><br><span class="line"> </span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;LOL.exe&quot;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;试图打开 d:&#x2F;LOL.exe&quot;);</span><br><span class="line">        new FileInputStream(f);</span><br><span class="line">        System.out.println(&quot;成功打开&quot;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-throw和throws的区别"><a class="header-anchor" href="#步骤-7-throw和throws的区别">¶</a>步骤 7 : throw和throws的区别</h3>
<p>throws与throw这两个关键字接近，不过意义不一样，有如下区别：</p>
<ol>
<li>
<p>throws 出现在方法声明上，而throw通常都出现在方法体内。</p>
</li>
<li>
<p>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。</p>
</li>
</ol>
<h3 id="步骤-8-练习-异常处理"><a class="header-anchor" href="#步骤-8-练习-异常处理">¶</a>步骤 8 : 练习-异常处理</h3>
<p>假设有一个方法 public int method()， 会返回一个整数<br>
在这个方法中有try catch 和 finally.<br>
try 里返回 1<br>
catch 里 返回 2<br>
finally 里 返回3<br>
那么，这个方法到底返回多少？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先要记住一点 ： finally 中的代码 一定会执行</span><br><span class="line"></span><br><span class="line">先执行try中代码，如果try中代码没有异常且有返回值 ，先会执行 finally中代码 ，如果finally没有返回值，会回过头执行try的return;如果finally中有返回值。则直接返回。不会执行try中的return了；</span><br><span class="line"></span><br><span class="line">catch 同理；</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA-中异常的分类"><a class="header-anchor" href="#3、JAVA-中异常的分类">¶</a>3、JAVA 中异常的分类</h2>
<h3 id="步骤-1-可查异常"><a class="header-anchor" href="#步骤-1-可查异常">¶</a>步骤 1 : 可查异常</h3>
<p>可查异常： CheckedException<br>
可查异常即<strong>必须进行处理的异常</strong>，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException<br>
如果不处理，编译器，就不让你通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">  </span><br><span class="line">public class TestException &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        File f&#x3D; new File(&quot;d:&#x2F;LOL.exe&quot;);</span><br><span class="line">          </span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;试图打开 d:&#x2F;LOL.exe&quot;);</span><br><span class="line">            new FileInputStream(f);</span><br><span class="line">            System.out.println(&quot;成功打开&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(&quot;d:&#x2F;LOL.exe不存在&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-运行时异常"><a class="header-anchor" href="#步骤-2-运行时异常">¶</a>步骤 2 : 运行时异常</h3>
<p>运行时异常RuntimeException指： <strong>不是必须进行try catch的异常</strong><br>
<strong>常见运行时异常:</strong><br>
除数不能为0异常:ArithmeticException<br>
下标越界异常:ArrayIndexOutOfBoundsException<br>
空指针异常:NullPointerException<br>
在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，<strong>即便不进行try catch，也不会有编译错误</strong><br>
Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常<strong>太过于普遍</strong>，如果都需要进行捕捉，代码的可读性就会变得很糟糕。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line">  </span><br><span class="line">public class TestException &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;任何除数不能为0:ArithmeticException</span><br><span class="line">        int k &#x3D; 5&#x2F;0;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;下标越界异常：ArrayIndexOutOfBoundsException</span><br><span class="line">        int j[] &#x3D; new int[5];</span><br><span class="line">        j[10] &#x3D; 10;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;空指针异常：NullPointerException</span><br><span class="line">        String str &#x3D; null;</span><br><span class="line">        str.length();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-错误"><a class="header-anchor" href="#步骤-3-错误">¶</a>步骤 3 : 错误</h3>
<p>错误Error，指的是<strong>系统级别的异常</strong>，通常是内存用光了<br>
在<strong>默认设置下</strong>，一般java程序启动的时候，最大可以使用16m的内存<br>
如例不停的给StringBuffer追加字符，很快就把内存使用光了。抛出<strong>OutOfMemoryError</strong><br>
与运行时异常一样，错误也是不要求强制捕捉的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line">  </span><br><span class="line">public class TestException &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     </span><br><span class="line">        StringBuffer sb &#x3D;new StringBuffer();</span><br><span class="line">         </span><br><span class="line">        for (int i &#x3D; 0; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            sb.append(&#39;a&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-三种分类"><a class="header-anchor" href="#步骤-4-三种分类">¶</a>步骤 4 : 三种分类</h3>
<p>总体上异常分三类：</p>
<ol>
<li>
<p>错误</p>
</li>
<li>
<p>运行时异常</p>
</li>
<li>
<p>可查异常</p>
</li>
</ol>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2412.png" alt></p>
<h3 id="步骤-5-练习-异常分类"><a class="header-anchor" href="#步骤-5-练习-异常分类">¶</a>步骤 5 : 练习-异常分类</h3>
<p>运行时异常 RuntimeException，能否被捕捉？</p>
<p>错误Error，能否被捕捉？</p>
<p><strong>面试题常问题：</strong> 运行时异常与非运行时异常的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行时错误是RunTimeException类或其子类，一般是由程序逻辑问题引起的，如果不进行异常处理，线程或程序将在问题处中断（或main函数处中断）;  非运行错误是RuntimeException以外的异常，类型上都属于Exception类及其子类，java编辑器要求必须对这类异常进行处理</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RuntimeException如果使用try和catch异常可以被捕捉。 错误Error 不能够被捕捉 运行时异常与非运行时异常的区别 Throwable 是所有 Java 程序中错误处理的父类 ，有两种资类： Error 和 Exception 。   Error ：表示由 JVM 所侦测到的无法预期的错误，由于这是属于 JVM 层次的严重错误 ，导致 JVM 无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 Exception ：表示可恢复的例外，这是可捕捉到的。 Java 提供了两类主要的异常 :runtime exception 和 checked exception 。 checked 异常也就是我们经常遇到的 IO 异常，以及 SQL 异常都是这种异常。 对于这种异常， JAVA 编译器强制要求我们必需对出现的这些异常进行  catch 。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆 catch 块去处理可能的异常。     但是另外一种异常： runtime exception ，也称运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机 接管。比如：我们从来没有人去处理过 NullPointerException 异常，它就是运行时异常，并且这种异常还是最常见的异常之一。    出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由 Thread.run() 抛出 ，如果是单线程就被 main() 抛出 。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是  Exception 的子类，也有一般异常的特点，是可以被 Catch  块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。     如果不想终止，则必须扑捉所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。  在这个场景这样处理可能是一个比较好的应用，但并不代表在所有的场景你都应该如此。如果在其它场景，遇到了一些错误，如果退出程序比较好，这时你就可以不太理会运行时异常  ，或者是通过对异常的处理显式的控制程序退出。</span><br></pre></td></tr></table></figure>
<h2 id="4、JAVA-THROWABLE接口"><a class="header-anchor" href="#4、JAVA-THROWABLE接口">¶</a>4、JAVA THROWABLE接口</h2>
<h3 id="步骤-1-Throwable"><a class="header-anchor" href="#步骤-1-Throwable">¶</a>步骤 1 : Throwable</h3>
<p>Throwable是类，Exception和Error都继承了该类<br>
所以在捕捉的时候，也可以使用Throwable进行捕捉<br>
如图： 异常分<strong>Error</strong>和<strong>Exception</strong><br>
Exception里又分<strong>运行时异常</strong>和<strong>可查异常</strong>。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/742.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line"> </span><br><span class="line">public class TestException &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;LOL.exe&quot;);</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            new FileInputStream(f);</span><br><span class="line">            &#x2F;&#x2F;使用Throwable进行异常捕捉</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-Throwable"><a class="header-anchor" href="#步骤-2-练习-Throwable">¶</a>步骤 2 : 练习-Throwable</h3>
<p>在方法声明上，可以抛出指定的异常，比如FileNotFoundException<br>
那么能否抛出Throwable这个类？</p>
<p>这个方法的调用者又该如何处理？</p>
<p>可以抛出Throwable这个类，但catch的时候必须也是Throwable类型</p>
<h2 id="5、JAVA-自定义异常"><a class="header-anchor" href="#5、JAVA-自定义异常">¶</a>5、JAVA 自定义异常</h2>
<h3 id="示例-1-创建自定义异常"><a class="header-anchor" href="#示例-1-创建自定义异常">¶</a>示例 1 : 创建自定义异常</h3>
<p>一个英雄攻击另一个英雄的时候，如果发现另一个英雄已经挂了，就会抛出EnemyHeroIsDeadException<br>
创建一个类EnemyHeroIsDeadException，并继承Exception<br>
提供两个构造方法</p>
<ol>
<li>
<p>无参的构造方法</p>
</li>
<li>
<p>带参的构造方法，并调用父类的对应的构造方法</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class EnemyHeroIsDeadException extends Exception&#123;</span><br><span class="line">     </span><br><span class="line">    public EnemyHeroIsDeadException()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    public EnemyHeroIsDeadException(String msg)&#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-抛出自定义异常"><a class="header-anchor" href="#示例-2-抛出自定义异常">¶</a>示例 2 : 抛出自定义异常</h3>
<p>在Hero的attack方法中，当发现敌方英雄的血量为0的时候，抛出该异常</p>
<ol>
<li>
<p>创建一个EnemyHeroIsDeadException实例</p>
</li>
<li>
<p>通过<strong>throw</strong> 抛出该异常</p>
</li>
<li>
<p>当前方法通过 <strong>throws</strong> 抛出该异常</p>
</li>
</ol>
<p>在外部调用attack方法的时候，就需要进行捕捉，并且捕捉的时候，可以通过e.getMessage() 获取当时出错的具体原因</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/744.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public void attackHero(Hero h) throws EnemyHeroIsDeadException&#123;</span><br><span class="line">        if(h.hp &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            throw new EnemyHeroIsDeadException(h.name + &quot; 已经挂了,不需要施放技能&quot; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    class EnemyHeroIsDeadException extends Exception&#123;</span><br><span class="line">         </span><br><span class="line">        public EnemyHeroIsDeadException()&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        public EnemyHeroIsDeadException(String msg)&#123;</span><br><span class="line">            super(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero garen &#x3D;  new Hero();</span><br><span class="line">        garen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        garen.hp &#x3D; 616;</span><br><span class="line"> </span><br><span class="line">        Hero teemo &#x3D;  new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 0;</span><br><span class="line">         </span><br><span class="line">        try &#123;</span><br><span class="line">            garen.attackHero(teemo);</span><br><span class="line">             </span><br><span class="line">        &#125; catch (EnemyHeroIsDeadException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            System.out.println(&quot;异常的具体原因:&quot;+e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-练习-自定义异常"><a class="header-anchor" href="#示例-3-练习-自定义异常">¶</a>示例 3 : 练习-自定义异常</h3>
<p>对[MyStringBuffer]的插入和删除方法中的边界条件判断，用抛出异常来解决<br>
例: insert(int pos, String b) , 当pos 是负数的时候，抛出<strong>自定义异常</strong><br>
需要实现自定义两种异常<br>
IndexIsNagetiveException 下标为负异常<br>
IndexIsOutofRangeException 下标超出范围异常<br>
以下是需要调用这些异常的场景：</p>
<p><code>pos&lt;0</code></p>
<p>抛出 IndexIsNagetiveException</p>
<p><code>pos&gt;length</code></p>
<p>抛出 IndexIsOutofRangeException</p>
<p><code>null==b</code></p>
<p>抛出 NullPointerException</p>
<p><code>start&lt;0</code></p>
<p>抛出 IndexIsNagetiveException</p>
<p><code>start&gt;length</code></p>
<p>抛出 IndexIsOutofRangeException</p>
<p><code>end&lt;0</code><br>
抛出 IndexIsNagetiveException</p>
<p><code>end&gt;length</code></p>
<p>抛出 IndexIsOutofRangeException</p>
<p><code>start&gt;=end</code></p>
<p>抛出 IndexIsOutofRangeException</p>
<p><strong>注意：</strong> 接口IStringBuffer中声明的方法需要抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package test;</span><br><span class="line"> </span><br><span class="line">public class my  &#123;</span><br><span class="line"> </span><br><span class="line">    int capacity &#x3D; 16;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    char[] value;</span><br><span class="line"> </span><br><span class="line">    public my() &#123;</span><br><span class="line">        value &#x3D; new char[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 有参构造方法</span><br><span class="line">    public my(String str) &#123;</span><br><span class="line">        this();</span><br><span class="line">        if (null &#x3D;&#x3D; str)</span><br><span class="line">            return;</span><br><span class="line"> </span><br><span class="line">        if (capacity &lt; str.length()) &#123;</span><br><span class="line">            capacity &#x3D; value.length * 2;</span><br><span class="line">            value &#x3D; new char[capacity];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (capacity &gt;&#x3D; str.length())</span><br><span class="line">            System.arraycopy(str.toCharArray(), 0, value, 0, str.length());</span><br><span class="line"> </span><br><span class="line">        length &#x3D; str.length();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    public void append(String str) throws IndexIsNagetiveException,IndexIsOutofRangeException&#123;</span><br><span class="line"> </span><br><span class="line">        insert(length, str);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    public void append(char c) throws IndexIsNagetiveException,IndexIsOutofRangeException&#123;</span><br><span class="line">        append(String.valueOf(c));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    public void insert(int pos, char b) throws IndexIsNagetiveException,IndexIsOutofRangeException&#123;</span><br><span class="line">        insert(pos, String.valueOf(b));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    public void delete(int start) throws IndexIsNagetiveException,IndexIsOutofRangeException&#123;</span><br><span class="line"> </span><br><span class="line">        delete(start, length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    public void delete(int start, int end) throws IndexIsNagetiveException,IndexIsOutofRangeException&#123;</span><br><span class="line">        &#x2F;&#x2F; 边界条件判断</span><br><span class="line">        if (start &lt; 0)</span><br><span class="line">            throw new IndexIsNagetiveException(&quot;下标为负异常&quot;);</span><br><span class="line"> </span><br><span class="line">        if (start &gt; length)</span><br><span class="line">            throw new IndexIsOutofRangeException(&quot;下标超出范围&quot;);</span><br><span class="line"> </span><br><span class="line">        if (end &lt; 0)</span><br><span class="line">            throw new IndexIsNagetiveException(&quot;下标为负异常&quot;);</span><br><span class="line"> </span><br><span class="line">        if (end &gt; length)</span><br><span class="line">            throw new IndexIsOutofRangeException(&quot;下标超出范围&quot;);</span><br><span class="line"> </span><br><span class="line">        if (start &gt;&#x3D; end)</span><br><span class="line">            throw new IndexIsOutofRangeException(&quot;下标超出范围&quot;);</span><br><span class="line"> </span><br><span class="line">        System.arraycopy(value, end, value, start, length - end);</span><br><span class="line">        length -&#x3D; end - start;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public void reverse() &#123;</span><br><span class="line"> </span><br><span class="line">        for (int i &#x3D; 0; i &lt; length &#x2F; 2; i++) &#123;</span><br><span class="line">            char temp &#x3D; value[i];</span><br><span class="line">            value[i] &#x3D; value[length - i - 1];</span><br><span class="line">            value[length - i - 1] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public int length() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    public void insert(int pos, String b) throws IndexIsNagetiveException,IndexIsOutofRangeException&#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 边界条件判断</span><br><span class="line">        if (pos &lt; 0)</span><br><span class="line">            throw new IndexIsNagetiveException(&quot;下标为负异常&quot;);</span><br><span class="line"> </span><br><span class="line">        if (pos &gt; length)</span><br><span class="line">            throw new IndexIsOutofRangeException(&quot;下标超出范围&quot;);</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 扩容</span><br><span class="line">        while (length + b.length() &gt; capacity) &#123;</span><br><span class="line">            capacity &#x3D; (int) ((length + b.length()) * 1.5f);</span><br><span class="line">            char[] newValue &#x3D; new char[capacity];</span><br><span class="line">            System.arraycopy(value, 0, newValue, 0, length);</span><br><span class="line">            value &#x3D; newValue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        char[] cs &#x3D; b.toCharArray();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 先把已经存在的数据往后移</span><br><span class="line"> </span><br><span class="line">        System.arraycopy(value, pos, value, pos + cs.length, length - pos);</span><br><span class="line">        &#x2F;&#x2F; 把要插入的数据插入到指定位置</span><br><span class="line">        System.arraycopy(cs, 0, value, pos, cs.length);</span><br><span class="line"> </span><br><span class="line">        length &#x3D; length + cs.length;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String toString() &#123;</span><br><span class="line"> </span><br><span class="line">        char[] realValue &#x3D; new char[length];</span><br><span class="line"> </span><br><span class="line">        System.arraycopy(value, 0, realValue, 0, length);</span><br><span class="line"> </span><br><span class="line">        return new String(realValue);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 下标超出范围异常</span><br><span class="line">    public class IndexIsOutofRangeException extends Exception &#123;</span><br><span class="line">        public IndexIsOutofRangeException() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        public IndexIsOutofRangeException(String s) &#123;</span><br><span class="line">            super(s);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 下标为负异常</span><br><span class="line">    public class IndexIsNagetiveException extends Exception &#123;</span><br><span class="line">        public IndexIsNagetiveException() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        public IndexIsNagetiveException(String s) &#123;</span><br><span class="line">            super(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        my sb &#x3D; new my(&quot;there light&quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        try &#123;</span><br><span class="line">            sb.insert(1, &quot;let&quot;);</span><br><span class="line">            sb.delete(1,3);</span><br><span class="line">        &#125; catch (IndexIsOutofRangeException | IndexIsNagetiveException e ) &#123;</span><br><span class="line">            if (e instanceof IndexIsOutofRangeException)</span><br><span class="line">                System.out.println(&quot;下标超出范围异常&quot;);</span><br><span class="line">            if (e instanceof IndexIsNagetiveException)</span><br><span class="line">                System.out.println(&quot;下标为负异常&quot;);</span><br><span class="line">             System.out.println(&quot;异常的具体原因:&quot;+e.getMessage());</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、JAVA-异常综合练习题"><a class="header-anchor" href="#6、JAVA-异常综合练习题">¶</a>6、JAVA 异常综合练习题</h2>
<h3 id="步骤-1-练习-异常综合1"><a class="header-anchor" href="#步骤-1-练习-异常综合1">¶</a>步骤 1 : 练习-异常综合1</h3>
<p>这是一个类图<br>
Account类： 银行账号<br>
属性： balance 余额<br>
方法： getBalance() 获取余额<br>
方法： deposit() 存钱<br>
方法： withdraw() 取钱<br>
OverdraftException： 透支异常，继承Exception<br>
属性： deficit 透支额</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/745.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class Account &#123;</span><br><span class="line">    protected double balance;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    public Account(double balance) &#123;</span><br><span class="line">        this.balance &#x3D; balance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    public void deposit(double amt) &#123;</span><br><span class="line">        this.balance +&#x3D;amt;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    public void withdraw(double amt) throws OverDraftException&#123;</span><br><span class="line">        if(balance&lt;amt) &#123;</span><br><span class="line">            throw new OverDraftException(&quot;余额不足&quot;,amt-this.balance);</span><br><span class="line">        &#125;</span><br><span class="line">        this.balance -&#x3D; amt;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    public double getBalance() &#123;</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;开户存了1000</span><br><span class="line">        Account a &#x3D; new Account(1000);</span><br><span class="line">        &#x2F;&#x2F;存钱1000</span><br><span class="line">        a.deposit(1000);</span><br><span class="line">        &#x2F;&#x2F;查看余额</span><br><span class="line">        System.out.println(a.getBalance());</span><br><span class="line">            </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;取2001</span><br><span class="line">            a.withdraw(2001);</span><br><span class="line">        &#125; catch (OverDraftException e) &#123;</span><br><span class="line">            System.err.println(&quot;透支金额：&quot;+e.getDeficit());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-异常综合2"><a class="header-anchor" href="#步骤-2-练习-异常综合2">¶</a>步骤 2 : 练习-异常综合2</h3>
<p>类： CheckingAccount 支票账户，具备透支额度，继承Account<br>
属性：overdraftProtection 透支额度</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/746.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class CheckingAccount extends Account &#123;</span><br><span class="line">	private double overdraftProtection;</span><br><span class="line"></span><br><span class="line">	public CheckingAccount(double balance) &#123;</span><br><span class="line">		super(balance);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public CheckingAccount(double balance, double protect) &#123;</span><br><span class="line">		super(balance);</span><br><span class="line">		overdraftProtection &#x3D; protect;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double getOverdraftProtection() &#123; &#x2F;&#x2F;添加的方法获得透支额度</span><br><span class="line">		return overdraftProtection;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void withdraw(double take) throws OverDraftException &#123;</span><br><span class="line">		if (this.balance + overdraftProtection &lt; take) &#123;</span><br><span class="line">			throw new OverDraftException(&quot;余额不足&quot;, take - (overdraftProtection + this.balance));</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.balance &gt;&#x3D; take) &#123; &#x2F;&#x2F; 如果本金够就先扣本金的</span><br><span class="line">			this.balance -&#x3D; take;</span><br><span class="line">		&#125; else if (balance &lt; take) &#123; &#x2F;&#x2F;如果本金不够 就先得出差数 然后本金归零 透支的额度减去差数就好</span><br><span class="line">			overdraftProtection -&#x3D; (take - balance);</span><br><span class="line">			balance &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		CheckingAccount a &#x3D; new CheckingAccount(1000, 500);</span><br><span class="line">		try &#123;</span><br><span class="line">			a.withdraw(10);</span><br><span class="line">		&#125; catch (OverDraftException e) &#123;</span><br><span class="line">			System.out.println(&quot;超出金额为：&quot;+e.getDeficit());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			System.out.println(&quot;本金余额为：&quot; + a.getBalance());</span><br><span class="line">			System.out.println(&quot;透支余额为：&quot; + a.getOverdraftProtection());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、I-O"><a class="header-anchor" href="#二、I-O">¶</a>二、I/O</h1>
<h2 id="1、JAVA-的FILE类，以及常用方法"><a class="header-anchor" href="#1、JAVA-的FILE类，以及常用方法">¶</a>1、JAVA 的FILE类，以及常用方法</h2>
<h3 id="步骤-1-创建一个文件对象"><a class="header-anchor" href="#步骤-1-创建一个文件对象">¶</a>步骤 1 : 创建一个文件对象</h3>
<p>使用绝对路径或者相对路径创建File对象</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/756.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">  </span><br><span class="line">public class TestFile &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 绝对路径</span><br><span class="line">        File f1 &#x3D; new File(&quot;d:&#x2F;LOLFolder&quot;);</span><br><span class="line">        System.out.println(&quot;f1的绝对路径：&quot; + f1.getAbsolutePath());</span><br><span class="line">        &#x2F;&#x2F; 相对路径,相对于工作目录，如果在eclipse中，就是项目目录</span><br><span class="line">        File f2 &#x3D; new File(&quot;LOL.exe&quot;);</span><br><span class="line">        System.out.println(&quot;f2的绝对路径：&quot; + f2.getAbsolutePath());</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 把f1作为父目录创建文件对象</span><br><span class="line">        File f3 &#x3D; new File(f1, &quot;LOL.exe&quot;);</span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;f3的绝对路径：&quot; + f3.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-文件常用方法1"><a class="header-anchor" href="#步骤-2-文件常用方法1">¶</a>步骤 2 : 文件常用方法1</h3>
<p><strong>注意1：</strong> 需要在D:\LOLFolder确实存在一个LOL.exe,才可以看到对应的文件长度、修改时间等信息</p>
<p><strong>注意2： renameTo  方法用于对物理文件名称进行修改，但是并不会修改File对象的name属性。</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/757.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.Date;</span><br><span class="line">  </span><br><span class="line">public class TestFile &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;LOLFolder&#x2F;LOL.exe&quot;);</span><br><span class="line">        System.out.println(&quot;当前文件是：&quot; +f);</span><br><span class="line">        &#x2F;&#x2F;文件是否存在</span><br><span class="line">        System.out.println(&quot;判断是否存在：&quot;+f.exists());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;是否是文件夹</span><br><span class="line">        System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory());</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;是否是文件（非文件夹）</span><br><span class="line">        System.out.println(&quot;判断是否是文件：&quot;+f.isFile());</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;文件长度</span><br><span class="line">        System.out.println(&quot;获取文件的长度：&quot;+f.length());</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;文件最后修改时间</span><br><span class="line">        long time &#x3D; f.lastModified();</span><br><span class="line">        Date d &#x3D; new Date(time);</span><br><span class="line">        System.out.println(&quot;获取文件的最后修改时间：&quot;+d);</span><br><span class="line">        &#x2F;&#x2F;设置文件修改时间为1970.1.1 08:00:00</span><br><span class="line">        f.setLastModified(0);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;文件重命名</span><br><span class="line">        File f2 &#x3D;new File(&quot;d:&#x2F;LOLFolder&#x2F;DOTA.exe&quot;);</span><br><span class="line">        f.renameTo(f2);</span><br><span class="line">        System.out.println(&quot;把LOL.exe改名成了DOTA.exe&quot;);</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\r\n才可以看到对应的文件长度、修改时间等信息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-文件常用方法2"><a class="header-anchor" href="#步骤-3-文件常用方法2">¶</a>步骤 3 : 文件常用方法2</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">  </span><br><span class="line">public class TestFile &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">  </span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;LOLFolder&#x2F;skin&#x2F;garen.ski&quot;);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span><br><span class="line">        f.list();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span><br><span class="line">        File[]fs&#x3D; f.listFiles();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 以字符串形式返回获取所在文件夹</span><br><span class="line">        f.getParent();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 以文件形式返回获取所在文件夹</span><br><span class="line">        f.getParentFile();</span><br><span class="line">        &#x2F;&#x2F; 创建文件夹，如果父文件夹skin不存在，创建就无效</span><br><span class="line">        f.mkdir();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹</span><br><span class="line">        f.mkdirs();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 创建一个空文件,如果父文件夹skin不存在，就会抛出异常</span><br><span class="line">        f.createNewFile();</span><br><span class="line">        &#x2F;&#x2F; 所以创建一个空文件之前，通常都会创建父目录</span><br><span class="line">        f.getParentFile().mkdirs();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 列出所有的盘符c: d: e: 等等</span><br><span class="line">        f.listRoots();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 刪除文件</span><br><span class="line">        f.delete();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; JVM结束的时候，刪除文件，常用于临时文件的删除</span><br><span class="line">        f.deleteOnExit();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-遍历文件夹"><a class="header-anchor" href="#步骤-4-练习-遍历文件夹">¶</a>步骤 4 : 练习-遍历文件夹</h3>
<p>一般说来操作系统都会安装在C盘，所以会有一个 C:\WINDOWS目录。</p>
<p>遍历这个目录下所有的文件(不用遍历子目录)</p>
<p>找出这些文件里，最大的和最小(非0)的那个文件，打印出他们的文件名</p>
<p><strong>注:</strong> 最小的文件不能是0长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">public class File_BianLi_C_WINDOWS &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        File f &#x3D; new File(&quot;C:&#x2F;Windows&quot;);</span><br><span class="line">        File[] fs &#x3D; f.listFiles();</span><br><span class="line">        File maxFile &#x3D; null;</span><br><span class="line">        File minFile &#x3D; null;</span><br><span class="line">        </span><br><span class="line">        for(File f1 : fs) &#123;</span><br><span class="line">        	System.out.println(f1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (File ff : fs) &#123;</span><br><span class="line">            if (ff.length() !&#x3D; 0)&#123;</span><br><span class="line">                maxFile &#x3D; ff;</span><br><span class="line">                minFile &#x3D; ff;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (File ff : fs) &#123;</span><br><span class="line">            if (ff.length() !&#x3D; 0) &#123;</span><br><span class="line">                if (ff.length() &gt; maxFile.length()) &#123;</span><br><span class="line">                    maxFile &#x3D; ff;</span><br><span class="line">                &#125;</span><br><span class="line">                if (ff.length() &lt; minFile.length()) &#123;</span><br><span class="line">                    minFile &#x3D; ff;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;最大文件是：&quot; + maxFile.getAbsolutePath() + &quot;,大小为：&quot; + maxFile.length() + &quot;字节&quot;);</span><br><span class="line">        System.out.println(&quot;最小文件是：&quot; + minFile.getAbsolutePath() + &quot;,大小为：&quot; + minFile.length() + &quot;字节&quot;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-遍历子文件夹"><a class="header-anchor" href="#步骤-5-练习-遍历子文件夹">¶</a>步骤 5 : 练习-遍历子文件夹</h3>
<p>同上的练习，要求遍历子文件夹</p>
<h2 id="2、什么JAVA-的流-STREAM？"><a class="header-anchor" href="#2、什么JAVA-的流-STREAM？">¶</a>2、什么JAVA 的流 STREAM？</h2>
<h3 id="步骤-1-什么是流"><a class="header-anchor" href="#步骤-1-什么是流">¶</a>步骤 1 : 什么是流</h3>
<p>当不同的介质之间有数据交互的时候，JAVA就使用流来实现。<br>
数据源可以是文件，还可以是数据库，网络甚至是其他的程序</p>
<p>比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流<br>
输入流： InputStream<br>
输出流：OutputStream</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/759.png" alt></p>
<h3 id="步骤-2-文件输入流"><a class="header-anchor" href="#步骤-2-文件输入流">¶</a>步骤 2 : 文件输入流</h3>
<p>如下代码，就建立了一个文件输入流，这个流可以用来把数据从硬盘的文件，读取到JVM(内存)。</p>
<p>目前代码只是建立了流，还没有开始读取，真正的读取在下个章节讲解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            File f &#x3D; new File(&quot;d:&#x2F;lol.txt&quot;);</span><br><span class="line">            &#x2F;&#x2F; 创建基于文件的输入流</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(f);</span><br><span class="line">            &#x2F;&#x2F; 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟机中来，也就是读取到内存中</span><br><span class="line"> </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-流"><a class="header-anchor" href="#步骤-3-练习-流">¶</a>步骤 3 : 练习-流</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line"> </span><br><span class="line">public class Test1 &#123;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            File f &#x3D; new File(&quot;f:&#x2F;lol.txt&quot;);</span><br><span class="line">            &#x2F;&#x2F;创建基于文件的输出流</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(f);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA-字节流-INPUTSTREAM-OUTPUTSTREAM"><a class="header-anchor" href="#3、JAVA-字节流-INPUTSTREAM-OUTPUTSTREAM">¶</a>3、JAVA 字节流 INPUTSTREAM OUTPUTSTREAM</h2>
<h3 id="步骤-1-ASCII码-概念"><a class="header-anchor" href="#步骤-1-ASCII码-概念">¶</a>步骤 1 : ASCII码 概念</h3>
<p>所有的数据存放在计算机中都是以数字的形式存放的。 所以<strong>字母就需要转换为数字才能够存放</strong>。<br>
比如A就对应的数字65，a对应的数字97. 不同的字母和符号对应不同的数字，就是一张码表。<br>
ASCII是这样的一种码表。 只<strong>包含简单的英文字母</strong>，符号，数字等等。 <strong>不包含中文，德文，俄语等复杂</strong>的。</p>
<p>示例中列出了可见的ASCII码以及对应的十进制和十六进制数字，不可见的暂未列出</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>十进制数字</th>
<th>十六进制数字</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>33</td>
<td>21</td>
</tr>
<tr>
<td>&quot;</td>
<td>34</td>
<td>22</td>
</tr>
<tr>
<td>#</td>
<td>35</td>
<td>23</td>
</tr>
<tr>
<td>$</td>
<td>36</td>
<td>24</td>
</tr>
<tr>
<td>%</td>
<td>37</td>
<td>25</td>
</tr>
<tr>
<td>&amp;</td>
<td>38</td>
<td>26</td>
</tr>
<tr>
<td>’</td>
<td>39</td>
<td>27</td>
</tr>
<tr>
<td>(</td>
<td>40</td>
<td>28</td>
</tr>
<tr>
<td>)</td>
<td>41</td>
<td>29</td>
</tr>
<tr>
<td>*</td>
<td>42</td>
<td>2A</td>
</tr>
<tr>
<td>+</td>
<td>43</td>
<td>2B</td>
</tr>
<tr>
<td>,</td>
<td>44</td>
<td>2C</td>
</tr>
<tr>
<td>-</td>
<td>45</td>
<td>2D</td>
</tr>
<tr>
<td>.</td>
<td>46</td>
<td>2E</td>
</tr>
<tr>
<td>/</td>
<td>47</td>
<td>2F</td>
</tr>
<tr>
<td>0</td>
<td>48</td>
<td>30</td>
</tr>
<tr>
<td>1</td>
<td>49</td>
<td>31</td>
</tr>
<tr>
<td>2</td>
<td>50</td>
<td>32</td>
</tr>
<tr>
<td>3</td>
<td>51</td>
<td>33</td>
</tr>
<tr>
<td>4</td>
<td>52</td>
<td>34</td>
</tr>
<tr>
<td>5</td>
<td>53</td>
<td>35</td>
</tr>
<tr>
<td>6</td>
<td>54</td>
<td>36</td>
</tr>
<tr>
<td>7</td>
<td>55</td>
<td>37</td>
</tr>
<tr>
<td>8</td>
<td>56</td>
<td>38</td>
</tr>
<tr>
<td>9</td>
<td>57</td>
<td>39</td>
</tr>
<tr>
<td>:</td>
<td>58</td>
<td>3A</td>
</tr>
<tr>
<td>;</td>
<td>59</td>
<td>3B</td>
</tr>
<tr>
<td>&lt;</td>
<td>60</td>
<td>3C</td>
</tr>
<tr>
<td>=</td>
<td>61</td>
<td>3D</td>
</tr>
<tr>
<td>&gt;</td>
<td>62</td>
<td>3E</td>
</tr>
<tr>
<td>@</td>
<td>64</td>
<td>40</td>
</tr>
<tr>
<td>A</td>
<td>65</td>
<td>41</td>
</tr>
<tr>
<td>B</td>
<td>66</td>
<td>42</td>
</tr>
<tr>
<td>C</td>
<td>67</td>
<td>43</td>
</tr>
<tr>
<td>D</td>
<td>68</td>
<td>44</td>
</tr>
<tr>
<td>E</td>
<td>69</td>
<td>45</td>
</tr>
<tr>
<td>F</td>
<td>70</td>
<td>46</td>
</tr>
<tr>
<td>G</td>
<td>71</td>
<td>47</td>
</tr>
<tr>
<td>H</td>
<td>72</td>
<td>48</td>
</tr>
<tr>
<td>I</td>
<td>73</td>
<td>49</td>
</tr>
<tr>
<td>J</td>
<td>74</td>
<td>4A</td>
</tr>
<tr>
<td>K</td>
<td>75</td>
<td>4B</td>
</tr>
<tr>
<td>L</td>
<td>76</td>
<td>4C</td>
</tr>
<tr>
<td>M</td>
<td>77</td>
<td>4D</td>
</tr>
<tr>
<td>N</td>
<td>78</td>
<td>4E</td>
</tr>
<tr>
<td>O</td>
<td>79</td>
<td>4F</td>
</tr>
<tr>
<td>P</td>
<td>80</td>
<td>50</td>
</tr>
<tr>
<td>Q</td>
<td>81</td>
<td>51</td>
</tr>
<tr>
<td>R</td>
<td>82</td>
<td>52</td>
</tr>
<tr>
<td>S</td>
<td>83</td>
<td>53</td>
</tr>
<tr>
<td>T</td>
<td>84</td>
<td>54</td>
</tr>
<tr>
<td>U</td>
<td>85</td>
<td>55</td>
</tr>
<tr>
<td>V</td>
<td>86</td>
<td>56</td>
</tr>
<tr>
<td>W</td>
<td>87</td>
<td>57</td>
</tr>
<tr>
<td>X</td>
<td>88</td>
<td>58</td>
</tr>
<tr>
<td>Y</td>
<td>89</td>
<td>59</td>
</tr>
<tr>
<td>Z</td>
<td>90</td>
<td>5A</td>
</tr>
<tr>
<td>[</td>
<td>91</td>
<td>5B</td>
</tr>
<tr>
<td>\</td>
<td>92</td>
<td>5C</td>
</tr>
<tr>
<td>]</td>
<td>93</td>
<td>5D</td>
</tr>
<tr>
<td>^</td>
<td>94</td>
<td>5E</td>
</tr>
<tr>
<td>_</td>
<td>95</td>
<td>5F</td>
</tr>
<tr>
<td>`</td>
<td>96</td>
<td>60</td>
</tr>
<tr>
<td>a</td>
<td>97</td>
<td>61</td>
</tr>
<tr>
<td>b</td>
<td>98</td>
<td>62</td>
</tr>
<tr>
<td>c</td>
<td>99</td>
<td>63</td>
</tr>
<tr>
<td>d</td>
<td>100</td>
<td>64</td>
</tr>
<tr>
<td>e</td>
<td>101</td>
<td>65</td>
</tr>
<tr>
<td>f</td>
<td>102</td>
<td>66</td>
</tr>
<tr>
<td>g</td>
<td>103</td>
<td>67</td>
</tr>
<tr>
<td>h</td>
<td>104</td>
<td>68</td>
</tr>
<tr>
<td>i</td>
<td>105</td>
<td>69</td>
</tr>
<tr>
<td>j</td>
<td>106</td>
<td>6A</td>
</tr>
<tr>
<td>k</td>
<td>107</td>
<td>6B</td>
</tr>
<tr>
<td>l</td>
<td>108</td>
<td>6C</td>
</tr>
<tr>
<td>m</td>
<td>109</td>
<td>6D</td>
</tr>
<tr>
<td>n</td>
<td>110</td>
<td>6E</td>
</tr>
<tr>
<td>o</td>
<td>111</td>
<td>6F</td>
</tr>
<tr>
<td>p</td>
<td>112</td>
<td>70</td>
</tr>
<tr>
<td>q</td>
<td>113</td>
<td>71</td>
</tr>
<tr>
<td>r</td>
<td>114</td>
<td>72</td>
</tr>
<tr>
<td>s</td>
<td>115</td>
<td>73</td>
</tr>
<tr>
<td>t</td>
<td>116</td>
<td>74</td>
</tr>
<tr>
<td>u</td>
<td>117</td>
<td>75</td>
</tr>
<tr>
<td>v</td>
<td>118</td>
<td>76</td>
</tr>
<tr>
<td>w</td>
<td>119</td>
<td>77</td>
</tr>
<tr>
<td>x</td>
<td>120</td>
<td>78</td>
</tr>
<tr>
<td>y</td>
<td>121</td>
<td>79</td>
</tr>
<tr>
<td>z</td>
<td>122</td>
<td>7A</td>
</tr>
<tr>
<td>{</td>
<td>123</td>
<td>7B</td>
</tr>
<tr>
<td>|</td>
<td>124</td>
<td>7C</td>
</tr>
<tr>
<td>}</td>
<td>125</td>
<td>7D</td>
</tr>
<tr>
<td>~</td>
<td>126</td>
<td>7E</td>
</tr>
</tbody>
</table>
<h3 id="步骤-2-以字节流的形式读取文件内容"><a class="header-anchor" href="#步骤-2-以字节流的形式读取文件内容">¶</a>步骤 2 : 以字节流的形式读取文件内容</h3>
<p>InputStream是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。<br>
FileInputStream 是InputStream子类，以FileInputStream 为例进行文件读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">  </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;准备文件lol.txt其中的内容是AB，对应的ASCII分别是65 66</span><br><span class="line">            File f &#x3D;new File(&quot;d:&#x2F;lol.txt&quot;);</span><br><span class="line">            &#x2F;&#x2F;创建基于文件的输入流</span><br><span class="line">            FileInputStream fis &#x3D;new FileInputStream(f);</span><br><span class="line">            &#x2F;&#x2F;创建字节数组，其长度就是文件的长度</span><br><span class="line">            byte[] all &#x3D;new byte[(int) f.length()];</span><br><span class="line">            &#x2F;&#x2F;以字节流的形式读取文件所有内容</span><br><span class="line">            fis.read(all);</span><br><span class="line">            for (byte b : all) &#123;</span><br><span class="line">                &#x2F;&#x2F;打印出来是65 66</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;每次使用完流，都应该进行关闭</span><br><span class="line">            fis.close();</span><br><span class="line">              </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-以字节流的形式向文件写入数据"><a class="header-anchor" href="#步骤-3-以字节流的形式向文件写入数据">¶</a>步骤 3 : 以字节流的形式向文件写入数据</h3>
<p>OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。<br>
FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据</p>
<p>注: 如果文件d:/lol2.txt不存在，写出操作会自动创建该文件。<br>
但是如果是文件 d:/xyz/lol2.txt，而目录xyz又不存在，会抛出异常</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2414.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 准备文件lol2.txt其中的内容是空的</span><br><span class="line">            File f &#x3D; new File(&quot;d:&#x2F;lol2.txt&quot;);</span><br><span class="line">            &#x2F;&#x2F; 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y</span><br><span class="line">            byte data[] &#x3D; &#123; 88, 89 &#125;;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 创建基于文件的输出流</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(f);</span><br><span class="line">            &#x2F;&#x2F; 把数据写入到输出流</span><br><span class="line">            fos.write(data);</span><br><span class="line">            &#x2F;&#x2F; 关闭输出流</span><br><span class="line">            fos.close();</span><br><span class="line">             </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-写入数据到文件"><a class="header-anchor" href="#步骤-4-练习-写入数据到文件">¶</a>步骤 4 : 练习-写入数据到文件</h3>
<p>[以字节流的形式向文件写入数据] 中的例子，当lol2.txt不存在的时候，是会自动创建lol2.txt文件的。<br>
但是，如果是写入数据到d:/xyz/lol2.txt，而目录xyz又不存在的话，就会抛出异常。<br>
那么怎么自动创建xyz目录？<br>
如果是多层目录 d:/xyz/abc/def/lol2.txt 呢？</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2415.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;准备文件lol.txt其中的内容是空的</span><br><span class="line">			File f&#x3D;new File(&quot;D:&#x2F;xyz&#x2F;lol.txt&quot;);</span><br><span class="line">			&#x2F;&#x2F;获得父目录生成文件夹</span><br><span class="line">			f.getParentFile().mkdirs();</span><br><span class="line">			&#x2F;&#x2F;准备长度是5的数组，用65,66,90,91,92</span><br><span class="line">			byte[] b&#x3D;&#123;65,66,90,91,92&#125;;</span><br><span class="line">			&#x2F;&#x2F;创建基于文件的输出流</span><br><span class="line">			FileOutputStream fos&#x3D;new FileOutputStream(f);</span><br><span class="line">			&#x2F;&#x2F;把数据写入到输出流</span><br><span class="line">			fos.write(b);</span><br><span class="line">			&#x2F;&#x2F;关闭输出流</span><br><span class="line">			fos.close();</span><br><span class="line"></span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-拆分文件"><a class="header-anchor" href="#步骤-5-练习-拆分文件">¶</a>步骤 5 : 练习-拆分文件</h3>
<p>找到一个大于100k的文件，按照100k为单位，拆分成多个子文件，并且以编号作为文件名结束。<br>
比如文件 eclipse.exe，大小是309k。<br>
拆分之后，成为<br>
eclipse.exe-0<br>
eclipse.exe-1<br>
eclipse.exe-2<br>
eclipse.exe-3</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2417.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">  </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int eachSize &#x3D; 100 * 1024; &#x2F;&#x2F; 100k</span><br><span class="line">        File srcFile &#x3D; new File(&quot;d:&#x2F;eclipse.exe&quot;);</span><br><span class="line">        splitFile(srcFile, eachSize);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 拆分的思路，先把源文件的所有内容读取到内存中，然后从内存中挨个分到子文件里</span><br><span class="line">     * @param srcFile 要拆分的源文件</span><br><span class="line">     * @param eachSize 按照这个大小，拆分</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void splitFile(File srcFile, int eachSize) &#123;</span><br><span class="line">  </span><br><span class="line">        if (0 &#x3D;&#x3D; srcFile.length())</span><br><span class="line">            throw new RuntimeException(&quot;文件长度为0，不可拆分&quot;);</span><br><span class="line">  </span><br><span class="line">        byte[] fileContent &#x3D; new byte[(int) srcFile.length()];</span><br><span class="line">        &#x2F;&#x2F; 先把文件读取到数组中</span><br><span class="line">        try &#123;</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(srcFile);</span><br><span class="line">            fis.read(fileContent);</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 计算需要被划分成多少份子文件</span><br><span class="line">        int fileNumber;</span><br><span class="line">        &#x2F;&#x2F; 文件是否能被整除得到的子文件个数是不一样的</span><br><span class="line">        &#x2F;&#x2F; (假设文件长度是25，每份的大小是5，那么就应该是5个)</span><br><span class="line">        &#x2F;&#x2F; (假设文件长度是26，每份的大小是5，那么就应该是6个)</span><br><span class="line">        if (0 &#x3D;&#x3D; fileContent.length % eachSize)</span><br><span class="line">            fileNumber &#x3D; (int) (fileContent.length &#x2F; eachSize);</span><br><span class="line">        else</span><br><span class="line">            fileNumber &#x3D; (int) (fileContent.length &#x2F; eachSize) + 1;</span><br><span class="line">  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; fileNumber; i++) &#123;</span><br><span class="line">            String eachFileName &#x3D; srcFile.getName() + &quot;-&quot; + i;</span><br><span class="line">            File eachFile &#x3D; new File(srcFile.getParent(), eachFileName);</span><br><span class="line">            byte[] eachContent;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 从源文件的内容里，复制部分数据到子文件</span><br><span class="line">            &#x2F;&#x2F; 除开最后一个文件，其他文件大小都是100k</span><br><span class="line">            &#x2F;&#x2F; 最后一个文件的大小是剩余的</span><br><span class="line">            if (i !&#x3D; fileNumber - 1) &#x2F;&#x2F; 不是最后一个</span><br><span class="line">                eachContent &#x3D; Arrays.copyOfRange(fileContent, eachSize * i, eachSize * (i + 1));</span><br><span class="line">            else &#x2F;&#x2F; 最后一个</span><br><span class="line">                eachContent &#x3D; Arrays.copyOfRange(fileContent, eachSize * i, fileContent.length);</span><br><span class="line">  </span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 写出去</span><br><span class="line">                FileOutputStream fos &#x3D; new FileOutputStream(eachFile);</span><br><span class="line">                fos.write(eachContent);</span><br><span class="line">                &#x2F;&#x2F; 记得关闭</span><br><span class="line">                fos.close();</span><br><span class="line">                System.out.printf(&quot;输出子文件%s，其大小是 %d字节%n&quot;, eachFile.getAbsoluteFile(), eachFile.length());</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-练习-合并文件"><a class="header-anchor" href="#步骤-6-练习-合并文件">¶</a>步骤 6 : 练习-合并文件</h3>
<p>把上述拆分出来的文件，合并成一个原文件。</p>
<p>以是否能正常运行，验证合并是否正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Merge &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        murgeFile(&quot;D:\\abc\\split&quot;, &quot;01.pdf&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 合并的思路，就是从eclipse.exe-0开始，读取到一个文件，就开始写出到 eclipse.exe中，直到没有文件可以读</span><br><span class="line">     * @param folder</span><br><span class="line">     *            需要合并的文件所处于的目录</span><br><span class="line">     * @param fileName</span><br><span class="line">     *            需要合并的文件的名称</span><br><span class="line">     * @throws FileNotFoundException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void murgeFile(String folder, String fileName) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 合并的目标文件</span><br><span class="line">            File destFile &#x3D; new File(folder, fileName);</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(destFile);</span><br><span class="line">            int index &#x3D; 0;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                &#x2F;&#x2F;子文件</span><br><span class="line">                File eachFile &#x3D; new File(folder, fileName + &quot;-&quot; + index++);</span><br><span class="line">                &#x2F;&#x2F;如果子文件不存在了就结束</span><br><span class="line">                if (!eachFile.exists())</span><br><span class="line">                    break;</span><br><span class="line">  </span><br><span class="line">                &#x2F;&#x2F;读取子文件的内容</span><br><span class="line">                FileInputStream fis &#x3D; new FileInputStream(eachFile);</span><br><span class="line">                byte[] eachContent &#x3D; new byte[(int) eachFile.length()];</span><br><span class="line">                fis.read(eachContent);</span><br><span class="line">                fis.close();</span><br><span class="line">                  </span><br><span class="line">                &#x2F;&#x2F;把子文件的内容写出去</span><br><span class="line">                fos.write(eachContent);</span><br><span class="line">                fos.flush();</span><br><span class="line">                System.out.printf(&quot;把子文件 %s写出到目标文件中%n&quot;,eachFile);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            fos.close();</span><br><span class="line">            System.out.printf(&quot;最后目标文件的大小：%,d字节&quot; , destFile.length());</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、关闭流的方式"><a class="header-anchor" href="#4、关闭流的方式">¶</a>4、关闭流的方式</h2>
<h3 id="步骤-1-在try中关闭"><a class="header-anchor" href="#步骤-1-在try中关闭">¶</a>步骤 1 : 在try中关闭</h3>
<p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端；<br>
如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 <strong>不推荐</strong>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            File f &#x3D; new File(&quot;d:&#x2F;lol.txt&quot;);</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(f);</span><br><span class="line">            byte[] all &#x3D; new byte[(int) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            for (byte b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 在try 里关闭流</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-在finally中关闭"><a class="header-anchor" href="#步骤-2-在finally中关闭">¶</a>步骤 2 : 在finally中关闭</h3>
<p>这是标准的关闭流的方式</p>
<ol>
<li>
<p>首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally.</p>
</li>
<li>
<p>在finally关闭之前，要先判断该引用是否为空</p>
</li>
<li>
<p>关闭的时候，需要再一次进行try catch处理</p>
</li>
</ol>
<p>这是标准的严谨的关闭流的方式，但是看上去很繁琐，所以写不重要的或者测试代码的时候，都会采用上面的<strong>有隐患</strong>try的方式，因为不麻烦~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;lol.txt&quot;);</span><br><span class="line">        FileInputStream fis &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis &#x3D; new FileInputStream(f);</span><br><span class="line">            byte[] all &#x3D; new byte[(int) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            for (byte b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 在finally 里关闭流</span><br><span class="line">            if (null !&#x3D; fis)</span><br><span class="line">                try &#123;</span><br><span class="line"> </span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-使用try-的方式"><a class="header-anchor" href="#步骤-3-使用try-的方式">¶</a>步骤 3 : 使用try()的方式</h3>
<p>把流定义在try()里,try,catch或者finally结束的时候，会自动关闭<br>
这种编写代码的方式叫做 <strong>try-with-resources</strong>， 这是从JDK7开始支持的技术</p>
<p>所有的流，都实现了一个接口叫做 <strong>AutoCloseable</strong>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">  </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;lol.txt&quot;);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</span><br><span class="line">        try (FileInputStream fis &#x3D; new FileInputStream(f)) &#123;</span><br><span class="line">            byte[] all &#x3D; new byte[(int) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            for (byte b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-关闭流"><a class="header-anchor" href="#步骤-4-练习-关闭流">¶</a>步骤 4 : 练习-关闭流</h3>
<p>把 [拆分文件]中关闭流的风格，修改成 finally 方式</p>
<p>把 [合并文件]中关闭流的风格，修改成 try() 方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"> </span><br><span class="line">public class TestStream1 &#123;</span><br><span class="line">     </span><br><span class="line">    public static void main(String []args) &#123;</span><br><span class="line">        split();</span><br><span class="line">        merge();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void split() &#123;</span><br><span class="line">&#x2F;&#x2F;      找到一个大于100k的文件，按照100k为单位，拆分成多个子文件，并且以编号作为文件名结束。</span><br><span class="line">&#x2F;&#x2F;      比如文件 eclipse.exe，大小是309k。</span><br><span class="line">&#x2F;&#x2F;      拆分之后，成为 </span><br><span class="line">&#x2F;&#x2F;      eclipse.exe-0</span><br><span class="line">&#x2F;&#x2F;      eclipse.exe-1</span><br><span class="line">&#x2F;&#x2F;      eclipse.exe-2</span><br><span class="line">&#x2F;&#x2F;      eclipse.exe-3</span><br><span class="line">        &#x2F;&#x2F;之前在TestStream里用自己的方式做了一次，现在来用Arrays.copyOfRange再 来做一次</span><br><span class="line">        &#x2F;&#x2F;这一次用的文件只有19K，所以会以2K，或者3K来做拆分                      </span><br><span class="line">        File f &#x3D; new File(&quot;F:\\testFile\\lianxi.txt&quot;);</span><br><span class="line">        System.out.println(&quot;源文件的是:&quot;+f.getName()+&quot;，大小是：&quot;+f.length());</span><br><span class="line">        &#x2F;&#x2F;文件的总长度</span><br><span class="line">        long allLength &#x3D; f.length();</span><br><span class="line">        &#x2F;&#x2F;得到要写入的字节数据的长度</span><br><span class="line">        int num &#x3D; (int) (allLength &#x2F; 1024 &#x2F; 2 +1);</span><br><span class="line">        &#x2F;&#x2F;创建文件数据对象</span><br><span class="line">        File files[] &#x3D; new File[num];</span><br><span class="line">        &#x2F;&#x2F;初始化文件</span><br><span class="line">        for (int i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">            files[i] &#x3D; new File(f.getParent(), f.getName()+&#39;-&#39;+i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        FileInputStream fis &#x3D;null;</span><br><span class="line">        FileOutputStream fos &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;FileInputStream fis &#x3D; new FileInputStream(f);</span><br><span class="line">            fis &#x3D; new FileInputStream(f);</span><br><span class="line">            byte all[] &#x3D; new byte[(int)allLength];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">                byte []temp &#x3D; null;</span><br><span class="line">                if(i &#x3D;&#x3D; files.length-1) &#123;</span><br><span class="line">                    temp &#x3D; Arrays.copyOfRange(all, i*1024*2, (int)allLength);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    temp &#x3D; Arrays.copyOfRange(all, i*1024*2, (i+1)*1024*2);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;FileOutputStream fos &#x3D; new FileOutputStream(files[i]); </span><br><span class="line">                fos &#x3D; new FileOutputStream(files[i]); </span><br><span class="line">                fos.write(temp);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(null!&#x3D;fis) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(null!&#x3D;fos) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        for (File file : files) &#123;</span><br><span class="line">            System.out.println(&quot;拆分后的文件名是：&quot;+file.getName()+&quot;,大小是：&quot;+file.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void merge() &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F;      把上述拆分出来的文件，合并成一个原文件。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;      以是否能正常运行，验证合并是否正确</span><br><span class="line">        &#x2F;&#x2F;先定义一下要合并的文件</span><br><span class="line">        File tagf &#x3D; new File(&quot;F:\\testFile\\lianxi11\\lianxi.txt&quot;);</span><br><span class="line">        tagf.getParentFile().mkdirs();</span><br><span class="line">        &#x2F;&#x2F;假设并不知道要合并的个数，只知道名称样式</span><br><span class="line">        &#x2F;&#x2F;合并文件的总长度</span><br><span class="line">        long totalLength &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;要合并的文件个数</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;遍历目录下我们要合并的文件</span><br><span class="line">        File f &#x3D; new File(&quot;F:\\testFile&quot;);</span><br><span class="line">        &#x2F;&#x2F;目录下的所有文件</span><br><span class="line">        File []files &#x3D; f.listFiles();</span><br><span class="line">        System.out.println(&quot;文件的总个数为:&quot;+files.length);</span><br><span class="line">        &#x2F;&#x2F;找出要合并的文件是那些</span><br><span class="line">        for (int i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">            if(files[i].getName().contains(&quot;lianxi.txt-&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F;得到文件的总长度</span><br><span class="line">                totalLength +&#x3D;files[i].length();</span><br><span class="line">                &#x2F;&#x2F;文件个数</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;总长度为:&quot;+totalLength);</span><br><span class="line">        System.out.println(&quot;文件个数为:&quot;+num);</span><br><span class="line">        &#x2F;&#x2F;创建目标文件的字节数据，用上面找到的长度和个数来创建字节数组tagbb和文件数组files2</span><br><span class="line">        byte tagbb[] &#x3D; new byte[(int)totalLength];</span><br><span class="line">        File files2[] &#x3D; new File[num];</span><br><span class="line">        &#x2F;&#x2F;临时变量</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;写入内容，内容要从上面的文件中来</span><br><span class="line">        for (int i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">            if(files[i].getName().contains(&quot;lianxi.txt-&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F;得到文件的总长度</span><br><span class="line">                files2[j]&#x3D;files[i];</span><br><span class="line">                &#x2F;&#x2F;文件个数</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;文件中的内容合并到tagbb中</span><br><span class="line">        &#x2F;&#x2F;FileInputStream fis &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;这次循环只有循环files2的个数了</span><br><span class="line">        for (int i &#x3D; 0; i &lt; files2.length; i++) &#123;</span><br><span class="line">            try (FileInputStream fis &#x3D;new FileInputStream(files2[i]))&#123;</span><br><span class="line">                &#x2F;&#x2F;创建字节输入流</span><br><span class="line">                &#x2F;&#x2F;fis &#x3D; new FileInputStream(files2[i]);</span><br><span class="line">                &#x2F;&#x2F;临时的字节数组</span><br><span class="line">                byte []temp &#x3D; new byte[(int)files2[i].length()];</span><br><span class="line">                &#x2F;&#x2F;读入内容</span><br><span class="line">                fis.read(temp);</span><br><span class="line">                &#x2F;&#x2F;将内容依次写入tagbb中，利用System.arraycopy的功能，下次不要傻傻自己写方法了</span><br><span class="line">                System.arraycopy(temp, 0, tagbb, i*1024*2, temp.length);</span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;   </span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;创建字节输出流</span><br><span class="line">        try (FileOutputStream fos &#x3D; new FileOutputStream(tagf))&#123;</span><br><span class="line">            fos.write(tagbb);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        String str &#x3D; &quot;合并后的文件目录为%s,合并后的文件大小为：%d&quot;;</span><br><span class="line">        System.out.printf(str,tagf.getAbsolutePath(),tagf.length());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、JAVA的字符流-READER-WRITER"><a class="header-anchor" href="#5、JAVA的字符流-READER-WRITER">¶</a>5、JAVA的字符流 READER WRITER</h2>
<h3 id="步骤-1-使用字符流读取文件"><a class="header-anchor" href="#步骤-1-使用字符流读取文件">¶</a>步骤 1 : 使用字符流读取文件</h3>
<p>FileReader 是Reader子类，以FileReader 为例进行文件读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 准备文件lol.txt其中的内容是AB</span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;lol.txt&quot;);</span><br><span class="line">        &#x2F;&#x2F; 创建基于文件的Reader</span><br><span class="line">        try (FileReader fr &#x3D; new FileReader(f)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建字符数组，其长度就是文件的长度</span><br><span class="line">            char[] all &#x3D; new char[(int) f.length()];</span><br><span class="line">            &#x2F;&#x2F; 以字符流的形式读取文件所有内容</span><br><span class="line">            fr.read(all);</span><br><span class="line">            for (char b : all) &#123;</span><br><span class="line">                &#x2F;&#x2F; 打印出来是A B</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-使用字符流把字符串写入到文件"><a class="header-anchor" href="#步骤-2-使用字符流把字符串写入到文件">¶</a>步骤 2 : 使用字符流把字符串写入到文件</h3>
<p>FileWriter 是Writer的子类，以FileWriter 为例把字符串写入到文件</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2432.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">  </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 准备文件lol2.txt</span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;lol2.txt&quot;);</span><br><span class="line">        &#x2F;&#x2F; 创建基于文件的Writer</span><br><span class="line">        try (FileWriter fr &#x3D; new FileWriter(f)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 以字符流的形式把数据写入到文件中</span><br><span class="line">            String data&#x3D;&quot;abcdefg1234567890&quot;;</span><br><span class="line">            char[] cs &#x3D; data.toCharArray();</span><br><span class="line">            fr.write(cs);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-文件加密"><a class="header-anchor" href="#步骤-3-练习-文件加密">¶</a>步骤 3 : 练习-文件加密</h3>
<p>准备一个<strong>文本文件</strong>(非二进制)，其中包含<a href="https://how2j.cn/k/io/io-bytestream/340.html#step766" target="_blank" rel="noopener">ASCII码</a>的字符和中文字符。<br>
设计一个方法</p>
<p>public static void encodeFile(File encodingFile, File encodedFile);</p>
<p>在这个方法中把encodingFile的内容进行加密，然后保存到encodedFile文件中。<br>
加密算法：<br>
数字：<br>
如果不是9的数字，在原来的基础上加1，比如5变成6, 3变成4<br>
如果是9的数字，变成0<br>
字母字符：<br>
如果是非z字符，向右移动一个，比如d变成e, G变成H<br>
如果是z，z-&gt;a, Z-A。<br>
字符需要保留大小写<br>
非字母字符<br>
比如’,&amp;^ 保留不变，中文也保留不变<br>
<strong>建议：</strong> 使用以前学习的练习题中的某个Java文件，比如循环练习，就有很多的字符和数字</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2434.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class Test&#123;</span><br><span class="line">    static File f1 &#x3D; new File(&quot;D:&#x2F;lianxi.txt&quot;);</span><br><span class="line">    static File f2 &#x3D; new File(&quot;D:&#x2F;lianxi2.txt&quot;);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        encodeFile(f1, f2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void encodeFile(File encodingFile, File encodedFile)&#123;</span><br><span class="line">        FileReader fr &#x3D; null;</span><br><span class="line">        FileWriter fw &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fr &#x3D; new FileReader(encodingFile);</span><br><span class="line">            fw &#x3D; new FileWriter(encodedFile);</span><br><span class="line">            char[] before &#x3D; new char[(int)f1.length()];</span><br><span class="line">            fr.read(before);</span><br><span class="line">            char[] after &#x3D; new char[(int)f1.length()];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; before.length; i++)&#123;</span><br><span class="line">                after[i] &#x3D; change(before[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            fw.write(after);</span><br><span class="line">            System.out.println(&quot;加密前的内容：&quot;);</span><br><span class="line">            for (char c : before)&#123;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;\n加密后的内容：&quot;);</span><br><span class="line">            for (char c : after)&#123;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if (fr !&#x3D; null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (fw !&#x3D; null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static char change(char c)&#123;</span><br><span class="line">        if ((int)c &gt;&#x3D; 48 &amp;&amp; (int)c &lt;&#x3D; 56)&#123;</span><br><span class="line">            return (char)(c+1);</span><br><span class="line">        &#125;else if ((int)c &#x3D;&#x3D; 57)&#123;</span><br><span class="line">            return &#39;0&#39;;</span><br><span class="line">        &#125;else if ((int)c &gt;&#x3D; 65 &amp;&amp; (int)c &lt;&#x3D; 89)&#123;</span><br><span class="line">            return (char)(c+1);</span><br><span class="line">        &#125;else if ((int)c &#x3D;&#x3D; 90)&#123;</span><br><span class="line">            return &#39;A&#39;;</span><br><span class="line">        &#125;else if ((int)c &gt;&#x3D; 97 &amp;&amp; (int)c &lt;&#x3D; 121)&#123;</span><br><span class="line">            return (char)(c+1);</span><br><span class="line">        &#125;else if ((int)c &#x3D;&#x3D; 122)&#123;</span><br><span class="line">            return &#39;a&#39;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-文件解密"><a class="header-anchor" href="#步骤-4-练习-文件解密">¶</a>步骤 4 : 练习-文件解密</h3>
<p>解密在[文件加密]中生成的文件。<br>
设计一个方法</p>
<p>public static void decodeFile(File decodingFile, File decodedFile);</p>
<p>在这个方法中把decodingFile的内容进行解密，然后保存到decodedFile文件中。<br>
解密算法：<br>
数字：<br>
如果不是0的数字，在原来的基础上减1，比如6变成5, 4变成3<br>
如果是0的数字，变成9<br>
字母字符：<br>
如果是非a字符，向左移动一个，比如e变成d, H变成G<br>
如果是a，a-&gt;z, A-Z。<br>
字符需要保留大小写<br>
非字母字符：<br>
比如’,&amp;^ 保留不变，中文也保留不变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class Test&#123;</span><br><span class="line">    static File f1 &#x3D; new File(&quot;D:&#x2F;lianxi2.txt&quot;);</span><br><span class="line">    static File f2 &#x3D; new File(&quot;D:&#x2F;lianxi1.txt&quot;);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        encodeFile(f1, f2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void encodeFile(File encodingFile, File encodedFile)&#123;</span><br><span class="line">        FileReader fr &#x3D; null;</span><br><span class="line">        FileWriter fw &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fr &#x3D; new FileReader(encodingFile);</span><br><span class="line">            fw &#x3D; new FileWriter(encodedFile);</span><br><span class="line">            char[] before &#x3D; new char[(int)f1.length()];</span><br><span class="line">            fr.read(before);</span><br><span class="line">            char[] after &#x3D; new char[(int)f1.length()];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; before.length; i++)&#123;</span><br><span class="line">                after[i] &#x3D; change(before[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            fw.write(after);</span><br><span class="line">            System.out.println(&quot;解密前的内容：&quot;);</span><br><span class="line">            for (char c : before)&#123;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;\n解密后的内容：&quot;);</span><br><span class="line">            for (char c : after)&#123;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if (fr !&#x3D; null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (fw !&#x3D; null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static char change(char c)&#123;</span><br><span class="line">        if ((int)c &gt;&#x3D; 49 &amp;&amp; (int)c &lt;&#x3D; 57)&#123;</span><br><span class="line">            return (char)(c-1);</span><br><span class="line">        &#125;else if ((int)c &#x3D;&#x3D; 48)&#123;</span><br><span class="line">            return &#39;9&#39;;</span><br><span class="line">        &#125;else if ((int)c &gt;&#x3D; 66 &amp;&amp; (int)c &lt;&#x3D; 90)&#123;</span><br><span class="line">            return (char)(c-1);</span><br><span class="line">        &#125;else if ((int)c &#x3D;&#x3D; 65)&#123;</span><br><span class="line">            return &#39;Z&#39;;</span><br><span class="line">        &#125;else if ((int)c &gt;&#x3D; 98 &amp;&amp; (int)c &lt;&#x3D; 122)&#123;</span><br><span class="line">            return (char)(c-1);</span><br><span class="line">        &#125;else if ((int)c &#x3D;&#x3D; 97)&#123;</span><br><span class="line">            return &#39;z&#39;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、JAVA-编码中文问题系统透彻讲解-UNICODE-GBK-UTF-8-ISO-8859-1-之间的区别"><a class="header-anchor" href="#6、JAVA-编码中文问题系统透彻讲解-UNICODE-GBK-UTF-8-ISO-8859-1-之间的区别">¶</a>6、JAVA 编码中文问题系统透彻讲解 UNICODE GBK UTF-8 ISO-8859-1 之间的区别</h2>
<h3 id="步骤-1-编码概念"><a class="header-anchor" href="#步骤-1-编码概念">¶</a>步骤 1 : 编码概念</h3>
<p>计算机存放数据只能存放数字，所有的字符都会被转换为不同的数字。<br>
就像一个棋盘一样，不同的字，处于不同的位置，而不同的位置，有不同的数字编号。<br>
有的棋盘很小，只能放数字和英文<br>
有的大一点，还能放中文<br>
有的“足够”大，能够放下世界人民所使用的所有文字和符号</p>
<p>如图所示，英文字符 <strong>A</strong> 能够放在所有的棋盘里，而且位置都差不多<br>
中文字符, 中文字符 <strong>中</strong> 能够放在后两种棋盘里，并且位置不一样，而且在小的那个棋盘里，就放不下中文</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2481.png" alt></p>
<h3 id="步骤-2-常见编码"><a class="header-anchor" href="#步骤-2-常见编码">¶</a>步骤 2 : 常见编码</h3>
<p>工作后经常接触的编码方式有如下几种：<br>
<strong>ISO-8859-1 ASCII</strong> 数字和西欧字母<br>
<strong>GBK GB2312 BIG5</strong> 中文<br>
<strong>UNICODE</strong> (统一码，万国码)</p>
<p>其中<br>
ISO-8859-1 包含 ASCII<br>
GB2312 是简体中文，BIG5是繁体中文，GBK同时包含简体和繁体以及日文。<br>
UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含其中</p>
<h3 id="步骤-3-UNICODE和UTF"><a class="header-anchor" href="#步骤-3-UNICODE和UTF">¶</a>步骤 3 : UNICODE和UTF</h3>
<p>根据前面的学习，我们了解到不同的编码方式对应不同的<strong>棋盘</strong>，而UNICODE因为要存放所有的数据，那么它的棋盘是最大的。<br>
不仅如此，棋盘里每个数字都是很长的(4个字节)，因为不仅要表示字母，还要表示汉字等。</p>
<p>如果完全按照UNICODE的方式来存储数据，就会有很大的浪费。<br>
比如在ISO-8859-1中，<strong>a</strong> 字符对应的数字是0x61<br>
而UNICODE中对应的数字是 0x00000061，倘若一篇文章大部分都是英文字母，那么按照UNICODE的方式进行数据保存就会消耗很多空间</p>
<p>在这种情况下，就出现了UNICODE的各种<strong>减肥</strong>子编码, 比如UTF-8对数字和字母就使用一个字节，而对汉字就使用3个字节，从而达到了<strong>减肥还能保证健康</strong>的效果</p>
<p>UTF-8，UTF-16和UTF-32 针对不同类型的数据有不同的<strong>减肥效果</strong>，一般说来UTF-8是比较常用的方式</p>
<p>UTF-8，UTF-16和UTF-32 彼此的区别在此不作赘述，有兴趣的可以参考 <a href="http://baike.baidu.com/link?url=ty4mEX5hSfK2xAyPO8N2zgxTibBE59CShSb5yFxbVkBun_QVz65llOPEXOepgPeqe3AQDLt6LLjTayn6tioS4_#4" target="_blank" rel="noopener">unicode-百度百科</a></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2482.png" alt></p>
<h3 id="步骤-4-Java采用的是Unicode"><a class="header-anchor" href="#步骤-4-Java采用的是Unicode">¶</a>步骤 4 : Java采用的是Unicode</h3>
<p>写在.java源代码中的汉字，在执行之后，都会变成JVM中的字符。<br>
而这些中文字符采用的编码方式，都是使用UNICODE. &quot;中&quot;字对应的UNICODE是<strong>4E2D</strong>,所以在内存中，实际保存的数据就是十六进制的0x4E2D, 也就是十进制的20013。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str &#x3D; &quot;中&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-一个汉字使用不同编码方式的表现"><a class="header-anchor" href="#步骤-5-一个汉字使用不同编码方式的表现">¶</a>步骤 5 : 一个汉字使用不同编码方式的表现</h3>
<p>以字符 <strong>中</strong> 为例，查看其在不同编码方式下的值是多少</p>
<p>也即在不同的<strong>棋盘上的位置</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2483.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str &#x3D; &quot;中&quot;;</span><br><span class="line">        showCode(str);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void showCode(String str) &#123;</span><br><span class="line">        String[] encodes &#x3D; &#123; &quot;BIG5&quot;, &quot;GBK&quot;, &quot;GB2312&quot;, &quot;UTF-8&quot;, &quot;UTF-16&quot;, &quot;UTF-32&quot; &#125;;</span><br><span class="line">        for (String encode : encodes) &#123;</span><br><span class="line">            showCode(str, encode);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void showCode(String str, String encode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.printf(&quot;字符: \&quot;%s\&quot; 的在编码方式%s下的十六进制值是%n&quot;, str, encode);</span><br><span class="line">            byte[] bs &#x3D; str.getBytes(encode);</span><br><span class="line"> </span><br><span class="line">            for (byte b : bs) &#123;</span><br><span class="line">                int i &#x3D; b&amp;0xff;</span><br><span class="line">                System.out.print(Integer.toHexString(i) + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.printf(&quot;UnsupportedEncodingException: %s编码方式无法解析字符%s\n&quot;, encode, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-文件的编码方式-记事本"><a class="header-anchor" href="#步骤-6-文件的编码方式-记事本">¶</a>步骤 6 : 文件的编码方式-记事本</h3>
<p>接下来讲，字符在文件中的保存<br>
字符保存在文件中肯定也是以数字形式保存的，即对应在不同的<strong>棋盘</strong>上的不同的数字<br>
用<strong>记事本</strong>打开任意文本文件，并且<strong>另存为</strong>，就能够在编码这里看到一个下拉。<br>
<strong>ANSI</strong> 这个<strong>不是  ASCII  <strong>的意思，而是采用</strong>本地编码</strong>的意思。如果你是中文的操作系统，就会使GBK，如果是英文的就会是ISO-8859-1<br>
<strong>Unicode</strong> UNICODE原生的编码方式<br>
<strong>Unicode big endian</strong> 另一个 UNICODE编码方式<br>
<strong>UTF-8</strong> 最常见的UTF-8编码方式，数字和字母用一个字节， 汉字用3个字节。</p>
<h3 id="步骤-7-文件的编码方式-eclipse"><a class="header-anchor" href="#步骤-7-文件的编码方式-eclipse">¶</a>步骤 7 : 文件的编码方式-eclipse</h3>
<p>eclipse也有类似的编码方式，右键任意文本文件，点击最下面的&quot;property&quot;<br>
就可以看到<strong>Text file encoding</strong><br>
也有ISO-8859-1，GBK,UTF-8等等选项。<br>
其他的US-ASCII,UTF-16，UTF-16BE,UTF-16LE不常用。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2485.png" alt></p>
<h3 id="步骤-8-用FileInputStream-字节流正确读取中文"><a class="header-anchor" href="#步骤-8-用FileInputStream-字节流正确读取中文">¶</a>步骤 8 : 用FileInputStream 字节流正确读取中文</h3>
<p>为了能够正确的读取中文内容</p>
<ol>
<li>
<p>必须了解文本是以哪种编码方式保存字符的</p>
</li>
<li>
<p>使用字节流读取了文本后，再使用对应的<strong>编码方式去识别这些数字</strong>，得到正确的字符<br>
如本例，一个文件中的内容是字符<strong>中</strong>，编码方式是GBK，那么读出来的数据一定是D6D0。<br>
再使用GBK编码方式识别D6D0，就能正确的得到字符<strong>中</strong></p>
</li>
</ol>
<p><strong>注：</strong> 在GBK的棋盘上找到的<strong>中</strong>字后，JVM会自动找到<strong>中</strong>在UNICODE这个棋盘上对应的数字，并且以[UNICODE上的数字保存在内存中]。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2488.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">   </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">   </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File f &#x3D; new File(&quot;E:\\project\\j2se\\src\\test.txt&quot;);</span><br><span class="line">        try (FileInputStream fis &#x3D; new FileInputStream(f);) &#123;</span><br><span class="line">            byte[] all &#x3D; new byte[(int) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">   </span><br><span class="line">            &#x2F;&#x2F;文件中读出来的数据是</span><br><span class="line">            System.out.println(&quot;文件中读出来的数据是：&quot;);</span><br><span class="line">            for (byte b : all)</span><br><span class="line">            &#123;</span><br><span class="line">                int i &#x3D; b&amp;0x000000ff;  &#x2F;&#x2F;只取16进制的后两位</span><br><span class="line">                System.out.println(Integer.toHexString(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;把这个数字，放在GBK的棋盘上去：&quot;);</span><br><span class="line">            String str &#x3D; new String(all,&quot;GBK&quot;);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-9-用FileReader-字符流正确读取中文"><a class="header-anchor" href="#步骤-9-用FileReader-字符流正确读取中文">¶</a>步骤 9 : 用FileReader 字符流正确读取中文</h3>
<p>FileReader得到的是字符，所以一定是已经把字节<strong>根据某种编码识别成了字符</strong>了<br>
而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK<br>
FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替，像这样：</p>
<p>new InputStreamReader(new FileInputStream(f),Charset.forName(“UTF-8”));</p>
<p>在本例中，用记事本另存为UTF-8格式，然后用UTF-8就能识别对应的中文了。</p>
<p><strong>解释：</strong> 为什么中字前面有一个?<br>
如果是使用记事本另存为UTF-8的格式，那么在第一个字节有一个<strong>标示符</strong>，叫做BOM用来标志这个文件是用UTF-8来编码的。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2489.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws UnsupportedEncodingException, FileNotFoundException &#123;</span><br><span class="line">        File f &#x3D; new File(&quot;E:\\project\\j2se\\src\\test.txt&quot;);</span><br><span class="line">        System.out.println(&quot;默认编码方式:&quot;+Charset.defaultCharset());</span><br><span class="line">        &#x2F;&#x2F;FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了</span><br><span class="line">        &#x2F;&#x2F;而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK</span><br><span class="line">        try (FileReader fr &#x3D; new FileReader(f)) &#123;</span><br><span class="line">            char[] cs &#x3D; new char[(int) f.length()];</span><br><span class="line">            fr.read(cs);</span><br><span class="line">            System.out.printf(&quot;FileReader会使用默认的编码方式%s,识别出来的字符是：%n&quot;,Charset.defaultCharset());</span><br><span class="line">            System.out.println(new String(cs));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替</span><br><span class="line">        &#x2F;&#x2F;并且使用new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;)); 这样的形式</span><br><span class="line">        try (InputStreamReader isr &#x3D; new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;))) &#123;</span><br><span class="line">            char[] cs &#x3D; new char[(int) f.length()];</span><br><span class="line">            isr.read(cs);</span><br><span class="line">            System.out.printf(&quot;InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n&quot;);</span><br><span class="line">            System.out.println(new String(cs));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-10-练习-数字对应的中文"><a class="header-anchor" href="#步骤-10-练习-数字对应的中文">¶</a>步骤 10 : 练习-数字对应的中文</h3>
<p>找出 E5 B1 8C 这3个十六进制对应UTF-8编码的汉字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line"></span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line">public class TestFile &#123;</span><br><span class="line">		public static void main(String[] args) throws UnsupportedEncodingException &#123;</span><br><span class="line">		byte[] bs &#x3D; &#123;(byte) 0xE5,(byte) 0xB1,(byte) 0x8C&#125;;</span><br><span class="line"></span><br><span class="line">		String str &#x3D; new String(bs,&quot;UTF-8&quot;);</span><br><span class="line">		System.out.println(&quot;E5 B1 8C 用UTF-8编码对应的的汉字是：&quot;+str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-11-练习-移除BOM"><a class="header-anchor" href="#步骤-11-练习-移除BOM">¶</a>步骤 11 : 练习-移除BOM</h3>
<p>如果用记事本根据UTF-8编码保存汉字就会在最前面生成一段标示符，这个标示符用于表示该文件是使用UTF-8编码的。</p>
<p>找出这段标示符对应的十六进制，并且开发一个方法，自动去除这段标示符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package rego;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">public class FileTest3 &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        File f&#x3D;new File(&quot;E:\\新建文件夹\\ReGo\\lol.txt&quot;);</span><br><span class="line">        Bom(f);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    public static void Bom(File file)</span><br><span class="line">    &#123;</span><br><span class="line">        try(FileInputStream fis&#x3D;new FileInputStream(file))</span><br><span class="line">        &#123;</span><br><span class="line">            byte [] all &#x3D; new byte[(int)(file.length())];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            String s&#x3D;new String(all,&quot;UTF-8&quot;);</span><br><span class="line">            System.out.printf(&quot;未斩首的:%s&quot;,s);</span><br><span class="line">            System.out.println();</span><br><span class="line">             &#x2F;*for (byte b : all) &#123;</span><br><span class="line">                    int i &#x3D; b &amp; 0xff;</span><br><span class="line">                    System.out.print(Integer.toHexString(i) + &quot; &quot;);&#125;*&#x2F;</span><br><span class="line">             all&#x3D;Arrays.copyOfRange(all, 3, all.length);</span><br><span class="line">             fis.read(all);</span><br><span class="line">             String s2&#x3D;new String(all,&quot;UTF-8&quot;);</span><br><span class="line">             System.out.printf(&quot;斩首后（去BOM）的:%s&quot;,s2);</span><br><span class="line">            &#x2F;* System.out.println(&quot;改过后的：&quot;);</span><br><span class="line">             for (byte b : all) &#123;</span><br><span class="line">                    int i &#x3D; b &amp; 0xff;</span><br><span class="line">                    System.out.print(Integer.toHexString(i) + &quot; &quot;);&#125;*&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、JAVA-缓存流BUFFEREDREADER，PRINTWRITER"><a class="header-anchor" href="#7、JAVA-缓存流BUFFEREDREADER，PRINTWRITER">¶</a>7、JAVA 缓存流BUFFEREDREADER，PRINTWRITER</h2>
<h3 id="示例-1-使用缓存流读取数据"><a class="header-anchor" href="#示例-1-使用缓存流读取数据">¶</a>示例 1 : 使用缓存流读取数据</h3>
<p>缓存字符输入流 BufferedReader 可以一次读取一行数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">  </span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">  </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 准备文件lol.txt其中的内容是</span><br><span class="line">        &#x2F;&#x2F; garen kill teemo</span><br><span class="line">        &#x2F;&#x2F; teemo revive after 1 minutes</span><br><span class="line">        &#x2F;&#x2F; teemo try to garen, but killed again</span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;lol.txt&quot;);</span><br><span class="line">        &#x2F;&#x2F; 创建文件字符流</span><br><span class="line">        &#x2F;&#x2F; 缓存流必须建立在一个存在的流的基础上</span><br><span class="line">        try (</span><br><span class="line">                FileReader fr &#x3D; new FileReader(f);</span><br><span class="line">                BufferedReader br &#x3D; new BufferedReader(fr);</span><br><span class="line">            )</span><br><span class="line">        &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                &#x2F;&#x2F; 一次读一行</span><br><span class="line">                String line &#x3D; br.readLine();</span><br><span class="line">                if (null &#x3D;&#x3D; line)</span><br><span class="line">                    break;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-使用缓存流写出数据"><a class="header-anchor" href="#示例-2-使用缓存流写出数据">¶</a>示例 2 : 使用缓存流写出数据</h3>
<p>PrintWriter 缓存字符输出流， 可以一次写出一行数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">   </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">   </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 向文件lol2.txt中写入三行语句</span><br><span class="line">        File f &#x3D; new File(&quot;d:&#x2F;lol2.txt&quot;);</span><br><span class="line">          </span><br><span class="line">        try (</span><br><span class="line">                &#x2F;&#x2F; 创建文件字符流</span><br><span class="line">                FileWriter fw &#x3D; new FileWriter(f);</span><br><span class="line">                &#x2F;&#x2F; 缓存流必须建立在一个存在的流的基础上              </span><br><span class="line">                PrintWriter pw &#x3D; new PrintWriter(fw);              </span><br><span class="line">        ) &#123;</span><br><span class="line">            pw.println(&quot;garen kill teemo&quot;);</span><br><span class="line">            pw.println(&quot;teemo revive after 1 minutes&quot;);</span><br><span class="line">            pw.println(&quot;teemo try to garen, but killed again&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-flush"><a class="header-anchor" href="#示例-3-flush">¶</a>示例 3 : flush</h3>
<p>有的时候，需要<strong>立即把数据写入到硬盘</strong>，而不是等缓存满了才写出去。 这时候就需要用到flush</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">    </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">public class TestStream &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;向文件lol2.txt中写入三行语句</span><br><span class="line">        File f &#x3D;new File(&quot;d:&#x2F;lol2.txt&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建文件字符流</span><br><span class="line">        &#x2F;&#x2F;缓存流必须建立在一个存在的流的基础上</span><br><span class="line">        try(FileWriter fr &#x3D; new FileWriter(f);PrintWriter pw &#x3D; new PrintWriter(fr);) &#123;</span><br><span class="line">            pw.println(&quot;garen kill teemo&quot;);</span><br><span class="line">            &#x2F;&#x2F;强制把缓存中的数据写入硬盘，无论缓存是否已满</span><br><span class="line">                pw.flush();           </span><br><span class="line">            pw.println(&quot;teemo revive after 1 minutes&quot;);</span><br><span class="line">                pw.flush();</span><br><span class="line">            pw.println(&quot;teemo try to garen, but killed again&quot;);</span><br><span class="line">                pw.flush();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-练习-移除注释"><a class="header-anchor" href="#示例-4-练习-移除注释">¶</a>示例 4 : 练习-移除注释</h3>
<p>设计一个方法，用于移除Java文件中的注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void removeComments(File javaFile)</span><br></pre></td></tr></table></figure>
<p>比如，移出以//开头的注释行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File f &#x3D; new File(&quot;d:&#x2F;LOLFolder&#x2F;LOL.exe&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;当前文件是：&quot; +f);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件是否存在</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;判断是否存在：&quot;+f.exists());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;是否是文件夹</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory());</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong> 如果注释在后面，或者是/**/风格的注释，暂不用处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">&#x2F;&#x2F; 设计一个方法，用于移除Java文件中的注释</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; public void removeComments(File javaFile)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比如，移出以&#x2F;&#x2F;开头的注释行</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; File f &#x3D; new File(&quot;d:&#x2F;LOLFolder&#x2F;LOL.exe&quot;);</span><br><span class="line">&#x2F;&#x2F; System.out.println(&quot;当前文件是：&quot; +f);</span><br><span class="line">&#x2F;&#x2F; 文件是否存在</span><br><span class="line">&#x2F;&#x2F; System.out.println(&quot;判断是否存在：&quot;+f.exists());</span><br><span class="line">&#x2F;&#x2F; 是否是文件夹</span><br><span class="line">&#x2F;&#x2F; System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory());</span><br><span class="line">public class RemoveComments &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		&#x2F;&#x2F; 这是一行注释</span><br><span class="line">		File file1 &#x3D; new File(&quot;d:\\yzb.txt&quot;);</span><br><span class="line">		File file2 &#x3D; new File(&quot;d:\\yzb1.txt&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			FileReader fr &#x3D; new FileReader(file1);</span><br><span class="line">			FileWriter fw &#x3D; new FileWriter(file2);</span><br><span class="line">			BufferedReader br &#x3D; new BufferedReader(fr);</span><br><span class="line">			BufferedWriter bf &#x3D; new BufferedWriter(fw);</span><br><span class="line">			while (true) &#123;</span><br><span class="line">				String s &#x3D; br.readLine();</span><br><span class="line">				if (s !&#x3D; null) &#123;</span><br><span class="line">					&#x2F;&#x2F; 把含有&#x2F;&#x2F;的字符串分割成几个部分</span><br><span class="line">					String ss[] &#x3D; s.split(&quot;&#x2F;&#x2F;&quot;);</span><br><span class="line">					&#x2F;&#x2F; 如果ss</span><br><span class="line">					&#x2F;&#x2F; 这个数组的长度大于一，也就是表示s这个字符串含有&#x2F;&#x2F;（不含有的话ss.length&#x3D;&#x3D;1），并且&#x2F;&#x2F;的前头为&quot;&quot;就不写入文件（就是注释）</span><br><span class="line">					if (ss.length &gt; 1 &amp;&amp; ss[0].equals(&quot;&quot;)) &#123;</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">					&#x2F;&#x2F; 还有种情况，就是这一行含有&#x2F;&#x2F;但是开头不是&quot;&quot;,而是由空白字符组成。这也是注释</span><br><span class="line">					else if (ss.length &gt; 1) &#123;</span><br><span class="line">						&#x2F;&#x2F; 这里使用了正则表达式，ss[0].matches(&quot;[\\s]+&quot;)表示了这个字符串中是否全是由空白字符组成，是的话就返回true</span><br><span class="line">						if (ss[0].matches(&quot;[\\s]+&quot;)) &#123;</span><br><span class="line">							continue;</span><br><span class="line">						&#125;</span><br><span class="line">						&#x2F;&#x2F; 除了以上两种情况的字符串就算含有&#x2F;&#x2F; 也会正常写入文件</span><br><span class="line">						else &#123;</span><br><span class="line">							bf.write(s);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						bf.write(s);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					br.close();</span><br><span class="line">					bf.flush();</span><br><span class="line">					bf.close();</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、JAVA-数据流DATAINPUTSTREAM-，DATAOUTPUTSTREAM"><a class="header-anchor" href="#8、JAVA-数据流DATAINPUTSTREAM-，DATAOUTPUTSTREAM">¶</a>8、JAVA 数据流DATAINPUTSTREAM ，DATAOUTPUTSTREAM</h2>
<h3 id="步骤-1-直接进行字符串的读写"><a class="header-anchor" href="#步骤-1-直接进行字符串的读写">¶</a>步骤 1 : 直接进行字符串的读写</h3>
<p>使用数据流的writeUTF()和readUTF() 可以进行数据的<strong>格式化顺序读写</strong><br>
如本例，通过DataOutputStream 向文件顺序写出 布尔值，整数和字符串。 然后再通过DataInputStream 顺序读入这些数据。</p>
<p><strong>注：</strong> 要用DataInputStream 读取一个文件，这个文件必须是由DataOutputStream 写出的，否则会出现EOFException，因为DataOutputStream 在写出的时候会做一些特殊标记，只有DataInputStream 才能成功的读取。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/771.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">      </span><br><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">      </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        write();</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void read() &#123;</span><br><span class="line">        File f &#x3D;new File(&quot;d:&#x2F;lol.txt&quot;);</span><br><span class="line">        try (</span><br><span class="line">                FileInputStream fis  &#x3D; new FileInputStream(f);</span><br><span class="line">                DataInputStream dis &#x3D;new DataInputStream(fis);</span><br><span class="line">        )&#123;</span><br><span class="line">            boolean b&#x3D; dis.readBoolean();</span><br><span class="line">            int i &#x3D; dis.readInt();</span><br><span class="line">            String str &#x3D; dis.readUTF();</span><br><span class="line">             </span><br><span class="line">            System.out.println(&quot;读取到布尔值:&quot;+b);</span><br><span class="line">            System.out.println(&quot;读取到整数:&quot;+i);</span><br><span class="line">            System.out.println(&quot;读取到字符串:&quot;+str);</span><br><span class="line"> </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void write() &#123;</span><br><span class="line">        File f &#x3D;new File(&quot;d:&#x2F;lol.txt&quot;);</span><br><span class="line">        try (</span><br><span class="line">                FileOutputStream fos  &#x3D; new FileOutputStream(f);</span><br><span class="line">                DataOutputStream dos &#x3D;new DataOutputStream(fos);</span><br><span class="line">        )&#123;</span><br><span class="line">            dos.writeBoolean(true);</span><br><span class="line">            dos.writeInt(300);</span><br><span class="line">            dos.writeUTF(&quot;123 this is gareen&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-向文件中写入两个数字，然后把这两个数字分别读取出来"><a class="header-anchor" href="#步骤-2-练习-向文件中写入两个数字，然后把这两个数字分别读取出来">¶</a>步骤 2 : 练习-向文件中写入两个数字，然后把这两个数字分别读取出来</h3>
<p>要求<br>
第一种方式： 使用[缓存流]把两个数字以字符串的形式写到文件里，再用[缓存流]以字符串的形式读取出来，然后转换为两个数字。<br>
<strong>注：</strong> 两个数字之间要有分隔符用于区分这两个数字。 比如数字是31和15，如果不使用分隔符，那么就是3115，读取出来就无法识别到底是哪两个数字。 使用分隔符31@15能解决这个问题。</p>
<p>第二种方式： 使用数据流DataOutputStream向文件连续写入两个数字，然后用DataInpuStream连续读取两个数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">public class TestFile&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		File f &#x3D; new File(&quot;D:&#x2F;lol.txt&quot;);</span><br><span class="line">		try(</span><br><span class="line">				FileWriter fw &#x3D; new FileWriter(f);</span><br><span class="line">				PrintWriter pw &#x3D; new PrintWriter(fw);</span><br><span class="line">		) &#123;</span><br><span class="line">			pw.println(&quot;31@15&quot;);</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try(</span><br><span class="line">				FileReader fd &#x3D; new FileReader(f);</span><br><span class="line">				BufferedReader br &#x3D; new BufferedReader(fd);</span><br><span class="line">		) &#123;</span><br><span class="line">			String str &#x3D; br.readLine();</span><br><span class="line">			String[] strs &#x3D; str.split(&quot;@&quot;);</span><br><span class="line">			System.out.println(&quot;两个数字为：&quot; + Integer.valueOf(strs[0]) + &quot;和&quot; + Integer.valueOf(strs[1]));</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">public class TestFile&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File f &#x3D; new File(&quot;D:&#x2F;lol.txt&quot;);</span><br><span class="line">        write(f);</span><br><span class="line">        read(f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void write(File f)&#123;</span><br><span class="line">        try(</span><br><span class="line">                DataOutputStream dos &#x3D; new DataOutputStream(new FileOutputStream(f))</span><br><span class="line">                ) &#123;</span><br><span class="line">            dos.writeUTF(&quot;31@15&quot;);</span><br><span class="line">        &#125;  catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void read(File f)&#123;</span><br><span class="line">        try(</span><br><span class="line">                DataInputStream dis &#x3D; new DataInputStream(new FileInputStream(f))</span><br><span class="line">                ) &#123;</span><br><span class="line">            String str &#x3D; dis.readUTF();</span><br><span class="line">            String[] strs &#x3D; str.split(&quot;@&quot;);</span><br><span class="line">            System.out.println(&quot;两个数字是：&quot; + Integer.valueOf(strs[0]) + &quot;和&quot; + Integer.valueOf(strs[1]));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、JAVA-对象流-OBJECTINPUTSTREAM-OBJECTOUTPUTSTREAM"><a class="header-anchor" href="#9、JAVA-对象流-OBJECTINPUTSTREAM-OBJECTOUTPUTSTREAM">¶</a>9、JAVA 对象流 OBJECTINPUTSTREAM,OBJECTOUTPUTSTREAM</h2>
<h3 id="步骤-1-序列化一个对象"><a class="header-anchor" href="#步骤-1-序列化一个对象">¶</a>步骤 1 : 序列化一个对象</h3>
<p>创建一个Hero对象，设置其名称为garen。<br>
把该对象序列化到一个文件garen.lol。<br>
然后再通过序列化把该文件转换为一个Hero对象</p>
<p>**注：**把一个对象序列化有一个前提是：这个对象的类，必须实现了Serializable接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">    </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">    </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个Hero garen</span><br><span class="line">        &#x2F;&#x2F;要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口</span><br><span class="line">        Hero h &#x3D; new Hero();</span><br><span class="line">        h.name &#x3D; &quot;garen&quot;;</span><br><span class="line">        h.hp &#x3D; 616;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;准备一个文件用于保存该对象</span><br><span class="line">        File f &#x3D;new File(&quot;d:&#x2F;garen.lol&quot;);</span><br><span class="line"> </span><br><span class="line">        try(</span><br><span class="line">            &#x2F;&#x2F;创建对象输出流</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(f);</span><br><span class="line">            ObjectOutputStream oos &#x3D;new ObjectOutputStream(fos);</span><br><span class="line">            &#x2F;&#x2F;创建对象输入流              </span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(f);</span><br><span class="line">            ObjectInputStream ois &#x3D;new ObjectInputStream(fis);</span><br><span class="line">        ) &#123;</span><br><span class="line">            oos.writeObject(h);</span><br><span class="line">            Hero h2 &#x3D; (Hero) ois.readObject();</span><br><span class="line">            System.out.println(h2.name);</span><br><span class="line">            System.out.println(h2.hp);</span><br><span class="line">               </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import java.io.Serializable;</span><br><span class="line"> </span><br><span class="line">public class Hero implements Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F;表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-序列化数组"><a class="header-anchor" href="#步骤-2-练习-序列化数组">¶</a>步骤 2 : 练习-序列化数组</h3>
<p>准备一个长度是10，类型是Hero的数组，使用10个Hero对象初始化该数组</p>
<p>然后把该数组序列化到一个文件heros.lol</p>
<p>接着使用ObjectInputStream 读取该文件，并转换为Hero数组，验证该数组中的内容，是否和序列化之前一样</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2442.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">    </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">    </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个Hero garen</span><br><span class="line">        &#x2F;&#x2F;要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口</span><br><span class="line">    	Hero[] heroes &#x3D; new Hero[10];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class="line">            heroes[i] &#x3D; new Hero(i);</span><br><span class="line">        &#125;</span><br><span class="line">        File f &#x3D; new File(&quot;D:&#x2F;heros.lol&quot;);</span><br><span class="line">        System.out.println(&quot;查看中文件中反序列化出来的数组中的每一个元素：&quot;);</span><br><span class="line">        try(</span><br><span class="line">                ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(f));</span><br><span class="line">                ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(f))</span><br><span class="line">                ) &#123;</span><br><span class="line">            for (Hero h : heroes)&#123;</span><br><span class="line">                oos.writeObject(h);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class="line">                Hero h &#x3D; (Hero)ois.readObject();</span><br><span class="line">                System.out.println(&quot;hero:&quot; + h.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import java.io.Serializable;</span><br><span class="line"> </span><br><span class="line">public class Hero implements Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F;表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line">    public int num;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">    </span><br><span class="line">    public Hero(int i) &#123;</span><br><span class="line">    	num &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、JAVA-控制台输入流SYSTEM-IN和SCANNER"><a class="header-anchor" href="#10、JAVA-控制台输入流SYSTEM-IN和SCANNER">¶</a>10、JAVA 控制台输入流SYSTEM.IN和SCANNER</h2>
<h3 id="步骤-1-System-in"><a class="header-anchor" href="#步骤-1-System-in">¶</a>步骤 1 : <a href="http://System.in" target="_blank" rel="noopener">System.in</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 控制台输入</span><br><span class="line">        try (InputStream is &#x3D; System.in;) &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                &#x2F;&#x2F; 敲入a,然后敲回车可以看到</span><br><span class="line">                &#x2F;&#x2F; 97 13 10</span><br><span class="line">                &#x2F;&#x2F; 97是a的ASCII码</span><br><span class="line">                &#x2F;&#x2F; 13 10分别对应回车换行</span><br><span class="line">                int i &#x3D; is.read();</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-Scanner读取字符串"><a class="header-anchor" href="#步骤-2-Scanner读取字符串">¶</a>步骤 2 : Scanner读取字符串</h3>
<p>使用System.in.read虽然可以读取数据，但是很不方便<br>
使用Scanner就可以逐行读取了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line">    </span><br><span class="line">import java.util.Scanner;</span><br><span class="line">    </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">            Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">             </span><br><span class="line">            while(true)&#123;</span><br><span class="line">                String line &#x3D; s.nextLine();</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-Scanner从控制台读取整数"><a class="header-anchor" href="#步骤-3-Scanner从控制台读取整数">¶</a>步骤 3 : Scanner从控制台读取整数</h3>
<p>使用Scanner从控制台读取整数</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2142.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        int a &#x3D; s.nextInt();</span><br><span class="line">        System.out.println(&quot;第一个整数：&quot;+a);</span><br><span class="line">        int b &#x3D; s.nextInt();</span><br><span class="line">        System.out.println(&quot;第二个整数：&quot;+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-自动创建类"><a class="header-anchor" href="#步骤-4-练习-自动创建类">¶</a>步骤 4 : 练习-自动创建类</h3>
<p>自动创建有一个属性的类文件。<br>
通过控制台，获取类名，属性名称，属性类型，根据一个模板文件，自动创建这个类文件，并且为属性提供setter和getter</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2444.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class @class@ &#123;</span><br><span class="line">    public @type@ @property@;</span><br><span class="line">    public @class@() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void set@Uproperty@(@type@  @property@)&#123;</span><br><span class="line">        this.@property@ &#x3D; @property@;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public @type@  get@Uproperty@()&#123;</span><br><span class="line">        return this.@property@;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class TestStream &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File fRead &#x3D; new File(&quot;D:&#x2F;1.txt&quot;);</span><br><span class="line">        File fWrite &#x3D; new File(&quot;D:&#x2F;Dog.java&quot;);</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        replace(fRead, fWrite, s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected static void replace(File fRead, File fWrite, Scanner s) &#123;</span><br><span class="line">        System.out.println(&quot;请输入类的名称：&quot;);</span><br><span class="line">        String className &#x3D; s.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入属性的类型：&quot;);</span><br><span class="line">        String type &#x3D; s.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入属性的名称：&quot;);</span><br><span class="line">        String propertyName &#x3D; s.nextLine();</span><br><span class="line">        try (FileReader fr &#x3D; new FileReader(fRead);</span><br><span class="line">                BufferedReader br &#x3D; new BufferedReader(fr);</span><br><span class="line">                FileWriter fw &#x3D; new FileWriter(fWrite);</span><br><span class="line">                PrintWriter pw &#x3D; new PrintWriter(fw)) &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                String str &#x3D; br.readLine();</span><br><span class="line">                if (null &#x3D;&#x3D; str)</span><br><span class="line">                    break;</span><br><span class="line">                if (str.contains(&quot;@class@&quot;) || str.contains(&quot;@type@&quot;) || str.contains(&quot;@property@&quot;)</span><br><span class="line">                        || str.contains(&quot;@Uproperty@&quot;)) &#123;</span><br><span class="line">                    str &#x3D; str.replaceAll(&quot;@class@&quot;, className);</span><br><span class="line">                    str &#x3D; str.replaceAll(&quot;@type@&quot;, type);</span><br><span class="line">                    str &#x3D; str.replaceAll(&quot;@property@&quot;, propertyName);</span><br><span class="line">                    str &#x3D; str.replaceAll(&quot;@Uproperty@&quot;, toUpperFirstLetter(propertyName));</span><br><span class="line">                &#125;</span><br><span class="line">                pw.println(str);</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static String toUpperFirstLetter(String propertyName) &#123;</span><br><span class="line">        char c &#x3D; propertyName.charAt(0);</span><br><span class="line">        propertyName &#x3D; propertyName.replace(c, Character.toUpperCase(c));</span><br><span class="line">        return propertyName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11、JAVA-复制文件，复制文件夹"><a class="header-anchor" href="#11、JAVA-复制文件，复制文件夹">¶</a>11、JAVA 复制文件，复制文件夹</h2>
<h3 id="步骤-1-练习-复制文件"><a class="header-anchor" href="#步骤-1-练习-复制文件">¶</a>步骤 1 : 练习-复制文件</h3>
<p>复制文件是常见的IO操作，设计如下方法，实现复制源文件srcFile到目标文件destFile</p>
<p>public static void copyFile(String srcFile, String destFile){</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">public class TestFile&#123;</span><br><span class="line">	public static void copyFile(String srcFile, String destFile)throws Exception&#123;</span><br><span class="line">        File file &#x3D; new File(srcFile);</span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(file);</span><br><span class="line">        BufferedInputStream bis &#x3D; new BufferedInputStream(fis);</span><br><span class="line">        byte[] bytes &#x3D; new byte[(int) file.length()];</span><br><span class="line">        bis.read(bytes);</span><br><span class="line"> </span><br><span class="line">        File file2 &#x3D; new File(destFile);</span><br><span class="line">        if(file2.exists())&#123;</span><br><span class="line">            file2.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fos &#x3D; new FileOutputStream(file2);</span><br><span class="line">        BufferedOutputStream bos &#x3D; new BufferedOutputStream(fos);</span><br><span class="line">        bos.write(bytes);</span><br><span class="line">        bos.flush();</span><br><span class="line">        bis.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">        fos.close();</span><br><span class="line">	&#125;</span><br><span class="line">	 public static void main(String[] args)throws Exception &#123;</span><br><span class="line">		 copyFile(&quot;D:\\1.txt&quot;,&quot;D:\\学校\\1.txt&quot;);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-复制文件夹"><a class="header-anchor" href="#步骤-2-练习-复制文件夹">¶</a>步骤 2 : 练习-复制文件夹</h3>
<p>复制文件夹,实现如下方法，把源文件夹下所有的文件 复制到目标文件夹下(包括子文件夹)</p>
<p>public static void copyFolder(String srcFolder, String destFolder){</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">public class TestFile&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">				copyFolder(&quot;D:\\test&quot;,&quot;D:\\test2&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			public static void copyFolder(String srcFolder, String destFolder)&#123;</span><br><span class="line">				File filesrc&#x3D;new File(srcFolder);</span><br><span class="line">				File filedest&#x3D;new File(destFolder);</span><br><span class="line">				File[] files&#x3D;filesrc.listFiles();</span><br><span class="line">				for (int i &#x3D; 0; i &lt;files.length; i++) &#123;</span><br><span class="line">					if (files[i].isFile())&#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							FileInputStream in&#x3D;new FileInputStream(files[i]);</span><br><span class="line">							File file1&#x3D;new File(filedest,files[i].getName());</span><br><span class="line">							FileOutputStream ou&#x3D;new FileOutputStream(file1);</span><br><span class="line">							byte[] buf&#x3D;new byte[1024];</span><br><span class="line">							int d;</span><br><span class="line">							while ((d&#x3D;in.read(buf))!&#x3D;-1)&#123;</span><br><span class="line">								ou.write(buf,0,d);</span><br><span class="line">							&#125;</span><br><span class="line">							ou.close();</span><br><span class="line">							in.close();</span><br><span class="line">						&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125; catch (IOException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;else if (files[i].isDirectory())&#123;</span><br><span class="line">						File file1&#x3D;new File(filedest,files[i].getName());</span><br><span class="line">						file1.mkdir();</span><br><span class="line">						copyFolder(files[i].getAbsolutePath(),file1.getAbsolutePath());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-查找文件内容"><a class="header-anchor" href="#步骤-3-练习-查找文件内容">¶</a>步骤 3 : 练习-查找文件内容</h3>
<p>public static void search(File folder, String search);</p>
<p>假设你的项目目录是 e:/project，遍历这个目录下所有的java文件（包括子文件夹），找出文件内容包括 <strong>Magic</strong>的那些文件，并打印出来。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2491.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">public class TestFile&#123;</span><br><span class="line">	public static void search(File f, String s) &#123;</span><br><span class="line">        if (f.isDirectory() &#x3D;&#x3D; true) &#123;</span><br><span class="line">            File[] file &#x3D; f.listFiles();</span><br><span class="line">            for (File a : file) &#123;</span><br><span class="line">                search(a, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (f.isFile() &#x3D;&#x3D; true &amp;&amp; f.getName().endsWith(&quot;.java&quot;)) &#123;</span><br><span class="line">            try (FileReader fre &#x3D; new FileReader(f); BufferedReader bre &#x3D; new BufferedReader(fre);) &#123;</span><br><span class="line">                String str &#x3D; &quot;0&quot;;</span><br><span class="line">                while ((str &#x3D; bre.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                    if (str.contains(s))&#123;</span><br><span class="line">                        System.out.println(f.getAbsolutePath());</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException E) &#123;</span><br><span class="line">                System.out.println(E);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        search(new File(&quot;D:\\test&quot;), &quot;this&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12、流关系图"><a class="header-anchor" href="#12、流关系图">¶</a>12、流关系图</h2>
<h3 id="步骤-1-流关系图"><a class="header-anchor" href="#步骤-1-流关系图">¶</a>步骤 1 : 流关系图</h3>
<h3 id="步骤-2-其他流"><a class="header-anchor" href="#步骤-2-其他流">¶</a>步骤 2 : 其他流</h3>
<p>除了上图所接触的流之外，还有很多其他流，如图所示InputStream下面有很多的子类。 这些子类不需要立即掌握，他们大体上用法是差不多的，只是在一些特殊场合下用起来更方便，在工作中用到的时候再进行学习就行了。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/5679.png" alt></p>
<h1 id="三、集合框架"><a class="header-anchor" href="#三、集合框架">¶</a>三、集合框架</h1>
<h2 id="1、ARRAYLIST-JAVA-ARRAYLIST-完整教程"><a class="header-anchor" href="#1、ARRAYLIST-JAVA-ARRAYLIST-完整教程">¶</a>1、ARRAYLIST - JAVA ARRAYLIST 完整教程</h2>
<h3 id="示例-1-使用数组的局限性"><a class="header-anchor" href="#示例-1-使用数组的局限性">¶</a>示例 1 : 使用数组的局限性</h3>
<p>如果要存放多个对象，可以使用数组，但是数组有局限性<br>
比如 声明长度是10的数组<br>
不用的数组就浪费了<br>
超过10的个数，又放不下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;数组的局限性</span><br><span class="line">        Hero heros[] &#x3D; new Hero[10];</span><br><span class="line">        &#x2F;&#x2F;声明长度是10的数组</span><br><span class="line">        &#x2F;&#x2F;不用的数组就浪费了</span><br><span class="line">        &#x2F;&#x2F;超过10的个数，又放不下</span><br><span class="line">        heros[0] &#x3D; new Hero(&quot;盖伦&quot;);</span><br><span class="line">                &#x2F;&#x2F;放不下要报错</span><br><span class="line">        heros[20] &#x3D; new Hero(&quot;提莫&quot;);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line"> </span><br><span class="line">    public int damage;</span><br><span class="line"> </span><br><span class="line">    public Hero() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 增加一个初始化name的构造方法</span><br><span class="line">    public Hero(String name) &#123;</span><br><span class="line"> </span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 重写toString方法</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-ArrayList存放对象"><a class="header-anchor" href="#示例-2-ArrayList存放对象">¶</a>示例 2 : ArrayList存放对象</h3>
<p>为了解决数组的局限性，引入容器类的概念。 最常见的容器类就是<br>
ArrayList<br>
[容器的容量]&quot;capacity&quot;会随着对象的增加，自动增长<br>
只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;容器类ArrayList，用于存放对象</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line">        heros.add( new Hero(&quot;盖伦&quot;));</span><br><span class="line">        System.out.println(heros.size());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;容器的容量&quot;capacity&quot;会随着对象的增加，自动增长</span><br><span class="line">        &#x2F;&#x2F;只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。</span><br><span class="line">        heros.add( new Hero(&quot;提莫&quot;));</span><br><span class="line">        System.out.println(heros.size());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、ARRAYLIST-ARRAYLIST-常用方法"><a class="header-anchor" href="#2、ARRAYLIST-ARRAYLIST-常用方法">¶</a>2、ARRAYLIST - ARRAYLIST 常用方法</h2>
<h3 id="步骤-1-增加"><a class="header-anchor" href="#步骤-1-增加">¶</a>步骤 1 : 增加</h3>
<p><strong>add</strong> 有两种用法<br>
第一种是直接add对象，把对象加在最后面</p>
<p>heros.add(new Hero(&quot;hero &quot; + i));</p>
<p>第二种是在指定位置加对象</p>
<p>heros.add(3, specialHero);</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2453.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 把5个对象加入到ArrayList中</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(heros);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 在指定位置增加对象</span><br><span class="line">        Hero specialHero &#x3D; new Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.add(3, specialHero);</span><br><span class="line"> </span><br><span class="line">        System.out.println(heros.toString());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">  </span><br><span class="line">    public int damage;</span><br><span class="line">  </span><br><span class="line">    public Hero() &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 增加一个初始化name的构造方法</span><br><span class="line">    public Hero(String name) &#123;</span><br><span class="line">  </span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 重写toString方法</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-判断是否存在"><a class="header-anchor" href="#步骤-2-判断是否存在">¶</a>步骤 2 : 判断是否存在</h3>
<p>通过方法<strong>contains</strong> 判断一个对象是否在容器中<br>
判断标准： 是否是同一个对象，而不是name是否相同</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2454.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化5个对象</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero &#x3D; new Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.add(specialHero);</span><br><span class="line"> </span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        &#x2F;&#x2F; 判断一个对象是否在容器中</span><br><span class="line">        &#x2F;&#x2F; 判断标准： 是否是同一个对象，而不是name是否相同</span><br><span class="line">        System.out.print(&quot;虽然一个新的对象名字也叫 hero 1，但是contains的返回是:&quot;);</span><br><span class="line">        System.out.println(heros.contains(new Hero(&quot;hero 1&quot;)));</span><br><span class="line">        System.out.print(&quot;而对specialHero的判断，contains的返回是:&quot;);</span><br><span class="line">        System.out.println(heros.contains(specialHero));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-获取指定位置的对象"><a class="header-anchor" href="#步骤-3-获取指定位置的对象">¶</a>步骤 3 : 获取指定位置的对象</h3>
<p>通过get获取指定位置的对象，如果输入的下标越界，一样会报错</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2455.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化5个对象</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero &#x3D; new Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.add(specialHero);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;获取指定位置的对象</span><br><span class="line">        System.out.println(heros.get(5));</span><br><span class="line">        &#x2F;&#x2F;如果超出了范围，依然会报错</span><br><span class="line">        System.out.println(heros.get(6));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-获取对象所处的位置"><a class="header-anchor" href="#步骤-4-获取对象所处的位置">¶</a>步骤 4 : 获取对象所处的位置</h3>
<p><strong>indexOf</strong>用于判断一个对象在ArrayList中所处的位置<br>
与[contains]一样，判断标准是对象是否相同，而非对象的name值是否相等</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2456.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化5个对象</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero &#x3D; new Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.add(specialHero);</span><br><span class="line"> </span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;specialHero所处的位置:&quot;+heros.indexOf(specialHero));</span><br><span class="line">        System.out.println(&quot;新的英雄，但是名字是\&quot;hero 1\&quot;所处的位置:&quot;+heros.indexOf(new Hero(&quot;hero 1&quot;)));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-删除"><a class="header-anchor" href="#步骤-5-删除">¶</a>步骤 5 : 删除</h3>
<p><strong>remove</strong>用于把对象从ArrayList中删除<br>
remove可以根据下标删除ArrayList的元素</p>
<p>heros.remove(2);</p>
<p>也可以根据对象删除</p>
<p>heros.remove(specialHero);</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2457.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化5个对象</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero &#x3D; new Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.add(specialHero);</span><br><span class="line">         </span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        heros.remove(2);</span><br><span class="line">        System.out.println(&quot;删除下标是2的对象&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;删除special hero&quot;);</span><br><span class="line">        heros.remove(specialHero);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-替换"><a class="header-anchor" href="#步骤-6-替换">¶</a>步骤 6 : 替换</h3>
<p><strong>set</strong>用于替换指定位置的元素</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2458.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化5个对象</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero &#x3D; new Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.add(specialHero);</span><br><span class="line">         </span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;把下标是5的元素，替换为\&quot;hero 5\&quot;&quot;);</span><br><span class="line">        heros.set(5, new Hero(&quot;hero 5&quot;));</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-获取大小"><a class="header-anchor" href="#步骤-7-获取大小">¶</a>步骤 7 : 获取大小</h3>
<p><strong>size</strong> 用于获取ArrayList的大小</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2459.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化5个对象</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero &#x3D; new Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.add(specialHero);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;获取ArrayList的大小：&quot;);</span><br><span class="line">        System.out.println(heros.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-8-转换为数组"><a class="header-anchor" href="#步骤-8-转换为数组">¶</a>步骤 8 : 转换为数组</h3>
<p><strong>toArray</strong>可以把一个ArrayList对象转换为数组。<br>
需要注意的是，如果要转换为一个Hero数组，那么需要传递一个Hero数组类型的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2460.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化5个对象</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero &#x3D; new Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.add(specialHero);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        Hero hs[] &#x3D; (Hero[])heros.toArray(new Hero[]&#123;&#125;);</span><br><span class="line">        System.out.println(&quot;数组:&quot; +hs);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-9-把另一个容器所有对象都加进来"><a class="header-anchor" href="#步骤-9-把另一个容器所有对象都加进来">¶</a>步骤 9 : 把另一个容器所有对象都加进来</h3>
<p><strong>addAll</strong> 把另一个容器所有对象都加进来</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2461.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化5个对象</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;ArrayList heros:\t&quot; + heros);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;把另一个容器里所有的元素，都加入到该容器里来</span><br><span class="line">        ArrayList anotherHeros &#x3D; new ArrayList();</span><br><span class="line">        anotherHeros.add(new Hero(&quot;hero a&quot;));</span><br><span class="line">        anotherHeros.add(new Hero(&quot;hero b&quot;));</span><br><span class="line">        anotherHeros.add(new Hero(&quot;hero c&quot;));</span><br><span class="line">        System.out.println(&quot;anotherHeros heros:\t&quot; + anotherHeros);</span><br><span class="line">        heros.addAll(anotherHeros);</span><br><span class="line">        System.out.println(&quot;把另一个ArrayList的元素都加入到当前ArrayList:&quot;);</span><br><span class="line">        System.out.println(&quot;ArrayList heros:\t&quot; + heros);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-10-清空"><a class="header-anchor" href="#步骤-10-清空">¶</a>步骤 10 : 清空</h3>
<p><strong>clear</strong> 清空一个ArrayList</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2462.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化5个对象</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;ArrayList heros:\t&quot; + heros);</span><br><span class="line">        System.out.println(&quot;使用clear清空&quot;);</span><br><span class="line">        heros.clear();</span><br><span class="line">        System.out.println(&quot;ArrayList heros:\t&quot; + heros);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-11-练习-判断是否相同"><a class="header-anchor" href="#步骤-11-练习-判断是否相同">¶</a>步骤 11 : 练习-判断是否相同</h3>
<p>如果就是要判断集合里是否存在一个 name等于 &quot;hero 1&quot;的对象，应该怎么做？</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2463.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">    ArrayList heros &#x3D; new ArrayList();</span><br><span class="line">     </span><br><span class="line">    for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">        heros.add(new Hero(&quot;hero&quot;+i));</span><br><span class="line">    &#125;</span><br><span class="line">    Hero[] name &#x3D;(Hero[])heros.toArray(new Hero[]&#123;&#125;);</span><br><span class="line">    for(int i&#x3D;0;i&lt;name.length;i++)&#123;</span><br><span class="line">        if(name[i].toString().equals(&quot;hero1&quot;))&#123;</span><br><span class="line">            System.out.println(&quot;找到了名字hero1,下标为&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-12-练习-MyStringBuffer"><a class="header-anchor" href="#步骤-12-练习-MyStringBuffer">¶</a>步骤 12 : 练习-MyStringBuffer</h3>
<p>做一个一样的[MyStringBuffer]练习，但是不使用字符数组，而是使用ArrayList来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ArrayList;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">public class MyStringBuffer &#123;</span><br><span class="line">    ArrayList value;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;有参构造方法</span><br><span class="line">        public MyStringBuffer(String str)&#123;</span><br><span class="line">            this();</span><br><span class="line">            if(null&#x3D;&#x3D;str)</span><br><span class="line">                return;</span><br><span class="line">              </span><br><span class="line">            char cs[] &#x3D; str.toCharArray();</span><br><span class="line">         </span><br><span class="line">            for (int i &#x3D; 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">                &#x2F;&#x2F;char c &#x3D; cs[i];</span><br><span class="line">                value.add(cs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        public MyStringBuffer() &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">            value &#x3D; new ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public void append(String str) &#123;</span><br><span class="line">      </span><br><span class="line">            insert(value.size(),str);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        public void append(char c) &#123;</span><br><span class="line">            append(String.valueOf(c));</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        public void insert(int pos, char b) &#123;</span><br><span class="line">            insert(pos,String.valueOf(b));</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        public void delete(int start) &#123;</span><br><span class="line">              </span><br><span class="line">            delete(start,value.size());</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        public void delete(int start, int end) &#123;</span><br><span class="line">            &#x2F;&#x2F;边界条件判断</span><br><span class="line">            if(start&lt;0)</span><br><span class="line">                return;</span><br><span class="line">              </span><br><span class="line">            if(start&gt;value.size())</span><br><span class="line">                return;</span><br><span class="line">              </span><br><span class="line">            if(end&lt;0)</span><br><span class="line">                return;</span><br><span class="line">              </span><br><span class="line">            if(end&gt;value.size())</span><br><span class="line">                return;</span><br><span class="line">              </span><br><span class="line">            if(start&gt;&#x3D;end)</span><br><span class="line">                return;</span><br><span class="line">            </span><br><span class="line">            for (int i &#x3D; 0; i &lt; end - start; i++) &#123;</span><br><span class="line">                value.remove(start);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        public void reverse() &#123;</span><br><span class="line">      </span><br><span class="line">            for (int i &#x3D; 0; i &lt; value.size()&#x2F;2; i++) &#123;</span><br><span class="line">               int length &#x3D; value.size();</span><br><span class="line">               char temp &#x3D; (char) value.get(i);</span><br><span class="line">               value.set(i,value.get(length -i-1) );</span><br><span class="line">               value.set(length-i-1, temp);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        public int length() &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">            return value.size();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">        public void insert(int pos, String b) &#123;</span><br><span class="line">      </span><br><span class="line">              </span><br><span class="line">            &#x2F;&#x2F; 边界条件判断</span><br><span class="line">            if (pos &lt; 0)</span><br><span class="line">                return;</span><br><span class="line">      </span><br><span class="line">            if (pos &gt; value.size())</span><br><span class="line">                return;</span><br><span class="line">      </span><br><span class="line">            if (null &#x3D;&#x3D; b)</span><br><span class="line">                return;</span><br><span class="line">      </span><br><span class="line">            &#x2F;&#x2F; 无需手动扩容</span><br><span class="line">      </span><br><span class="line">            char[] cs &#x3D; b.toCharArray();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; cs.length; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;              char c &#x3D; cs[i];</span><br><span class="line">                value.add(pos + i, cs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        public String toString()&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            char[] charValue &#x3D; new char[value.size()];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; value.size(); i++) &#123;</span><br><span class="line">                charValue[i] &#x3D; (char) value.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            return new String(charValue);</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            MyStringBuffer sb &#x3D; new MyStringBuffer(&quot;there light&quot;);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">            sb.insert(0, &quot;let &quot;);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">      </span><br><span class="line">            sb.insert(10, &quot;be &quot;);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">            sb.insert(0, &quot;God Say:&quot;);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">            sb.append(&quot;!&quot;);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">            sb.append(&#39;?&#39;);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">            sb.reverse();</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">              </span><br><span class="line">            sb.reverse();</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">              </span><br><span class="line">            sb.delete(0,4);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">            sb.delete(4);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、ARRAYLIST-ARRAYLIST与LIST接口"><a class="header-anchor" href="#3、ARRAYLIST-ARRAYLIST与LIST接口">¶</a>3、ARRAYLIST - ARRAYLIST与LIST接口</h2>
<h3 id="步骤-1-ArrayList和List"><a class="header-anchor" href="#步骤-1-ArrayList和List">¶</a>步骤 1 : ArrayList和List</h3>
<p>ArrayList实现了接口List<br>
常见的写法会把引用声明为接口List类型<br>
注意：是<strong>java.util.List</strong>,而<strong>不是</strong>java.awt.List</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/808.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;ArrayList实现了接口List</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;常见的写法会把引用声明为接口List类型</span><br><span class="line">        &#x2F;&#x2F;注意：是java.util.List,而不是java.awt.List</span><br><span class="line">        &#x2F;&#x2F;接口引用指向子类对象（多态）</span><br><span class="line">         </span><br><span class="line">        List heros &#x3D; new ArrayList();</span><br><span class="line">        heros.add( new Hero(&quot;盖伦&quot;));</span><br><span class="line">        System.out.println(heros.size());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-List接口的方法"><a class="header-anchor" href="#步骤-2-List接口的方法">¶</a>步骤 2 : List接口的方法</h3>
<p>因为ArrayList实现了List接口，所以List接口的方法ArrayList都实现了。<br>
在[ArrayList 常用方法]章节有详细的讲解，在此不作赘述</p>
<h2 id="4、ARRAYLIST-ARRAYLIST上使用泛型"><a class="header-anchor" href="#4、ARRAYLIST-ARRAYLIST上使用泛型">¶</a>4、ARRAYLIST - ARRAYLIST上使用泛型</h2>
<h3 id="步骤-1-泛型-Generic"><a class="header-anchor" href="#步骤-1-泛型-Generic">¶</a>步骤 1 : 泛型 Generic</h3>
<p>不指定泛型的容器，可以存放任何类型的元素<br>
指定了泛型的容器，只能存放指定类型的元素以及其子类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">public class Item &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int price;</span><br><span class="line">     </span><br><span class="line">    public Item()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;提供一个初始化name的构造方法</span><br><span class="line">    public Item(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void effect()&#123;</span><br><span class="line">        System.out.println(&quot;物品使用后，可以有效果&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">  </span><br><span class="line">import property.Item;</span><br><span class="line">import charactor.APHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;对于不使用泛型的容器，可以往里面放英雄，也可以往里面放物品</span><br><span class="line">        List heros &#x3D; new ArrayList();</span><br><span class="line">          </span><br><span class="line">        heros.add(new Hero(&quot;盖伦&quot;));</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;本来用于存放英雄的容器，现在也可以存放物品了</span><br><span class="line">        heros.add(new Item(&quot;冰杖&quot;));</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;对象转型会出现问题</span><br><span class="line">        Hero h1&#x3D;  (Hero) heros.get(0);</span><br><span class="line">        &#x2F;&#x2F;尤其是在容器里放的对象太多的时候，就记不清楚哪个位置放的是哪种类型的对象了</span><br><span class="line">        Hero h2&#x3D;  (Hero) heros.get(1);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;引入泛型Generic</span><br><span class="line">        &#x2F;&#x2F;声明容器的时候，就指定了这种容器，只能放Hero，放其他的就会出错</span><br><span class="line">        List&lt;Hero&gt; genericheros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        genericheros.add(new Hero(&quot;盖伦&quot;));</span><br><span class="line">        &#x2F;&#x2F;如果不是Hero类型，根本就放不进去</span><br><span class="line">        &#x2F;&#x2F;genericheros.add(new Item(&quot;冰杖&quot;));</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;除此之外，还能存放Hero的子类</span><br><span class="line">        genericheros.add(new APHero());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;并且在取出数据的时候，不需要再进行转型了，因为里面肯定是放的Hero或者其子类</span><br><span class="line">        Hero h &#x3D; genericheros.get(0);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-泛型的简写"><a class="header-anchor" href="#步骤-2-泛型的简写">¶</a>步骤 2 : 泛型的简写</h3>
<p>为了不使编译器出现警告，需要前后都使用泛型，像这样：</p>
<p>List<Hero> genericheros = new ArrayList<Hero>();</Hero></Hero></p>
<p>不过JDK7提供了一个可以略微减少代码量的泛型简写方式</p>
<p>List<Hero> genericheros2 = new ArrayList&lt;&gt;();</Hero></p>
<p>后面的泛型可以用&lt;&gt;来代替，聊胜于无吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Hero&gt; genericheros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        List&lt;Hero&gt; genericheros2 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-泛型的系统学习"><a class="header-anchor" href="#步骤-3-泛型的系统学习">¶</a>步骤 3 : 泛型的系统学习</h3>
<p>泛型的知识还包含 [支持泛型的类] [泛型转型] [通配符] 这些内容都在[泛型章节]详细展开</p>
<h3 id="步骤-4-练习-支持泛型的ArrayList"><a class="header-anchor" href="#步骤-4-练习-支持泛型的ArrayList">¶</a>步骤 4 : 练习-支持泛型的ArrayList</h3>
<p>借助泛型和前面学习的面向对象的知识，设计一个ArrayList，使得这个ArrayList里，又可以放Hero，又可以放Item,但是除了这两种对象，其他的对象都不能放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestCollection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            Hero h1 &#x3D; new Hero();</span><br><span class="line">            Hero h2 &#x3D; new Hero();</span><br><span class="line"> </span><br><span class="line">            List&lt;LOL&gt; lollist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            lollist.add(new Hero(&quot;maodiao&quot;));</span><br><span class="line">            lollist.add(new Item(&quot;shadiao&quot;));</span><br><span class="line">            lollist.forEach(l-&gt;System.out.println(l.name));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">public class LOL &#123;</span><br><span class="line">    public String name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class Hero extends LOL &#123;&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class Item extends LOL &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;步骤 4 : 练习-支持泛型的ArrayList</span><br><span class="line">        List&lt;LOL&gt; lolList &#x3D; new ArrayList&lt;LOL&gt;();&#x2F;&#x2F;通过接口实现Hero跟Item的连接，并且可以直接调用接口,换做继承也行，但是问题一样，就是怎么打印出来</span><br><span class="line">        lolList.add(new Hero3(&quot;Lily&quot;));&#x2F;&#x2F;能放Hero</span><br><span class="line">        lolList.add(new Item2(&quot;long pike&quot;));&#x2F;&#x2F;也能放Item</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;        lolList.add(new GiantDragon());&#x2F;&#x2F;除了Hero和Item容不下其他</span><br><span class="line">        System.out.println(lolList.get(1).getName());&#x2F;&#x2F;给接口写了一个getName方法，然后Hero3 和 Item2 类都需要重写这个方法，然后就可以直接调用了</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Hero的</span><br><span class="line">package property;</span><br><span class="line"> </span><br><span class="line">import collection.Hero;</span><br><span class="line"> </span><br><span class="line">public class Item extends Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    int price;</span><br><span class="line">     </span><br><span class="line">    public Item() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    public Item(String name) &#123;</span><br><span class="line">          </span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 重写toString方法</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;下面是Testcollection5 </span><br><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import property.Item;</span><br><span class="line">&#x2F;&#x2F;import collection.Hero;</span><br><span class="line"> </span><br><span class="line">public class Testcollection5   &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Hero&gt; al &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        al.add(new Hero(&quot;盖伦&quot;));</span><br><span class="line">        al.add(new Item(&quot;冰杖&quot;));</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        Hero h &#x3D; (Hero) al.get(0);</span><br><span class="line">        Item g &#x3D; (Item) al.get(1);</span><br><span class="line">         </span><br><span class="line">        System.out.println(h.name);</span><br><span class="line">        System.out.println(g.name);     </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、ARRAYLIST-遍历ARRAYLIST的三种方法"><a class="header-anchor" href="#5、ARRAYLIST-遍历ARRAYLIST的三种方法">¶</a>5、ARRAYLIST - 遍历ARRAYLIST的三种方法</h2>
<h3 id="步骤-1-用for循环遍历"><a class="header-anchor" href="#步骤-1-用for循环遍历">¶</a>步骤 1 : 用for循环遍历</h3>
<p>通过前面的学习，知道了可以用size()和get()分别得到大小，和获取指定位置的元素，结合for循环就可以遍历出ArrayList的内容</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2469.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 放5个Hero进入容器</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero name &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 第一种遍历 for循环</span><br><span class="line">        System.out.println(&quot;--------for 循环-------&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; heros.size(); i++) &#123;</span><br><span class="line">            Hero h &#x3D; heros.get(i);</span><br><span class="line">            System.out.println(h);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-迭代器遍历"><a class="header-anchor" href="#步骤-2-迭代器遍历">¶</a>步骤 2 : 迭代器遍历</h3>
<p>使用迭代器Iterator遍历集合中的元素</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/806.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;放5个Hero进入容器</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero name &quot; +i));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;第二种遍历，使用迭代器</span><br><span class="line">        System.out.println(&quot;--------使用while的iterator-------&quot;);</span><br><span class="line">        Iterator&lt;Hero&gt; it&#x3D; heros.iterator();</span><br><span class="line">        &#x2F;&#x2F;从最开始的位置判断&quot;下一个&quot;位置是否有数据</span><br><span class="line">        &#x2F;&#x2F;如果有就通过next取出来，并且把指针向下移动</span><br><span class="line">        &#x2F;&#x2F;直到&quot;下一个&quot;位置没有数据</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            Hero h &#x3D; it.next();</span><br><span class="line">            System.out.println(h);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;迭代器的for写法</span><br><span class="line">        System.out.println(&quot;--------使用for的iterator-------&quot;);</span><br><span class="line">        for (Iterator&lt;Hero&gt; iterator &#x3D; heros.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            Hero hero &#x3D; (Hero) iterator.next();</span><br><span class="line">            System.out.println(hero);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-用增强型for循环"><a class="header-anchor" href="#步骤-3-用增强型for循环">¶</a>步骤 3 : 用增强型for循环</h3>
<p>使用增强型for循环可以非常方便的遍历ArrayList中的元素，这是很多开发人员的首选。</p>
<p>不过增强型for循环也有不足：<br>
无法用来进行ArrayList的初始化<br>
无法得知当前是第几个元素了，当需要只打印单数元素的时候，就做不到了。 必须再自定下标变量。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2470.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 放5个Hero进入容器</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero name &quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 第三种，增强型for循环</span><br><span class="line">        System.out.println(&quot;--------增强型for循环-------&quot;);</span><br><span class="line">        for (Hero h : heros) &#123;</span><br><span class="line">            System.out.println(h);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-删除ArrayList中的数据"><a class="header-anchor" href="#步骤-4-练习-删除ArrayList中的数据">¶</a>步骤 4 : 练习-删除ArrayList中的数据</h3>
<p>首先初始化一个Hero集合，里面放100个Hero对象，名称分别是从<br>
hero 0<br>
hero 1<br>
hero 2<br>
…<br>
hero 99.</p>
<p>通过遍历的手段，删除掉名字编号是8的倍数的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class Delect &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(&quot;删除掉名字编号是8的倍数后的元素有：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">            if(i%8!&#x3D;0)&#123;</span><br><span class="line">                heros.add(new Hero(&quot;hero &quot;+i));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        for(Hero h:heros)&#123;</span><br><span class="line">            System.out.print(h.name + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class Delect &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		System.out.println(&quot;原集合元素为：&quot;);</span><br><span class="line">		for(int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">			heros.add(new Hero(&quot;hero &quot;+i));</span><br><span class="line">			System.out.print(&quot;hero &quot;+i+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;现集合元素为：&quot;);</span><br><span class="line">		for(int j&#x3D;0;j&lt;heros.size();j++)&#123;</span><br><span class="line">			String[] index &#x3D; heros.get(j).name.split(&quot; &quot;);</span><br><span class="line">			int indexNum &#x3D; Integer.parseInt(index[1]);</span><br><span class="line">			if(indexNum%8&#x3D;&#x3D;0)&#123;</span><br><span class="line">				heros.remove(j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(Hero h:heros)&#123;</span><br><span class="line">			System.out.print(h.name + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line"></span><br><span class="line">	public String name;</span><br><span class="line"></span><br><span class="line">	public Hero(String name) &#123;</span><br><span class="line">		</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、其他集合-JAVA-LINKEDLIST"><a class="header-anchor" href="#6、其他集合-JAVA-LINKEDLIST">¶</a>6、其他集合 - JAVA LINKEDLIST</h2>
<h3 id="示例-1-LinkedList-与-List接口"><a class="header-anchor" href="#示例-1-LinkedList-与-List接口">¶</a>示例 1 : LinkedList 与 List接口</h3>
<p>与[ArrayList]一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。 详细使用，请参考[ArrayList 常用方法]，在此不作赘述。</p>
<p>接下来要讲的是LinkedList的一些特别的地方</p>
<h3 id="示例-2-双向链表-Deque"><a class="header-anchor" href="#示例-2-双向链表-Deque">¶</a>示例 2 : 双向链表 - Deque</h3>
<p>除了实现了List接口外，LinkedList还实现了<strong>双向链表结构</strong>Deque，可以很方便的在头尾插入删除数据</p>
<p>什么是链表结构: 与数组结构相比较，数组结构，就好像是电影院，每个位置都有标示，每个位置之间的间隔都是一样的。 而链表就相当于佛珠，每个珠子，只连接前一个和后一个，不用关心除此之外的其他佛珠在哪里。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/809.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;LinkedList是一个双向链表结构的list</span><br><span class="line">        LinkedList&lt;Hero&gt; ll &#x3D;new LinkedList&lt;Hero&gt;();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;所以可以很方便的在头部和尾部插入数据</span><br><span class="line">        &#x2F;&#x2F;在最后插入新的英雄</span><br><span class="line">        ll.addLast(new Hero(&quot;hero1&quot;));</span><br><span class="line">        ll.addLast(new Hero(&quot;hero2&quot;));</span><br><span class="line">        ll.addLast(new Hero(&quot;hero3&quot;));</span><br><span class="line">        System.out.println(ll);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;在最前面插入新的英雄</span><br><span class="line">        ll.addFirst(new Hero(&quot;heroX&quot;));</span><br><span class="line">        System.out.println(ll);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;查看最前面的英雄</span><br><span class="line">        System.out.println(ll.getFirst());</span><br><span class="line">        &#x2F;&#x2F;查看最后面的英雄</span><br><span class="line">        System.out.println(ll.getLast());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;查看不会导致英雄被删除</span><br><span class="line">        System.out.println(ll);</span><br><span class="line">        &#x2F;&#x2F;取出最前面的英雄</span><br><span class="line">        System.out.println(ll.removeFirst());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;取出最后面的英雄</span><br><span class="line">        System.out.println(ll.removeLast());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;取出会导致英雄被删除</span><br><span class="line">        System.out.println(ll);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-队列-Queue"><a class="header-anchor" href="#示例-3-队列-Queue">¶</a>示例 3 : 队列 - Queue</h3>
<p>LinkedList 除了实现了List和Deque外，还实现了<strong>Queue</strong>接口(队列)。<br>
Queue是先进先出队列 <strong>FIFO</strong>，常用方法：<br>
<strong>offer</strong> 在最后添加元素<br>
<strong>poll</strong> 取出第一个元素<br>
<strong>peek</strong> 查看第一个元素</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/810.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;和ArrayList一样，LinkedList也实现了List接口</span><br><span class="line">        List ll &#x3D;new LinkedList&lt;Hero&gt;();</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口</span><br><span class="line">        &#x2F;&#x2F;Queue代表FIFO 先进先出的队列</span><br><span class="line">        Queue&lt;Hero&gt; q&#x3D; new LinkedList&lt;Hero&gt;();</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;加在队列的最后面</span><br><span class="line">        System.out.print(&quot;初始化队列：\t&quot;);</span><br><span class="line">        q.offer(new Hero(&quot;Hero1&quot;));</span><br><span class="line">        q.offer(new Hero(&quot;Hero2&quot;));</span><br><span class="line">        q.offer(new Hero(&quot;Hero3&quot;));</span><br><span class="line">        q.offer(new Hero(&quot;Hero4&quot;));</span><br><span class="line">          </span><br><span class="line">        System.out.println(q);</span><br><span class="line">        System.out.print(&quot;把第一个元素取poll()出来:\t&quot;);</span><br><span class="line">        &#x2F;&#x2F;取出第一个Hero，FIFO 先进先出</span><br><span class="line">        Hero h &#x3D; q.poll();</span><br><span class="line">        System.out.println(h);</span><br><span class="line">        System.out.print(&quot;取出第一个元素之后的队列:\t&quot;);</span><br><span class="line">        System.out.println(q);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;把第一个拿出来看一看，但是不取出来</span><br><span class="line">        h&#x3D;q.peek();</span><br><span class="line">        System.out.print(&quot;查看peek()第一个元素:\t&quot;);</span><br><span class="line">        System.out.println(h);</span><br><span class="line">        System.out.print(&quot;查看并不会导致第一个元素被取出来:\t&quot;);</span><br><span class="line">        System.out.println(q);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-ArrayList-与-LinkedList的区别"><a class="header-anchor" href="#示例-4-ArrayList-与-LinkedList的区别">¶</a>示例 4 : ArrayList 与 LinkedList的区别</h3>
<p>ArrayList 与 LinkedList的区别是面试常常会问到的考题<br>
具体区别，详见 [ArrayList 与 LinkedList的区别]</p>
<h3 id="示例-5-练习-使用LinkedList实现Stack栈"><a class="header-anchor" href="#示例-5-练习-使用LinkedList实现Stack栈">¶</a>示例 5 : 练习-使用LinkedList实现Stack栈</h3>
<p>与<strong>FIFO</strong>(先入先出的)<strong>队列</strong>类似的一种数据结构是<strong>FILO</strong>先入后出<strong>栈</strong>Stack<br>
根据接口Stack ：<br>
实现类：MyStack</p>
<p>public class MyStack implements Stack</p>
<p>并向这个栈中，压入5个英雄，接着弹出5个英雄</p>
<p>再解释一下栈: 栈的结构，就像给弹夹添加子弹一样，先添加的子弹，就放在了最下面，<strong>打手枪</strong>的时候，只能从最上面取子弹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public interface Stack &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;把英雄推入到最后位置</span><br><span class="line">    public void push(Hero h);</span><br><span class="line">    &#x2F;&#x2F;把最后一个英雄取出来</span><br><span class="line">    public Hero pull();</span><br><span class="line">    &#x2F;&#x2F;查看最后一个英雄</span><br><span class="line">    public Hero peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line">public class MyStack implements Stack &#123;</span><br><span class="line"> </span><br><span class="line">    LinkedList&lt;Hero&gt; heros &#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    public void push(Hero h) &#123;</span><br><span class="line">    heros.addLast(h);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Hero pull() &#123;</span><br><span class="line">        return heros.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Hero peek() &#123;</span><br><span class="line">        return heros.getLast();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyStack heroS&#x3D; new MyStack();</span><br><span class="line">        for(int i&#x3D;0;i&lt;5;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            heroS.push(new Hero(&quot;hero name &quot;+i));</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;5;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;依次取出对象&quot;+heroS.pull());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、其他集合-JAVA-二叉树"><a class="header-anchor" href="#7、其他集合-JAVA-二叉树">¶</a>7、其他集合 - JAVA 二叉树</h2>
<h3 id="示例-1-二叉树概念"><a class="header-anchor" href="#示例-1-二叉树概念">¶</a>示例 1 : 二叉树概念</h3>
<p>二叉树由各种<strong>节点</strong>组成<br>
二叉树特点：<br>
每个节点都可以有<strong>左子</strong>节点，<strong>右子</strong>节点<br>
每一个节点都有一个<strong>值</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/1008.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">public class Node &#123;</span><br><span class="line">    &#x2F;&#x2F; 左子节点</span><br><span class="line">    public Node leftNode;</span><br><span class="line">    &#x2F;&#x2F; 右子节点</span><br><span class="line">    public Node rightNode;</span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    public Object value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-二叉树排序-插入数据"><a class="header-anchor" href="#示例-2-二叉树排序-插入数据">¶</a>示例 2 : 二叉树排序-插入数据</h3>
<p>假设通过二叉树对如下10个随机数进行排序<br>
67,7,30,73,10,0,78,81,10,74<br>
排序的第一个步骤是把数据插入到该二叉树中<br>
插入基本逻辑是，<strong>小、相同的放左边</strong>，<strong>大的放右边</strong></p>
<ol>
<li>
<p>67 放在根节点</p>
</li>
<li>
<p>7 比 67小，放在67的左节点</p>
</li>
<li>
<p>30 比67 小，找到67的左节点7，30比7大，就放在7的右节点</p>
</li>
<li>
<p>73 比67大， 放在67的右节点</p>
</li>
<li>
<p>10 比 67小，找到67的左节点7，10比7大，找到7的右节点30，10比30小，放在30的左节点。<br>
…<br>
…</p>
</li>
<li>
<p>10比67小，找到67的左节点7，10比7大，找到7的右节点30，10比30小，找到30的左节点10，10和10一样大，放在左边</p>
</li>
</ol>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/1009.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">public class Node &#123;</span><br><span class="line">    &#x2F;&#x2F; 左子节点</span><br><span class="line">    public Node leftNode;</span><br><span class="line">    &#x2F;&#x2F; 右子节点</span><br><span class="line">    public Node rightNode;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    public Object value;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 插入 数据</span><br><span class="line">    public void add(Object v) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前节点没有值，就把数据放在当前节点上</span><br><span class="line">        if (null &#x3D;&#x3D; value)</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 如果当前节点有值，就进行判断，新增的值与当前值的大小关系</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 新增的值，比当前值小或者相同</span><br><span class="line">             </span><br><span class="line">            if ((Integer) v -((Integer)value) &lt;&#x3D; 0) &#123;</span><br><span class="line">                if (null &#x3D;&#x3D; leftNode)</span><br><span class="line">                    leftNode &#x3D; new Node();</span><br><span class="line">                leftNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 新增的值，比当前值大</span><br><span class="line">            else &#123;</span><br><span class="line">                if (null &#x3D;&#x3D; rightNode)</span><br><span class="line">                    rightNode &#x3D; new Node();</span><br><span class="line">                rightNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        int randoms[] &#x3D; new int[] &#123; 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 &#125;;</span><br><span class="line">  </span><br><span class="line">        Node roots &#x3D; new Node();</span><br><span class="line">        for (int number : randoms) &#123;</span><br><span class="line">            roots.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-二叉树排序-遍历"><a class="header-anchor" href="#示例-3-二叉树排序-遍历">¶</a>示例 3 : 二叉树排序-遍历</h3>
<p>通过上一个步骤的插入行为，实际上，数据就已经排好序了。 接下来要做的是看，把<strong>这些已经排好序的数据</strong>，遍历成我们常用的List或者数组的形式</p>
<p>二叉树的遍历分左序，中序，右序<br>
<strong>左序</strong>即： 中间的数遍历后放在<strong>左边</strong><br>
<strong>中序</strong>即： 中间的数遍历后放在<strong>中间</strong><br>
<strong>右序</strong>即： 中间的数遍历后放在<strong>右边</strong><br>
如图所见，我们希望遍历后的结果是从小到大的，所以应该采用<strong>中序遍历</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/1010.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class Node &#123;</span><br><span class="line">    &#x2F;&#x2F; 左子节点</span><br><span class="line">    public Node leftNode;</span><br><span class="line">    &#x2F;&#x2F; 右子节点</span><br><span class="line">    public Node rightNode;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    public Object value;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 插入 数据</span><br><span class="line">    public void add(Object v) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前节点没有值，就把数据放在当前节点上</span><br><span class="line">        if (null &#x3D;&#x3D; value)</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 如果当前节点有值，就进行判断，新增的值与当前值的大小关系</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 新增的值，比当前值小或者相同</span><br><span class="line">             </span><br><span class="line">            if ((Integer) v -((Integer)value) &lt;&#x3D; 0) &#123;</span><br><span class="line">                if (null &#x3D;&#x3D; leftNode)</span><br><span class="line">                    leftNode &#x3D; new Node();</span><br><span class="line">                leftNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 新增的值，比当前值大</span><br><span class="line">            else &#123;</span><br><span class="line">                if (null &#x3D;&#x3D; rightNode)</span><br><span class="line">                    rightNode &#x3D; new Node();</span><br><span class="line">                rightNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 中序遍历所有的节点</span><br><span class="line">    public List&lt;Object&gt; values() &#123;</span><br><span class="line">        List&lt;Object&gt; values &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 左节点的遍历结果</span><br><span class="line">        if (null !&#x3D; leftNode)</span><br><span class="line">            values.addAll(leftNode.values());</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 当前节点</span><br><span class="line">        values.add(value);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 右节点的遍历结果</span><br><span class="line">        if (null !&#x3D; rightNode)</span><br><span class="line">  </span><br><span class="line">            values.addAll(rightNode.values());</span><br><span class="line">  </span><br><span class="line">        return values;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        int randoms[] &#x3D; new int[] &#123; 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 &#125;;</span><br><span class="line">  </span><br><span class="line">        Node roots &#x3D; new Node();</span><br><span class="line">        for (int number : randoms) &#123;</span><br><span class="line">            roots.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        System.out.println(roots.values());</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-练习-英雄二叉树"><a class="header-anchor" href="#示例-4-练习-英雄二叉树">¶</a>示例 4 : 练习-英雄二叉树</h3>
<p>根据上面的学习和理解，设计一个Hero二叉树，HeroNode.<br>
可以向这个英雄二叉树插入不同的Hero对象，并且按照Hero的<strong>血量倒排序</strong>。</p>
<p>随机生成10个Hero对象，每个Hero对象都有不同的血量值，插入这个HeroNode后，把排序结果打印出来。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2511.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class HeroBinaryTree &#123;</span><br><span class="line">	static List&lt;Hero&gt; heros&#x3D; new ArrayList&lt;&gt;(); </span><br><span class="line">	&#x2F;&#x2F;二叉树排序</span><br><span class="line">	public HeroBinaryTree leftNode;</span><br><span class="line">	public HeroBinaryTree rightNode;</span><br><span class="line">	public Hero present;</span><br><span class="line">	public void add(Hero h) &#123;</span><br><span class="line">        if (null &#x3D;&#x3D; present) &#123;</span><br><span class="line">            present &#x3D; h;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if ((Integer) h.hp &lt; (Integer) present.hp) &#123;</span><br><span class="line">                if(null &#x3D;&#x3D; leftNode)</span><br><span class="line">                    leftNode &#x3D; new HeroBinaryTree();</span><br><span class="line">                leftNode.add(h);</span><br><span class="line">            &#125;</span><br><span class="line">            if ((Integer) h.hp &gt; (Integer) present.hp) &#123;</span><br><span class="line">                if(null &#x3D;&#x3D; rightNode)</span><br><span class="line">                    rightNode &#x3D; new HeroBinaryTree();</span><br><span class="line">                rightNode.add(h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;二叉树遍历</span><br><span class="line">    public List&lt;Hero&gt; updateHeros()&#123;</span><br><span class="line">        List&lt;Hero&gt; updateHeros &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(null !&#x3D; leftNode)</span><br><span class="line">            updateHeros.addAll(leftNode.updateHeros());</span><br><span class="line">         </span><br><span class="line">        updateHeros.add(present);</span><br><span class="line">         </span><br><span class="line">        if(null !&#x3D; rightNode)</span><br><span class="line">            updateHeros.addAll(rightNode.updateHeros());</span><br><span class="line">         </span><br><span class="line">        return updateHeros;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;放置英雄方法</span><br><span class="line">    public void push(Hero h) &#123;</span><br><span class="line">        heros.add(h);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;主方法</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	HeroBinaryTree root &#x3D; new HeroBinaryTree();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Hero h &#x3D; new Hero(&quot;hero&quot;+i,(int) (Math.random()*1000));</span><br><span class="line">            root.push(h);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序前&quot;);</span><br><span class="line">        for (Hero h : heros) &#123;</span><br><span class="line">            System.out.println(&quot;英雄名称：&quot;+h.name+&quot;\t&quot;+&quot;英雄血量：&quot;+h.hp);</span><br><span class="line">            root.add(h);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;排序后&quot;);</span><br><span class="line">        List&lt;Hero&gt; updateHeros &#x3D; root.updateHeros();</span><br><span class="line">        for (Hero h : updateHeros) &#123;</span><br><span class="line">            System.out.println(&quot;英雄名称：&quot;+h.name+&quot;\t&quot;+&quot;英雄血量：&quot;+h.hp);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-练习-比较冒泡法，选择法以及二叉树排序的性能区别"><a class="header-anchor" href="#示例-5-练习-比较冒泡法，选择法以及二叉树排序的性能区别">¶</a>示例 5 : 练习-比较冒泡法，选择法以及二叉树排序的性能区别</h3>
<p>二叉树排序用时极短，选择排序耗时较长，冒泡排序耗时最长</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package HOW2J.Middle.Container;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">import suanfa_basic.sort.class_03.Code_14_FindFirstIntersectNode;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;创建4万个随机数，然后用分别用冒泡法，选择法，二叉树3种排序算法进行排序，比较哪种更快</span><br><span class="line">public class Test_compareSort &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;创建一个随机数组</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param index 数组长度</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int[] random(int index)&#123;</span><br><span class="line">        int[] arr &#x3D; new int[index];</span><br><span class="line">        for (int i &#x3D; 0;i &lt; index;i++)&#123;</span><br><span class="line">            arr[i] &#x3D; (int)(Math.random()*10000);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;交换两数</span><br><span class="line">    public static void swap(int[] arr,int L,int R)&#123;</span><br><span class="line">        int temp &#x3D; arr[L];</span><br><span class="line">        arr[L] &#x3D; arr[R];</span><br><span class="line">        arr[R] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;冒泡排序算法(稳定)</span><br><span class="line">    &#x2F;&#x2F;从小到大顺序</span><br><span class="line">    public static int[] bubbleSort(int[] arr)&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length;i++)&#123;</span><br><span class="line">            boolean flag &#x3D; true;  &#x2F;&#x2F;重置交换标志位</span><br><span class="line">            for (int j &#x3D; 1;j &lt; arr.length - i;j++)&#123;</span><br><span class="line">                if (arr[j -1] &gt; arr[j])&#123;</span><br><span class="line">                    swap(arr,j-1,j);  &#x2F;&#x2F;交换两数</span><br><span class="line">                    flag &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;选择排序(不稳定排序)</span><br><span class="line">    &#x2F;&#x2F;寻找当前排序区间最小值放在排序区间的首位</span><br><span class="line">    public static int[]  selectSort(int[] arr)&#123;</span><br><span class="line">        if (arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        for (int i &#x3D; 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            int temp &#x3D; i;  &#x2F;&#x2F;最小元素下标</span><br><span class="line">            for (int j &#x3D; i+1;j &lt; arr.length;j++)&#123;</span><br><span class="line">                if (arr[j] &lt; arr[temp])&#123;</span><br><span class="line">                    temp &#x3D; j;  &#x2F;&#x2F;交换下标</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,temp);  &#x2F;&#x2F;交换两数</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;二叉树排序(HOW2J方法)</span><br><span class="line">    static class SelectionSort&#123;</span><br><span class="line"> </span><br><span class="line">        int numbers[];</span><br><span class="line">        SelectionSort(int [] numbers)&#123;</span><br><span class="line">            this.numbers &#x3D; numbers;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public void sort() &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; numbers.length-1; j++) &#123;</span><br><span class="line">                for (int i &#x3D; j+1; i &lt; numbers.length; i++) &#123;</span><br><span class="line">                    if(numbers[i]&lt;numbers[j])&#123;</span><br><span class="line">                        int temp &#x3D; numbers[j];</span><br><span class="line">                        numbers[j] &#x3D; numbers[i];</span><br><span class="line">                        numbers[i] &#x3D; temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public int[] values() &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">            return numbers;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;二叉树排序</span><br><span class="line">    public static class Node1&#123;</span><br><span class="line">        public Integer value;</span><br><span class="line">        public Node1 leftNode;</span><br><span class="line">        public Node1 rightNode;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        public void BinaryTreeSort(int a)&#123;</span><br><span class="line">            if (value &#x3D;&#x3D; null)&#123;</span><br><span class="line">                this.value &#x3D; Integer.valueOf(a);</span><br><span class="line">            &#125;else if (value.intValue() &gt; a)&#123;  &#x2F;&#x2F;小于放左孩子</span><br><span class="line">                if (leftNode &#x3D;&#x3D; null)</span><br><span class="line">                    leftNode &#x3D; new Node1();</span><br><span class="line">                leftNode.BinaryTreeSort(a);</span><br><span class="line">            &#125;else &#123;  &#x2F;&#x2F;大于放右孩子</span><br><span class="line">                if (rightNode &#x3D;&#x3D; null)</span><br><span class="line">                    rightNode &#x3D; new Node1();</span><br><span class="line">                rightNode.BinaryTreeSort(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;中序遍历(非递归版本)</span><br><span class="line">        &#x2F;&#x2F;从小到大</span><br><span class="line">        public int[] inorderRecur(Node1 head,int[] arr)&#123;</span><br><span class="line">            if (head !&#x3D; null)&#123;</span><br><span class="line">                int i &#x3D; 0;  &#x2F;&#x2F;数组指针</span><br><span class="line">                Stack&lt;Node1&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">                while (!stack.isEmpty() || head !&#x3D; null)&#123;</span><br><span class="line">                    if (head !&#x3D; null)&#123;</span><br><span class="line">                        stack.push(head);</span><br><span class="line">                        head &#x3D; head.leftNode;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        head &#x3D; stack.pop();</span><br><span class="line">                        arr[i++] &#x3D; head.value;</span><br><span class="line">                        head &#x3D; head.rightNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; random(40000);  &#x2F;&#x2F;生成40000个元素的随机数组</span><br><span class="line">        System.out.println(&quot;接下来分别用3种算法进行排序&quot;);</span><br><span class="line">        int[] a &#x3D; &#123;4,2,1,3,5,5,8,9,-10&#125;;  &#x2F;&#x2F;测试数组</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;复制初始化随机数组</span><br><span class="line">        int[] temp;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;冒泡排序算法计时</span><br><span class="line">        temp &#x3D; Arrays.copyOf(arr,arr.length);</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        int[] sortNumberBybubblesort &#x3D; bubbleSort(temp);</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.printf(&quot;冒泡排序算法耗时：%d%n&quot;,end-start);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;选择排序算法计时</span><br><span class="line">        temp &#x3D; Arrays.copyOf(arr,arr.length);</span><br><span class="line">        start &#x3D; System.currentTimeMillis();</span><br><span class="line">        int[] sortNumberByselectionsort &#x3D; selectSort(temp);</span><br><span class="line">        end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.printf(&quot;选择排序算法耗时：%d%n&quot;,end -start);</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;查看排序算法结果&quot;);</span><br><span class="line">        System.out.println(&quot;比较 选择法 和 冒泡法  排序结果：&quot;);</span><br><span class="line">        System.out.println(Arrays.equals(sortNumberBybubblesort, sortNumberByselectionsort));</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;二叉树排序算法计时</span><br><span class="line">        temp &#x3D; Arrays.copyOf(arr,arr.length);</span><br><span class="line">        Node1 head &#x3D; new Node1();</span><br><span class="line">        start &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0;i &lt; temp.length;i++)&#123;</span><br><span class="line">            head.BinaryTreeSort(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] sortNumberBytreeSort &#x3D; head.inorderRecur(head,temp);</span><br><span class="line">        end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.printf(&quot;二叉树排序算法耗时：%d%n&quot;,end -start);</span><br><span class="line">        System.out.println(&quot;比较 选择法 和 二叉树  排序结果：&quot;);</span><br><span class="line">        System.out.println(Arrays.equals(sortNumberBybubblesort, sortNumberBytreeSort));</span><br><span class="line">        System.out.println(&quot;打印冒泡排序后的数组&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(sortNumberBybubblesort));</span><br><span class="line">        System.out.println(&quot;打印二叉树排序后的数组&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(sortNumberBytreeSort));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、其他集合-JAVA-HASHMAP"><a class="header-anchor" href="#8、其他集合-JAVA-HASHMAP">¶</a>8、其他集合 - JAVA HASHMAP</h2>
<h3 id="示例-1-HashMap的键值对"><a class="header-anchor" href="#示例-1-HashMap的键值对">¶</a>示例 1 : HashMap的键值对</h3>
<p>HashMap储存数据的方式是—— 键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.HashMap;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String,String&gt; dictionary &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        dictionary.put(&quot;adc&quot;, &quot;物理英雄&quot;);</span><br><span class="line">        dictionary.put(&quot;apc&quot;, &quot;魔法英雄&quot;);</span><br><span class="line">        dictionary.put(&quot;t&quot;, &quot;坦克&quot;);</span><br><span class="line">         </span><br><span class="line">        System.out.println(dictionary.get(&quot;t&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-键不能重复，值可以重复"><a class="header-anchor" href="#示例-2-键不能重复，值可以重复">¶</a>示例 2 : 键不能重复，值可以重复</h3>
<p>对于HashMap而言，key是唯一的，不可以重复的。<br>
所以，以相同的key 把不同的value插入到 Map中会导致旧元素被覆盖，只留下最后插入的元素。<br>
不过，同一个对象可以作为值插入到map中，只要对应的key不一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">import java.util.HashMap;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String,Hero&gt; heroMap &#x3D; new HashMap&lt;String,Hero&gt;();</span><br><span class="line">         </span><br><span class="line">        heroMap.put(&quot;gareen&quot;, new Hero(&quot;gareen1&quot;));</span><br><span class="line">        System.out.println(heroMap);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;key为gareen已经有value了，再以gareen作为key放入数据，会导致原英雄，被覆盖</span><br><span class="line">        &#x2F;&#x2F;不会增加新的元素到Map中</span><br><span class="line">        heroMap.put(&quot;gareen&quot;, new Hero(&quot;gareen2&quot;));</span><br><span class="line">        System.out.println(heroMap);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;清空map</span><br><span class="line">        heroMap.clear();</span><br><span class="line">        Hero gareen &#x3D; new Hero(&quot;gareen&quot;);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;同一个对象可以作为值插入到map中，只要对应的key不一样</span><br><span class="line">        heroMap.put(&quot;hero1&quot;, gareen);</span><br><span class="line">        heroMap.put(&quot;hero2&quot;, gareen);</span><br><span class="line">         </span><br><span class="line">        System.out.println(heroMap);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-练习-查找内容性能比较"><a class="header-anchor" href="#示例-3-练习-查找内容性能比较">¶</a>示例 3 : 练习-查找内容性能比较</h3>
<p>准备一个ArrayList其中存放3000000(三百万个)Hero对象，其名称是随机的,格式是hero-[4位随机数]<br>
hero-3229<br>
hero-6232<br>
hero-9365<br>
…</p>
<p>因为总数很大，所以几乎每种都有重复，把名字叫做 hero-5555的所有对象找出来<br>
要求使用两种办法来寻找</p>
<ol>
<li>
<p>不使用HashMap，直接使用for循环找出来，并统计花费的时间</p>
</li>
<li>
<p>借助HashMap，找出结果，并统计花费的时间</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package otherlist;</span><br><span class="line"></span><br><span class="line">import charactor.Hero;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class HashMapL &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Hero&gt; hs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		System.out.println(&quot;初始化开始&quot;);</span><br><span class="line">		for(int i &#x3D;0;i&lt;3000000;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Hero h &#x3D; new Hero(&quot;hero-&quot;+((int)(Math.random()*9000)+1000));</span><br><span class="line">			hs.add(h);</span><br><span class="line">		&#125;</span><br><span class="line">		HashMap&lt;String,List&lt;Hero&gt;&gt; heroMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">		for(Hero h : hs)</span><br><span class="line">		&#123;</span><br><span class="line">			List&lt;Hero&gt; list &#x3D; heroMap.get(h.name);</span><br><span class="line">			if(list&#x3D;&#x3D;null)</span><br><span class="line">			&#123;</span><br><span class="line">				list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">				heroMap.put(h.name,list);</span><br><span class="line">			&#125;</span><br><span class="line">			list.add(h);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;初始化结束&quot;);</span><br><span class="line">		System.out.println(&quot;开始查找&quot;);</span><br><span class="line">		findByMap(heroMap);</span><br><span class="line">		findByIteration(hs);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static List&lt;Hero&gt; findByMap(HashMap&lt;String,List&lt;Hero&gt;&gt; m)</span><br><span class="line">	&#123;</span><br><span class="line">		long start &#x3D;System.currentTimeMillis();</span><br><span class="line">		List&lt;Hero&gt; result&#x3D; m.get(&quot;hero-6666&quot;);</span><br><span class="line">		long end &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.printf(&quot;通过map查找，一共找到%d个英雄，耗时%d毫秒%n&quot;,result.size(),end-start);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static List&lt;Hero&gt; findByIteration(List&lt;Hero&gt; hs)</span><br><span class="line">	&#123;</span><br><span class="line">		long start &#x3D; System.currentTimeMillis();</span><br><span class="line">		List&lt;Hero&gt; result&#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		for(Hero h : hs)</span><br><span class="line">		&#123;</span><br><span class="line">			if(h.name.equals(&quot;hero-6666&quot;))</span><br><span class="line">			&#123;</span><br><span class="line">				result.add(h);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		long end &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.printf(&quot;通过for查找，一共找到%d个英雄，耗时%d毫秒%n&quot;,result.size(),end-start);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、其他集合-JAVA-HASHSET-详解"><a class="header-anchor" href="#9、其他集合-JAVA-HASHSET-详解">¶</a>9、其他集合 - JAVA HASHSET 详解</h2>
<h3 id="示例-1-元素不能重复"><a class="header-anchor" href="#示例-1-元素不能重复">¶</a>示例 1 : 元素不能重复</h3>
<p>Set中的元素，不能重复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">import java.util.HashSet;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        HashSet&lt;String&gt; names &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">         </span><br><span class="line">        names.add(&quot;gareen&quot;);</span><br><span class="line">         </span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;第二次插入同样的数据，是插不进去的，容器中只会保留一个</span><br><span class="line">        names.add(&quot;gareen&quot;);</span><br><span class="line">        System.out.println(names);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-没有顺序"><a class="header-anchor" href="#示例-2-没有顺序">¶</a>示例 2 : 没有顺序</h3>
<p>Set中的元素，没有顺序。<br>
严格的说，是没有按照元素的插入顺序排列</p>
<p>HashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。关于hashcode有专门的章节讲解: [hashcode 原理]。</p>
<p>以下是<strong>HashSet源代码</strong>中的部分注释</p>
<p>/**</p>
<p>* It makes no guarantees as to the iteration order of the set;</p>
<p>* in particular, it does not guarantee that the order will remain constant over time.</p>
<p>*/</p>
<p>不保证Set的迭代顺序; 确切的说，在不同条件下，元素的顺序都有可能不一样</p>
<p>换句话说，同样是插入0-9到HashSet中， 在JVM的不同版本中，看到的顺序都是不一样的。 所以在开发的时候，不能依赖于某种<strong>臆测的顺序</strong>，这个顺序本身是<strong>不稳定的</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/823.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.HashSet;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; numbers &#x3D; new HashSet&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line">        numbers.add(9);</span><br><span class="line">        numbers.add(5);</span><br><span class="line">        numbers.add(1);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Set中的元素排列，不是按照插入顺序</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-遍历"><a class="header-anchor" href="#示例-3-遍历">¶</a>示例 3 : 遍历</h3>
<p>Set不提供get()来获取指定位置的元素<br>
所以遍历需要用到迭代器，或者增强型for循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; numbers &#x3D; new HashSet&lt;Integer&gt;();</span><br><span class="line">         </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;Set不提供get方法来获取指定位置的元素</span><br><span class="line">        &#x2F;&#x2F;numbers.get(0)</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;遍历Set可以采用迭代器iterator</span><br><span class="line">        for (Iterator&lt;Integer&gt; iterator &#x3D; numbers.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            Integer i &#x3D; (Integer) iterator.next();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;或者采用增强型for循环</span><br><span class="line">        for (Integer i : numbers) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-HashSet和HashMap的关系"><a class="header-anchor" href="#示例-4-HashSet和HashMap的关系">¶</a>示例 4 : HashSet和HashMap的关系</h3>
<p>通过观察HashSet的源代码（[如何查看源代码]）<br>
可以发现HashSet自身并没有独立的实现，而是在里面封装了一个Map.<br>
HashSet是作为Map的key而存在的<br>
而value是一个命名为PRESENT的static的Object对象，因为是一个类属性，所以只会有一个。</p>
<p>private static final Object PRESENT = new Object();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.AbstractSet;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"> </span><br><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">    extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;HashSet里封装了一个HashMap</span><br><span class="line">    private  HashMap&lt;E,Object&gt; map;</span><br><span class="line"> </span><br><span class="line">    private static final Object PRESENT &#x3D; new Object();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;HashSet的构造方法初始化这个HashMap</span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map &#x3D; new HashMap&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;向HashSet中增加元素，其实就是把该元素作为key，增加到Map中</span><br><span class="line">    &#x2F;&#x2F;value是PRESENT，静态，final的对象，所有的HashSet都使用这么同一个对象</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;HashSet的size就是map的size</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return map.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;清空Set就是清空Map</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;迭代Set,就是把Map的键拿出来迭代</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-练习-HashSet"><a class="header-anchor" href="#示例-5-练习-HashSet">¶</a>示例 5 : 练习-HashSet</h3>
<p>在[比较字符串]章节，有一个同样的练习<br>
创建一个长度是100的字符串数组<br>
使用长度是2的随机字符填充该字符串数组<br>
统计这个字符串数组里<strong>重复的字符串有多少种</strong><br>
使用HashSet来解决这个问题</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2386.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class HashSetTest &#123;</span><br><span class="line">	public static String RandomString()&#123;</span><br><span class="line">		String s &#x3D;&quot;0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;;</span><br><span class="line">		char [] chars &#x3D; s.toCharArray();</span><br><span class="line">		String s1 &#x3D; String.valueOf(chars[(int) (Math.random()*chars.length)])</span><br><span class="line">				+String.valueOf(chars[(int) (Math.random()*chars.length)]);</span><br><span class="line">		return s1;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		HashSet&lt;String&gt; hashSet &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">		HashSet&lt;String&gt; hashSet1 &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">		ArrayList&lt;String&gt; arrayList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		System.out.println(&quot;元素：&quot;+&quot;\n&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;100 ; i++) &#123;</span><br><span class="line">			if (i%25&#x3D;&#x3D;0)&#123;</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">			String temp &#x3D; RandomString();</span><br><span class="line">			if (hashSet.contains(temp))&#123;</span><br><span class="line">				hashSet1.add(temp);</span><br><span class="line">			&#125;</span><br><span class="line">			hashSet.add(temp);</span><br><span class="line">			System.out.print(temp+&quot;\t&quot;);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;重复的个数为：&quot;+hashSet1.size()+&quot;\n重复的元素：&quot;+hashSet1);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;hashSet的个数为：&quot;+hashSet.size());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、其他集合-JAVA-集合框架-COLLECTION"><a class="header-anchor" href="#10、其他集合-JAVA-集合框架-COLLECTION">¶</a>10、其他集合 - JAVA 集合框架 COLLECTION</h2>
<h3 id="步骤-1-Collection"><a class="header-anchor" href="#步骤-1-Collection">¶</a>步骤 1 : Collection</h3>
<p>Collection是 Set List Queue和 Deque的接口<br>
Queue: 先进先出队列<br>
Deque: 双向链表</p>
<p>**注：**Collection和Map之间没有关系，Collection是放一个一个对象的，Map 是放键值对的<br>
**注：**Deque 继承 Queue,间接的继承了 Collection</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/830.png" alt></p>
<h2 id="11、其他集合-JAVA-工具类-COLLECTIONS"><a class="header-anchor" href="#11、其他集合-JAVA-工具类-COLLECTIONS">¶</a>11、其他集合 - JAVA 工具类 COLLECTIONS</h2>
<p>Collections是一个类，容器的工具类,就如同Arrays是数组的工具类</p>
<h3 id="步骤-1-反转"><a class="header-anchor" href="#步骤-1-反转">¶</a>步骤 1 : 反转</h3>
<p><strong>reverse</strong> 使List中的数据发生翻转</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2498.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化集合numbers</span><br><span class="line">        List&lt;Integer&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">        Collections.reverse(numbers);</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;翻转后集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-混淆"><a class="header-anchor" href="#步骤-2-混淆">¶</a>步骤 2 : 混淆</h3>
<p><strong>shuffle</strong> 混淆List中数据的顺序</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2501.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化集合numbers</span><br><span class="line">        List&lt;Integer&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">        Collections.shuffle(numbers);</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;混淆后集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-排序"><a class="header-anchor" href="#步骤-3-排序">¶</a>步骤 3 : 排序</h3>
<p><strong>sort</strong> 对List中的数据进行排序</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2499.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化集合numbers</span><br><span class="line">        List&lt;Integer&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">        Collections.shuffle(numbers);</span><br><span class="line">        System.out.println(&quot;混淆后集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">        Collections.sort(numbers);</span><br><span class="line">        System.out.println(&quot;排序后集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-交换"><a class="header-anchor" href="#步骤-4-交换">¶</a>步骤 4 : 交换</h3>
<p><strong>swap</strong> 交换两个数据的位置</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2500.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化集合numbers</span><br><span class="line">        List&lt;Integer&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">        Collections.swap(numbers,0,5);</span><br><span class="line">        System.out.println(&quot;交换0和5下标的数据后，集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-滚动"><a class="header-anchor" href="#步骤-5-滚动">¶</a>步骤 5 : 滚动</h3>
<p><strong>rotate</strong> 把List中的数据，向右滚动指定单位的长度</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2497.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化集合numbers</span><br><span class="line">        List&lt;Integer&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">        Collections.rotate(numbers,2);</span><br><span class="line">        System.out.println(&quot;把集合向右滚动2个单位，标的数据后，集合中的数据:&quot;);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-线程安全化"><a class="header-anchor" href="#步骤-6-线程安全化">¶</a>步骤 6 : 线程安全化</h3>
<p><strong>synchronizedList</strong> 把非线程安全的List转换为线程安全的List。 因为截至目前为止，还没有学习[线程安全]的内容，暂时不展开。 线程安全的内容将在[多线程]章节展开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;把非线程安全的List转换为线程安全的List&quot;);</span><br><span class="line">        List&lt;Integer&gt; synchronizedNumbers &#x3D; (List&lt;Integer&gt;) Collections.synchronizedList(numbers);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-练习-统计概率"><a class="header-anchor" href="#步骤-7-练习-统计概率">¶</a>步骤 7 : 练习-统计概率</h3>
<p>首先初始化一个List,长度是10，值是0-9。<br>
然后不断的shuffle，直到前3位出现<br>
3 1 4</p>
<p>shuffle 1000,000 次，统计出现的概率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package otherlist;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Integer&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		for(int i &#x3D;0;i&lt;10;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			numbers.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		int num&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;1000000;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Collections.shuffle(numbers);</span><br><span class="line">			if(numbers.get(0)&#x3D;&#x3D;3&amp;&amp;numbers.get(1)&#x3D;&#x3D;1&amp;&amp;numbers.get(2)&#x3D;&#x3D;4)</span><br><span class="line">			&#123;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		double rate &#x3D; num&#x2F;(1000000d);</span><br><span class="line">		System.out.println(&quot;出现314的概率为:&quot;+rate*100+&quot;%&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12、关系与区别-JAVA-ARRAYLIST和HASHSET的区别"><a class="header-anchor" href="#12、关系与区别-JAVA-ARRAYLIST和HASHSET的区别">¶</a>12、关系与区别 - JAVA ARRAYLIST和HASHSET的区别</h2>
<h3 id="示例-1-是否有顺序"><a class="header-anchor" href="#示例-1-是否有顺序">¶</a>示例 1 : 是否有顺序</h3>
<p>ArrayList: 有顺序<br>
HashSet: 无顺序</p>
<p>HashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。关于hashcode有专门的章节讲解: [hashcode 原理]。</p>
<p>以下是<strong>HasetSet源代码</strong>中的部分注释</p>
<p>/**</p>
<p>* It makes no guarantees as to the iteration order of the set;</p>
<p>* in particular, it does not guarantee that the order will remain constant over time.</p>
<p>*/</p>
<p>不保证Set的迭代顺序; 确切的说，在不同条件下，元素的顺序都有可能不一样</p>
<p>换句话说，同样是插入0-9到HashSet中， 在JVM的不同版本中，看到的顺序都是不一样的。 所以在开发的时候，不能依赖于某种<strong>臆测的顺序</strong>，这个顺序本身是<strong>不稳定的</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/798.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">    </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           </span><br><span class="line">        ArrayList&lt;Integer&gt; numberList &#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F;List中的数据按照插入顺序存放</span><br><span class="line">        System.out.println(&quot;----------List----------&quot;);</span><br><span class="line">        System.out.println(&quot;向List 中插入 9 5 1&quot;);</span><br><span class="line">        numberList.add(9);</span><br><span class="line">        numberList.add(5);</span><br><span class="line">        numberList.add(1);</span><br><span class="line">        System.out.println(&quot;List 按照顺序存放数据:&quot;);</span><br><span class="line">        System.out.println(numberList);</span><br><span class="line">        System.out.println(&quot;----------Set----------&quot;);</span><br><span class="line">        HashSet&lt;Integer&gt; numberSet &#x3D;new HashSet&lt;Integer&gt;();</span><br><span class="line">        System.out.println(&quot;向Set 中插入9 5 1&quot;);</span><br><span class="line">        &#x2F;&#x2F;Set中的数据不是按照插入顺序存放</span><br><span class="line">        numberSet.add(9);</span><br><span class="line">        numberSet.add(5);</span><br><span class="line">        numberSet.add(1);</span><br><span class="line">        System.out.println(&quot;Set 不是按照顺序存放数据:&quot;);</span><br><span class="line">        System.out.println(numberSet);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-能否重复"><a class="header-anchor" href="#示例-2-能否重复">¶</a>示例 2 : 能否重复</h3>
<p>List中的数据可以重复<br>
Set中的数据不能够重复<br>
重复判断标准是:<br>
首先看hashcode是否相同<br>
如果hashcode不同，则认为是不同数据<br>
如果hashcode相同，再比较equals，如果equals相同，则是相同数据，否则是不同数据<br>
更多关系hashcode，请参考[hashcode原理]</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2513.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">    </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           </span><br><span class="line">        ArrayList&lt;Integer&gt; numberList &#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F;List中的数据可以重复</span><br><span class="line">        System.out.println(&quot;----------List----------&quot;);</span><br><span class="line">        System.out.println(&quot;向List 中插入 9 9&quot;);</span><br><span class="line">        numberList.add(9);</span><br><span class="line">        numberList.add(9);</span><br><span class="line">        System.out.println(&quot;List 中出现两个9:&quot;);</span><br><span class="line">        System.out.println(numberList);</span><br><span class="line">        System.out.println(&quot;----------Set----------&quot;);</span><br><span class="line">        HashSet&lt;Integer&gt; numberSet &#x3D;new HashSet&lt;Integer&gt;();</span><br><span class="line">        System.out.println(&quot;向Set 中插入9 9&quot;);</span><br><span class="line">        &#x2F;&#x2F;Set中的数据不能重复</span><br><span class="line">        numberSet.add(9);</span><br><span class="line">        numberSet.add(9);</span><br><span class="line">        System.out.println(&quot;Set 中只会保留一个9:&quot;);</span><br><span class="line">        System.out.println(numberSet);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-练习-不重复的随机数"><a class="header-anchor" href="#示例-3-练习-不重复的随机数">¶</a>示例 3 : 练习-不重复的随机数</h3>
<p>生成50个 0-9999之间的随机数，要求不能有重复的</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2520.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.HashSet;</span><br><span class="line">    </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;生成一个HashSet集合</span><br><span class="line">        HashSet&lt;Integer&gt; list&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        while(list.size()&lt;50) &#123;</span><br><span class="line">            Integer n&#x3D;(int)(Math.random()*9999);</span><br><span class="line">            list.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13、关系与区别-ARRAYLIST和LINKEDLIST的区别详解"><a class="header-anchor" href="#13、关系与区别-ARRAYLIST和LINKEDLIST的区别详解">¶</a>13、关系与区别 - ARRAYLIST和LINKEDLIST的区别详解</h2>
<h3 id="步骤-1-ArrayList和LinkedList的区别"><a class="header-anchor" href="#步骤-1-ArrayList和LinkedList的区别">¶</a>步骤 1 : ArrayList和LinkedList的区别</h3>
<p>ArrayList <strong>插入，删除数据慢</strong><br>
LinkedList， <strong>插入，删除数据快</strong><br>
ArrayList是顺序结构，所以<strong>定位很快</strong>，指哪找哪。 就像电影院位置一样，有了电影票，一下就找到位置了。<br>
LinkedList 是链表结构，就像手里的一串佛珠，要找出第99个佛珠，必须得一个一个的数过去，所以<strong>定位慢</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/799.png" alt></p>
<h3 id="步骤-2-插入数据"><a class="header-anchor" href="#步骤-2-插入数据">¶</a>步骤 2 : 插入数据</h3>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2507.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; l;</span><br><span class="line">        l &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        insertFirst(l, &quot;ArrayList&quot;);</span><br><span class="line"> </span><br><span class="line">        l &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        insertFirst(l, &quot;LinkedList&quot;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void insertFirst(List&lt;Integer&gt; l, String type) &#123;</span><br><span class="line">        int total &#x3D; 1000 * 100;</span><br><span class="line">        final int number &#x3D; 5;</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; total; i++) &#123;</span><br><span class="line">            l.add(0, number);</span><br><span class="line">        &#125;</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.printf(&quot;在%s 最前面插入%d条数据，总共耗时 %d 毫秒 %n&quot;, type, total, end - start);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-定位数据"><a class="header-anchor" href="#步骤-3-定位数据">¶</a>步骤 3 : 定位数据</h3>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2508.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; l;</span><br><span class="line">        l &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        modify(l, &quot;ArrayList&quot;);</span><br><span class="line"> </span><br><span class="line">        l &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        modify(l, &quot;LinkedList&quot;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void modify(List&lt;Integer&gt; l, String type) &#123;</span><br><span class="line">        int total &#x3D; 100 * 1000;</span><br><span class="line">        int index &#x3D; total&#x2F;2;</span><br><span class="line">        final int number &#x3D; 5;</span><br><span class="line">        &#x2F;&#x2F;初始化</span><br><span class="line">        for (int i &#x3D; 0; i &lt; total; i++) &#123;</span><br><span class="line">            l.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line"> </span><br><span class="line">        for (int i &#x3D; 0; i &lt; total; i++) &#123;</span><br><span class="line">             int n &#x3D; l.get(index);</span><br><span class="line">             n++;</span><br><span class="line">             l.set(index, n);</span><br><span class="line">        &#125;</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.printf(&quot;%s总长度是%d，定位到第%d个数据，取出来，加1，再放回去%n 重复%d遍，总共耗时 %d 毫秒 %n&quot;, type,total, index,total, end - start);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-在后面插入数据"><a class="header-anchor" href="#步骤-4-练习-在后面插入数据">¶</a>步骤 4 : 练习-在后面插入数据</h3>
<p>比较 ArrayList和LinkedList <strong>在最后面插入</strong>100000条数据，谁快谁慢？为什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; arry &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		LinkedList&lt;Integer&gt; link &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		endFirst(arry, &quot;ArrayList&quot;, 1000000);</span><br><span class="line"></span><br><span class="line">		endFirst(link, &quot;LinkeList&quot;, 1000000);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public static void endFirst(List&lt;Integer&gt; l, String n, int s) &#123;</span><br><span class="line">			long start &#x3D; System.currentTimeMillis();</span><br><span class="line">			for (int i &#x3D; 0; i &lt; s; i++) &#123;</span><br><span class="line">				l.add(5);</span><br><span class="line">			&#125;</span><br><span class="line">			long end &#x3D; System.currentTimeMillis();</span><br><span class="line">			System.out.println(&quot;在&quot; + n + &quot;最后面插入&quot; + s + &quot;条数据，总共耗时&quot; + (end - start) + &quot;毫秒&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在ArrayList最后面插入1000000条数据，总共耗时17毫秒</span><br><span class="line">在LinkeList最后面插入1000000条数据，总共耗时66毫秒</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-在中间插入数据"><a class="header-anchor" href="#步骤-5-练习-在中间插入数据">¶</a>步骤 5 : 练习-在中间插入数据</h3>
<p>在List的中间位置，插入数据，比较ArrayList快，还是LinkedList快，并解释为什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;第一题：比较 ArrayList和LinkedList 在最后面插入100000条数据，谁快谁慢？为什么？</span><br><span class="line">		List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		long start1 &#x3D; System.currentTimeMillis();</span><br><span class="line">		for(int i &#x3D; 0;i&lt;100000;i++)&#123;</span><br><span class="line">			list.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		long end1 &#x3D; System.currentTimeMillis();</span><br><span class="line">		Long costTime1 &#x3D; end1 - start1;</span><br><span class="line">		List&lt;Integer&gt; list2 &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">		long start2 &#x3D; System.currentTimeMillis();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 100000;i++) &#123;</span><br><span class="line">			list2.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		long end2 &#x3D; System.currentTimeMillis();</span><br><span class="line">		Long costTime2 &#x3D; end2 - start2;</span><br><span class="line">		System.out.println(&quot;在后面加入数据，ArrayList花费的时间是：&quot;+costTime1);</span><br><span class="line">		System.out.println(&quot;在后面加入数据，LinkedList花费的时间是：&quot;+costTime2);</span><br><span class="line"></span><br><span class="line">		long start11 &#x3D; System.currentTimeMillis();</span><br><span class="line">		for(int i &#x3D; 0;i&lt;100000;i++)&#123;</span><br><span class="line">			list.add(5000,i);</span><br><span class="line">		&#125;</span><br><span class="line">		long end11 &#x3D; System.currentTimeMillis();</span><br><span class="line">		Long costTime11 &#x3D; end11 - start11;</span><br><span class="line">		long start22 &#x3D; System.currentTimeMillis();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 100000;i++) &#123;</span><br><span class="line">			list2.add(5000,i);</span><br><span class="line">		&#125;</span><br><span class="line">		long end22 &#x3D; System.currentTimeMillis();</span><br><span class="line">		Long costTime22 &#x3D; end22 - start22;</span><br><span class="line">		System.out.println(&quot;在中间加入数据，ArrayList花费的时间是：&quot;+costTime11);</span><br><span class="line">		System.out.println(&quot;在中间加入数据，LinkedList花费的时间是：&quot;+costTime22);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14、关系与区别-HASHMAP和HASHTABLE之间的区别"><a class="header-anchor" href="#14、关系与区别-HASHMAP和HASHTABLE之间的区别">¶</a>14、关系与区别 - HASHMAP和HASHTABLE之间的区别</h2>
<h3 id="步骤-1-HashMap和Hashtable的区别"><a class="header-anchor" href="#步骤-1-HashMap和Hashtable的区别">¶</a>步骤 1 : HashMap和Hashtable的区别</h3>
<p>HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式<br>
区别1：<br>
HashMap可以存放 null<br>
Hashtable不能存放null<br>
区别2：<br>
HashMap不是[线程安全的类]<br>
Hashtable是线程安全的类</p>
<p>鉴于目前学习的进度，不对线程安全做展开，在[线程章节]会详细讲解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"> </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式</span><br><span class="line">         </span><br><span class="line">        HashMap&lt;String,String&gt; hashMap &#x3D; new HashMap&lt;String,String&gt;();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;HashMap可以用null作key,作value</span><br><span class="line">        hashMap.put(null, &quot;123&quot;);</span><br><span class="line">        hashMap.put(&quot;123&quot;, null);</span><br><span class="line">         </span><br><span class="line">        Hashtable&lt;String,String&gt; hashtable &#x3D; new Hashtable&lt;String,String&gt;();</span><br><span class="line">        &#x2F;&#x2F;Hashtable不能用null作key，不能用null作value</span><br><span class="line">        hashtable.put(null, &quot;123&quot;);</span><br><span class="line">        hashtable.put(&quot;123&quot;, null);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-反转key和value"><a class="header-anchor" href="#步骤-2-练习-反转key和value">¶</a>步骤 2 : 练习-反转key和value</h3>
<p>使用如下键值对，初始化一个HashMap：<br>
adc - 物理英雄<br>
apc - 魔法英雄<br>
t - 坦克</p>
<p>对这个HashMap进行反转，key变成value,value变成key<br>
<strong>提示</strong>： keySet()可以获取所有的key, values()可以获取所有的value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		HashMap&lt;String,String&gt; hm &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">		HashMap&lt;String,String&gt; hm1 &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">		hm.put(&quot;adc&quot;,&quot;物理英雄&quot;);</span><br><span class="line">		hm.put(&quot;apc&quot;,&quot;魔法英雄&quot;);</span><br><span class="line">		hm.put(&quot;t&quot;,&quot;坦克&quot;);</span><br><span class="line">		System.out.println(hm);</span><br><span class="line">		Set&lt;String&gt;keys &#x3D; hm.keySet();</span><br><span class="line">		for(String key :keys)&#123;</span><br><span class="line">			String value &#x3D; hm.get(key);</span><br><span class="line">			hm1.put(value,key);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(hm1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15、关系与区别-HASHSET、-LINKEDHASHSET、TREESET之间的区别"><a class="header-anchor" href="#15、关系与区别-HASHSET、-LINKEDHASHSET、TREESET之间的区别">¶</a>15、关系与区别 - HASHSET、 LINKEDHASHSET、TREESET之间的区别</h2>
<h3 id="步骤-1-HashSet-LinkedHashSet-TreeSet"><a class="header-anchor" href="#步骤-1-HashSet-LinkedHashSet-TreeSet">¶</a>步骤 1 : HashSet LinkedHashSet TreeSet</h3>
<p>HashSet： 无序<br>
LinkedHashSet： 按照插入顺序<br>
TreeSet： 从小到大排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; numberSet1 &#x3D;new HashSet&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F;HashSet中的数据不是按照插入顺序存放</span><br><span class="line">        numberSet1.add(88);</span><br><span class="line">        numberSet1.add(8);</span><br><span class="line">        numberSet1.add(888);</span><br><span class="line">          </span><br><span class="line">        System.out.println(numberSet1);</span><br><span class="line">          </span><br><span class="line">        LinkedHashSet&lt;Integer&gt; numberSet2 &#x3D;new LinkedHashSet&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F;LinkedHashSet中的数据是按照插入顺序存放</span><br><span class="line">        numberSet2.add(88);</span><br><span class="line">        numberSet2.add(8);</span><br><span class="line">        numberSet2.add(888);</span><br><span class="line">          </span><br><span class="line">        System.out.println(numberSet2);</span><br><span class="line">        TreeSet&lt;Integer&gt; numberSet3 &#x3D;new TreeSet&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F;TreeSet 中的数据是进行了排序的</span><br><span class="line">        numberSet3.add(88);</span><br><span class="line">        numberSet3.add(8);</span><br><span class="line">        numberSet3.add(888);</span><br><span class="line">          </span><br><span class="line">        System.out.println(numberSet3);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-既不重复，又有顺序"><a class="header-anchor" href="#步骤-2-练习-既不重复，又有顺序">¶</a>步骤 2 : 练习-既不重复，又有顺序</h3>
<p>利用LinkedHashSet的既不重复，又有顺序的特性，把Math.PI中的数字，按照出现顺序打印出来，相同数字，只出现一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		LinkedHashSet&lt;Integer&gt; set &#x3D; new LinkedHashSet&lt;&gt;();</span><br><span class="line">		double pi &#x3D; Math.PI;</span><br><span class="line">		while(set.size()&lt;10) &#123;</span><br><span class="line">			set.add((Integer)(int)(pi%10));</span><br><span class="line">			pi*&#x3D;10;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(set);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16、其他-JAVA-HASHCODE原理详解"><a class="header-anchor" href="#16、其他-JAVA-HASHCODE原理详解">¶</a>16、其他 - JAVA HASHCODE原理详解</h2>
<h3 id="步骤-1-List查找的低效率"><a class="header-anchor" href="#步骤-1-List查找的低效率">¶</a>步骤 1 : List查找的低效率</h3>
<p>假设在List中存放着无重复名称，没有顺序的2000000个Hero<br>
要把名字叫做“hero 1000000”的对象找出来<br>
List的做法是对每一个进行挨个遍历，直到找到名字叫做“hero 1000000”的英雄。<br>
<strong>最差的情况下，需要遍历和比较2000000次</strong>，才能找到对应的英雄。<br>
测试逻辑：</p>
<ol>
<li>
<p>初始化2000000个对象到ArrayList中</p>
</li>
<li>
<p>打乱容器中的数据顺序</p>
</li>
<li>
<p>进行10次查询，统计每一次消耗的时间<br>
不同计算机的配置情况下，所花的时间是有区别的。 在本机上，花掉的时间大概是600毫秒左右</p>
</li>
</ol>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/817.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">     </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">     </span><br><span class="line">import charactor.Hero;</span><br><span class="line">     </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">            </span><br><span class="line">        for (int j &#x3D; 0; j &lt; 2000000; j++) &#123;</span><br><span class="line">            Hero h &#x3D; new Hero(&quot;Hero &quot; + j);</span><br><span class="line">            heros.add(h);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F; 进行10次查找，观察大体的平均值</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 打乱heros中元素的顺序</span><br><span class="line">            Collections.shuffle(heros);</span><br><span class="line">             </span><br><span class="line">            long start &#x3D; System.currentTimeMillis();</span><br><span class="line">     </span><br><span class="line">            String target &#x3D; &quot;Hero 1000000&quot;;</span><br><span class="line">     </span><br><span class="line">            for (Hero hero : heros) &#123;</span><br><span class="line">                if (hero.name.equals(target)) &#123;</span><br><span class="line">                    System.out.println(&quot;找到了 hero!&quot; );</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            long end &#x3D; System.currentTimeMillis();</span><br><span class="line">            long elapsed &#x3D; end - start;</span><br><span class="line">            System.out.println(&quot;一共花了：&quot; + elapsed + &quot; 毫秒&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-HashMap的性能表现"><a class="header-anchor" href="#步骤-2-HashMap的性能表现">¶</a>步骤 2 : HashMap的性能表现</h3>
<p>使用HashMap 做同样的查找</p>
<ol>
<li>
<p>初始化2000000个对象到HashMap中。</p>
</li>
<li>
<p>进行10次查询</p>
</li>
<li>
<p>统计每一次的查询消耗的时间<br>
可以观察到，几乎不花时间，花费的时间在1毫秒以内</p>
</li>
</ol>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/818.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">import java.util.HashMap;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        HashMap&lt;String,Hero&gt; heroMap &#x3D; new HashMap&lt;String,Hero&gt;();</span><br><span class="line">        for (int j &#x3D; 0; j &lt; 2000000; j++) &#123;</span><br><span class="line">            Hero h &#x3D; new Hero(&quot;Hero &quot; + j);</span><br><span class="line">            heroMap.put(h.name, h);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;数据准备完成&quot;);</span><br><span class="line">  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            long start &#x3D; System.currentTimeMillis();</span><br><span class="line">              </span><br><span class="line">            &#x2F;&#x2F;查找名字是Hero 1000000的对象</span><br><span class="line">            Hero target &#x3D; heroMap.get(&quot;Hero 1000000&quot;);</span><br><span class="line">            System.out.println(&quot;找到了 hero!&quot; + target.name);</span><br><span class="line">              </span><br><span class="line">            long end &#x3D; System.currentTimeMillis();</span><br><span class="line">            long elapsed &#x3D; end - start;</span><br><span class="line">            System.out.println(&quot;一共花了：&quot; + elapsed + &quot; 毫秒&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-HashMap原理与字典"><a class="header-anchor" href="#步骤-3-HashMap原理与字典">¶</a>步骤 3 : HashMap原理与字典</h3>
<p>在展开HashMap原理的讲解之前，首先回忆一下大家初中和高中使用的汉英字典。</p>
<p>比如要找一个单词对应的中文意思，假设单词是Lengendary,首先在目录找到Lengendary在第 555页。</p>
<p>然后，翻到第555页，这页不只一个单词，但是量已经很少了，逐一比较，很快就定位目标单词Lengendary。</p>
<p>555相当于就是Lengendary对应的<strong>hashcode</strong></p>
<h3 id="步骤-4-分析HashMap性能卓越的原因"><a class="header-anchor" href="#步骤-4-分析HashMap性能卓越的原因">¶</a>步骤 4 : 分析HashMap性能卓越的原因</h3>
<p><strong>-----hashcode概念-----</strong><br>
所有的对象，都有一个对应的<strong>hashcode（散列值）</strong><br>
比如字符串“gareen”对应的是1001 (实际上不是，这里是方便理解，假设的值)<br>
比如字符串“temoo”对应的是1004<br>
比如字符串“db”对应的是1008<br>
比如字符串“annie”对应的<strong>也 是1008</strong></p>
<p><strong>-----保存数据-----</strong><br>
准备一个数组，其长度是2000，并且设定特殊的hashcode算法，使得所有字符串对应的hashcode，都会落在0-1999之间<br>
要存放名字是&quot;gareen&quot;的英雄，就把该英雄和名称组成一个<strong>键值对</strong>，存放在数组的1001这个位置上<br>
要存放名字是&quot;temoo&quot;的英雄，就把该英雄存放在数组的1004这个位置上<br>
要存放名字是&quot;db&quot;的英雄，就把该英雄存放在数组的1008这个位置上<br>
要存放名字是&quot;annie&quot;的英雄，然而 &quot;annie&quot;的hashcode 1008对应的位置<strong>已经有db英雄了</strong>，那么就在这里创建一个链表，<strong>接在db英雄后面存放annie</strong></p>
<p><strong>-----查找数据-----</strong><br>
比如要查找gareen，首先计算&quot;gareen&quot;的hashcode是1001，根据1001这个下标，到数组中进行定位，（<strong>根据数组下标进行定位，是非常快速的</strong>） 发现1001这个位置就只有一个英雄，那么该英雄就是gareen.<br>
比如要查找annie，首先计算&quot;annie&quot;的hashcode是1008，根据1008这个下标，到数组中进行定位，发现1008这个位置<strong>有两个英雄</strong>，那么就对两个英雄的名字进行逐一比较(<strong>equals</strong>)，因为此时需要比较的量就已经少很多了，很快也就可以找出目标英雄<br>
这就是使用hashmap进行查询，非常快原理。</p>
<p>这是一种用<strong>空间换时间</strong>的思维方式</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/819.png" alt></p>
<h3 id="步骤-5-HashSet判断是否重复"><a class="header-anchor" href="#步骤-5-HashSet判断是否重复">¶</a>步骤 5 : HashSet判断是否重复</h3>
<p>HashSet的数据是不能重复的，相同数据不能保存在一起，到底如何判断是否是重复的呢？<br>
根据[HashSet和HashMap的关系]，我们了解到因为HashSet没有自身的实现，而是里面封装了一个HashMap，所以本质上就是判断HashMap的key是否重复。</p>
<p>再通过上一步的学习，key是否重复，是由两个步骤判断的：<br>
hashcode是否一样<br>
如果hashcode不一样，就是在<strong>不同的坑里</strong>，一定是不重复的<br>
如果hashcode一样，就是在<strong>同一个坑里</strong>，还需要进行equals比较<br>
如果equals一样，则是重复数据<br>
如果equals不一样，则是不同数据。</p>
<h3 id="步骤-6-练习-自定义字符串的hashcode"><a class="header-anchor" href="#步骤-6-练习-自定义字符串的hashcode">¶</a>步骤 6 : 练习-自定义字符串的hashcode</h3>
<p>如下是Java API提供的String的hashcode生成办法；</p>
<p>s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]</p>
<p>s[0] 表示第一位字符<br>
n表示字符串的长度<br>
本练习并不是要求去理解这个算法，而是自定义一个<strong>简单的hashcode算法</strong>，计算任意字符串的hashcode<br>
因为String类不能被重写，所以我们通过一个静态方法来返回一个String的hashcode</p>
<p>public static int hashcode(String)</p>
<p>如果字符串长度是0，则返回0。<br>
否则： 获取每一位字符，转换成数字后，相加，最后乘以23</p>
<p>(s[0]+ s[1] + s[2] + s[3]+ s[n-1])*23.</p>
<p>如果值超过了1999，则取2000的余数，保证落在0-1999之间。<br>
如果是负数，则取绝对值。</p>
<p>随机生成长度是2-10的不等的100个字符串，打印用本hashcode获取的值分别是多少</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestHashSet &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str&#x3D;&quot;zxcvbnmlkjhgfdsaqwertyuiopQWERTYUIOPASDFGHJKLZXCVBNM1234567890&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            StringBuilder stringBuilder&#x3D;new StringBuilder(&quot;&quot;);</span><br><span class="line">            Random random&#x3D;new Random();</span><br><span class="line">            for (int j &#x3D; 0; j &lt; (2+(int)9*Math.random()); j++) &#123;</span><br><span class="line">                int number&#x3D;random.nextInt(str.length()-1);</span><br><span class="line">                stringBuilder.append(str.charAt(number));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(stringBuilder.toString()+&quot; &quot;+hashcode(stringBuilder.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int hashcode(String s)&#123;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            sum&#x3D;sum+s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        sum*&#x3D;23;</span><br><span class="line">        return sum&gt;1999?sum%2000:sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-练习-自定义MyHashMap"><a class="header-anchor" href="#步骤-7-练习-自定义MyHashMap">¶</a>步骤 7 : 练习-自定义MyHashMap</h3>
<p>根据前面学习的hashcode的原理和自定义hashcode, 设计一个MyHashMap，实现接口IHashMap</p>
<p>MyHashMap内部由一个长度是2000的对象数组实现。</p>
<p><strong>设计put(String key,Object value)方法</strong><br>
首先通过上一个[自定义字符串的hashcode练习]获取到该字符串的hashcode,然后把这个hashcode作为下标，定位到数组的指定位置。<br>
如果该位置没有数据，则把字符串和对象组合成<strong>键值对</strong>Entry，再创建一个LinkedList，把键值对，放进LinkedList中，最后把LinkedList 保存在这个位置。<br>
如果该位置有数据，一定是一个LinkedList,则把字符串和对象组合成<strong>键值对</strong>Entry，插入到LinkedList后面。</p>
<p><strong>设计 Object get(String key) 方法</strong><br>
首先通过上一个[自定义字符串的hashcode练习]获取到该字符串的hashcode,然后把这个hashcode作为下标，定位到数组的指定位置。<br>
如果这个位置没有数据，则返回空<br>
如果这个位置有数据，则挨个比较其中<strong>键值对</strong>的键-字符串，是否equals，找到匹配的，把键值对的值，返回出去。找不到匹配的，就返回空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">public interface IHashMap &#123;</span><br><span class="line">    public void put(String key,Object object);</span><br><span class="line">    public Object get(String key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;键值对</span><br><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;键值对</span><br><span class="line">public class Entry &#123;</span><br><span class="line"> </span><br><span class="line">    public Entry(Object key, Object value) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object key;</span><br><span class="line">    public Object value;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;[key&#x3D;&quot; + key + &quot;, value&#x3D;&quot; + value + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class MyHashMap implements IHashMap&#123;</span><br><span class="line">    public Object[] objects&#x3D;new Object[2000];</span><br><span class="line">    @Override</span><br><span class="line">    public void put(String key, Object object) &#123;</span><br><span class="line">        int hashcode&#x3D;TestHashSet.hashcode(key);</span><br><span class="line">        if (objects[hashcode]&#x3D;&#x3D;null)&#123;</span><br><span class="line">            Entry entry&#x3D;new Entry(key,object);</span><br><span class="line">            LinkedList&lt;Entry&gt; list&#x3D;new LinkedList&lt;Entry&gt;();</span><br><span class="line">            list.add(entry);</span><br><span class="line">            objects[hashcode]&#x3D;list;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Entry entry&#x3D;new Entry(key,object);</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">			LinkedList&lt;Entry&gt; list&#x3D;(LinkedList&lt;Entry&gt;)objects[hashcode];</span><br><span class="line">            list.addLast(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Object get(String key) &#123;</span><br><span class="line">        int hashcode&#x3D;TestHashSet.hashcode(key);</span><br><span class="line">        if (objects[hashcode]!&#x3D;null)&#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">			LinkedList&lt;Entry&gt; list&#x3D;(LinkedList&lt;Entry&gt;)objects[hashcode];</span><br><span class="line">            for (Entry entry :</span><br><span class="line">                    list) &#123;</span><br><span class="line">                if (key.equals(entry.key))&#123;</span><br><span class="line">                    return entry.value;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyHashMap myHashMap&#x3D;new MyHashMap();</span><br><span class="line">        myHashMap.put(&quot;土拨鼠&quot;,12345);</span><br><span class="line">        &#x2F;*System.out.println(TestHashSet.hashcode(&quot;zhuzhu&quot;));</span><br><span class="line">        System.out.println(myHashMap.objects[1778]);*&#x2F;</span><br><span class="line">        System.out.println(myHashMap.get(&quot;土拨鼠&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-8-练习-内容查找性能比较"><a class="header-anchor" href="#步骤-8-练习-内容查找性能比较">¶</a>步骤 8 : 练习-内容查找性能比较</h3>
<p>重复前面的 [练习-查找内容性能比较]，不过不使用HashMap,而是使用上个练习中自定义的MyHashMap.</p>
<p>准备一个ArrayList其中存放100000(十万个)Hero对象，其名称是随机的,格式是hero-[4位随机数]<br>
hero-3229<br>
hero-6232<br>
hero-9365<br>
…</p>
<p>因为总数很大，所以几乎每种都有重复，把名字叫做 hero-5555的所有对象找出来<br>
要求使用两种办法来寻找</p>
<ol>
<li>
<p>不使用MyHashMap，直接使用for循环找出来，并统计花费的时间</p>
</li>
<li>
<p>借助MyHashMap，找出结果，并统计花费的时间</p>
</li>
</ol>
<h2 id="17、其他-JAVA-COMPARATOR和COMPARABLE-比较器"><a class="header-anchor" href="#17、其他-JAVA-COMPARATOR和COMPARABLE-比较器">¶</a>17、其他 - JAVA COMPARATOR和COMPARABLE 比较器</h2>
<h3 id="步骤-1-Comparator"><a class="header-anchor" href="#步骤-1-Comparator">¶</a>步骤 1 : Comparator</h3>
<p>假设Hero有三个属性 name,hp,damage<br>
一个集合中放存放10个Hero,通过Collections.sort对这10个进行排序<br>
那么<strong>到底是hp小的放前面？还是damage小的放前面？<strong>Collections.sort也无法确定<br>
所以要指定到底按照哪种属性进行排序<br>
这里就需要提供一个Comparator给定如何进行两个对象之间的</strong>大小</strong>比较</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/828.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero  &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">  </span><br><span class="line">    public int damage;</span><br><span class="line">  </span><br><span class="line">    public Hero() &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public Hero(String name) &#123;</span><br><span class="line"> </span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hero [name&#x3D;&quot; + name + &quot;, hp&#x3D;&quot; + hp + &quot;, damage&#x3D;&quot; + damage + &quot;]\r\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Hero(String name, int hp, int damage) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">        this.damage &#x3D; damage;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">     </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">    </span><br><span class="line">import charactor.Hero;</span><br><span class="line">     </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D;new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">            </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;通过随机值实例化hero的hp和damage</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot;+ i, r.nextInt(100), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F;直接调用sort会出现编译错误，因为Hero有各种属性</span><br><span class="line">        &#x2F;&#x2F;到底按照哪种属性进行比较，Collections也不知道，不确定，所以没法排</span><br><span class="line">        &#x2F;&#x2F;Collections.sort(heros);</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F;引入Comparator，指定比较的算法</span><br><span class="line">        Comparator&lt;Hero&gt; c &#x3D; new Comparator&lt;Hero&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Hero h1, Hero h2) &#123;</span><br><span class="line">                &#x2F;&#x2F;按照hp进行排序</span><br><span class="line">                if(h1.hp&gt;&#x3D;h2.hp)</span><br><span class="line">                    return 1;  &#x2F;&#x2F;正数表示h1比h2要大</span><br><span class="line">                else</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Collections.sort(heros,c);</span><br><span class="line">        System.out.println(&quot;按照血量排序后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-Comparable"><a class="header-anchor" href="#步骤-2-Comparable">¶</a>步骤 2 : Comparable</h3>
<p>使Hero类实现Comparable接口<br>
在类里面提供比较算法<br>
Collections.sort就有足够的信息进行排序了，也无需额外提供比较器Comparator<br>
<strong>注：</strong> 如果返回-1, 就表示当前的更小，否则就是更大</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/829.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">    </span><br><span class="line">public class Hero implements Comparable&lt;Hero&gt;&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">       </span><br><span class="line">    public int damage;</span><br><span class="line">       </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public Hero(String name) &#123;</span><br><span class="line">        this.name &#x3D;name;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;初始化name,hp,damage的构造方法</span><br><span class="line">    public Hero(String name,float hp, int damage) &#123;</span><br><span class="line">        this.name &#x3D;name;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">        this.damage &#x3D; damage;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Hero anotherHero) &#123;</span><br><span class="line">        if(damage&lt;anotherHero.damage)</span><br><span class="line">            return 1; </span><br><span class="line">        else</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hero [name&#x3D;&quot; + name + &quot;, hp&#x3D;&quot; + hp + &quot;, damage&#x3D;&quot; + damage + &quot;]\r\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D;new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">          </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;通过随机值实例化hero的hp和damage</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot;+ i, r.nextInt(100), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;初始化后的集合&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;Hero类实现了接口Comparable，即自带比较信息。</span><br><span class="line">        &#x2F;&#x2F;Collections直接进行排序，无需额外的Comparator</span><br><span class="line">        Collections.sort(heros);</span><br><span class="line">        System.out.println(&quot;按照伤害高低排序后的集合&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-自定义顺序的TreeSet"><a class="header-anchor" href="#步骤-3-练习-自定义顺序的TreeSet">¶</a>步骤 3 : 练习-自定义顺序的TreeSet</h3>
<p>默认情况下，TreeSet中的数据是从小到大排序的，不过TreeSet的构造方法支持传入一个Comparator</p>
<p>public TreeSet(Comparator comparator)</p>
<p>通过这个构造方法创建一个TreeSet，使得其中的的数字是倒排序的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        Comparator&lt;Integer&gt;C&#x3D;new Comparator&lt;Integer&gt;()&#123;</span><br><span class="line"> </span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">                if(o1&lt;&#x3D;o2)</span><br><span class="line">                    return 1;</span><br><span class="line">                else</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;;</span><br><span class="line">        TreeSet&lt;Integer&gt;t&#x3D;new TreeSet&lt;Integer&gt;(C);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            t.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-Comparable"><a class="header-anchor" href="#步骤-4-练习-Comparable">¶</a>步骤 4 : 练习-Comparable</h3>
<p>借助Comparable接口，使Item具备按照价格从高到低排序。<br>
初始化10个Item,并且用Collections.sort进行排序，查看排序结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero implements Comparable&lt;Hero&gt; &#123;</span><br><span class="line">    public  String Name;</span><br><span class="line">    public int hp;</span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Hero(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        Name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Hero(String name, int hp) &#123;</span><br><span class="line">        super();</span><br><span class="line">        Name &#x3D; name;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return Name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        Name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getHp() &#123;</span><br><span class="line">        return hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setHp(int hp) &#123;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Hero o) &#123;</span><br><span class="line">        &#x2F;&#x2F; 以血量进行排序</span><br><span class="line">        int sum &#x3D; this.hp - o.hp;</span><br><span class="line">&#x2F;&#x2F;      </span><br><span class="line">        &#x2F;&#x2F; 当hp相同时，按照名字排序</span><br><span class="line">        int sum2 &#x3D; sum &#x3D;&#x3D; 0 ? o.Name.compareTo(this.Name) : sum;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hero [hp&#x3D;&quot; + hp + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Hero&gt; ts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">			Hero hero &#x3D; new Hero();</span><br><span class="line">			hero.Name&#x3D; &quot;Hero&quot;+i;</span><br><span class="line">			hero.hp&#x3D; (int) (Math.random()*100);</span><br><span class="line">			ts.add(hero);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;初始化后的Hero：&quot;);</span><br><span class="line">		for (Hero hero : ts) &#123;</span><br><span class="line">			System.out.println(hero.getName() + &quot; &quot; + hero.getHp());</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot; ----------&quot;);</span><br><span class="line">		Collections.sort(ts);</span><br><span class="line">		System.out.println(&quot;排序之后的Hero&quot;);</span><br><span class="line">		for (Hero hero : ts) &#123;</span><br><span class="line">			System.out.println(hero.getName() + &quot; &quot; + hero.getHp());</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化后的Hero：</span><br><span class="line">Hero0 25</span><br><span class="line">Hero1 40</span><br><span class="line">Hero2 94</span><br><span class="line">Hero3 14</span><br><span class="line">Hero4 33</span><br><span class="line">Hero5 75</span><br><span class="line">Hero6 31</span><br><span class="line">Hero7 37</span><br><span class="line">Hero8 89</span><br><span class="line">Hero9 90</span><br><span class="line"> ----------</span><br><span class="line">排序之后的Hero</span><br><span class="line">Hero3 14</span><br><span class="line">Hero0 25</span><br><span class="line">Hero6 31</span><br><span class="line">Hero4 33</span><br><span class="line">Hero7 37</span><br><span class="line">Hero1 40</span><br><span class="line">Hero5 75</span><br><span class="line">Hero8 89</span><br><span class="line">Hero9 90</span><br><span class="line">Hero2 94</span><br></pre></td></tr></table></figure>
<h2 id="18、其他-聚合操作"><a class="header-anchor" href="#18、其他-聚合操作">¶</a>18、其他 - 聚合操作</h2>
<h3 id="步骤-1-聚合操作"><a class="header-anchor" href="#步骤-1-聚合操作">¶</a>步骤 1 : 聚合操作</h3>
<p>JDK8之后，引入了对集合的聚合操作，可以非常容易的遍历，筛选，比较集合中的元素。</p>
<p>像这样：</p>
<p>​        String name =heros</p>
<p>​            .stream()</p>
<p>​            .sorted((h1,h2)-&gt;h1.hp&gt;h2.hp?-1:1)</p>
<p>​            .skip(2)</p>
<p>​            .map(h-&gt;h.getName())</p>
<p>​            .findFirst()</p>
<p>​            .get();</p>
<p>但是要用好聚合，必须先掌握[Lambda表达式]，聚合的章节讲放在[Lambda与聚合操作]部分详细讲解</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2564.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestAggregate &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;初始化集合后的数据 (最后一个数据重复)：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;传统方式</span><br><span class="line">        Collections.sort(heros,new Comparator&lt;Hero&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Hero o1, Hero o2) &#123;</span><br><span class="line">                return (int) (o2.hp-o1.hp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        Hero hero &#x3D; heros.get(2);</span><br><span class="line">        System.out.println(&quot;通过传统方式找出来的hp第三高的英雄名称是:&quot; + hero.name);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;聚合方式</span><br><span class="line">        String name &#x3D;heros</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted((h1,h2)-&gt;h1.hp&gt;h2.hp?-1:1)</span><br><span class="line">            .skip(2)</span><br><span class="line">            .map(h-&gt;h.getName())</span><br><span class="line">            .findFirst()</span><br><span class="line">            .get();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;通过聚合操作找出来的hp第三高的英雄名称是:&quot; + name);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero implements Comparable&lt;Hero&gt; &#123;</span><br><span class="line">    public  String Name;</span><br><span class="line">    public int hp;</span><br><span class="line">    public int damage;</span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Hero(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        Name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Hero(String name, int hp) &#123;</span><br><span class="line">        super();</span><br><span class="line">        Name &#x3D; name;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Hero(String i, int hp, int damage) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">    	this.Name &#x3D; i;</span><br><span class="line">    	this.hp &#x3D; hp;</span><br><span class="line">    	this.damage &#x3D; damage;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">        return Name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        Name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getHp() &#123;</span><br><span class="line">        return hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setHp(int hp) &#123;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Hero o) &#123;</span><br><span class="line">        &#x2F;&#x2F; 以血量进行排序</span><br><span class="line">        int sum &#x3D; this.hp - o.hp;</span><br><span class="line">&#x2F;&#x2F;      </span><br><span class="line">        &#x2F;&#x2F; 当hp相同时，按照名字排序</span><br><span class="line">        int sum2 &#x3D; sum &#x3D;&#x3D; 0 ? o.Name.compareTo(this.Name) : sum;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hero [name&#x3D;&quot; + Name + &quot;,&quot; + &quot; hp&#x3D;&quot; + hp + &quot; damage&#x3D;&quot; + damage + &quot;]\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、泛型"><a class="header-anchor" href="#四、泛型">¶</a>四、泛型</h1>
<h2 id="1、JAVA-什么是-泛型？"><a class="header-anchor" href="#1、JAVA-什么是-泛型？">¶</a>1、JAVA 什么是 泛型？</h2>
<h3 id="示例-1-不使用泛型"><a class="header-anchor" href="#示例-1-不使用泛型">¶</a>示例 1 : 不使用泛型</h3>
<p>不使用泛型带来的问题<br>
ADHero（物理攻击英雄） APHero（魔法攻击英雄）都是Hero的子类<br>
ArrayList 默认接受Object类型的对象，所以所有对象都可以放进ArrayList中<br>
所以get(0) <strong>返回的类型是Object</strong><br>
接着，需要进行强制转换才可以得到APHero类型或者ADHero类型。<br>
如果软件开发人员记忆比较好，能<strong>记得哪个是哪个</strong>，还是可以的。 但是开发人员会犯错误，比如第20行，会记错，把第0个对象转换为ADHero,这样就会出现类型转换异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.APHero;</span><br><span class="line"> </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        ArrayList heros &#x3D; new ArrayList();</span><br><span class="line">         </span><br><span class="line">        heros.add(new APHero());</span><br><span class="line">        heros.add(new ADHero());</span><br><span class="line">         </span><br><span class="line">        APHero apHero &#x3D;  (APHero) heros.get(0);</span><br><span class="line">        ADHero adHero &#x3D;  (ADHero) heros.get(1);</span><br><span class="line">         </span><br><span class="line">        ADHero adHero2 &#x3D;  (ADHero) heros.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-使用泛型"><a class="header-anchor" href="#示例-2-使用泛型">¶</a>示例 2 : 使用泛型</h3>
<p>使用泛型的好处：<br>
泛型的用法是在容器后面添加<Type><br>
Type可以是类，抽象类，接口<br>
泛型表示这种容器，<strong>只能存放APHero</strong>，ADHero就放不进去了。</Type></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.APHero;</span><br><span class="line"> </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;APHero&gt; heros &#x3D; new ArrayList&lt;APHero&gt;();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;只有APHero可以放进去    </span><br><span class="line">        heros.add(new APHero());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;ADHero甚至放不进去</span><br><span class="line">        &#x2F;&#x2F;heros.add(new ADHero());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;获取的时候也不需要进行转型，因为取出来一定是APHero</span><br><span class="line">        APHero apHero &#x3D;  heros.get(0);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-子类对象"><a class="header-anchor" href="#示例-3-子类对象">¶</a>示例 3 : 子类对象</h3>
<p>假设容器的泛型是Hero,那么<strong>Hero的子类</strong>APHero,ADHero<strong>都可以放进去</strong><br>
和Hero无关的类型Item还是放不进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line"> </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.APHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;只有作为Hero的子类可以放进去     </span><br><span class="line">        heros.add(new APHero());</span><br><span class="line">        heros.add(new ADHero());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;和Hero无关的类型Item还是放不进去</span><br><span class="line">        &#x2F;&#x2F;heros.add(new Item());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-泛型的简写"><a class="header-anchor" href="#示例-4-泛型的简写">¶</a>示例 4 : 泛型的简写</h3>
<p>为了不使编译器出现警告，需要前后都使用泛型，像这样：</p>
<p>ArrayList<Hero> heros = new ArrayList<Hero>();</Hero></Hero></p>
<p>不过JDK7提供了一个可以略微减少代码量的泛型简写方式</p>
<p>ArrayList<Hero> heros2 = new ArrayList&lt;&gt;();</Hero></p>
<p>后面的泛型可以用&lt;&gt;来代替，聊胜于无吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        &#x2F;&#x2F;后面可以只用&lt;&gt;</span><br><span class="line">        ArrayList&lt;Hero&gt; heros2 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-练习-泛型"><a class="header-anchor" href="#示例-5-练习-泛型">¶</a>示例 5 : 练习-泛型</h3>
<p>根据[数字类]的知识，设计一个集合，这个集合里即可以放整数，也可以放浮点数，但是不能放字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;泛型使用Number</span><br><span class="line">		ArrayList&lt;Number&gt; aList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		&#x2F;&#x2F;可以放入子类类型</span><br><span class="line">		aList.add(1);</span><br><span class="line">		aList.add(1f);</span><br><span class="line">		aList.add(1d);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;非子类报错</span><br><span class="line">		&#x2F;&#x2F;aList.add(&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA-如何设计支持泛型的类"><a class="header-anchor" href="#2、JAVA-如何设计支持泛型的类">¶</a>2、JAVA 如何设计支持泛型的类</h2>
<h3 id="步骤-1-不支持泛型的Stack"><a class="header-anchor" href="#步骤-1-不支持泛型的Stack">¶</a>步骤 1 : 不支持泛型的Stack</h3>
<p>以[Stack栈]为例子，如果不使用泛型<br>
当需要一个只能放Hero的栈的时候，就需要设计一个HeroStack<br>
当需要一个只能放Item的栈的时候，就需要一个ItemStack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line">   </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class HeroStack &#123;</span><br><span class="line">   </span><br><span class="line">    LinkedList&lt;Hero&gt; heros &#x3D; new LinkedList&lt;Hero&gt;();</span><br><span class="line">       </span><br><span class="line">    public void push(Hero h) &#123;</span><br><span class="line">        heros.addLast(h);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public Hero pull() &#123;</span><br><span class="line">        return heros.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public Hero peek() &#123;</span><br><span class="line">        return heros.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           </span><br><span class="line">        HeroStack heroStack &#x3D; new HeroStack();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Hero h &#x3D; new Hero(&quot;hero name &quot; + i);</span><br><span class="line">            System.out.println(&quot;压入 hero:&quot; + h);</span><br><span class="line">            heroStack.push(h);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Hero h &#x3D;heroStack.pull();</span><br><span class="line">            System.out.println(&quot;弹出 hero&quot; + h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line">   </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line">   </span><br><span class="line">public class ItemStack &#123;</span><br><span class="line">   </span><br><span class="line">    LinkedList&lt;Item&gt; Items &#x3D; new LinkedList&lt;Item&gt;();</span><br><span class="line">       </span><br><span class="line">    public void push(Item h) &#123;</span><br><span class="line">        Items.addLast(h);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public Item pull() &#123;</span><br><span class="line">        return Items.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public Item peek() &#123;</span><br><span class="line">        return Items.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           </span><br><span class="line">        ItemStack ItemStack &#x3D; new ItemStack();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Item item &#x3D; new Item(&quot;Item name &quot; + i);</span><br><span class="line">            System.out.println(&quot;压入 Item:&quot; + item);</span><br><span class="line">            ItemStack.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Item item &#x3D;ItemStack.pull();</span><br><span class="line">            System.out.println(&quot;弹出 Item&quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-支持泛型的Stack"><a class="header-anchor" href="#步骤-2-支持泛型的Stack">¶</a>步骤 2 : 支持泛型的Stack</h3>
<p>设计一个支持泛型的栈MyStack<br>
设计这个类的时候，在类的声明上，加上一个<T>，表示该类支持泛型。<br>
T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。</T></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line">   </span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">import property.Item;</span><br><span class="line">   </span><br><span class="line">public class MyStack&lt;T&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    LinkedList&lt;T&gt; values &#x3D; new LinkedList&lt;T&gt;();</span><br><span class="line">       </span><br><span class="line">    public void push(T t) &#123;</span><br><span class="line">        values.addLast(t);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public T pull() &#123;</span><br><span class="line">        return values.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public T peek() &#123;</span><br><span class="line">        return values.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;在声明这个Stack的时候，使用泛型&lt;Hero&gt;就表示该Stack只能放Hero</span><br><span class="line">        MyStack&lt;Hero&gt; heroStack &#x3D; new MyStack&lt;&gt;();</span><br><span class="line">        heroStack.push(new Hero());</span><br><span class="line">        &#x2F;&#x2F;不能放Item</span><br><span class="line">        heroStack.push(new Item());</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;在声明这个Stack的时候，使用泛型&lt;Item&gt;就表示该Stack只能放Item</span><br><span class="line">        MyStack&lt;Item&gt; itemStack &#x3D; new MyStack&lt;&gt;();</span><br><span class="line">        itemStack.push(new Item());</span><br><span class="line">        &#x2F;&#x2F;不能放Hero</span><br><span class="line">        itemStack.push(new Hero());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-支持泛型的二叉树"><a class="header-anchor" href="#步骤-3-练习-支持泛型的二叉树">¶</a>步骤 3 : 练习-支持泛型的二叉树</h3>
<p>把[二叉树]中的Node类，改造成支持泛型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">import charactor.Hero;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class Node&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line">	public Node&lt;T&gt; left;</span><br><span class="line">	public Node&lt;T&gt; right;</span><br><span class="line">	public T value;</span><br><span class="line"></span><br><span class="line">	public void add(T e) &#123;</span><br><span class="line">		if (null &#x3D;&#x3D; value) &#123;</span><br><span class="line">			value &#x3D; e;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (e.compareTo(value) &lt;&#x3D; 0) &#123;</span><br><span class="line">				if (null &#x3D;&#x3D; left) left &#x3D; new Node&lt;&gt;();</span><br><span class="line">				left.add(e);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				if (null &#x3D;&#x3D; right) right &#x3D; new Node&lt;&gt;();</span><br><span class="line">				right.add(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public List&lt;T&gt; values() &#123;</span><br><span class="line">		List&lt;T&gt; values &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		if (null !&#x3D; left) &#123;</span><br><span class="line">			values.addAll(left.values());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		values.add(value);</span><br><span class="line"></span><br><span class="line">		if (null !&#x3D; right) &#123;</span><br><span class="line">			values.addAll(right.values());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return values;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Node&lt;Integer&gt; is &#x3D; new Node&lt;&gt;();</span><br><span class="line">		is.add(3);</span><br><span class="line">		is.add(5);</span><br><span class="line">		is.add(1);</span><br><span class="line">		is.add(4);</span><br><span class="line">		is.add(2);</span><br><span class="line"></span><br><span class="line">		System.out.println(is.values());</span><br><span class="line"></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">		System.out.println();</span><br><span class="line"></span><br><span class="line">		Random r &#x3D; new Random();</span><br><span class="line">		Node&lt;Hero&gt; hs &#x3D; new Node&lt;&gt;();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">			hs.add(new Hero(&quot;hero&quot;+i, r.nextInt(100)));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(hs.values());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA-泛型通配符-EXTENDS-SUPER-的用法"><a class="header-anchor" href="#3、JAVA-泛型通配符-EXTENDS-SUPER-的用法">¶</a>3、JAVA 泛型通配符 ? EXTENDS SUPER 的用法</h2>
<h3 id="示例-1-extends"><a class="header-anchor" href="#示例-1-extends">¶</a>示例 1 : ? extends</h3>
<p>ArrayList heroList&lt;? extends Hero&gt; 表示这是一个Hero泛型或者其子类泛型<br>
heroList 的泛型可能是Hero<br>
heroList 的泛型可能是APHero<br>
heroList 的泛型可能是ADHero<br>
所以 可以确凿的是，<strong>从heroList取出来的对象，一定是可以转型成Hero的</strong></p>
<p>但是，不能往里面放东西，因为<br>
放APHero就不满足<ADHero><br>
放ADHero又不满足<APHero></APHero></ADHero></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/837.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">  </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.APHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList &#x3D; new ArrayList&lt;APHero&gt;();</span><br><span class="line">        apHeroList.add(new APHero());</span><br><span class="line">         </span><br><span class="line">        ArrayList&lt;? extends Hero&gt; heroList &#x3D; apHeroList;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;? extends Hero 表示这是一个Hero泛型的子类泛型</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;heroList 的泛型可以是Hero</span><br><span class="line">        &#x2F;&#x2F;heroList 的泛型可以使APHero</span><br><span class="line">        &#x2F;&#x2F;heroList 的泛型可以使ADHero</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的</span><br><span class="line">          </span><br><span class="line">        Hero h&#x3D; heroList.get(0);</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;但是，不能往里面放东西</span><br><span class="line">        heroList.add(new ADHero()); &#x2F;&#x2F;编译错误，因为heroList的泛型 有可能是APHero</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-super"><a class="header-anchor" href="#示例-2-super">¶</a>示例 2 : ? super</h3>
<p>ArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型<br>
heroList的泛型可能是Hero<br>
heroList的泛型可能是Object</p>
<p><strong>可以往里面插入Hero以及Hero的子类</strong><br>
但是取出来有风险，因为不确定取出来是Hero还是Object</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/838.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">  </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.APHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;? super Hero&gt; heroList &#x3D; new ArrayList&lt;Object&gt;();</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;? super Hero 表示 heroList的泛型是Hero或者其父类泛型</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;heroList 的泛型可以是Hero</span><br><span class="line">        &#x2F;&#x2F;heroList 的泛型可以是Object</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;所以就可以插入Hero</span><br><span class="line">        heroList.add(new Hero());</span><br><span class="line">        &#x2F;&#x2F;也可以插入Hero的子类</span><br><span class="line">        heroList.add(new APHero());</span><br><span class="line">        heroList.add(new ADHero());</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败</span><br><span class="line">        Hero h&#x3D; heroList.get(0);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-泛型通配符"><a class="header-anchor" href="#示例-3-泛型通配符">¶</a>示例 3 : 泛型通配符?</h3>
<p>泛型通配符? 代表任意泛型<br>
既然?代表任意泛型，那么换句话说，这个容器什么泛型都有可能</p>
<p>所以只能以Object的形式取出来<br>
并且不能往里面放对象，因为不知道到底是一个什么泛型的容器</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/836.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line">import charactor.APHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList &#x3D; new ArrayList&lt;APHero&gt;();</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;?泛型通配符，表示任意泛型</span><br><span class="line">        ArrayList&lt;?&gt; generalList &#x3D; apHeroList;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型</span><br><span class="line">        &#x2F;&#x2F;所以只能以Object的形式取出来</span><br><span class="line">        Object o &#x3D; generalList.get(0);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item</span><br><span class="line">        &#x2F;&#x2F;所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去</span><br><span class="line">        generalList.add(new Item()); &#x2F;&#x2F;编译错误 因为?代表任意泛型，很有可能不是Item</span><br><span class="line">        generalList.add(new Hero()); &#x2F;&#x2F;编译错误 因为?代表任意泛型，很有可能不是Hero</span><br><span class="line">        generalList.add(new APHero()); &#x2F;&#x2F;编译错误  因为?代表任意泛型，很有可能不是APHero</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-总结"><a class="header-anchor" href="#示例-4-总结">¶</a>示例 4 : 总结</h3>
<p>如果希望只取出，不插入，就使用? extends Hero<br>
如果希望只插入，不取出，就使用? super Hero<br>
如果希望，又能插入，又能取出，就不要用通配符？</p>
<h3 id="示例-5-练习-extends"><a class="header-anchor" href="#示例-5-练习-extends">¶</a>示例 5 : 练习- extends</h3>
<p>如代码所示，为了遍历不同泛型的3种集合，需要设计3个方法</p>
<p>借助? extends， 把代码减肥到只是用一种方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.APHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line"> </span><br><span class="line">    public static void iterate(ArrayList&lt;Hero&gt; list) &#123;</span><br><span class="line">        for (Hero hero : list) &#123;</span><br><span class="line">            System.out.println(hero.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void iterateAP(ArrayList&lt;APHero&gt; list) &#123;</span><br><span class="line">        for (Hero hero : list) &#123;</span><br><span class="line">            System.out.println(hero.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void iterateAD(ArrayList&lt;ADHero&gt; list) &#123;</span><br><span class="line">        for (Hero hero : list) &#123;</span><br><span class="line">            System.out.println(hero.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;APHero&gt; aphs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        iterate(hs);</span><br><span class="line">        iterateAP(aphs);</span><br><span class="line">        iterateAD(adhs);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.APHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line"> </span><br><span class="line">    public static void iterate(ArrayList&lt;? extends Hero&gt; list) &#123;</span><br><span class="line">        for (Hero hero : list) &#123;</span><br><span class="line">            System.out.println(hero.Name);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;APHero&gt; aphs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        iterate(hs);</span><br><span class="line">        iterateAP(aphs);</span><br><span class="line">        iterateAD(adhs);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-练习-二叉树"><a class="header-anchor" href="#示例-6-练习-二叉树">¶</a>示例 6 : 练习-二叉树</h3>
<p>把[练习-支持泛型的二叉树]改造成 支持泛型 <T extends comparable>，并在比较的时候使用compare方法</T></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">  </span><br><span class="line">import charactor.GiantDragon;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class Nodes&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line">  </span><br><span class="line">    public Node&lt;T&gt; leftNode;</span><br><span class="line">  </span><br><span class="line">    public Node&lt;T&gt; rightNode;</span><br><span class="line">  </span><br><span class="line">    public T value;</span><br><span class="line">  </span><br><span class="line">    public void add(T t) &#123;</span><br><span class="line">  </span><br><span class="line">        if (null &#x3D;&#x3D; value)</span><br><span class="line">            value &#x3D; t;</span><br><span class="line">  </span><br><span class="line">        else &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;t和value都是T 类型，而T类型extends Comparable，所以必然提供compare接口</span><br><span class="line">            if (t.compareTo(value) &lt;&#x3D; 0) &#123;</span><br><span class="line">                if (null &#x3D;&#x3D; leftNode)</span><br><span class="line">                    leftNode &#x3D; new Node&lt;T&gt;();</span><br><span class="line">                leftNode.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            else &#123;</span><br><span class="line">                if (null &#x3D;&#x3D; rightNode)</span><br><span class="line">                    rightNode &#x3D; new Node&lt;T&gt;();</span><br><span class="line">                rightNode.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public List&lt;T&gt; values() &#123;</span><br><span class="line">        List&lt;T&gt; values &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">        if (null !&#x3D; leftNode)</span><br><span class="line">            values.addAll(leftNode.values());</span><br><span class="line">  </span><br><span class="line">        values.add(value);</span><br><span class="line">  </span><br><span class="line">        if (null !&#x3D; rightNode)</span><br><span class="line">  </span><br><span class="line">            values.addAll(rightNode.values());</span><br><span class="line">  </span><br><span class="line">        return values;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        int randoms[] &#x3D; new int[] &#123; 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 &#125;;</span><br><span class="line">  </span><br><span class="line">        Node&lt;Integer&gt; roots &#x3D; new Node&lt;&gt;();</span><br><span class="line">        for (int number : randoms) &#123;</span><br><span class="line">            roots.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        System.out.println(roots.values());</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;Hero实现了 Comparable接口，所以可以作为Node的泛型</span><br><span class="line">        Node&lt;Hero&gt; heros &#x3D; new Node&lt;&gt;();</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;GiantDragon 没有实现 Comparable接口，所以不能作为Node的泛型</span><br><span class="line">        Node&lt;GiantDragon&gt; dragons &#x3D; new Node&lt;&gt;();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、JAVA-中的子类泛型-转型-成父类泛型"><a class="header-anchor" href="#4、JAVA-中的子类泛型-转型-成父类泛型">¶</a>4、JAVA 中的子类泛型 转型 成父类泛型</h2>
<h3 id="步骤-1-对象转型"><a class="header-anchor" href="#步骤-1-对象转型">¶</a>步骤 1 : 对象转型</h3>
<p>根据面向对象学习的知识，[子类转父类]是一定可以成功的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"> </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Hero h &#x3D; new Hero();</span><br><span class="line">        ADHero ad &#x3D; new ADHero();</span><br><span class="line">        &#x2F;&#x2F;子类转父类</span><br><span class="line">        h &#x3D; ad;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-子类泛型转父类泛型"><a class="header-anchor" href="#步骤-2-子类泛型转父类泛型">¶</a>步骤 2 : 子类泛型转父类泛型</h3>
<p>既然 子类对象 转 父类对象是可以成功的，那么子类泛型转父类泛型能成功吗？<br>
如代码<br>
hs的泛型是父类Hero<br>
adhs 的泛型是子类ADHero</p>
<p>那么 把adhs转换为hs能成功吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs &#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs &#x3D;new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;子类泛型转父类泛型</span><br><span class="line">        hs &#x3D; adhs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;&#x2F;&#x2F;不能</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-假设可以转型成功"><a class="header-anchor" href="#步骤-3-假设可以转型成功">¶</a>步骤 3 : 假设可以转型成功</h3>
<p>假设可以转型成功<br>
引用hs指向了ADHero泛型的容器<br>
作为Hero泛型的引用hs, 看上去是可以往里面加一个APHero的。<br>
但是hs这个引用，实际上是指向的一个ADHero泛型的容器<br>
如果能加进去，就变成了ADHero泛型的容器里放进了APHero，这就矛盾了</p>
<p>所以子类泛型<strong>不可以</strong>转换为父类泛型</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/835.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.APHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs &#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs &#x3D;new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;假设能转换成功</span><br><span class="line">        hs &#x3D; adhs;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;作为Hero泛型的hs,是可以向其中加入APHero的</span><br><span class="line">        &#x2F;&#x2F;但是hs这个引用，实际上是指向的一个ADHero泛型的容器</span><br><span class="line">        &#x2F;&#x2F;如果能加进去，就变成了ADHero泛型的容器里放进了APHero，这就矛盾了</span><br><span class="line">        hs.add(new APHero());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-父类泛型能否转换为子类泛型？"><a class="header-anchor" href="#步骤-4-练习-父类泛型能否转换为子类泛型？">¶</a>步骤 4 : 练习-父类泛型能否转换为子类泛型？</h3>
<p>上面使用反证法分析了，子类泛型不能转换为父类泛型。</p>
<p>那么父类泛型又能否转换成子类泛型？ 为什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">  </span><br><span class="line">import charactor.ADHero;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs &#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs &#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;父类泛型转子类泛型，能否成功？为什么？</span><br><span class="line">        adhs &#x3D; hs;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;&#x2F;&#x2F;不能</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt;hs&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;APHero&gt;aphs&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;父类指向子类是不行的，一旦指向子类以后，hs就不能添加ADHero了</span><br><span class="line">&#x2F;&#x2F;      hs&#x3D;aphs; </span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;子类指向父类也不行，一旦指向父类以后，aphs也能添加ADHero了</span><br><span class="line">&#x2F;&#x2F;      aphs&#x3D;hs;</span><br><span class="line">&#x2F;&#x2F;      aphs.add(new ADHero());</span><br></pre></td></tr></table></figure>
<h1 id="五、Lambda"><a class="header-anchor" href="#五、Lambda">¶</a>五、Lambda</h1>
<h2 id="1、JAVA-LAMBDA-表达式教程"><a class="header-anchor" href="#1、JAVA-LAMBDA-表达式教程">¶</a>1、JAVA LAMBDA 表达式教程</h2>
<h3 id="步骤-1-普通方法"><a class="header-anchor" href="#步骤-1-普通方法">¶</a>步骤 1 : 普通方法</h3>
<p>使用一个普通方法，在for循环遍历中进行条件判断，筛选出满足条件的数据</p>
<p>hp&gt;100 &amp;&amp; damage&lt;50</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2551.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;筛选出 hp&gt;100 &amp;&amp; damange&lt;50的英雄&quot;);</span><br><span class="line">        filter(heros);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    private static void filter(List&lt;Hero&gt; heros) &#123;</span><br><span class="line">        for (Hero hero : heros) &#123;</span><br><span class="line">            if(hero.hp&gt;100 &amp;&amp; hero.damage&lt;50)</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">     </span><br><span class="line">public class Hero implements Comparable&lt;Hero&gt;&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">        </span><br><span class="line">    public int damage;</span><br><span class="line">        </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public Hero(String name) &#123;</span><br><span class="line">        this.name &#x3D;name;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F;初始化name,hp,damage的构造方法</span><br><span class="line">    public Hero(String name,float hp, int damage) &#123;</span><br><span class="line">        this.name &#x3D;name;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">        this.damage &#x3D; damage;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Hero anotherHero) &#123;</span><br><span class="line">        if(damage&lt;anotherHero.damage)</span><br><span class="line">            return 1; </span><br><span class="line">        else</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hero [name&#x3D;&quot; + name + &quot;, hp&#x3D;&quot; + hp + &quot;, damage&#x3D;&quot; + damage + &quot;]\r\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-匿名类方式"><a class="header-anchor" href="#步骤-2-匿名类方式">¶</a>步骤 2 : 匿名类方式</h3>
<p>首先准备一个接口HeroChecker，提供一个test(Hero)方法<br>
然后通过匿名类的方式，实现这个接口</p>
<p>HeroChecker checker = new HeroChecker() {</p>
<p>​	public boolean test(Hero h) {</p>
<p>​		return (h.hp&gt;100 &amp;&amp; h.damage&lt;50);</p>
<p>​	}</p>
<p>};</p>
<p>接着调用filter，传递这个checker进去进行判断，这种方式就很像通过Collections.sort在对一个Hero集合排序，需要传一个[Comparator]的匿名类对象进去一样。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2552.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">   </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;使用匿名类的方式，筛选出 hp&gt;100 &amp;&amp; damange&lt;50的英雄&quot;);</span><br><span class="line">        HeroChecker checker &#x3D; new HeroChecker() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Hero h) &#123;</span><br><span class="line">                return (h.hp&gt;100 &amp;&amp; h.damage&lt;50);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">           </span><br><span class="line">        filter(heros,checker);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    private static void filter(List&lt;Hero&gt; heros,HeroChecker checker) &#123;</span><br><span class="line">        for (Hero hero : heros) &#123;</span><br><span class="line">            if(checker.test(hero))</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-Lambda方式"><a class="header-anchor" href="#步骤-3-Lambda方式">¶</a>步骤 3 : Lambda方式</h3>
<p>使用Lambda方式筛选出数据</p>
<p>filter(heros,(h)-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50);</p>
<p>同样是调用filter方法，从上一步的传递匿名类对象，变成了传递一个Lambda表达式进去</p>
<p>h-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50</p>
<p>咋一看Lambda表达式似乎不好理解，其实很简单，下一步讲解如何从一个匿名类一点点<strong>演变成</strong>Lambda表达式</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2553.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestLamdba &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;使用Lamdba的方式，筛选出 hp&gt;100 &amp;&amp; damange&lt;50的英雄&quot;);</span><br><span class="line">        filter(heros,h-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void filter(List&lt;Hero&gt; heros,HeroChecker checker) &#123;</span><br><span class="line">        for (Hero hero : heros) &#123;</span><br><span class="line">            if(checker.test(hero))</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-设置eclipse以支持Lambda"><a class="header-anchor" href="#步骤-4-设置eclipse以支持Lambda">¶</a>步骤 4 : 设置eclipse以支持Lambda</h3>
<p>如果你的eclipse能够正常识别Lambda，那么就可以跳过这个章节了。<br>
因为Lambda是JDK8的内容，除了JDK需要使用1.8以上版本外([在JDK环境变量配置]下载的就是1.8了)，还需要在eclipse中把编译器设置为1.8才能够正常识别Lambda.</p>
<p>设置办法：<br>
菜单-&gt;Window-&gt;Preferences-&gt;Java-Compiler-&gt;Compiler compliance leve: 设置为1.8即可</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2570.png" alt></p>
<h3 id="步骤-5-从匿名类演变成Lambda表达式"><a class="header-anchor" href="#步骤-5-从匿名类演变成Lambda表达式">¶</a>步骤 5 : 从匿名类演变成Lambda表达式</h3>
<p>Lambda表达式可以看成是匿名类一点点<strong>演变过来</strong></p>
<ol>
<li>匿名类的正常写法</li>
</ol>
<p>HeroChecker c1 = new HeroChecker() {</p>
<p>​    public boolean test(Hero h) {</p>
<p>​        return (h.hp&gt;100 &amp;&amp; h.damage&lt;50);</p>
<p>​    }</p>
<p>};</p>
<ol start="2">
<li>把外面的壳子去掉<br>
只保留<strong>方法参数</strong>和<strong>方法体</strong><br>
参数和方法体之间加上符号 <strong>-&gt;</strong></li>
</ol>
<p>HeroChecker c2 = (Hero h) -&gt;{</p>
<p>​	return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</p>
<p>};</p>
<ol start="3">
<li>把return和{}去掉</li>
</ol>
<p>HeroChecker c3 = (Hero h) -&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50;</p>
<ol start="4">
<li>把 参数类型和圆括号去掉(只有一个参数的时候，才可以去掉圆括号)</li>
</ol>
<p>HeroChecker c4 = h -&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50;</p>
<ol start="5">
<li>把c4作为参数传递进去</li>
</ol>
<p>filter(heros,c4);</p>
<ol start="6">
<li>直接把表达式传递进去</li>
</ol>
<p>filter(heros, h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestLamdba &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;使用匿名类的方式，筛选出 hp&gt;100 &amp;&amp; damange&lt;50的英雄&quot;);</span><br><span class="line">        &#x2F;&#x2F; 匿名类的正常写法</span><br><span class="line">        HeroChecker c1 &#x3D; new HeroChecker() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Hero h) &#123;</span><br><span class="line">                return (h.hp &gt; 100 &amp;&amp; h.damage &lt; 50);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; 把new HeroChcekcer，方法名，方法返回类型信息去掉</span><br><span class="line">        &#x2F;&#x2F; 只保留方法参数和方法体</span><br><span class="line">        &#x2F;&#x2F; 参数和方法体之间加上符号 -&gt;</span><br><span class="line">        HeroChecker c2 &#x3D; (Hero h) -&gt; &#123;</span><br><span class="line">            return h.hp &gt; 100 &amp;&amp; h.damage &lt; 50;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 把return和&#123;&#125;去掉</span><br><span class="line">        HeroChecker c3 &#x3D; (Hero h) -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 把 参数类型和圆括号去掉</span><br><span class="line">        HeroChecker c4 &#x3D; h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 把c4作为参数传递进去</span><br><span class="line">        filter(heros, c4);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F; 直接把表达式传递进去</span><br><span class="line">        filter(heros, h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void filter(List&lt;Hero&gt; heros, HeroChecker checker) &#123;</span><br><span class="line">        for (Hero hero : heros) &#123;</span><br><span class="line">            if (checker.test(hero))</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-匿名方法"><a class="header-anchor" href="#步骤-6-匿名方法">¶</a>步骤 6 : 匿名方法</h3>
<p>与[匿名类] 概念相比较，<br>
Lambda 其实就是<strong>匿名方法</strong>，这是一种<strong>把方法作为参数</strong>进行传递的编程思想。</p>
<p>虽然代码是这么写</p>
<p>filter(heros, h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50);</p>
<p>但是，Java会在背后，悄悄的，把这些都还原成[匿名类方式]。<br>
引入Lambda表达式，会使得代码更加紧凑，而不是各种接口和匿名类到处飞。</p>
<h3 id="步骤-7-Lambda的弊端"><a class="header-anchor" href="#步骤-7-Lambda的弊端">¶</a>步骤 7 : Lambda的弊端</h3>
<p>Lambda表达式虽然带来了代码的简洁，但是也有其局限性。</p>
<ol>
<li>
<p>可读性差，与<strong>啰嗦的</strong>但是<strong>清晰的</strong>匿名类代码结构比较起来，Lambda表达式一旦变得比较长，就难以理解</p>
</li>
<li>
<p>不便于调试，很难在Lambda表达式中增加调试信息，比如日志</p>
</li>
<li>
<p>版本支持，Lambda表达式在JDK8版本中才开始支持，如果系统使用的是以前的版本，考虑系统的稳定性等原因，而不愿意升级，那么就无法使用。</p>
</li>
</ol>
<p>Lambda比较适合用在简短的业务代码中，并不适合用在复杂的系统中，会加大维护成本。</p>
<h3 id="步骤-8-练习-Comparator"><a class="header-anchor" href="#步骤-8-练习-Comparator">¶</a>步骤 8 : 练习-Comparator</h3>
<p>把[比较器-Comparator] 章节中的代码，按照[从匿名类演变成Lambda表达式]的步骤，改写为Lambda表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collections.sort(heros,(h1,h2)-&gt;h1.hp-h2.hp)</span><br></pre></td></tr></table></figure>
<h2 id="2、方法引用"><a class="header-anchor" href="#2、方法引用">¶</a>2、方法引用</h2>
<h3 id="步骤-1-引用静态方法"><a class="header-anchor" href="#步骤-1-引用静态方法">¶</a>步骤 1 : 引用静态方法</h3>
<p>首先为TestLambda添加一个静态方法：</p>
<p>public static boolean testHero(Hero h) {</p>
<p>return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</p>
<p>}</p>
<p>Lambda表达式：</p>
<p>filter(heros, h-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50);</p>
<p>在Lambda表达式中调用这个静态方法：</p>
<p>filter(heros, h -&gt; TestLambda.testHero(h) );</p>
<p>调用静态方法还可以改写为：</p>
<p>filter(heros, TestLambda::testHero);</p>
<p>这种方式就叫做<strong>引用静态方法</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2560.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">   </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">           </span><br><span class="line">        HeroChecker c &#x3D; new HeroChecker() &#123;</span><br><span class="line">            public boolean test(Hero h) &#123;</span><br><span class="line">                return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;使用匿名类过滤&quot;);</span><br><span class="line">        filter(heros, c);</span><br><span class="line">        System.out.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">        filter(heros, h-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50);</span><br><span class="line">        System.out.println(&quot;在Lambda表达式中使用静态方法&quot;);</span><br><span class="line">        filter(heros, h -&gt; TestLambda.testHero(h) );</span><br><span class="line">        System.out.println(&quot;直接引用静态方法&quot;);</span><br><span class="line">        filter(heros, TestLambda::testHero);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static boolean testHero(Hero h) &#123;</span><br><span class="line">        return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    private static void filter(List&lt;Hero&gt; heros, HeroChecker checker) &#123;</span><br><span class="line">        for (Hero hero : heros) &#123;</span><br><span class="line">            if (checker.test(hero))</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-引用对象方法"><a class="header-anchor" href="#步骤-2-引用对象方法">¶</a>步骤 2 : 引用对象方法</h3>
<p>与引用静态方法很类似，只是传递方法的时候，需要一个对象的存在</p>
<p>TestLambda testLambda = new TestLambda();</p>
<p>filter(heros, testLambda::testHero);</p>
<p>这种方式叫做<strong>引用对象方法</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2561.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">     </span><br><span class="line">        System.out.println(&quot;使用引用对象方法  的过滤结果：&quot;);</span><br><span class="line">        &#x2F;&#x2F;使用类的对象方法</span><br><span class="line">        TestLambda testLambda &#x3D; new TestLambda();</span><br><span class="line">        filter(heros, testLambda::testHero);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public boolean testHero(Hero h) &#123;</span><br><span class="line">        return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    private static void filter(List&lt;Hero&gt; heros, HeroChecker checker) &#123;</span><br><span class="line">        for (Hero hero : heros) &#123;</span><br><span class="line">            if (checker.test(hero))</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-引用容器中的对象的方法"><a class="header-anchor" href="#步骤-3-引用容器中的对象的方法">¶</a>步骤 3 : 引用容器中的对象的方法</h3>
<p>首先为Hero添加一个方法</p>
<p>public boolean matched(){</p>
<p>return this.hp&gt;100 &amp;&amp; this.damage&lt;50;</p>
<p>}</p>
<p>使用Lambda表达式</p>
<p>filter(heros,h-&gt; h.hp&gt;100 &amp;&amp; h.damage&lt;50 );</p>
<p>在Lambda表达式中调用容器中的对象Hero的方法matched</p>
<p>filter(heros,h-&gt; h.matched() );</p>
<p>matched恰好就是容器中的对象Hero的方法，那就可以进一步改写为</p>
<p>filter(heros, Hero::matched);</p>
<p>这种方式就叫做<strong>引用容器中的对象的方法</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2562.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line">   </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">   </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;Lambda表达式：&quot;);       </span><br><span class="line">        filter(heros,h-&gt; h.hp&gt;100 &amp;&amp; h.damage&lt;50 );</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;Lambda表达式中调用容器中的对象的matched方法：&quot;);       </span><br><span class="line">        filter(heros,h-&gt; h.matched() );</span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;引用容器中对象的方法 之过滤结果：&quot;);       </span><br><span class="line">        filter(heros, Hero::matched);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public boolean testHero(Hero h) &#123;</span><br><span class="line">        return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    private static void filter(List&lt;Hero&gt; heros, HeroChecker checker) &#123;</span><br><span class="line">        for (Hero hero : heros) &#123;</span><br><span class="line">            if (checker.test(hero))</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-引用构造器"><a class="header-anchor" href="#步骤-4-引用构造器">¶</a>步骤 4 : 引用构造器</h3>
<p>有的接口中的方法会返回一个对象，比如<strong>java.util.function.Supplier</strong>提供<br>
了一个get方法，返回一个对象。</p>
<p>public interface Supplier<T> {</T></p>
<p>​    T get();</p>
<p>}</p>
<p>设计一个方法，参数是这个接口</p>
<p>public static List getList(Supplier<List> s){</List></p>
<p>return s.get();</p>
<p>}</p>
<p>为了调用这个方法，有3种方式<br>
第一种匿名类：</p>
<p>Supplier<List> s = new Supplier<List>() {</List></List></p>
<p>​	public List get() {</p>
<p>​		return new ArrayList();</p>
<p>​	}</p>
<p>};</p>
<p>List list1 = getList(s);</p>
<p>第二种：Lambda表达式</p>
<p>List list2 = getList(()-&gt;new ArrayList());</p>
<p>第三种：引用构造器</p>
<p>List list3 = getList(ArrayList::new);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"> </span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    Supplier&lt;List&gt; s &#x3D; new Supplier&lt;List&gt;() &#123;</span><br><span class="line">        public List get() &#123;</span><br><span class="line">            return new ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;匿名类</span><br><span class="line">    List list1 &#x3D; getList(s);</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;Lambda表达式</span><br><span class="line">    List list2 &#x3D; getList(()-&gt;new ArrayList());</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;引用构造器</span><br><span class="line">    List list3 &#x3D; getList(ArrayList::new);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static List getList(Supplier&lt;List&gt; s)&#123;</span><br><span class="line">        return s.get();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-引用静态方法"><a class="header-anchor" href="#步骤-5-练习-引用静态方法">¶</a>步骤 5 : 练习-引用静态方法</h3>
<p>把[比较器-Comparator]章节中的代码，使用引用静态方法的方式来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import charactor.Hero;</span><br><span class="line"></span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line">	public static int compareHero(Hero h1, Hero h2) &#123;</span><br><span class="line">		return h1.hp &gt;&#x3D; h2.hp ? 1 : -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Hero&gt; heroList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		float hp;</span><br><span class="line">		int damage;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;</span><br><span class="line">			hp &#x3D; (float) (Math.random() * 100);</span><br><span class="line">			damage &#x3D; (int) (Math.random() * 1000);</span><br><span class="line">			heroList.add(new Hero(&quot;hero&quot; + i, hp, damage));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">		for (Hero hero : heroList) &#123;</span><br><span class="line">			System.out.print(hero);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 使用两种静态方法来实现</span><br><span class="line">		Collections.sort(heroList, TestGeneric::compareHero);</span><br><span class="line">		Collections.sort(heroList, (h1, h2) -&gt; TestGeneric.compareHero(h1, h2));</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;按照血量排序后的集合：&quot;);</span><br><span class="line">		for (Hero hero : heroList) &#123;</span><br><span class="line">			System.out.print(hero);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-练习-引用容器中的对象的方法"><a class="header-anchor" href="#步骤-6-练习-引用容器中的对象的方法">¶</a>步骤 6 : 练习-引用容器中的对象的方法</h3>
<p>把[比较器-Comparator] 章节中的代码，使用 引用容器中的对象的方法 的方式来实现。<br>
<strong>提示</strong>: 为Hero提供一个compareHero方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">import charactor.Hero;</span><br><span class="line"></span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Random r &#x3D;new Random();</span><br><span class="line">		List&lt;Hero&gt; aList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">			aList.add(new Hero(&quot;hero &quot;+ i, r.nextInt(100), r.nextInt(100)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">		for (Hero hero1 : aList) &#123;</span><br><span class="line">			System.out.println(hero1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方法引用，容器中类调用方法内容写入实现方法中</span><br><span class="line">		Collections.sort(aList,Hero::compareTo);</span><br><span class="line">		System.out.println(&quot;方法引用进行排序：&quot;);</span><br><span class="line">		for (Hero hero1 : aList) &#123;</span><br><span class="line">			System.out.println(hero1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;Lambda表达式实现方法,方法参数-&gt;容器中的对象调用比较方法</span><br><span class="line">		Collections.sort(aList, (h1,h2)-&gt;h1.compareTo(h2));</span><br><span class="line">		System.out.println(&quot;Lambda进行排序：&quot;);</span><br><span class="line">		for (Hero hero1 : aList) &#123;</span><br><span class="line">			System.out.println(hero1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-练习-引用构造器"><a class="header-anchor" href="#步骤-7-练习-引用构造器">¶</a>步骤 7 : 练习-引用构造器</h3>
<p>把[比较ArrayList和LinkedList的区别]这段代码，改造成引用构造器的模式。<br>
目前的调用方式是:</p>
<p>​        List<Integer> l;</Integer></p>
<p>​        l = new ArrayList&lt;&gt;();</p>
<p>​        insertFirst(l, “ArrayList”);</p>
<p>​        l = new LinkedList&lt;&gt;();</p>
<p>​        insertFirst(l, “LinkedList”);</p>
<p>改造后的调用方式将变为：</p>
<p>​        insertFirst(ArrayList::new, “ArrayList”);</p>
<p>​        insertFirst(LinkedList::new, “LinkedList”);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; l;</span><br><span class="line">        l &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        insertFirst(l, &quot;ArrayList&quot;);</span><br><span class="line">  </span><br><span class="line">        l &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        insertFirst(l, &quot;LinkedList&quot;);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    private static void insertFirst(List&lt;Integer&gt; l, String type) &#123;</span><br><span class="line">        int total &#x3D; 1000 * 100;</span><br><span class="line">        final int number &#x3D; 5;</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; total; i++) &#123;</span><br><span class="line">            l.add(0, number);</span><br><span class="line">        &#125;</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.printf(&quot;在%s 最前面插入%d条数据，总共耗时 %d 毫秒 %n&quot;, type, total, end - start);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;构造器引用实现了匿名内部类中方法的返回内容：创建对象ArrayList</span><br><span class="line">		insertFirst(ArrayList::new, &quot;ArrayList&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;创建容器类插入数据，形参1是实现接口supplier，传入构造器引用来实现方法</span><br><span class="line">	private static void insertFirst(Supplier&lt;List&gt; s, String type) &#123;</span><br><span class="line">		int total &#x3D; 1000 * 100;</span><br><span class="line">		final int number &#x3D; 5;</span><br><span class="line">		long start &#x3D; System.currentTimeMillis();</span><br><span class="line">		&#x2F;&#x2F;调用Supplier的匿名内部类实现方法，进行创建对象new ArrayList</span><br><span class="line">		List list &#x3D; s.get();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; total; i++) &#123;</span><br><span class="line">			&#x2F;&#x2F;给容器插入数据</span><br><span class="line">			list.add(0, number);</span><br><span class="line">		&#125;</span><br><span class="line">		long end &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.printf(&quot;在%s 最前面插入%d条数据，总共耗时 %d 毫秒 %n&quot;, type, total, end - start);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA-集合的聚合操作"><a class="header-anchor" href="#3、JAVA-集合的聚合操作">¶</a>3、JAVA 集合的聚合操作</h2>
<h3 id="步骤-1-传统方式与聚合操作方式遍历数据"><a class="header-anchor" href="#步骤-1-传统方式与聚合操作方式遍历数据">¶</a>步骤 1 : 传统方式与聚合操作方式遍历数据</h3>
<p>遍历数据的传统方式就是使用for循环，然后条件判断，最后打印出满足条件的数据</p>
<p>for (Hero h : heros) {</p>
<p>if (h.hp &gt; 100 &amp;&amp; h.damage &lt; 50)</p>
<p>​      System.out.println(<a href="http://h.name" target="_blank" rel="noopener">h.name</a>);</p>
<p>}</p>
<p>使用聚合操作方式，<strong>画风</strong>就发生了变化：</p>
<p>heros</p>
<p>​	.stream()</p>
<p>​	.filter(h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50)</p>
<p>​	.forEach(h -&gt; System.out.println(<a href="http://h.name" target="_blank" rel="noopener">h.name</a>));</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2565.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestAggregate &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;查询条件：hp&gt;100 &amp;&amp; damage&lt;50&quot;);</span><br><span class="line">        System.out.println(&quot;通过传统操作方式找出满足条件的数据：&quot;);</span><br><span class="line"> </span><br><span class="line">        for (Hero h : heros) &#123;</span><br><span class="line">            if (h.hp &gt; 100 &amp;&amp; h.damage &lt; 50)</span><br><span class="line">                System.out.println(h.name);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;通过聚合操作方式找出满足条件的数据：&quot;);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50)</span><br><span class="line">            .forEach(h -&gt; System.out.println(h.name));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-Stream和管道的概念"><a class="header-anchor" href="#步骤-2-Stream和管道的概念">¶</a>步骤 2 : Stream和管道的概念</h3>
<p>heros</p>
<p>​	.stream()</p>
<p>​	.filter(h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50)</p>
<p>​	.forEach(h -&gt; System.out.println(<a href="http://h.name" target="_blank" rel="noopener">h.name</a>));</p>
<p>要了解聚合操作，首先要建立<strong>Stream</strong>和<strong>管道</strong>的概念<br>
<strong>Stream</strong> 和Collection结构化的数据不一样，Stream是一系列的元素，就像是生产线上的罐头一样，一串串的出来。<br>
<strong>管道</strong>指的是一系列的聚合操作。</p>
<p>管道又分3个部分<br>
<strong>管道源</strong>：在这个例子里，源是一个List<br>
<strong>中间操作</strong>： 每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。<br>
<strong>结束操作</strong>：当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回, 结束操作才进行真正的遍历行为，在遍历的时候，才会去进行中间操作的相关判断</p>
<p><strong>注：</strong> 这个Stream和I/O章节的InputStream,OutputStream是不一样的概念。</p>
<h3 id="步骤-3-管道源"><a class="header-anchor" href="#步骤-3-管道源">¶</a>步骤 3 : 管道源</h3>
<p>把Collection切换成管道源很简单，调用stream()就行了。</p>
<p>heros.stream()</p>
<p>但是数组却没有stream()方法，需要使用</p>
<p>Arrays.stream(hs)</p>
<p>或者</p>
<p>Stream.of(hs)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestAggregate &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;管道源是集合</span><br><span class="line">        heros</span><br><span class="line">        .stream()</span><br><span class="line">        .forEach(h-&gt;System.out.println(h.name));</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;管道源是数组</span><br><span class="line">        Hero hs[] &#x3D; heros.toArray(new Hero[heros.size()]);</span><br><span class="line">        Arrays.stream(hs)</span><br><span class="line">        .forEach(h-&gt;System.out.println(h.name));</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-中间操作"><a class="header-anchor" href="#步骤-4-中间操作">¶</a>步骤 4 : 中间操作</h3>
<p>每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。<br>
中间操作比较多，主要分两类<br>
对元素进行筛选 和 转换为其他形式的流<br>
<strong>对元素进行筛选：</strong><br>
filter 匹配<br>
distinct 去除重复(根据equals判断)<br>
sorted 自然排序<br>
sorted(Comparator<T>) 指定排序<br>
limit 保留<br>
skip 忽略<br>
<strong>转换为其他形式的流</strong><br>
mapToDouble 转换为double的流<br>
map 转换为任意类型的流</T></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2568.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">      </span><br><span class="line">public class Hero implements Comparable&lt;Hero&gt;&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">         </span><br><span class="line">    public int damage;</span><br><span class="line">         </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public float getHp() &#123;</span><br><span class="line">        return hp;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setHp(float hp) &#123;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getDamage() &#123;</span><br><span class="line">        return damage;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setDamage(int damage) &#123;</span><br><span class="line">        this.damage &#x3D; damage;</span><br><span class="line">    &#125;</span><br><span class="line">    public Hero(String name) &#123;</span><br><span class="line">        this.name &#x3D;name;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;初始化name,hp,damage的构造方法</span><br><span class="line">    public Hero(String name,float hp, int damage) &#123;</span><br><span class="line">        this.name &#x3D;name;</span><br><span class="line">        this.hp &#x3D; hp;</span><br><span class="line">        this.damage &#x3D; damage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Hero anotherHero) &#123;</span><br><span class="line">        if(damage&lt;anotherHero.damage)</span><br><span class="line">            return 1; </span><br><span class="line">        else</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hero [name&#x3D;&quot; + name + &quot;, hp&#x3D;&quot; + hp + &quot;, damage&#x3D;&quot; + damage + &quot;]\r\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestAggregate &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;制造一个重复数据</span><br><span class="line">        heros.add(heros.get(0));</span><br><span class="line">        System.out.println(&quot;初始化集合后的数据 (最后一个数据重复)：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;满足条件hp&gt;100&amp;&amp;damage&lt;50的数据&quot;);</span><br><span class="line">          </span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(h-&gt;h.hp&gt;100&amp;&amp;h.damage&lt;50)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;去除重复的数据，去除标准是看equals&quot;);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">        System.out.println(&quot;按照血量排序&quot;);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted((h1,h2)-&gt;h1.hp&gt;&#x3D;h2.hp?1:-1)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;保留3个&quot;);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .limit(3)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;忽略前3个&quot;);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .skip(3)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;转换为double的Stream&quot;);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .mapToDouble(Hero::getHp)</span><br><span class="line">            .forEach(h-&gt;System.out.println(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;转换任意类型的Stream&quot;);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .map((h)-&gt; h.name + &quot; - &quot; + h.hp + &quot; - &quot; + h.damage)</span><br><span class="line">            .forEach(h-&gt;System.out.println(h));</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-结束操作"><a class="header-anchor" href="#步骤-5-结束操作">¶</a>步骤 5 : 结束操作</h3>
<p>当进行结束操作后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回,。<br>
结束操作才真正进行遍历行为，前面的中间操作也在这个时候，才真正的执行。<br>
常见结束操作如下：<br>
<strong>forEach()</strong> 遍历每个元素<br>
<strong>toArray()</strong> 转换为数组<br>
<strong>min(Comparator<T>)</T></strong> 取最小的元素<br>
<strong>max(Comparator<T>)</T></strong> 取最大的元素<br>
<strong>count()</strong> 总数<br>
<strong>findFirst()</strong> 第一个元素</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2569.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line">  </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"> </span><br><span class="line">import org.omg.Messaging.SYNC_WITH_TRANSPORT;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestAggregate &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;遍历集合中的每个数据&quot;);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">        System.out.println(&quot;返回一个数组&quot;);</span><br><span class="line">        Object[] hs&#x3D; heros</span><br><span class="line">            .stream()</span><br><span class="line">            .toArray();</span><br><span class="line">        System.out.println(Arrays.toString(hs));</span><br><span class="line">        System.out.println(&quot;返回伤害最低的那个英雄&quot;);</span><br><span class="line">        Hero minDamageHero &#x3D;</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .min((h1,h2)-&gt;h1.damage-h2.damage)</span><br><span class="line">            .get();</span><br><span class="line">        System.out.print(minDamageHero);</span><br><span class="line">        System.out.println(&quot;返回伤害最高的那个英雄&quot;);</span><br><span class="line"> </span><br><span class="line">        Hero mxnDamageHero &#x3D;</span><br><span class="line">                heros</span><br><span class="line">                .stream()</span><br><span class="line">                .max((h1,h2)-&gt;h1.damage-h2.damage)</span><br><span class="line">                .get();</span><br><span class="line">        System.out.print(mxnDamageHero);     </span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;流中数据的总数&quot;);</span><br><span class="line">        long count &#x3D; heros</span><br><span class="line">                .stream()</span><br><span class="line">                .count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;第一个英雄&quot;);</span><br><span class="line">        Hero firstHero &#x3D;</span><br><span class="line">                heros</span><br><span class="line">                .stream()</span><br><span class="line">                .findFirst()</span><br><span class="line">                .get();</span><br><span class="line">         </span><br><span class="line">        System.out.println(firstHero);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-练习-聚合操作"><a class="header-anchor" href="#步骤-6-练习-聚合操作">¶</a>步骤 6 : 练习-聚合操作</h3>
<p>首选准备10个Hero对象，hp和damage都是随机数。<br>
分别用传统方式和聚合操作的方式，把hp第三高的英雄名称打印出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">      </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">     </span><br><span class="line">import charactor.Hero;</span><br><span class="line">      </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D;new Random();</span><br><span class="line">        List&lt;Hero&gt; heros &#x3D; new ArrayList&lt;Hero&gt;();</span><br><span class="line">             </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot;+ i, r.nextInt(100), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;传统方式</span><br><span class="line">        System.out.println(&quot;排序后的集合&quot;);</span><br><span class="line">        Collections.sort(heros,(h1,h2)-&gt;h1.hp-h2.hp);</span><br><span class="line">         </span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(&quot;传统方式查找的hp第三高的英雄：&quot;+heros.get(7));</span><br><span class="line">         </span><br><span class="line">        Collections.shuffle(heros);</span><br><span class="line">        &#x2F;&#x2F;聚合操作</span><br><span class="line">        System.out.println(&quot;重新打乱的集合：\n&quot;+heros);</span><br><span class="line">        Hero hp3 &#x3D;</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted((h1,h2)-&gt;h1.hp-h2.hp)</span><br><span class="line">            .skip(7)</span><br><span class="line">            .findFirst()</span><br><span class="line">            .get();</span><br><span class="line">        System.out.println(&quot;聚合操作查找的hp第三高的英雄：&quot;+hp3);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六、多线程"><a class="header-anchor" href="#六、多线程">¶</a>六、多线程</h1>
<h2 id="1、JAVA-创建一个线程的三种方式"><a class="header-anchor" href="#1、JAVA-创建一个线程的三种方式">¶</a>1、JAVA 创建一个线程的三种方式</h2>
<h3 id="步骤-1-线程概念"><a class="header-anchor" href="#步骤-1-线程概念">¶</a>步骤 1 : 线程概念</h3>
<p>首先要理解进程(Processor)和线程(Thread)的区别<br>
**进程：**启动一个LOL.exe就叫一个进程。 接着又启动一个DOTA.exe，这叫两个进程。<br>
**线程：**线程是在进程内部同时做的事情，比如在LOL里，有很多事情要同时做，比如&quot;盖伦” 击杀“提莫”，<strong>同时</strong>“赏金猎人”又在击杀“盲僧”，这就是由多线程来实现的。</p>
<p>此处代码演示的是<strong>不使用多线程的情况</strong>：<br>
只有在盖伦杀掉提莫后，赏金猎人才开始杀盲僧</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/777.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import java.io.Serializable;</span><br><span class="line">  </span><br><span class="line">public class Hero&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">     </span><br><span class="line">    public int damage;</span><br><span class="line">     </span><br><span class="line">    public void attackHero(Hero h) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;为了表示攻击需要时间，每次攻击暂停1000毫秒</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        h.hp-&#x3D;damage;</span><br><span class="line">        System.out.format(&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;,name,h.name,h.name,h.hp);</span><br><span class="line">         </span><br><span class="line">        if(h.isDead())</span><br><span class="line">            System.out.println(h.name +&quot;死了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        return 0&gt;&#x3D;hp?true:false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 616;</span><br><span class="line">        gareen.damage &#x3D; 50;</span><br><span class="line"> </span><br><span class="line">        Hero teemo &#x3D; new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 300;</span><br><span class="line">        teemo.damage &#x3D; 30;</span><br><span class="line">         </span><br><span class="line">        Hero bh &#x3D; new Hero();</span><br><span class="line">        bh.name &#x3D; &quot;赏金猎人&quot;;</span><br><span class="line">        bh.hp &#x3D; 500;</span><br><span class="line">        bh.damage &#x3D; 65;</span><br><span class="line">         </span><br><span class="line">        Hero leesin &#x3D; new Hero();</span><br><span class="line">        leesin.name &#x3D; &quot;盲僧&quot;;</span><br><span class="line">        leesin.hp &#x3D; 455;</span><br><span class="line">        leesin.damage &#x3D; 80;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;盖伦攻击提莫</span><br><span class="line">        while(!teemo.isDead())&#123;</span><br><span class="line">            gareen.attackHero(teemo);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;赏金猎人攻击盲僧</span><br><span class="line">        while(!leesin.isDead())&#123;</span><br><span class="line">            bh.attackHero(leesin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-创建多线程-继承线程类"><a class="header-anchor" href="#步骤-2-创建多线程-继承线程类">¶</a>步骤 2 : 创建多线程-继承线程类</h3>
<p>使用多线程，就可以做到盖伦在攻击提莫的<strong>同时</strong>，赏金猎人也在攻击盲僧<br>
设计一个类KillThread <strong>继承Thread</strong>，<strong>并且重写run方法</strong><br>
启动线程办法： 实例化一个KillThread对象，并且调用其<strong>start</strong>方法<br>
就可以观察到 赏金猎人攻击盲僧的<strong>同时</strong>，盖伦也在攻击提莫</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/778.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class KillThread extends Thread&#123;</span><br><span class="line">     </span><br><span class="line">    private Hero h1;</span><br><span class="line">    private Hero h2;</span><br><span class="line"> </span><br><span class="line">    public KillThread(Hero h1, Hero h2)&#123;</span><br><span class="line">        this.h1 &#x3D; h1;</span><br><span class="line">        this.h2 &#x3D; h2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(!h2.isDead())&#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 616;</span><br><span class="line">        gareen.damage &#x3D; 50;</span><br><span class="line"> </span><br><span class="line">        Hero teemo &#x3D; new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 300;</span><br><span class="line">        teemo.damage &#x3D; 30;</span><br><span class="line">         </span><br><span class="line">        Hero bh &#x3D; new Hero();</span><br><span class="line">        bh.name &#x3D; &quot;赏金猎人&quot;;</span><br><span class="line">        bh.hp &#x3D; 500;</span><br><span class="line">        bh.damage &#x3D; 65;</span><br><span class="line">         </span><br><span class="line">        Hero leesin &#x3D; new Hero();</span><br><span class="line">        leesin.name &#x3D; &quot;盲僧&quot;;</span><br><span class="line">        leesin.hp &#x3D; 455;</span><br><span class="line">        leesin.damage &#x3D; 80;</span><br><span class="line">         </span><br><span class="line">        KillThread killThread1 &#x3D; new KillThread(gareen,teemo);</span><br><span class="line">        killThread1.start();</span><br><span class="line">        KillThread killThread2 &#x3D; new KillThread(bh,leesin);</span><br><span class="line">        killThread2.start();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-创建多线程-实现Runnable接口"><a class="header-anchor" href="#步骤-3-创建多线程-实现Runnable接口">¶</a>步骤 3 : 创建多线程-实现Runnable接口</h3>
<p>创建类Battle，实现Runnable接口<br>
启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动</p>
<p>Battle battle1 = new Battle(gareen,teemo);</p>
<p>new Thread(battle1).start();</p>
<p>battle1 对象实现了Runnable接口，所以有run方法，但是直接调用run方法，并不会启动一个新的线程。<br>
必须，借助一个线程对象的start()方法，才会启动一个新的线程。<br>
所以，在创建Thread对象的时候，把battle1作为构造方法的参数传递进去，这个线程启动的时候，就会去执行battle1.run()方法了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class Battle implements Runnable&#123;</span><br><span class="line">     </span><br><span class="line">    private Hero h1;</span><br><span class="line">    private Hero h2;</span><br><span class="line"> </span><br><span class="line">    public Battle(Hero h1, Hero h2)&#123;</span><br><span class="line">        this.h1 &#x3D; h1;</span><br><span class="line">        this.h2 &#x3D; h2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(!h2.isDead())&#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 616;</span><br><span class="line">        gareen.damage &#x3D; 50;</span><br><span class="line"> </span><br><span class="line">        Hero teemo &#x3D; new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 300;</span><br><span class="line">        teemo.damage &#x3D; 30;</span><br><span class="line">         </span><br><span class="line">        Hero bh &#x3D; new Hero();</span><br><span class="line">        bh.name &#x3D; &quot;赏金猎人&quot;;</span><br><span class="line">        bh.hp &#x3D; 500;</span><br><span class="line">        bh.damage &#x3D; 65;</span><br><span class="line">         </span><br><span class="line">        Hero leesin &#x3D; new Hero();</span><br><span class="line">        leesin.name &#x3D; &quot;盲僧&quot;;</span><br><span class="line">        leesin.hp &#x3D; 455;</span><br><span class="line">        leesin.damage &#x3D; 80;</span><br><span class="line">         </span><br><span class="line">        Battle battle1 &#x3D; new Battle(gareen,teemo);</span><br><span class="line">         </span><br><span class="line">        new Thread(battle1).start();</span><br><span class="line"> </span><br><span class="line">        Battle battle2 &#x3D; new Battle(bh,leesin);</span><br><span class="line">        new Thread(battle2).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-创建多线程-匿名类"><a class="header-anchor" href="#步骤-4-创建多线程-匿名类">¶</a>步骤 4 : 创建多线程-匿名类</h3>
<p>使用[匿名类]，继承Thread,重写run方法，直接在run方法中写业务代码<br>
匿名类的一个好处是可以很方便的访问外部的局部变量。<br>
前提是外部的局部变量需要被声明为final。(JDK7以后就不需要了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 616;</span><br><span class="line">        gareen.damage &#x3D; 50;</span><br><span class="line">  </span><br><span class="line">        Hero teemo &#x3D; new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 300;</span><br><span class="line">        teemo.damage &#x3D; 30;</span><br><span class="line">          </span><br><span class="line">        Hero bh &#x3D; new Hero();</span><br><span class="line">        bh.name &#x3D; &quot;赏金猎人&quot;;</span><br><span class="line">        bh.hp &#x3D; 500;</span><br><span class="line">        bh.damage &#x3D; 65;</span><br><span class="line">          </span><br><span class="line">        Hero leesin &#x3D; new Hero();</span><br><span class="line">        leesin.name &#x3D; &quot;盲僧&quot;;</span><br><span class="line">        leesin.hp &#x3D; 455;</span><br><span class="line">        leesin.damage &#x3D; 80;</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;匿名类</span><br><span class="line">        Thread t1&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                &#x2F;&#x2F;匿名类中用到外部的局部变量teemo，必须把teemo声明为final</span><br><span class="line">                &#x2F;&#x2F;但是在JDK7以后，就不是必须加final的了</span><br><span class="line">                while(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         </span><br><span class="line">        t1.start();</span><br><span class="line">          </span><br><span class="line">        Thread t2&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(!leesin.isDead())&#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-创建多线程的三种方式"><a class="header-anchor" href="#步骤-5-创建多线程的三种方式">¶</a>步骤 5 : 创建多线程的三种方式</h3>
<p>把上述3种方式再整理一下：</p>
<ol>
<li>
<p>继承Thread类</p>
</li>
<li>
<p>实现Runnable接口</p>
</li>
<li>
<p>匿名类的方式</p>
</li>
</ol>
<p>注： 启动线程是start()方法，run()并不能启动一个新的线程</p>
<h3 id="步骤-6-练习-同步查找文件内容"><a class="header-anchor" href="#步骤-6-练习-同步查找文件内容">¶</a>步骤 6 : 练习-同步查找文件内容</h3>
<p>把 [练习-查找文件内容] 改为多线程查找文件内容<br>
原练习的思路是遍历所有文件，当遍历到文件是 .java的时候，查找这个文件的内容，查找完毕之后，再遍历下一个文件</p>
<p>现在通过多线程调整这个思路：<br>
遍历所有文件，当遍历到文件是.java的时候，创建一个线程去查找这个文件的内容，不必等待这个线程结束，继续遍历下一个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] asgs)&#123;</span><br><span class="line">		long jk &#x3D; System.currentTimeMillis();</span><br><span class="line">		quirefile(&quot;D:\\Java&quot;, &quot;你好&quot;);</span><br><span class="line">		long dk &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;使用多线程的查询时间是：&quot; + (dk - jk));</span><br><span class="line">		System.out.println(&quot;-------------------------------------------------&quot;);</span><br><span class="line">		long jkk &#x3D; System.currentTimeMillis();</span><br><span class="line">		quirefile2(&quot;D:\\Java&quot;, &quot;你好&quot;);</span><br><span class="line">		long dkk &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;不使用多线程的查询时间是：&quot; + (dkk - jkk));</span><br><span class="line">		&#125;</span><br><span class="line">		public static void quirefile(String filepath, String data)&#123;</span><br><span class="line">			File file1&#x3D;new File(filepath);</span><br><span class="line">			if (!file1.isDirectory())&#123;</span><br><span class="line">				System.out.println(&quot;请输入目录路径&quot;);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			File[] files&#x3D;file1.listFiles();</span><br><span class="line">			for (int i &#x3D; 0; i &lt;files.length; i++) &#123;</span><br><span class="line">				if (files[i].isDirectory())&#123;</span><br><span class="line">					quirefile(files[i].getAbsolutePath(),data);</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					String name&#x3D;files[i].getName();</span><br><span class="line">					File fpath&#x3D;new File(files[i].getAbsolutePath());</span><br><span class="line">					String[] names&#x3D;name.split(&quot;\\.&quot;);</span><br><span class="line">					for (String name1:names)&#123;</span><br><span class="line">						if (name1.equals(&quot;txt&quot;))&#123;</span><br><span class="line">							new Thread(() -&gt; &#123;</span><br><span class="line">								try &#123;</span><br><span class="line">									FileInputStream in&#x3D;new FileInputStream(fpath);</span><br><span class="line">									byte[] buf&#x3D;new byte[1024];</span><br><span class="line">									int d;</span><br><span class="line">									while ((d&#x3D;in.read(buf))!&#x3D;-1)&#123;</span><br><span class="line">										if (data.equals(new String(buf,0,d)))&#123;</span><br><span class="line">											System.out.println(&quot;文件“&quot;+fpath.getName()+&quot;”中有“&quot;+data+&quot;”内容&quot;);</span><br><span class="line">										&#125;</span><br><span class="line">									&#125;</span><br><span class="line">									in.close();</span><br><span class="line">								&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">									e.printStackTrace();</span><br><span class="line">								&#125;catch (IOException e) &#123;</span><br><span class="line">									e.printStackTrace();</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;).start();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public static void quirefile2(String filepath, String data)&#123;</span><br><span class="line">			File file1&#x3D;new File(filepath);</span><br><span class="line">			if (!file1.isDirectory())&#123;</span><br><span class="line">				System.out.println(&quot;请输入目录路径&quot;);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			File[] files&#x3D;file1.listFiles();</span><br><span class="line">			for (int i &#x3D; 0; i &lt;files.length; i++) &#123;</span><br><span class="line">				if (files[i].isDirectory())&#123;</span><br><span class="line">					quirefile(files[i].getAbsolutePath(),data);</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					String name&#x3D;files[i].getName();</span><br><span class="line">					File fpath&#x3D;new File(files[i].getAbsolutePath());</span><br><span class="line">					String[] names&#x3D;name.split(&quot;\\.&quot;);</span><br><span class="line">					for (String name1:names)&#123;</span><br><span class="line">						if (name1.equals(&quot;txt&quot;))&#123;</span><br><span class="line">							try &#123;</span><br><span class="line">								FileInputStream in&#x3D;new FileInputStream(fpath);</span><br><span class="line">								byte[] buf&#x3D;new byte[1024];</span><br><span class="line">								int d;</span><br><span class="line">								while ((d&#x3D;in.read(buf))!&#x3D;-1)&#123;</span><br><span class="line">									if (data.equals(new String(buf,0,d)))&#123;</span><br><span class="line">										System.out.println(&quot;文件“&quot;+fpath.getName()+&quot;”中有“&quot;+data+&quot;”内容&quot;);</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								in.close();</span><br><span class="line">							&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">								e.printStackTrace();</span><br><span class="line">							&#125;catch (IOException e) &#123;</span><br><span class="line">									e.printStackTrace();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class SearchFileThread extends Thread&#123;</span><br><span class="line"> </span><br><span class="line">    private File file;</span><br><span class="line">    private String search;</span><br><span class="line">    public SearchFileThread(File file,String search) &#123;</span><br><span class="line">        this.file &#x3D; file;</span><br><span class="line">        this.search&#x3D; search;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run()&#123;</span><br><span class="line">        String fileContent &#x3D; readFileConent(file);</span><br><span class="line">        if(fileContent.contains(search))&#123;</span><br><span class="line">            System.out.printf(&quot;找到子目标字符串%s,在文件:%s%n&quot;,search,file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public String readFileConent(File file)&#123;</span><br><span class="line">        try (FileReader fr &#x3D; new FileReader(file)) &#123;</span><br><span class="line">            char[] all &#x3D; new char[(int) file.length()];</span><br><span class="line">            fr.read(all);</span><br><span class="line">            return new String(all);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">  </span><br><span class="line">    public static void search(File file, String search) &#123;</span><br><span class="line">        if (file.isFile()) &#123;</span><br><span class="line">            if(file.getName().toLowerCase().endsWith(&quot;.java&quot;))&#123;</span><br><span class="line">                &#x2F;&#x2F;当找到.java文件的时候，就启动一个线程，进行专门的查找</span><br><span class="line">                new SearchFileThread(file,search).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (file.isDirectory()) &#123;</span><br><span class="line">            File[] fs &#x3D; file.listFiles();</span><br><span class="line">            for (File f : fs) &#123;</span><br><span class="line">                search(f, search);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File folder &#x3D;new File(&quot;e:\\project&quot;);</span><br><span class="line">        search(folder,&quot;Magic&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、JAVA-常见的线程方法"><a class="header-anchor" href="#2、JAVA-常见的线程方法">¶</a>2、JAVA 常见的线程方法</h2>
<h3 id="示例-1-当前线程暂停"><a class="header-anchor" href="#示例-1-当前线程暂停">¶</a>示例 1 : 当前线程暂停</h3>
<p>Thread.sleep(1000); 表示当前线程暂停1000毫秒 ，其他线程不受影响<br>
Thread.sleep(1000); 会抛出InterruptedException 中断异常，因为当前线程sleep的时候，有可能被停止，这时就会抛出 InterruptedException</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Thread t1&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                int seconds &#x3D;0;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.printf(&quot;已经玩了LOL %d 秒%n&quot;, seconds++);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2-加入到当前线程中"><a class="header-anchor" href="#示例-2-加入到当前线程中">¶</a>示例 2 : 加入到当前线程中</h3>
<p>首先解释一下<strong>主线程</strong>的概念<br>
所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个<strong>看不见</strong>的主线程存在。<br>
在42行执行t.join，即表明<strong>在主线程中加入该线程</strong>。<br>
主线程会等待该线程结束完毕， 才会往下运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        final Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 616;</span><br><span class="line">        gareen.damage &#x3D; 50;</span><br><span class="line">  </span><br><span class="line">        final Hero teemo &#x3D; new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 300;</span><br><span class="line">        teemo.damage &#x3D; 30;</span><br><span class="line">          </span><br><span class="line">        final Hero bh &#x3D; new Hero();</span><br><span class="line">        bh.name &#x3D; &quot;赏金猎人&quot;;</span><br><span class="line">        bh.hp &#x3D; 500;</span><br><span class="line">        bh.damage &#x3D; 65;</span><br><span class="line">          </span><br><span class="line">        final Hero leesin &#x3D; new Hero();</span><br><span class="line">        leesin.name &#x3D; &quot;盲僧&quot;;</span><br><span class="line">        leesin.hp &#x3D; 455;</span><br><span class="line">        leesin.damage &#x3D; 80;</span><br><span class="line">          </span><br><span class="line">        Thread t1&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        t1.start();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;代码执行到这里，一直是main线程在运行</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Thread t2&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(!leesin.isDead())&#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;会观察到盖伦把提莫杀掉后，才运行t2线程</span><br><span class="line">        t2.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3-线程优先级"><a class="header-anchor" href="#示例-3-线程优先级">¶</a>示例 3 : 线程优先级</h3>
<p>当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源<br>
为了演示该效果，要把暂停时间去掉，多条线程各自会尽力去占有CPU资源<br>
同时把英雄的血量增加100倍，攻击减低到1，才有足够的时间观察到优先级的演示<br>
如图可见，线程1的优先级是MAX_PRIORITY，所以它争取到了更多的CPU资源执行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">import java.io.Serializable;</span><br><span class="line">   </span><br><span class="line">public class Hero&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">      </span><br><span class="line">    public int damage;</span><br><span class="line">      </span><br><span class="line">    public void attackHero(Hero h) &#123;</span><br><span class="line">        &#x2F;&#x2F;把暂停时间去掉，多条线程各自会尽力去占有CPU资源</span><br><span class="line">        &#x2F;&#x2F;线程的优先级效果才可以看得出来</span><br><span class="line">&#x2F;&#x2F;        try &#123;</span><br><span class="line">&#x2F;&#x2F;           </span><br><span class="line">&#x2F;&#x2F;            Thread.sleep(0);</span><br><span class="line">&#x2F;&#x2F;        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#x2F;&#x2F;            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">&#x2F;&#x2F;            e.printStackTrace();</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">        h.hp-&#x3D;damage;</span><br><span class="line">        System.out.format(&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;,name,h.name,h.name,h.hp);</span><br><span class="line">          </span><br><span class="line">        if(h.isDead())</span><br><span class="line">            System.out.println(h.name +&quot;死了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        return 0&gt;&#x3D;hp?true:false;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        final Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 6160;</span><br><span class="line">        gareen.damage &#x3D; 1;</span><br><span class="line">  </span><br><span class="line">        final Hero teemo &#x3D; new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 3000;</span><br><span class="line">        teemo.damage &#x3D; 1;</span><br><span class="line">          </span><br><span class="line">        final Hero bh &#x3D; new Hero();</span><br><span class="line">        bh.name &#x3D; &quot;赏金猎人&quot;;</span><br><span class="line">        bh.hp &#x3D; 5000;</span><br><span class="line">        bh.damage &#x3D; 1;</span><br><span class="line">          </span><br><span class="line">        final Hero leesin &#x3D; new Hero();</span><br><span class="line">        leesin.name &#x3D; &quot;盲僧&quot;;</span><br><span class="line">        leesin.hp &#x3D; 4505;</span><br><span class="line">        leesin.damage &#x3D; 1;</span><br><span class="line">          </span><br><span class="line">        Thread t1&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line"> </span><br><span class="line">                while(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        Thread t2&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(!leesin.isDead())&#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         </span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4-临时暂停"><a class="header-anchor" href="#示例-4-临时暂停">¶</a>示例 4 : 临时暂停</h3>
<p>当前线程，临时暂停，使得其他线程可以有更多的机会占用CPU资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        final Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 61600;</span><br><span class="line">        gareen.damage &#x3D; 1;</span><br><span class="line">  </span><br><span class="line">        final Hero teemo &#x3D; new Hero();</span><br><span class="line">        teemo.name &#x3D; &quot;提莫&quot;;</span><br><span class="line">        teemo.hp &#x3D; 30000;</span><br><span class="line">        teemo.damage &#x3D; 1;</span><br><span class="line">          </span><br><span class="line">        final Hero bh &#x3D; new Hero();</span><br><span class="line">        bh.name &#x3D; &quot;赏金猎人&quot;;</span><br><span class="line">        bh.hp &#x3D; 50000;</span><br><span class="line">        bh.damage &#x3D; 1;</span><br><span class="line">          </span><br><span class="line">        final Hero leesin &#x3D; new Hero();</span><br><span class="line">        leesin.name &#x3D; &quot;盲僧&quot;;</span><br><span class="line">        leesin.hp &#x3D; 45050;</span><br><span class="line">        leesin.damage &#x3D; 1;</span><br><span class="line">          </span><br><span class="line">        Thread t1&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line"> </span><br><span class="line">                while(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        Thread t2&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(!leesin.isDead())&#123;</span><br><span class="line">                    &#x2F;&#x2F;临时暂停，使得t1可以占用CPU资源</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                     </span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         </span><br><span class="line">        t1.setPriority(5);</span><br><span class="line">        t2.setPriority(5);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-5-守护线程"><a class="header-anchor" href="#示例-5-守护线程">¶</a>示例 5 : 守护线程</h3>
<p>守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。</p>
<p>就好像一个公司有销售部，生产部这些和业务挂钩的部门。<br>
除此之外，还有后勤，行政等这些支持部门。</p>
<p>如果一家公司销售部，生产部都解散了，那么只剩下后勤和行政，那么这家公司也可以解散了。</p>
<p>守护线程就相当于那些支持部门，如果一个进程只剩下守护线程，那么进程就会自动结束。</p>
<p>守护线程通常会被用来做日志，性能统计等工作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        Thread t1&#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                int seconds &#x3D;0;</span><br><span class="line">                 </span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.printf(&quot;已经玩了LOL %d 秒%n&quot;, seconds++);</span><br><span class="line">                     </span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setDaemon(true);</span><br><span class="line">        t1.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-6-练习-英雄充能"><a class="header-anchor" href="#示例-6-练习-英雄充能">¶</a>示例 6 : 练习-英雄充能</h3>
<p>英雄有可以放一个技能叫做: 波动拳-a du gen。<br>
每隔一秒钟，可以发一次，但是只能连续发3次。</p>
<p>发完3次之后，需要充能5秒钟，充满，再继续发。</p>
<p>借助本章节学习到的知识点，实现这个效果</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2589.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">          </span><br><span class="line">	public static void main(String[] asgs) &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			while (true)&#123;</span><br><span class="line">				for (int i &#x3D; 1; i &lt;4; i++) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.println(&quot;波动拳第&quot;+i+&quot;发&quot;);</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(&quot;开始为时5秒的充能&quot;);</span><br><span class="line">					Thread.sleep(5000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-7-练习-破解密码"><a class="header-anchor" href="#示例-7-练习-破解密码">¶</a>示例 7 : 练习-破解密码</h3>
<ol>
<li>
<p>生成一个长度是3的[随机字符串]，把这个字符串当作 <strong>密码</strong></p>
</li>
<li>
<p>创建一个破解线程，使用穷举法，匹配这个密码</p>
</li>
<li>
<p>创建一个日志线程，打印都用过哪些字符串去匹配，这个日志线程设计为守护线程</p>
</li>
</ol>
<p><strong>提示</strong>： 破解线程把穷举法生成的<strong>可能密码</strong>放在一个容器中，日志线程不断的从这个容器中拿出可能密码，并打印出来。 如果发现容器是空的，就休息1秒，如果发现不是空的，就不停的取出，并打印。</p>
<p>参考： [穷举法破解密码]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class TestThread &#123;</span><br><span class="line">	public static LinkedList&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		calcPassword(randomString(3));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void calcPassword(String password)&#123;</span><br><span class="line">		Thread thread1 &#x3D; new Thread()&#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				char[] c&#x3D;new char[3];</span><br><span class="line">				for(int i&#x3D;33;i&lt;127;i++)</span><br><span class="line">					for(int j&#x3D;33;j&lt;127;j++)</span><br><span class="line">						for(int k&#x3D;33;k&lt;127;k++) &#123;</span><br><span class="line">							c[0]&#x3D;(char)i;</span><br><span class="line">							c[1]&#x3D;(char)j;</span><br><span class="line">							c[2]&#x3D;(char)k;</span><br><span class="line">							list.add(new String(c));</span><br><span class="line">						&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		Thread thread2&#x3D;new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				while(true) &#123;</span><br><span class="line">					if(list.isEmpty())&#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							Thread.sleep(500);</span><br><span class="line">						&#125;catch(InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					String s &#x3D; list.removeFirst();</span><br><span class="line">					System.out.println(&quot;尝试密码：&quot; + s);</span><br><span class="line">					if(s.equals(password))&#123;</span><br><span class="line">						System.out.println(&quot;破解密码成功，密码为：&quot; + s);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		thread1.setDaemon(true);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String randomString(int len)&#123;</span><br><span class="line">		Random random &#x3D; new Random();</span><br><span class="line">		StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">		for(int i &#x3D; 0; i &lt; len; i++)&#123;</span><br><span class="line">			char at &#x3D; (char) (random.nextInt(127-33) + 33);</span><br><span class="line">			sb.append(at);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、JAVA-多线程同步-SYNCHRONIZED-详解"><a class="header-anchor" href="#3、JAVA-多线程同步-SYNCHRONIZED-详解">¶</a>3、JAVA 多线程同步 SYNCHRONIZED 详解</h2>
<h3 id="步骤-1-演示同步问题"><a class="header-anchor" href="#步骤-1-演示同步问题">¶</a>步骤 1 : 演示同步问题</h3>
<p>假设盖伦有10000滴血，并且在基地里，同时又被对方多个英雄攻击<br>
就是<strong>有多个线程在减少盖伦的hp</strong><br>
同时又有<strong>多个线程在恢复盖伦的hp</strong><br>
假设线程的数量是一样的，并且每次改变的值都是1，那么所有线程结束后，盖伦应该还是10000滴血。<br>
但是。。。</p>
<p><strong>注意</strong>： 不是每一次运行都会看到错误的数据产生，多运行几次，或者增加运行的次数</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/786.png" alt></p>
<h3 id="步骤-2-分析同步问题产生的原因"><a class="header-anchor" href="#步骤-2-分析同步问题产生的原因">¶</a>步骤 2 : 分析同步问题产生的原因</h3>
<ol>
<li>
<p>假设<strong>增加线程</strong>先进入，得到的hp是10000</p>
</li>
<li>
<p>进行增加运算</p>
</li>
<li>
<p>正在做增加运算的时候，<strong>还没有来得及修改hp的值</strong>，<strong>减少线程</strong>来了</p>
</li>
<li>
<p>减少线程得到的hp的值也是10000</p>
</li>
<li>
<p>减少线程进行减少运算</p>
</li>
<li>
<p>增加线程运算结束，得到值10001，并把这个值赋予hp</p>
</li>
<li>
<p>减少线程也运算结束，得到值9999，并把这个值赋予hp<br>
hp，最后的值就是9999<br>
虽然经历了两个线程各自增减了一次，本来期望还是原值10000，但是却得到了一个9999<br>
这个时候的值9999是一个错误的值，在业务上又叫做<strong>脏数据</strong></p>
</li>
</ol>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/787.png" alt></p>
<h3 id="步骤-3-解决思路"><a class="header-anchor" href="#步骤-3-解决思路">¶</a>步骤 3 : 解决思路</h3>
<p>总体解决思路是： 在增加线程访问hp期间，其他线程不可以访问hp</p>
<ol>
<li>
<p>增加线程获取到hp的值，并进行运算</p>
</li>
<li>
<p>在运算期间，减少线程试图来获取hp的值，但是<strong>不被允许</strong></p>
</li>
<li>
<p>增加线程运算结束，并成功修改hp的值为10001</p>
</li>
<li>
<p>减少线程，在增加线程做完后，才能访问hp的值，即10001</p>
</li>
<li>
<p>减少线程运算，并得到新的值10000</p>
</li>
</ol>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/788.png" alt></p>
<h3 id="步骤-4-synchronized-同步对象概念"><a class="header-anchor" href="#步骤-4-synchronized-同步对象概念">¶</a>步骤 4 : synchronized 同步对象概念</h3>
<p>解决上述问题之前，先理解<br>
<strong>synchronized</strong>关键字的意义<br>
如下代码：</p>
<p>Object someObject =new Object();</p>
<p>synchronized (someObject){</p>
<p>//此处的代码只有占有了someObject后才可以执行</p>
<p>}</p>
<p><strong>synchronized表示当前线程，独占 对象 someObject</strong><br>
当前线程<strong>独占</strong> 了对象someObject，如果有<strong>其他线程试图占有对象</strong>someObject，<strong>就会等待</strong>，直到当前线程释放对someObject的占用。<br>
someObject 又叫同步对象，所有的对象，都可以作为同步对象<br>
为了达到同步的效果，必须使用同一个同步对象</p>
<p><strong>释放同步对象</strong>的方式： synchronized 块自然结束，或者有异常抛出</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/789.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">   </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">     </span><br><span class="line">    public static String now()&#123;</span><br><span class="line">        return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Object someObject &#x3D; new Object();</span><br><span class="line">          </span><br><span class="line">        Thread t1 &#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println( now()+&quot; t1 线程已经运行&quot;);</span><br><span class="line">                    System.out.println( now()+this.getName()+ &quot; 试图占有对象：someObject&quot;);</span><br><span class="line">                    synchronized (someObject) &#123;</span><br><span class="line">                          </span><br><span class="line">                        System.out.println( now()+this.getName()+ &quot; 占有对象：someObject&quot;);</span><br><span class="line">                        Thread.sleep(5000);</span><br><span class="line">                        System.out.println( now()+this.getName()+ &quot; 释放对象：someObject&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(now()+&quot; t1 线程结束&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(&quot; t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 &#x3D; new Thread()&#123;</span><br><span class="line">  </span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println( now()+&quot; t2 线程已经运行&quot;);</span><br><span class="line">                    System.out.println( now()+this.getName()+ &quot; 试图占有对象：someObject&quot;);</span><br><span class="line">                    synchronized (someObject) &#123;</span><br><span class="line">                        System.out.println( now()+this.getName()+ &quot; 占有对象：someObject&quot;);</span><br><span class="line">                        Thread.sleep(5000);</span><br><span class="line">                        System.out.println( now()+this.getName()+ &quot; 释放对象：someObject&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(now()+&quot; t2 线程结束&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(&quot; t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-使用synchronized-解决同步问题"><a class="header-anchor" href="#步骤-5-使用synchronized-解决同步问题">¶</a>步骤 5 : 使用synchronized 解决同步问题</h3>
<p>所有需要修改hp的地方，有要<strong>建立在占有someObject的基础上</strong>。<br>
而对象 someObject在同一时间，只能被一个线程占有。 间接地，<strong>导致同一时间，hp只能被一个线程修改。</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/790.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">   </span><br><span class="line">import java.awt.GradientPaint;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        final Object someObject &#x3D; new Object();</span><br><span class="line">         </span><br><span class="line">        final Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 10000;</span><br><span class="line">          </span><br><span class="line">        int n &#x3D; 10000;</span><br><span class="line">  </span><br><span class="line">        Thread[] addThreads &#x3D; new Thread[n];</span><br><span class="line">        Thread[] reduceThreads &#x3D; new Thread[n];</span><br><span class="line">          </span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t &#x3D; new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                     </span><br><span class="line">                    &#x2F;&#x2F;任何线程要修改hp的值，必须先占用someObject</span><br><span class="line">                    synchronized (someObject) &#123;</span><br><span class="line">                        gareen.recover();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] &#x3D; t;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t &#x3D; new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    &#x2F;&#x2F;任何线程要修改hp的值，必须先占用someObject</span><br><span class="line">                    synchronized (someObject) &#123;</span><br><span class="line">                        gareen.hurt();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        for (Thread t : addThreads) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread t : reduceThreads) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.printf(&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;, n,n,gareen.hp);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-使用hero对象作为同步对象"><a class="header-anchor" href="#步骤-6-使用hero对象作为同步对象">¶</a>步骤 6 : 使用hero对象作为同步对象</h3>
<p>既然任意对象都可以用来作为同步对象，而所有的线程访问的都是同一个hero对象，<strong>索性就使用gareen来作为同步对象</strong><br>
进一步的，对于Hero的hurt方法，加上：<br>
synchronized (this) {<br>
}<br>
表示当前对象为同步对象，即也是gareen为同步对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">   </span><br><span class="line">import java.awt.GradientPaint;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        final Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 10000;</span><br><span class="line">          </span><br><span class="line">        int n &#x3D; 10000;</span><br><span class="line">  </span><br><span class="line">        Thread[] addThreads &#x3D; new Thread[n];</span><br><span class="line">        Thread[] reduceThreads &#x3D; new Thread[n];</span><br><span class="line">          </span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t &#x3D; new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                     </span><br><span class="line">                    &#x2F;&#x2F;使用gareen作为synchronized</span><br><span class="line">                    synchronized (gareen) &#123;</span><br><span class="line">                        gareen.recover();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] &#x3D; t;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t &#x3D; new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    &#x2F;&#x2F;使用gareen作为synchronized</span><br><span class="line">                    &#x2F;&#x2F;在方法hurt中有synchronized(this)</span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                     </span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        for (Thread t : addThreads) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread t : reduceThreads) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.printf(&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;, n,n,gareen.hp);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">     </span><br><span class="line">    public int damage;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;回血</span><br><span class="line">    public void recover()&#123;</span><br><span class="line">        hp&#x3D;hp+1;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;掉血</span><br><span class="line">    public void hurt()&#123;</span><br><span class="line">        &#x2F;&#x2F;使用this作为同步对象</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            hp&#x3D;hp-1;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void attackHero(Hero h) &#123;</span><br><span class="line">        h.hp-&#x3D;damage;</span><br><span class="line">        System.out.format(&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;,name,h.name,h.name,h.hp);</span><br><span class="line">        if(h.isDead())</span><br><span class="line">            System.out.println(h.name +&quot;死了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        return 0&gt;&#x3D;hp?true:false;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-在方法前，加上修饰符synchronized"><a class="header-anchor" href="#步骤-7-在方法前，加上修饰符synchronized">¶</a>步骤 7 : 在方法前，加上修饰符synchronized</h3>
<p>在recover前，直接加上synchronized ，其所对应的同步对象，就是this<br>
和hurt方法达到的效果是一样<br>
外部线程访问gareen的方法，就不需要额外使用synchronized 了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">     </span><br><span class="line">    public int damage;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;回血</span><br><span class="line">    &#x2F;&#x2F;直接在方法前加上修饰符synchronized</span><br><span class="line">    &#x2F;&#x2F;其所对应的同步对象，就是this</span><br><span class="line">    &#x2F;&#x2F;和hurt方法达到的效果一样</span><br><span class="line">    public synchronized void recover()&#123;</span><br><span class="line">        hp&#x3D;hp+1;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;掉血</span><br><span class="line">    public void hurt()&#123;</span><br><span class="line">        &#x2F;&#x2F;使用this作为同步对象</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            hp&#x3D;hp-1;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void attackHero(Hero h) &#123;</span><br><span class="line">        h.hp-&#x3D;damage;</span><br><span class="line">        System.out.format(&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;,name,h.name,h.name,h.hp);</span><br><span class="line">        if(h.isDead())</span><br><span class="line">            System.out.println(h.name +&quot;死了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        return 0&gt;&#x3D;hp?true:false;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">   </span><br><span class="line">import java.awt.GradientPaint;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">   </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        final Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 10000;</span><br><span class="line">          </span><br><span class="line">        int n &#x3D; 10000;</span><br><span class="line">  </span><br><span class="line">        Thread[] addThreads &#x3D; new Thread[n];</span><br><span class="line">        Thread[] reduceThreads &#x3D; new Thread[n];</span><br><span class="line">          </span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t &#x3D; new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                     </span><br><span class="line">                    &#x2F;&#x2F;recover自带synchronized</span><br><span class="line">                    gareen.recover();</span><br><span class="line">                     </span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] &#x3D; t;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t &#x3D; new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    &#x2F;&#x2F;hurt自带synchronized</span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                     </span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        for (Thread t : addThreads) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread t : reduceThreads) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.printf(&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;, n,n,gareen.hp);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-8-线程安全的类"><a class="header-anchor" href="#步骤-8-线程安全的类">¶</a>步骤 8 : 线程安全的类</h3>
<p>如果一个类，其<strong>方法都是有synchronized修饰的</strong>，那么该类就叫做<strong>线程安全的类</strong></p>
<p>同一时间，只有一个线程能够进入 <strong>这种类的一个实例</strong> 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)</p>
<p>比如StringBuffer和StringBuilder的区别<br>
StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类<br>
而StringBuilder就不是线程安全的类</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/793.png" alt></p>
<h3 id="步骤-9-练习-在类方法前面加修饰符synchronized"><a class="header-anchor" href="#步骤-9-练习-在类方法前面加修饰符synchronized">¶</a>步骤 9 : 练习-在类方法前面加修饰符synchronized</h3>
<p>[在对象方法前，加上修饰符synchronized]，同步对象是当前实例。<br>
那么如果在类方法前，加上修饰符 synchronized，同步对象是什么呢？</p>
<p>提示：要完成本练习，需要[反射reflection]的知识，如果未学习反射，可以暂时不做</p>
<h3 id="步骤-10-练习-线程安全的MyStack"><a class="header-anchor" href="#步骤-10-练习-线程安全的MyStack">¶</a>步骤 10 : 练习-线程安全的MyStack</h3>
<p>把[答案-使用LinkedList实现Stack栈] 中的MyStack类，改造为线程安全的类。</p>
<h2 id="4、常见的线程安全相关的面试题"><a class="header-anchor" href="#4、常见的线程安全相关的面试题">¶</a>4、常见的线程安全相关的面试题</h2>
<h3 id="步骤-1-HashMap和Hashtable的区别-v2"><a class="header-anchor" href="#步骤-1-HashMap和Hashtable的区别-v2">¶</a>步骤 1 : HashMap和Hashtable的区别</h3>
<p>HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式<br>
区别1：<br>
HashMap可以存放 null<br>
Hashtable不能存放null<br>
区别2：<br>
HashMap不是[线程安全的类]<br>
Hashtable是线程安全的类</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2595.png" alt></p>
<h3 id="步骤-2-StringBuffer和StringBuilder的区别"><a class="header-anchor" href="#步骤-2-StringBuffer和StringBuilder的区别">¶</a>步骤 2 : StringBuffer和StringBuilder的区别</h3>
<p>StringBuffer 是线程安全的<br>
StringBuilder 是非线程安全的</p>
<p>所以当进行大量字符串拼接操作的时候，如果是单线程就用StringBuilder会更快些，如果是多线程，就需要用StringBuffer 保证数据的安全性</p>
<p><strong>非线程安全的</strong>为什么会比<strong>线程安全的</strong> 快？ 因为不需要同步嘛，省略了些时间</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2596.png" alt></p>
<h3 id="步骤-3-ArrayList和Vector的区别"><a class="header-anchor" href="#步骤-3-ArrayList和Vector的区别">¶</a>步骤 3 : ArrayList和Vector的区别</h3>
<p>通过在[eclipse中查看源代码]可以得知：</p>
<p>ArrayList类的声明：</p>
<p>public class ArrayList<E> extends AbstractList<E></E></E></p>
<p>​        implements List<E>, RandomAccess, Cloneable, java.io.Serializable</E></p>
<p>Vector类的声明：</p>
<p>public class Vector<E>    extends AbstractList<E></E></E></p>
<p>​    implements List<E>, RandomAccess, Cloneable, java.io.Serializable</E></p>
<p>一模一样的~<br>
他们的区别也在于，Vector是线程安全的类，而ArrayList是非线程安全的。</p>
<h3 id="步骤-4-把非线程安全的集合转换为线程安全"><a class="header-anchor" href="#步骤-4-把非线程安全的集合转换为线程安全">¶</a>步骤 4 : 把非线程安全的集合转换为线程安全</h3>
<p>ArrayList是非线程安全的，换句话说，多个线程可以同时进入<strong>一个ArrayList对象</strong>的add方法</p>
<p>借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List。</p>
<p>与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都通过[工具类Collections]转换为线程安全的</p>
<h3 id="步骤-5-练习-线程安全的MyStack"><a class="header-anchor" href="#步骤-5-练习-线程安全的MyStack">¶</a>步骤 5 : 练习-线程安全的MyStack</h3>
<p>借助把非线程安全的集合转换为线程安全，用另一个方式完成 练习-线程安全的MyStack</p>
<p>把LinkedList通过 Collections.synchronizedList转换成了一个线程安全的List</p>
<p>List<Hero> heros = (List<Hero>) Collections.synchronizedList(new LinkedList<Hero>());</Hero></Hero></Hero></p>
<p>不需要在push上加synchronized修饰符<br>
虽然多个线程可以同时进入push方法，但是调用heros.add方法的时候<br>
同一时间，只有一个线程可以进入</p>
<p>public void push(Hero h) {</p>
<p>heros.add(h);</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">     </span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">     </span><br><span class="line">public class MyStack implements Stack&#123;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;把LinkedList通过 Collections.synchronizedList转换成了一个线程安全的List</span><br><span class="line">    List&lt;Hero&gt; heros &#x3D; (List&lt;Hero&gt;) Collections.synchronizedList(new LinkedList&lt;Hero&gt;());</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;不需要在push上加synchronized修饰符</span><br><span class="line">    &#x2F;&#x2F;虽然多个线程可以同时进入push方法，但是调用heros.add方法的时候</span><br><span class="line">    &#x2F;&#x2F;同一时间，只有一个线程可以进入</span><br><span class="line">    public void push(Hero h) &#123;</span><br><span class="line">        heros.add(h);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero pull() &#123;</span><br><span class="line">        return heros.remove(heros.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero peek() &#123;</span><br><span class="line">        return heros.get(heros.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、JAVA-演示多线程死锁"><a class="header-anchor" href="#5、JAVA-演示多线程死锁">¶</a>5、JAVA 演示多线程死锁</h2>
<h3 id="步骤-1-演示死锁"><a class="header-anchor" href="#步骤-1-演示死锁">¶</a>步骤 1 : 演示死锁</h3>
<ol>
<li>
<p>线程1 首先占有对象1，接着试图占有对象2</p>
</li>
<li>
<p>线程2 首先占有对象2，接着试图占有对象1</p>
</li>
<li>
<p>线程1 等待线程2释放对象2</p>
</li>
<li>
<p>与此同时，线程2等待线程1释放对象1</p>
<p>就会。。。一直等待下去，直到天荒地老，海枯石烂，山无棱 ，天地合。。。</p>
</li>
</ol>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/794.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">   </span><br><span class="line">import charactor.Hero;</span><br><span class="line">    </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Hero ahri &#x3D; new Hero();</span><br><span class="line">        ahri.name &#x3D; &quot;九尾妖狐&quot;;</span><br><span class="line">        final Hero annie &#x3D; new Hero();</span><br><span class="line">        annie.name &#x3D; &quot;安妮&quot;;</span><br><span class="line">         </span><br><span class="line">        Thread t1 &#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                &#x2F;&#x2F;占有九尾妖狐</span><br><span class="line">                synchronized (ahri) &#123;</span><br><span class="line">                    System.out.println(&quot;t1 已占有九尾妖狐&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F;停顿1000毫秒，另一个线程有足够的时间占有安妮</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    System.out.println(&quot;t1 试图占有安妮&quot;);</span><br><span class="line">                    System.out.println(&quot;t1 等待中 。。。。&quot;);</span><br><span class="line">                    synchronized (annie) &#123;</span><br><span class="line">                        System.out.println(&quot;do something&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 &#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                &#x2F;&#x2F;占有安妮</span><br><span class="line">                synchronized (annie) &#123;</span><br><span class="line">                    System.out.println(&quot;t2 已占有安妮&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                         </span><br><span class="line">                        &#x2F;&#x2F;停顿1000毫秒，另一个线程有足够的时间占有暂用九尾妖狐</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;t2 试图占有九尾妖狐&quot;);</span><br><span class="line">                    System.out.println(&quot;t2 等待中 。。。。&quot;);</span><br><span class="line">                    synchronized (ahri) &#123;</span><br><span class="line">                        System.out.println(&quot;do something&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-练习-死锁"><a class="header-anchor" href="#步骤-2-练习-死锁">¶</a>步骤 2 : 练习-死锁</h3>
<p>3个同步对象a, b, c<br>
3个线程 t1,t2,t3</p>
<p>故意设计场景，使这3个线程彼此死锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line">import charactor.Hero;</span><br><span class="line"></span><br><span class="line">public class TestThread &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Hero timo&#x3D;new Hero();</span><br><span class="line">		timo.name&#x3D;&quot;提莫&quot;;</span><br><span class="line">		Hero xiazi&#x3D;new Hero();</span><br><span class="line">		xiazi.name&#x3D;&quot;盲僧&quot;;</span><br><span class="line">		Hero jie&#x3D;new Hero();</span><br><span class="line">		jie.name&#x3D;&quot;劫&quot;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;1.创建第一个线程 t1</span><br><span class="line">		Thread t1&#x3D;new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;1.1占用提莫</span><br><span class="line">				synchronized (timo) &#123;</span><br><span class="line">					System.out.println(&quot;t1线程抢到了提莫!&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;t1线程想拥有盲僧!&quot;);</span><br><span class="line">					System.out.println(&quot;t1线程等待...&quot;);</span><br><span class="line">					synchronized (xiazi) &#123;</span><br><span class="line">						System.out.println(&quot;被其他线程占据中...&quot;);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t1.start();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;2.创建第二个线程 t2</span><br><span class="line">		Thread t2&#x3D;new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;2.1占用提莫</span><br><span class="line">				synchronized (xiazi) &#123;</span><br><span class="line">					System.out.println(&quot;t2线程抢到了盲僧!&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						&#x2F;&#x2F;2.2线程短暂睡眠</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;t2线程想拥有劫!&quot;);</span><br><span class="line">					System.out.println(&quot;t2线程等待...&quot;);</span><br><span class="line">					synchronized (jie) &#123;</span><br><span class="line">						System.out.println(&quot;被其他线程占据中...&quot;);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t2.start();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;3.创建第三个线程 t3</span><br><span class="line">		Thread t3&#x3D;new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;3.1占用劫</span><br><span class="line">				synchronized (jie) &#123;</span><br><span class="line">					System.out.println(&quot;t3线程抢到了劫!&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;t3线程想拥有提莫!&quot;);</span><br><span class="line">					System.out.println(&quot;t3线程等待...&quot;);</span><br><span class="line">					synchronized (timo) &#123;</span><br><span class="line">						System.out.println(&quot;被其他线程占据中...&quot;);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、JAVA-线程之间的交互-WAIT和NOTIFY"><a class="header-anchor" href="#6、JAVA-线程之间的交互-WAIT和NOTIFY">¶</a>6、JAVA 线程之间的交互 WAIT和NOTIFY</h2>
<h3 id="步骤-1-不好的解决方式"><a class="header-anchor" href="#步骤-1-不好的解决方式">¶</a>步骤 1 : 不好的解决方式</h3>
<p>故意设计减血线程频率更高，盖伦的血量迟早会到达1<br>
减血线程中<strong>使用while循环判断是否是1</strong>，如果是1就不停的循环,直到加血线程回复了血量<br>
这是不好的解决方式，因为会大量占用CPU,拖慢性能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">    </span><br><span class="line">import java.awt.GradientPaint;</span><br><span class="line">  </span><br><span class="line">import charactor.Hero;</span><br><span class="line">    </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        final Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 616;</span><br><span class="line">           </span><br><span class="line">        Thread t1 &#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                     </span><br><span class="line">                    &#x2F;&#x2F;因为减血更快，所以盖伦的血量迟早会到达1</span><br><span class="line">                    &#x2F;&#x2F;使用while循环判断是否是1，如果是1就不停的循环</span><br><span class="line">                    &#x2F;&#x2F;直到加血线程回复了血量</span><br><span class="line">                    while(gareen.hp&#x3D;&#x3D;1)&#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                    System.out.printf(&quot;t1 为%s 减血1点,减少血后，%s的血量是%.0f%n&quot;,gareen.name,gareen.name,gareen.hp);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"> </span><br><span class="line">        Thread t2 &#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    gareen.recover();</span><br><span class="line">                    System.out.printf(&quot;t2 为%s 回血1点,增加血后，%s的血量是%.0f%n&quot;,gareen.name,gareen.name,gareen.hp);</span><br><span class="line"> </span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public class Hero&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">      </span><br><span class="line">    public int damage;</span><br><span class="line">      </span><br><span class="line">    public synchronized void recover()&#123;</span><br><span class="line">        hp&#x3D;hp+1;</span><br><span class="line">    &#125;    </span><br><span class="line"> </span><br><span class="line">    public synchronized void hurt()&#123;</span><br><span class="line">            hp&#x3D;hp-1;   </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public void attackHero(Hero h) &#123;</span><br><span class="line">        h.hp-&#x3D;damage;</span><br><span class="line">        System.out.format(&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;,name,h.name,h.name,h.hp);</span><br><span class="line">        if(h.isDead())</span><br><span class="line">            System.out.println(h.name +&quot;死了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        return 0&gt;&#x3D;hp?true:false;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-使用wait和notify进行线程交互"><a class="header-anchor" href="#步骤-2-使用wait和notify进行线程交互">¶</a>步骤 2 : 使用wait和notify进行线程交互</h3>
<p>在Hero类中：hurt()减血方法：当hp=1的时候，执行this.wait().<br>
this.wait()<strong>表示 让占有this的线程等待，并临时释放占有</strong><br>
进入hurt方法的线程必然是减血线程，this.wait()会让减血线程临时释放对this的占有。 <strong>这样加血线程，就有机会进入recover()加血方法了</strong>。</p>
<p>recover() 加血方法：增加了血量，执行this.notify();<br>
this.notify() 表示通知那些<strong>等待在this的线程</strong>，可以苏醒过来了。 等待在this的线程，恰恰就是减血线程。 一旦recover()结束， 加血线程释放了this，减血线程，就可以重新占有this，并执行后面的减血工作。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/796.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line"> </span><br><span class="line">    public int damage;</span><br><span class="line"> </span><br><span class="line">    public synchronized void recover() &#123;</span><br><span class="line">        hp &#x3D; hp + 1;</span><br><span class="line">        System.out.printf(&quot;%s 回血1点,增加血后，%s的血量是%.0f%n&quot;, name, name, hp);</span><br><span class="line">        &#x2F;&#x2F; 通知那些等待在this对象上的线程，可以醒过来了，如第20行，等待着的减血线程，苏醒过来</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized void hurt() &#123;</span><br><span class="line">        if (hp &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 让占有this的减血线程，暂时释放对this的占有，并等待</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        hp &#x3D; hp - 1;</span><br><span class="line">        System.out.printf(&quot;%s 减血1点,减少血后，%s的血量是%.0f%n&quot;, name, name, hp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void attackHero(Hero h) &#123;</span><br><span class="line">        h.hp -&#x3D; damage;</span><br><span class="line">        System.out.format(&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;, name, h.name, h.name, h.hp);</span><br><span class="line">        if (h.isDead())</span><br><span class="line">            System.out.println(h.name + &quot;死了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        return 0 &gt;&#x3D; hp ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">      </span><br><span class="line">import java.awt.GradientPaint;</span><br><span class="line">    </span><br><span class="line">import charactor.Hero;</span><br><span class="line">      </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">        final Hero gareen &#x3D; new Hero();</span><br><span class="line">        gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">        gareen.hp &#x3D; 616;</span><br><span class="line">             </span><br><span class="line">        Thread t1 &#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                       </span><br><span class="line">                    &#x2F;&#x2F;无需循环判断</span><br><span class="line">&#x2F;&#x2F;                    while(gareen.hp&#x3D;&#x3D;1)&#123;</span><br><span class="line">&#x2F;&#x2F;                        continue;</span><br><span class="line">&#x2F;&#x2F;                    &#125;</span><br><span class="line">                       </span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                     </span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">   </span><br><span class="line">        Thread t2 &#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    gareen.recover();</span><br><span class="line">   </span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-关于wait、notify和notifyAll"><a class="header-anchor" href="#步骤-3-关于wait、notify和notifyAll">¶</a>步骤 3 : 关于wait、notify和notifyAll</h3>
<p>留意wait()和notify() 这两个方法是什么对象上的？</p>
<p>public synchronized void hurt() {</p>
<p>。。。</p>
<p>this.wait();</p>
<p>。。。</p>
<p>}</p>
<p>public synchronized void recover() {</p>
<p>。。。</p>
<p>this.notify();</p>
<p>}</p>
<p>这里需要强调的是，wait方法和notify方法，并<strong>不是Thread线程上的方法</strong>，它们是Object上的方法。</p>
<p>因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。</p>
<p>wait()的意思是： 让占用了这个同步对象的<strong>线程</strong>，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。</p>
<p>notify() 的意思是，通知<strong>一个</strong>等待在这个同步对象上的线程，<strong>你</strong>可以苏醒过来了，有机会重新占用当前对象了。</p>
<p>notifyAll() 的意思是，通知<strong>所有的</strong>等待在这个同步对象上的线程，<strong>你们</strong>可以苏醒过来了，有机会重新占用当前对象了。</p>
<h3 id="步骤-4-练习-线程交互"><a class="header-anchor" href="#步骤-4-练习-线程交互">¶</a>步骤 4 : 练习-线程交互</h3>
<p>假设加血线程运行得更加频繁，英雄的最大血量是1000</p>
<p>设计加血线程和减血线程的交互，让回血回满之后，加血线程等待，直到有减血线程减血</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">public class TestThread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Hero gareen&#x3D;new Hero();</span><br><span class="line">        gareen.name&#x3D;&quot;盖伦&quot;;</span><br><span class="line">        gareen.hp&#x3D;616;</span><br><span class="line">        Thread t1&#x3D;new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                        gareen.recover();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2&#x3D;new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                        gareen.hurt();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">      </span><br><span class="line">    public int damage;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;回血</span><br><span class="line">    &#x2F;&#x2F;直接在方法前加上修饰符synchronized</span><br><span class="line">    &#x2F;&#x2F;其所对应的同步对象，就是this</span><br><span class="line">    &#x2F;&#x2F;和hurt方法达到的效果一样</span><br><span class="line">    public synchronized void recover()&#123;</span><br><span class="line">        if(hp&#x3D;&#x3D;1000)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hp&#x3D;hp+1;</span><br><span class="line">        System.out.printf(&quot;%s 回血1点,增加血后，%s的血量是%.0f%n&quot;, name, name, hp);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;掉血</span><br><span class="line">    public synchronized void hurt()&#123;        </span><br><span class="line">            hp&#x3D;hp-1;        </span><br><span class="line">            System.out.printf(&quot;%s 减血1点,减少血后，%s的血量是%.0f%n&quot;, name, name, hp);</span><br><span class="line">            this.notify();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public void attackHero(Hero h) &#123;</span><br><span class="line">        h.hp-&#x3D;damage;</span><br><span class="line">        System.out.format(&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;, name, h.name, h.name, h.hp);</span><br><span class="line">        if(h.isDead())</span><br><span class="line">            System.out.println(h.name +&quot;死了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        return 0&gt;&#x3D;hp?true:false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-多线程交互"><a class="header-anchor" href="#步骤-5-练习-多线程交互">¶</a>步骤 5 : 练习-多线程交互</h3>
<p>在上面的练习的基础上，增加回血线程到2条，减血线程到5条，同时运行。</p>
<p>运行一段时间，观察会发生的错误，分析错误原因，并考虑解决办法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line">import charactor.*;</span><br><span class="line"></span><br><span class="line">public class TestThread &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		final Hero gareen &#x3D; new Hero();</span><br><span class="line">		gareen.name &#x3D; &quot;盖伦&quot;;</span><br><span class="line">		gareen.hp &#x3D; 616;</span><br><span class="line">		Thread[] addf&#x3D;new Thread[2];</span><br><span class="line">		Thread[] jianf&#x3D;new Thread[5];</span><br><span class="line">		for(int i&#x3D;0;i&lt;addf.length;i++) &#123;</span><br><span class="line">			Thread t1 &#x3D; new Thread() &#123;</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					while (true) &#123;</span><br><span class="line"></span><br><span class="line">						gareen.hurt();</span><br><span class="line"></span><br><span class="line">						try &#123;</span><br><span class="line">							Thread.sleep(100);</span><br><span class="line">						&#125; catch (InterruptedException e) &#123;</span><br><span class="line">							&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			t1.start();</span><br><span class="line">			addf[i]&#x3D;t1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;0;i&lt;jianf.length;i++) &#123;</span><br><span class="line">			Thread t2 &#x3D; new Thread() &#123;</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					while (true) &#123;</span><br><span class="line">						gareen.recover();</span><br><span class="line"></span><br><span class="line">						try &#123;</span><br><span class="line">							Thread.sleep(10);</span><br><span class="line">						&#125; catch (InterruptedException e) &#123;</span><br><span class="line">							&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			t2.start();</span><br><span class="line">			jianf[i]&#x3D;t2;</span><br><span class="line">		&#125;</span><br><span class="line">		for(Thread f:addf)&#123;</span><br><span class="line">			try&#123;</span><br><span class="line">				f.join();</span><br><span class="line">			&#125;catch (InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(Thread f2:jianf)&#123;</span><br><span class="line">			try&#123;</span><br><span class="line">				f2.join();</span><br><span class="line">			&#125;catch (InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-练习-生产者消费者问题"><a class="header-anchor" href="#步骤-6-练习-生产者消费者问题">¶</a>步骤 6 : 练习-生产者消费者问题</h3>
<p>生产者消费者问题是一个非常典型性的线程交互的问题。</p>
<ol>
<li>
<p>使用[栈]来存放数据<br>
1.1 把栈改造为支持线程安全<br>
1.2 把栈的边界操作进行处理，当栈里的数据是0的时候，访问pull的线程就会等待。 当栈里的数据是200的时候，访问push的线程就会等待</p>
</li>
<li>
<p>提供一个生产者（Producer）线程类，生产随机大写字符压入到堆栈</p>
</li>
<li>
<p>提供一个消费者（Consumer）线程类，从堆栈中弹出字符并打印到控制台</p>
</li>
<li>
<p>提供一个测试类，使两个生产者和三个消费者线程同时运行，结果类似如下 ：</p>
</li>
</ol>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2591.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.Vector;</span><br><span class="line"></span><br><span class="line">public class TestThread &#123;</span><br><span class="line"></span><br><span class="line">	class MyStack&#123;</span><br><span class="line">		Vector&lt;Character&gt; v&#x3D;new Vector&lt;Character&gt;();&#x2F;&#x2F;vecotr是线程安全的类</span><br><span class="line"></span><br><span class="line">		public synchronized void push(char c)&#123;</span><br><span class="line">			v.addElement(c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public synchronized char peek()&#123;</span><br><span class="line">			int size&#x3D;v.size();</span><br><span class="line">			if(size&#x3D;&#x3D;0)&#123;</span><br><span class="line">				throw new EmptyStackException();</span><br><span class="line">			&#125;</span><br><span class="line">			return v.get(size-1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public synchronized char pop()&#123;</span><br><span class="line">			int size&#x3D;v.size();</span><br><span class="line">			char ans&#x3D;peek();</span><br><span class="line">			v.removeElementAt(size-1);</span><br><span class="line">			return ans;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public synchronized int size() &#123;&#x2F;&#x2F;没有synchronized会报错</span><br><span class="line">			&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">			return v.size();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class Producer extends Thread&#123;</span><br><span class="line">		MyStack stack&#x3D;new MyStack();</span><br><span class="line">		String name;</span><br><span class="line"></span><br><span class="line">		public Producer(String name)&#123;</span><br><span class="line">			this.name&#x3D;name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public Producer()&#123;&#125;</span><br><span class="line"></span><br><span class="line">		public synchronized void run()&#123;</span><br><span class="line">			Random r&#x3D;new Random();</span><br><span class="line">			char c;</span><br><span class="line">			while(true)&#123;</span><br><span class="line">				c&#x3D;(char)(r.nextInt(27)+65);</span><br><span class="line">				try&#123;</span><br><span class="line">					Thread.sleep(100);</span><br><span class="line">				&#125;catch(InterruptedException e)&#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				while(stack.size()&#x3D;&#x3D;200)&#123;</span><br><span class="line">					try&#123;</span><br><span class="line">						this.wait();</span><br><span class="line">					&#125;catch(InterruptedException e)&#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				stack.push(c);</span><br><span class="line">				System.out.println(name+&quot;压入：&quot;+c);</span><br><span class="line">				this.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class Consumer extends Thread&#123;</span><br><span class="line">		MyStack stack&#x3D;new MyStack();</span><br><span class="line">		String name;</span><br><span class="line"></span><br><span class="line">		public Consumer()&#123;&#125;</span><br><span class="line"></span><br><span class="line">		public Consumer(String name)&#123;</span><br><span class="line">			this.name&#x3D;name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public synchronized void run()&#123;</span><br><span class="line">			char c;</span><br><span class="line">			while(true)&#123;</span><br><span class="line">				try&#123;</span><br><span class="line">					Thread.sleep(100);</span><br><span class="line">				&#125;catch(InterruptedException e)&#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				while(stack.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">					try&#123;</span><br><span class="line">						this.wait();</span><br><span class="line">					&#125;catch(InterruptedException e)&#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				c&#x3D;stack.pop();</span><br><span class="line">				System.out.println(name+&quot;弹出：&quot;+c);</span><br><span class="line">				this.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		TestThread t&#x3D;new TestThread();</span><br><span class="line">		MyStack stack&#x3D;t.new MyStack();</span><br><span class="line">		Producer p1&#x3D;t.new Producer(&quot;p1&quot;);</span><br><span class="line">		Producer p2&#x3D;t.new Producer(&quot;p2&quot;);</span><br><span class="line">		Consumer c1&#x3D;t.new Consumer(&quot;c1&quot;);</span><br><span class="line">		Consumer c2&#x3D;t.new Consumer(&quot;c2&quot;);</span><br><span class="line">		Consumer c3&#x3D;t.new Consumer(&quot;c3&quot;);</span><br><span class="line"></span><br><span class="line">		p1.stack&#x3D;p2.stack&#x3D;c1.stack&#x3D;c2.stack&#x3D;c3.stack&#x3D;stack;</span><br><span class="line"></span><br><span class="line">		p1.start();</span><br><span class="line">		p2.start();</span><br><span class="line">		c1.start();</span><br><span class="line">		c2.start();</span><br><span class="line">		c3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、JAVA-如何开发一个自定义线程池"><a class="header-anchor" href="#7、JAVA-如何开发一个自定义线程池">¶</a>7、JAVA 如何开发一个自定义线程池</h2>
<h3 id="步骤-1-线程池设计思路"><a class="header-anchor" href="#步骤-1-线程池设计思路">¶</a>步骤 1 : 线程池设计思路</h3>
<p>线程池的思路和[生产者消费者模型]是很接近的。</p>
<ol>
<li>
<p>准备一个任务容器</p>
</li>
<li>
<p>一次性启动10个 消费者线程</p>
</li>
<li>
<p>刚开始任务容器是空的，所以线程都<strong>wait</strong>在上面。</p>
</li>
<li>
<p>直到一个外部线程往这个任务容器中扔了一个“任务”，就会有一个消费者线程被[唤醒notify]</p>
</li>
<li>
<p>这个消费者线程取出“任务”，并且<strong>执行这个任务</strong>，执行完毕后，继续等待下一次任务的到来。</p>
</li>
<li>
<p>如果短时间内，有较多的任务加入，那么就会有多个线程被<strong>唤醒</strong>，去执行这些任务。</p>
</li>
</ol>
<p>在整个过程中，都不需要创建新的线程，而是<strong>循环使用这些已经存在的线程</strong></p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2600.png" alt></p>
<h3 id="步骤-2-开发一个自定义线程池"><a class="header-anchor" href="#步骤-2-开发一个自定义线程池">¶</a>步骤 2 : 开发一个自定义线程池</h3>
<p>这是一个自定义的线程池，虽然不够完善和健壮，但是已经足以说明线程池的工作原理</p>
<p>缓慢的给这个线程池添加任务，会看到有多条线程来执行这些任务。<br>
线程7执行完毕任务后，<strong>又回到池子里</strong>，下一次任务来的时候，线程7又来执行新的任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">  </span><br><span class="line">public class ThreadPool &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 线程池大小</span><br><span class="line">    int threadPoolSize;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 任务容器</span><br><span class="line">    LinkedList&lt;Runnable&gt; tasks &#x3D; new LinkedList&lt;Runnable&gt;();</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 试图消费任务的线程</span><br><span class="line">  </span><br><span class="line">    public ThreadPool() &#123;</span><br><span class="line">        threadPoolSize &#x3D; 10;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 启动10个任务消费者线程</span><br><span class="line">        synchronized (tasks) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; threadPoolSize; i++) &#123;</span><br><span class="line">                new TaskConsumeThread(&quot;任务消费者线程 &quot; + i).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void add(Runnable r) &#123;</span><br><span class="line">        synchronized (tasks) &#123;</span><br><span class="line">            tasks.add(r);</span><br><span class="line">            &#x2F;&#x2F; 唤醒等待的任务消费者线程</span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    class TaskConsumeThread extends Thread &#123;</span><br><span class="line">        public TaskConsumeThread(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        Runnable task;</span><br><span class="line">  </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;启动： &quot; + this.getName());</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (tasks) &#123;</span><br><span class="line">                    while (tasks.isEmpty()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            tasks.wait();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task &#x3D; tasks.removeLast();</span><br><span class="line">                    &#x2F;&#x2F; 允许添加任务的线程可以继续添加任务</span><br><span class="line">                    tasks.notifyAll();</span><br><span class="line">  </span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(this.getName() + &quot; 获取到任务，并执行&quot;);</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadPool pool &#x3D; new ThreadPool();</span><br><span class="line">  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Runnable task &#x3D; new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    &#x2F;&#x2F;System.out.println(&quot;执行任务&quot;);</span><br><span class="line">                    &#x2F;&#x2F;任务可能是打印一句话</span><br><span class="line">                    &#x2F;&#x2F;可能是访问文件</span><br><span class="line">                    &#x2F;&#x2F;可能是做排序</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">             </span><br><span class="line">            pool.add(task);</span><br><span class="line">             </span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-测试线程池"><a class="header-anchor" href="#步骤-3-测试线程池">¶</a>步骤 3 : 测试线程池</h3>
<p>创造一个情景，每个任务执行的时间都是1秒<br>
刚开始是间隔1秒钟向线程池中添加任务</p>
<p>然后间隔时间越来越短，执行任务的线程还没有来得及结束，新的任务又来了。<br>
就会观察到线程池里的其他线程被唤醒来执行这些任务</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2601.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadPool pool&#x3D; new ThreadPool();</span><br><span class="line">        int sleep&#x3D;1000;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            pool.add(new Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    &#x2F;&#x2F;System.out.println(&quot;执行任务&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(sleep);</span><br><span class="line">                sleep &#x3D; sleep&gt;100?sleep-100:sleep;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-使用java自带线程池"><a class="header-anchor" href="#步骤-4-使用java自带线程池">¶</a>步骤 4 : 使用java自带线程池</h3>
<p>java提供自带的线程池，而不需要自己去开发一个自定义线程池了。</p>
<p>线程池类<strong>ThreadPoolExecutor</strong>在包<strong>java.util.concurrent</strong></p>
<p>ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());</Runnable></p>
<p><strong>第一个</strong>参数10 表示这个线程池<strong>初始化了10个</strong>线程在里面工作<br>
<strong>第二个</strong>参数15 表示如果10个线程不够用了，就会自动增加到<strong>最多15个线程</strong><br>
<strong>第三个</strong>参数60 结合第四个参数TimeUnit.SECONDS，表示经过<strong>60秒</strong>，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个<br>
<strong>第四个</strong>参数TimeUnit.SECONDS 如上<br>
<strong>第五个</strong>参数 new LinkedBlockingQueue() 用来放任务的集合</p>
<p><strong>execute</strong>方法用于添加新的任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">   </span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">   </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">           </span><br><span class="line">        ThreadPoolExecutor threadPool&#x3D; new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">           </span><br><span class="line">        threadPool.execute(new Runnable()&#123;</span><br><span class="line">   </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">                System.out.println(&quot;任务1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">               </span><br><span class="line">        &#125;);</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-借助线程池同步查找文件内容"><a class="header-anchor" href="#步骤-5-练习-借助线程池同步查找文件内容">¶</a>步骤 5 : 练习- 借助线程池同步查找文件内容</h3>
<p>在 [练习-同步查找文件内容] ，如果文件特别多，就会创建很多的线程。 改写这个练习，使用线程池的方式来完成。</p>
<p>初始化一个大小是10的线程池</p>
<p>遍历所有文件，当遍历到文件是.java的时候，创建一个查找文件的任务，把这个任务<strong>扔进线程池</strong>去执行，继续遍历下一个文件</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2604.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class SearchFileTask implements Runnable&#123;</span><br><span class="line"> </span><br><span class="line">    private File file;</span><br><span class="line">    private String search;</span><br><span class="line">    public SearchFileTask(File file,String search) &#123;</span><br><span class="line">        this.file &#x3D; file;</span><br><span class="line">        this.search&#x3D; search;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run()&#123;</span><br><span class="line">         </span><br><span class="line">        String fileContent &#x3D; readFileConent(file);</span><br><span class="line">        if(fileContent.contains(search))&#123;</span><br><span class="line">            System.out.printf( &quot;线程: %s 找到子目标字符串%s,在文件:%s%n&quot;,Thread.currentThread().getName(), search,file);</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public String readFileConent(File file)&#123;</span><br><span class="line">        try (FileReader fr &#x3D; new FileReader(file)) &#123;</span><br><span class="line">            char[] all &#x3D; new char[(int) file.length()];</span><br><span class="line">            fr.read(all);</span><br><span class="line">            return new String(all);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">  </span><br><span class="line">public class ThreadPool &#123;</span><br><span class="line">    &#x2F;&#x2F; 线程池大小</span><br><span class="line">    int threadPoolSize;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 任务容器</span><br><span class="line">    LinkedList&lt;Runnable&gt; tasks &#x3D; new LinkedList&lt;Runnable&gt;();</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 试图消费任务的线程</span><br><span class="line">  </span><br><span class="line">    public ThreadPool() &#123;</span><br><span class="line">        threadPoolSize &#x3D; 10;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 启动10个任务消费者线程</span><br><span class="line">        synchronized (tasks) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; threadPoolSize; i++) &#123;</span><br><span class="line">                new TaskConsumeThread(&quot;任务消费者线程 &quot; + i).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void add(Runnable r) &#123;</span><br><span class="line">        synchronized (tasks) &#123;</span><br><span class="line">            tasks.add(r);</span><br><span class="line">            &#x2F;&#x2F; 唤醒等待的任务消费者线程</span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    class TaskConsumeThread extends Thread &#123;</span><br><span class="line">        public TaskConsumeThread(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        Runnable task;</span><br><span class="line">  </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (tasks) &#123;</span><br><span class="line">                    while (tasks.isEmpty()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            tasks.wait();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task &#x3D; tasks.removeLast();</span><br><span class="line">                    &#x2F;&#x2F; 允许添加任务的线程可以继续添加任务</span><br><span class="line">                    tasks.notifyAll();</span><br><span class="line">  </span><br><span class="line">                &#125;</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">   </span><br><span class="line">import java.io.File;</span><br><span class="line">   </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">   </span><br><span class="line">    static ThreadPool pool&#x3D; new ThreadPool();</span><br><span class="line">    public static void search(File file, String search) &#123;</span><br><span class="line">         </span><br><span class="line">        if (file.isFile()) &#123;</span><br><span class="line">            if(file.getName().toLowerCase().endsWith(&quot;.java&quot;))&#123;</span><br><span class="line">                SearchFileTask task &#x3D; new SearchFileTask(file, search);</span><br><span class="line">                pool.add(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (file.isDirectory()) &#123;</span><br><span class="line">            File[] fs &#x3D; file.listFiles();</span><br><span class="line">            for (File f : fs) &#123;</span><br><span class="line">                search(f, search);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File folder &#x3D;new File(&quot;e:\\project&quot;);</span><br><span class="line">        search(folder,&quot;Magic&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、LOCK对象"><a class="header-anchor" href="#8、LOCK对象">¶</a>8、LOCK对象</h2>
<h3 id="步骤-1-回忆-synchronized-同步的方式"><a class="header-anchor" href="#步骤-1-回忆-synchronized-同步的方式">¶</a>步骤 1 : 回忆 synchronized 同步的方式</h3>
<p>首先回忆一下 [synchronized 同步对象]的方式</p>
<p>当一个线程占用 synchronized 同步对象，其他线程就不能占用了，直到释放这个同步对象为止</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2610.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">   </span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">    </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">      </span><br><span class="line">    public static String now()&#123;</span><br><span class="line">        return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Object someObject &#x3D; new Object();</span><br><span class="line">           </span><br><span class="line">        Thread t1 &#x3D; new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println( now()+&quot; t1 线程已经运行&quot;);</span><br><span class="line">                    System.out.println( now()+this.getName()+ &quot; 试图占有对象：someObject&quot;);</span><br><span class="line">                    synchronized (someObject) &#123;</span><br><span class="line">                           </span><br><span class="line">                        System.out.println( now()+this.getName()+ &quot; 占有对象：someObject&quot;);</span><br><span class="line">                        Thread.sleep(5000);</span><br><span class="line">                        System.out.println( now()+this.getName()+ &quot; 释放对象：someObject&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(now()+&quot; t1 线程结束&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(&quot; t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 &#x3D; new Thread()&#123;</span><br><span class="line">   </span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println( now()+&quot; t2 线程已经运行&quot;);</span><br><span class="line">                    System.out.println( now()+this.getName()+ &quot; 试图占有对象：someObject&quot;);</span><br><span class="line">                    synchronized (someObject) &#123;</span><br><span class="line">                        System.out.println( now()+this.getName()+ &quot; 占有对象：someObject&quot;);</span><br><span class="line">                        Thread.sleep(5000);</span><br><span class="line">                        System.out.println( now()+this.getName()+ &quot; 释放对象：someObject&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(now()+&quot; t2 线程结束&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(&quot; t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-使用Lock对象实现同步效果"><a class="header-anchor" href="#步骤-2-使用Lock对象实现同步效果">¶</a>步骤 2 : 使用Lock对象实现同步效果</h3>
<p>Lock是一个接口，为了使用一个Lock对象，需要用到</p>
<p>Lock lock = new ReentrantLock();</p>
<p>与 <strong>synchronized (someObject)</strong> 类似的，<strong>lock()<strong>方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。<br>
与 <strong>synchronized</strong> 不同的是，一旦synchronized 块结束，就会自动释放对</strong>someObject</strong>的占用。 lock却必须调用<strong>unlock</strong>方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2611.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">    public static String now() &#123;</span><br><span class="line">        return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void log(String msg) &#123;</span><br><span class="line">        System.out.printf(&quot;%s %s %s %n&quot;, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">        Thread t1 &#x3D; new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"> </span><br><span class="line">                    lock.lock();</span><br><span class="line"> </span><br><span class="line">                    log(&quot;占有对象：lock&quot;);</span><br><span class="line">                    log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line"> </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    log(&quot;释放对象：lock&quot;);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;先让t1飞2秒</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t2 &#x3D; new Thread() &#123;</span><br><span class="line"> </span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"> </span><br><span class="line">                    lock.lock();</span><br><span class="line"> </span><br><span class="line">                    log(&quot;占有对象：lock&quot;);</span><br><span class="line">                    log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line"> </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    log(&quot;释放对象：lock&quot;);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-trylock方法"><a class="header-anchor" href="#步骤-3-trylock方法">¶</a>步骤 3 : trylock方法</h3>
<p>synchronized 是<strong>不占用到手不罢休</strong>的，会一直试图占用下去。<br>
与 synchronized 的<strong>钻牛角尖</strong>不一样，Lock接口还提供了一个trylock方法。<br>
trylock会在指定时间范围内<strong>试图占用</strong>，占成功了，就啪啪啪。 如果时间到了，还占用不成功，扭头就走~</p>
<p>注意： 因为使用trylock有可能成功，有可能失败，所以后面unlock释放锁的时候，需要判断是否占用成功了，如果没占用成功也unlock,就会抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">    public static String now() &#123;</span><br><span class="line">        return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void log(String msg) &#123;</span><br><span class="line">        System.out.printf(&quot;%s %s %s %n&quot;, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">        Thread t1 &#x3D; new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                boolean locked &#x3D; false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"> </span><br><span class="line">                    locked &#x3D; lock.tryLock(1,TimeUnit.SECONDS);</span><br><span class="line">                    if(locked)&#123;</span><br><span class="line">                        log(&quot;占有对象：lock&quot;);</span><br><span class="line">                        log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                        Thread.sleep(5000);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        log(&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                     </span><br><span class="line">                    if(locked)&#123;</span><br><span class="line">                        log(&quot;释放对象：lock&quot;);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;先让t1飞2秒</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t2 &#x3D; new Thread() &#123;</span><br><span class="line"> </span><br><span class="line">            public void run() &#123;</span><br><span class="line">                boolean locked &#x3D; false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"> </span><br><span class="line">                    locked &#x3D; lock.tryLock(1,TimeUnit.SECONDS);</span><br><span class="line">                    if(locked)&#123;</span><br><span class="line">                        log(&quot;占有对象：lock&quot;);</span><br><span class="line">                        log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                        Thread.sleep(5000);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        log(&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                     </span><br><span class="line">                    if(locked)&#123;</span><br><span class="line">                        log(&quot;释放对象：lock&quot;);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-线程交互"><a class="header-anchor" href="#步骤-4-线程交互">¶</a>步骤 4 : 线程交互</h3>
<p>使用synchronized方式进行线程交互，用到的是同步对象的wait,notify和notifyAll方法</p>
<p>Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：<strong>await</strong>, <strong>signal</strong>,<strong>signalAll</strong> 方法</p>
<p><strong>注意</strong>： 不是Condition对象的wait,nofity,notifyAll方法,是await,signal,signalAll</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2617.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">  </span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">  </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">  </span><br><span class="line">    public static String now() &#123;</span><br><span class="line">        return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public static void log(String msg) &#123;</span><br><span class="line">        System.out.printf(&quot;%s %s %s %n&quot;, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">        Condition condition &#x3D; lock.newCondition();</span><br><span class="line">         </span><br><span class="line">        Thread t1 &#x3D; new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line">  </span><br><span class="line">                    lock.lock();</span><br><span class="line">  </span><br><span class="line">                    log(&quot;占有对象：lock&quot;);</span><br><span class="line">                    log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                    log(&quot;临时释放对象 lock， 并等待&quot;);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    log(&quot;重新占有对象 lock，并进行5秒的业务操作&quot;);</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">  </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    log(&quot;释放对象：lock&quot;);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;先让t1飞2秒</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t2 &#x3D; new Thread() &#123;</span><br><span class="line">  </span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line">  </span><br><span class="line">                    lock.lock();</span><br><span class="line">  </span><br><span class="line">                    log(&quot;占有对象：lock&quot;);</span><br><span class="line">                    log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                    log(&quot;唤醒等待中的线程&quot;);</span><br><span class="line">                    condition.signal();</span><br><span class="line">  </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    log(&quot;释放对象：lock&quot;);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-总结Lock和synchronized的区别"><a class="header-anchor" href="#步骤-5-总结Lock和synchronized的区别">¶</a>步骤 5 : 总结Lock和synchronized的区别</h3>
<ol>
<li>
<p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。</p>
</li>
<li>
<p>Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。</p>
</li>
<li>
<p>synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。</p>
</li>
</ol>
<h3 id="步骤-6-练习-借助Lock，把MyStack修改为线程安全的类"><a class="header-anchor" href="#步骤-6-练习-借助Lock，把MyStack修改为线程安全的类">¶</a>步骤 6 : 练习-借助Lock，把MyStack修改为线程安全的类</h3>
<p>在[练习-线程安全的MyStack ]练习中，使用synchronized把MyStack修改为了线程安全的类。</p>
<p>接下来，借助Lock把MyStack修改为线程安全的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import charactor.*;</span><br><span class="line">import jdk.nashorn.internal.runtime.regexp.joni.constants.StackType;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line">public class clock_mystack implements StackType&#123;</span><br><span class="line"> </span><br><span class="line">    private static LinkedList&lt;Hero&gt; ll&#x3D;new LinkedList&lt;Hero&gt;();</span><br><span class="line">    private Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">    public void push(Hero h) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            ll.addLast(h);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#x2F;&#x2F;unlock释放锁操作必须放在finally执行，万一heros.addLast抛出异常也会执行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Hero pull() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            return ll.removeLast();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Hero peek() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            return ll.peekLast();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-练习-借助tryLock-解决死锁问题"><a class="header-anchor" href="#步骤-7-练习-借助tryLock-解决死锁问题">¶</a>步骤 7 : 练习-借助tryLock 解决死锁问题</h3>
<p>当多个线程按照不同顺序占用多个同步对象的时候，就有可能产生[死锁]现象。</p>
<p>[死锁]之所以会发生，就是因为synchronized 如果占用不到同步对象，就会苦苦的一直等待下去，借助tryLock的有限等待时间，解决死锁问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class TestTryLock &#123;</span><br><span class="line">	private static Lock lockB;</span><br><span class="line">	private static Lock lockA;</span><br><span class="line">	static Condition conditionA;</span><br><span class="line">	public static String now() &#123;</span><br><span class="line">		return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());</span><br><span class="line">	&#125;</span><br><span class="line">	public static void log(String msg) &#123;</span><br><span class="line">		System.out.println(now()+&quot;: &quot;+Thread.currentThread().getName()+msg);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		lockA &#x3D; new ReentrantLock();</span><br><span class="line">		lockB &#x3D; new ReentrantLock();</span><br><span class="line">		conditionA&#x3D;lockA.newCondition();</span><br><span class="line">		Thread t1&#x3D;new Thread() &#123;  &#x2F;&#x2F;线程t1</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				boolean aLock&#x3D;false;</span><br><span class="line">				boolean bLock&#x3D;false;</span><br><span class="line">				try &#123;</span><br><span class="line">					log(&quot;准备获取锁A&quot;);</span><br><span class="line">					aLock&#x3D;lockA.tryLock(2, TimeUnit.SECONDS);</span><br><span class="line">					if(aLock) &#123;</span><br><span class="line">						log(&quot;获取了锁A&quot;);</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">						log(&quot;准备获取锁B&quot;);</span><br><span class="line">						bLock&#x3D;lockB.tryLock(1, TimeUnit.SECONDS);</span><br><span class="line">						while(!bLock) &#123;</span><br><span class="line">							log(&quot;无法获取锁B&quot;);</span><br><span class="line">							log(&quot;临时释放锁A，并等待&quot;);</span><br><span class="line">							aLock&#x3D;false;</span><br><span class="line">							conditionA.await();</span><br><span class="line">							aLock&#x3D;true;</span><br><span class="line">							log(&quot;重新获取了锁A&quot;);</span><br><span class="line">							bLock&#x3D;lockB.tryLock(1, TimeUnit.SECONDS);</span><br><span class="line">						&#125;</span><br><span class="line">						log(&quot;获取了锁B&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						log(&quot;无法获取锁A，放弃&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;finally &#123;</span><br><span class="line">					if(aLock) &#123;</span><br><span class="line">						log(&quot;释放锁A&quot;);</span><br><span class="line">						lockA.unlock();</span><br><span class="line">					&#125;</span><br><span class="line">					if(bLock) &#123;</span><br><span class="line">						log(&quot;释放锁B&quot;);</span><br><span class="line">						lockB.unlock();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t1.setName(&quot;t1&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread t2&#x3D;new Thread() &#123;  &#x2F;&#x2F;线程t2</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				boolean aLock&#x3D;false;</span><br><span class="line">				boolean bLock&#x3D;false;</span><br><span class="line">				try &#123;</span><br><span class="line">					log(&quot;准备获取锁B&quot;);</span><br><span class="line">					bLock&#x3D;lockB.tryLock(2, TimeUnit.SECONDS);</span><br><span class="line">					if(bLock) &#123;</span><br><span class="line">						log(&quot;获取了锁B&quot;);</span><br><span class="line">						Thread.sleep(500);</span><br><span class="line">						log(&quot;准备获取锁A&quot;);</span><br><span class="line">						aLock&#x3D;lockA.tryLock(1,TimeUnit.SECONDS);</span><br><span class="line">						while(!aLock) &#123;</span><br><span class="line">							log(&quot;无法获取锁A&quot;);</span><br><span class="line">							aLock&#x3D;lockA.tryLock(1,TimeUnit.SECONDS);</span><br><span class="line">						&#125;</span><br><span class="line">						log(&quot;获取了锁A&quot;);</span><br><span class="line">						conditionA.signal();</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						log(&quot;无法获取锁B&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;finally &#123;</span><br><span class="line">					if(aLock) &#123;</span><br><span class="line">						log(&quot;释放锁A&quot;);</span><br><span class="line">						lockA.unlock();</span><br><span class="line">					&#125;</span><br><span class="line">					if(bLock) &#123;</span><br><span class="line">						log(&quot;释放锁B&quot;);</span><br><span class="line">						lockB.unlock();</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t2.setName(&quot;t2&quot;);</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-8-练习-生产者消费者问题"><a class="header-anchor" href="#步骤-8-练习-生产者消费者问题">¶</a>步骤 8 : 练习-生产者消费者问题</h3>
<p>在[练习-生产者消费者问题]这个练习中，是用wait(), notify(), notifyAll实现了。</p>
<p>接下来使用Condition对象的：<strong>await</strong>, <strong>signal</strong>,<strong>signalAll</strong> 方法实现同样的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line">public class MyStack&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    LinkedList&lt;T&gt; values &#x3D; new LinkedList&lt;T&gt;();</span><br><span class="line"> </span><br><span class="line">    Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    Condition condition &#x3D; lock.newCondition();</span><br><span class="line"> </span><br><span class="line">    public void push(T t) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while (values.size() &gt;&#x3D; 200) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            values.addLast(t);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public T pull() &#123;</span><br><span class="line">        T t&#x3D;null;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while (values.isEmpty()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            t&#x3D; values.removeLast();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public T peek() &#123;</span><br><span class="line">        return values.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、原子访问"><a class="header-anchor" href="#9、原子访问">¶</a>9、原子访问</h2>
<h3 id="步骤-1-原子性操作概念"><a class="header-anchor" href="#步骤-1-原子性操作概念">¶</a>步骤 1 : 原子性操作概念</h3>
<p>所谓的<strong>原子性操作</strong>即不可中断的操作，比如赋值操作</p>
<p>int i = 5;</p>
<p><strong>原子性操作本身是线程安全的</strong><br>
但是 i++ 这个行为，事实上是有3个原子性操作组成的。<br>
步骤 1. 取 i 的值<br>
步骤 2. i + 1<br>
步骤 3. 把新的值赋予i<br>
这三个步骤，每一步都是一个原子操作，但是合在一起，就不是原子操作。就<strong>不是线程安全</strong>的。<br>
换句话说，一个线程在步骤1 取i 的值结束后，还没有来得及进行步骤2，另一个线程也可以取 i的值了。<br>
这也是[分析同步问题产生的原因] 中的原理。<br>
i++ ，i–， i = i+1 这些都是非原子性操作。<br>
只有int i = 1,这个赋值操作是原子性的。</p>
<h3 id="步骤-2-AtomicInteger"><a class="header-anchor" href="#步骤-2-AtomicInteger">¶</a>步骤 2 : AtomicInteger</h3>
<p>JDK6 以后，新增加了一个包<strong>java.util.concurrent.atomic</strong>，里面有各种原子类，比如<strong>AtomicInteger</strong>。<br>
而AtomicInteger提供了各种自增，自减等方法，这些方法都是原子性的。 换句话说，自增方法<strong>incrementAndGet</strong> 是线程安全的，同一个时间，只有一个线程可以调用这个方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line">   </span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">   </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        AtomicInteger atomicI &#x3D;new AtomicInteger();</span><br><span class="line">        int i &#x3D; atomicI.decrementAndGet();</span><br><span class="line">        int j &#x3D; atomicI.incrementAndGet();</span><br><span class="line">        int k &#x3D; atomicI.addAndGet(3);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-同步测试"><a class="header-anchor" href="#步骤-3-同步测试">¶</a>步骤 3 : 同步测试</h3>
<p>分别使用基本变量的非原子性的**++<strong>运算符和 原子性的</strong>AtomicInteger对象的 incrementAndGet** 来进行多线程测试。<br>
测试结果如图所示</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2626.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"> </span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line">    </span><br><span class="line">    private static int value &#x3D; 0;</span><br><span class="line">    private static AtomicInteger atomicValue &#x3D;new AtomicInteger();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int number &#x3D; 100000;</span><br><span class="line">        Thread[] ts1 &#x3D; new Thread[number];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; number; i++) &#123;</span><br><span class="line">            Thread t &#x3D;new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    value++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts1[i] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;等待这些线程全部结束</span><br><span class="line">        for (Thread t : ts1) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.printf(&quot;%d个线程进行value++后，value的值变成:%d%n&quot;, number,value);</span><br><span class="line">        Thread[] ts2 &#x3D; new Thread[number];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; number; i++) &#123;</span><br><span class="line">            Thread t &#x3D;new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    atomicValue.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts2[i] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;等待这些线程全部结束</span><br><span class="line">        for (Thread t : ts2) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;%d个线程进行atomicValue.incrementAndGet();后，atomicValue的值变成:%d%n&quot;, number,atomicValue.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-使用AtomicInteger来替换Hero类中的synchronized"><a class="header-anchor" href="#步骤-4-练习-使用AtomicInteger来替换Hero类中的synchronized">¶</a>步骤 4 : 练习-使用AtomicInteger来替换Hero类中的synchronized</h3>
<p>在[给Hero的方法加上修饰符synchronized]这个知识点中，通过给hurt和 recover方法加上synchronized来达到线程安全的效果。</p>
<p>这一次换成使用AtomicInteger来解决这个问题</p>
<p><strong>提示</strong>：int基本类型对应的是AtomicInteger，但是float基本类型没有对应的AtomicFloat。 所以在这个练习中，把hp改为AtomicInteger即可。</p>
<h1 id="七、JDBC"><a class="header-anchor" href="#七、JDBC">¶</a>七、JDBC</h1>
<h2 id="1、JAVA-使用JDBC之前，先要准备MYSQL"><a class="header-anchor" href="#1、JAVA-使用JDBC之前，先要准备MYSQL">¶</a>1、JAVA 使用JDBC之前，先要准备MYSQL</h2>
<h3 id="步骤-1-MySQL"><a class="header-anchor" href="#步骤-1-MySQL">¶</a>步骤 1 : MySQL</h3>
<p><strong>Mysql</strong>是常见的数据库,在中小型网站经常被使用。<br>
如果以前没有接触过Mysql,请参考 [MySQL入门] 章节的学习<br>
其中包含了[mysql 服务器安装]，[客户端安装]，[创建数据库]，[创建表]，以及[常用的sql语句]</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/855.png" alt></p>
<h2 id="2、教程"><a class="header-anchor" href="#2、教程">¶</a>2、教程</h2>
<h3 id="步骤-1-为项目导入mysql-jdbc的jar包"><a class="header-anchor" href="#步骤-1-为项目导入mysql-jdbc的jar包">¶</a>步骤 1 : 为项目导入mysql-jdbc的jar包</h3>
<p>访问MySQL数据库需要用到第三方的类，这些第三方的类，都被压缩在一个叫做Jar的文件里。<br>
为了代码能够使用第三方的类，需要为项目导入mysql的专用Jar包。<br>
该包mysql-connector-java-5.0.8-bin.jar可以在右边下载<br>
通常都会把项目用到的jar包统一放在项目的lib目录下，在本例就会放在<br>
<strong>E:\project\j2se\lib</strong> 这个位置<br>
然后在eclipse中导入这个jar包</p>
<p>导包步骤： 右键project-&gt;property-&gt;java build path-&gt;libaries-&gt;add external jars</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/856.png" alt></p>
<h3 id="步骤-2-初始化驱动"><a class="header-anchor" href="#步骤-2-初始化驱动">¶</a>步骤 2 : 初始化驱动</h3>
<p>通过<strong>Class.forName</strong>(“com.mysql.jdbc.Driver”);<br>
初始化驱动类<strong>com.mysql.jdbc.Driver</strong><br>
就在 mysql-connector-java-5.0.8-bin.jar中<br>
如果忘记了[第一个步骤的导包]，就会抛出ClassNotFoundException</p>
<p>Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/857.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F;初始化驱动</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;驱动类com.mysql.jdbc.Driver</span><br><span class="line">            &#x2F;&#x2F;就在 mysql-connector-java-5.0.8-bin.jar中</span><br><span class="line">            &#x2F;&#x2F;如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">              </span><br><span class="line">            System.out.println(&quot;数据库驱动加载成功 ！&quot;);</span><br><span class="line">   </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版初始化驱动类<strong>Class.forName(“com.mysql.cj.jdbc.Driver”);</strong></p>
<h3 id="步骤-3-建立与数据库的连接"><a class="header-anchor" href="#步骤-3-建立与数据库的连接">¶</a>步骤 3 : 建立与数据库的连接</h3>
<p>建立与数据库的Connection连接<br>
这里需要提供：<br>
数据库所处于的ip:127.0.0.1 (本机)<br>
数据库的端口号： 3306 （mysql专用端口号）<br>
数据库名称 how2java<br>
编码方式 UTF-8<br>
账号 root<br>
密码 admin</p>
<p>注： 这一步要成功执行，必须建立在mysql中有数据库how2java的基础上，如果没有，点击[创建数据库]查看如何进行数据库的创建。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/858.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 建立与数据库的Connection连接</span><br><span class="line">            &#x2F;&#x2F; 这里需要提供：</span><br><span class="line">            &#x2F;&#x2F; 数据库所处于的ip:127.0.0.1 (本机)</span><br><span class="line">            &#x2F;&#x2F; 数据库的端口号： 3306 （mysql专用端口号）</span><br><span class="line">            &#x2F;&#x2F; 数据库名称 how2java</span><br><span class="line">            &#x2F;&#x2F; 编码方式 UTF-8</span><br><span class="line">            &#x2F;&#x2F; 账号 root</span><br><span class="line">            &#x2F;&#x2F; 密码 admin</span><br><span class="line">  </span><br><span class="line">            Connection c &#x3D; DriverManager</span><br><span class="line">                    .getConnection(</span><br><span class="line">                            &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;连接成功，获取连接对象： &quot; + c);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            System.out.println(&quot;数据库加载成功!&quot;);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 建立与数据库的Connection连接</span><br><span class="line">            &#x2F;&#x2F; 这里需要提供：</span><br><span class="line">            &#x2F;&#x2F; 数据库所处于的ip:127.0.0.1 (本机)</span><br><span class="line">            &#x2F;&#x2F; 数据库的端口号： 3306 （mysql专用端口号）</span><br><span class="line">            &#x2F;&#x2F; 数据库名称 how2java</span><br><span class="line">            &#x2F;&#x2F; 编码方式 UTF-8</span><br><span class="line">            &#x2F;&#x2F; 账号 root</span><br><span class="line">            &#x2F;&#x2F; 密码 admin</span><br><span class="line">  </span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;连接成功，获取连接对象： &quot; + c);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-创建Statement"><a class="header-anchor" href="#步骤-4-创建Statement">¶</a>步骤 4 : 创建Statement</h3>
<p>Statement是用于执行SQL语句的，比如增加，删除</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/859.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">  </span><br><span class="line">            Connection c &#x3D; DriverManager</span><br><span class="line">                    .getConnection(</span><br><span class="line">                            &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 注意：使用的是 java.sql.Statement</span><br><span class="line">            &#x2F;&#x2F; 不要不小心使用到： com.mysql.jdbc.Statement;</span><br><span class="line">            Statement s &#x3D; c.createStatement();</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;获取 Statement对象： &quot; + s);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            System.out.println(&quot;数据库加载成功!&quot;);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 建立与数据库的Connection连接</span><br><span class="line">            &#x2F;&#x2F; 这里需要提供：</span><br><span class="line">            &#x2F;&#x2F; 数据库所处于的ip:127.0.0.1 (本机)</span><br><span class="line">            &#x2F;&#x2F; 数据库的端口号： 3306 （mysql专用端口号）</span><br><span class="line">            &#x2F;&#x2F; 数据库名称 how2java</span><br><span class="line">            &#x2F;&#x2F; 编码方式 UTF-8</span><br><span class="line">            &#x2F;&#x2F; 账号 root</span><br><span class="line">            &#x2F;&#x2F; 密码 admin</span><br><span class="line">  </span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;连接成功，获取连接对象： &quot; + c);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 注意：使用的是 java.sql.Statement</span><br><span class="line">            &#x2F;&#x2F; 不要不小心使用到： com.mysql.jdbc.Statement;</span><br><span class="line">            Statement s &#x3D; c.createStatement();</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;获取 Statement对象： &quot; + s);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-执行SQL语句"><a class="header-anchor" href="#步骤-5-执行SQL语句">¶</a>步骤 5 : 执行SQL语句</h3>
<p>s.execute执行sql语句<br>
执行成功后，用mysql-front进行查看，明确插入成功</p>
<p>执行SQL语句之前要确保数据库how2java中有表hero的存在，如果没有，需要事先[创建表]</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/860.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">  </span><br><span class="line">            Connection c &#x3D; DriverManager</span><br><span class="line">                    .getConnection(</span><br><span class="line">                            &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">  </span><br><span class="line">            Statement s &#x3D; c.createStatement();</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 准备sql语句</span><br><span class="line">            &#x2F;&#x2F; 注意： 字符串要用单引号&#39;</span><br><span class="line">            String sql &#x3D; &quot;insert into hero values(null,&quot;+&quot;&#39;提莫&#39;&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;执行插入语句成功&quot;);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-6-关闭连接"><a class="header-anchor" href="#步骤-6-关闭连接">¶</a>步骤 6 : 关闭连接</h3>
<p>数据库的连接是有限资源，相关操作结束后，养成关闭数据库的好习惯<br>
先关闭Statement<br>
后关闭Connection</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Connection c &#x3D; null;</span><br><span class="line">        Statement s &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"> </span><br><span class="line">            c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;, &quot;root&quot;,</span><br><span class="line">                    &quot;admin&quot;);</span><br><span class="line"> </span><br><span class="line">            s &#x3D; c.createStatement();</span><br><span class="line"> </span><br><span class="line">            String sql &#x3D; &quot;insert into hero values(null,&quot; + &quot;&#39;提莫&#39;&quot; + &quot;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;</span><br><span class="line"> </span><br><span class="line">            s.execute(sql);</span><br><span class="line"> </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯</span><br><span class="line">            &#x2F;&#x2F; 先关闭Statement</span><br><span class="line">            if (s !&#x3D; null)</span><br><span class="line">                try &#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#x2F;&#x2F; 后关闭Connection</span><br><span class="line">            if (c !&#x3D; null)</span><br><span class="line">                try &#123;</span><br><span class="line">                    c.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	</span><br><span class="line">    	Connection c &#x3D; null;</span><br><span class="line">        Statement s &#x3D; null;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            System.out.println(&quot;数据库加载成功!&quot;);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 建立与数据库的Connection连接</span><br><span class="line">            &#x2F;&#x2F; 这里需要提供：</span><br><span class="line">            &#x2F;&#x2F; 数据库所处于的ip:127.0.0.1 (本机)</span><br><span class="line">            &#x2F;&#x2F; 数据库的端口号： 3306 （mysql专用端口号）</span><br><span class="line">            &#x2F;&#x2F; 数据库名称 how2java</span><br><span class="line">            &#x2F;&#x2F; 编码方式 UTF-8</span><br><span class="line">            &#x2F;&#x2F; 账号 root</span><br><span class="line">            &#x2F;&#x2F; 密码 admin</span><br><span class="line">  </span><br><span class="line">            c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;连接成功，获取连接对象： &quot; + c);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 注意：使用的是 java.sql.Statement</span><br><span class="line">            &#x2F;&#x2F; 不要不小心使用到： com.mysql.jdbc.Statement;</span><br><span class="line">            s &#x3D; c.createStatement();</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;获取 Statement对象： &quot; + s);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 准备sql语句</span><br><span class="line">            &#x2F;&#x2F; 注意： 字符串要用单引号&#39;</span><br><span class="line">            String sql &#x3D; &quot;insert into hero values(null,&quot;+&quot;&#39;提莫&#39;&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;执行插入语句成功&quot;);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯</span><br><span class="line">            &#x2F;&#x2F; 先关闭Statement</span><br><span class="line">            if (s !&#x3D; null)</span><br><span class="line">                try &#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#x2F;&#x2F; 后关闭Connection</span><br><span class="line">            if (c !&#x3D; null)</span><br><span class="line">                try &#123;</span><br><span class="line">                    c.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-7-使用try-with-resource的方式自动关闭连接"><a class="header-anchor" href="#步骤-7-使用try-with-resource的方式自动关闭连接">¶</a>步骤 7 : 使用try-with-resource的方式自动关闭连接</h3>
<p>如果觉得上一步的关闭连接的方式很麻烦，可以参考[关闭流]的方式，使用<strong>try-with-resource</strong>的方式自动关闭连接，因为Connection和Statement都实现了AutoCloseable接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        try (</span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();             </span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            String sql &#x3D; &quot;insert into hero values(null,&quot; + &quot;&#39;提莫&#39;&quot; + &quot;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">              </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        try (</span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();             </span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            String sql &#x3D; &quot;insert into hero values(null,&quot; + &quot;&#39;提莫&#39;&quot; + &quot;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">              </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-8-练习-一次性-插入100条数据"><a class="header-anchor" href="#步骤-8-练习-一次性-插入100条数据">¶</a>步骤 8 : 练习-一次性 插入100条数据</h3>
<p>借助循环，和上面学习到的JDBC的知识，向数据库中插入100条数据，并在mysql-front中观察查询结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        try (</span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;, &quot;885400&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();             </span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">        	for (int i &#x3D; 0; i &lt;100; i++) &#123;</span><br><span class="line">                String name&#x3D;&quot;&#39;&quot;+&quot;英雄 &quot;+i+&quot;&#39;&quot;;</span><br><span class="line">                String sql&#x3D;&quot;insert into hero values(null,&quot;+name+&quot;,&quot;+100.0f+&quot;,&quot;+40+&quot;)&quot;;</span><br><span class="line">                s.execute(sql);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、增、删、改"><a class="header-anchor" href="#3、增、删、改">¶</a>3、增、删、改</h2>
<h3 id="步骤-1-增加-v2"><a class="header-anchor" href="#步骤-1-增加-v2">¶</a>步骤 1 : 增加</h3>
<p>这段代码就是[Hello JDBC]中的代码，用于向数据库中插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        try (</span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();             </span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            String sql &#x3D; &quot;insert into hero values(null,&quot; + &quot;&#39;提莫&#39;&quot; + &quot;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">               </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-删除"><a class="header-anchor" href="#步骤-2-删除">¶</a>步骤 2 : 删除</h3>
<p>删除和增加很类似，只不过是执行的SQL语句不一样罢了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        try (</span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();             </span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            String sql &#x3D; &quot;delete from hero where id &#x3D; 5&quot;;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">               </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        try (</span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();             </span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">                String sql&#x3D;&quot;delete from hero where id &#x3D; 5&quot;;</span><br><span class="line">                s.execute(sql);</span><br><span class="line">            </span><br><span class="line">              </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-修改"><a class="header-anchor" href="#步骤-3-修改">¶</a>步骤 3 : 修改</h3>
<p>修改也一样，执行另一条SQL语句就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        try (</span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();             </span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            String sql &#x3D; &quot;update hero set name &#x3D; &#39;name 5&#39; where id &#x3D; 3&quot;;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">               </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        try (</span><br><span class="line">            Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();             </span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">                String sql&#x3D;&quot;update hero set name &#x3D; &#39;name 5&#39; where id &#x3D; 3&quot;;</span><br><span class="line">                s.execute(sql);</span><br><span class="line">            </span><br><span class="line">              </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-增-删-改"><a class="header-anchor" href="#步骤-4-练习-增-删-改">¶</a>步骤 4 : 练习-增 删 改</h3>
<p>设计一个方法</p>
<p>public static void execute(String sql)</p>
<p>方法接受的参数是SQL语句，无论是增加，删除，还是修改，都调用这个方法，每次传不同的SQL语句作为参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line">    public static void execute(String sql)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">            System.out.println(&quot;数据库驱动加载成功&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Connection c&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                    &quot;root&quot;,</span><br><span class="line">                    &quot;admin&quot;);</span><br><span class="line">            System.out.println(&quot;数据库连接成功&quot;);</span><br><span class="line">            Statement s&#x3D;c.createStatement();</span><br><span class="line">            s.execute(sql);</span><br><span class="line">            System.out.println(&quot;写入数据成功&quot;);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;       </span><br><span class="line">        execute(&quot;insert into hero values(null,&quot;+&quot;&#39;卡莉斯塔&#39;&quot;+&quot;,&quot;+570+&quot;,&quot;+69+&quot;)&quot;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void execute(String sql)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            System.out.println(&quot;数据库驱动加载成功&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Connection c&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            System.out.println(&quot;数据库连接成功&quot;);</span><br><span class="line">            Statement s&#x3D;c.createStatement();</span><br><span class="line">            s.execute(sql);</span><br><span class="line">            System.out.println(&quot;写入数据成功&quot;);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;       </span><br><span class="line">        execute(&quot;insert into hero values(null,&quot;+&quot;&#39;卡莉斯塔&#39;&quot;+&quot;,&quot;+570+&quot;,&quot;+69+&quot;)&quot;);</span><br><span class="line">        execute(&quot;delete from hero where id &#x3D; 99&quot;);</span><br><span class="line">        execute(&quot;update hero set name &#x3D; &#39;提莫&#39; where id &#x3D; 98&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、在JDBC中使用RESULTSET查询SQL语句"><a class="header-anchor" href="#4、在JDBC中使用RESULTSET查询SQL语句">¶</a>4、在JDBC中使用RESULTSET查询SQL语句</h2>
<h3 id="步骤-1-查询语句"><a class="header-anchor" href="#步骤-1-查询语句">¶</a>步骤 1 : 查询语句</h3>
<p>executeQuery 执行SQL查询语句</p>
<p><strong>注意：</strong> 在取第二列的数据的时候，用的是rs.get(2) ，而不是get(1). 这个是整个Java自带的api里<strong>唯二</strong>的地方，使用<strong>基1</strong>的，即2就代表第二个。</p>
<p>另一个地方是在[PreparedStatement]这里</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/866.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                &quot;root&quot;, &quot;admin&quot;); Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            String sql &#x3D; &quot;select * from hero&quot;;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 执行查询语句，并把结果集返回给ResultSet</span><br><span class="line">            ResultSet rs &#x3D; s.executeQuery(sql);</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                int id &#x3D; rs.getInt(&quot;id&quot;);&#x2F;&#x2F; 可以使用字段名</span><br><span class="line">                String name &#x3D; rs.getString(2);&#x2F;&#x2F; 也可以使用字段的顺序</span><br><span class="line">                float hp &#x3D; rs.getFloat(&quot;hp&quot;);</span><br><span class="line">                int damage &#x3D; rs.getInt(4);</span><br><span class="line">                System.out.printf(&quot;%d\t%s\t%f\t%d%n&quot;, id, name, hp, damage);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 不一定要在这里关闭ReultSet，因为Statement关闭的时候，会自动关闭ResultSet</span><br><span class="line">            &#x2F;&#x2F; rs.close();</span><br><span class="line"> </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;); </span><br><span class="line">        	</span><br><span class="line">        	Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line">        	</span><br><span class="line">            String sql &#x3D; &quot;select * from hero&quot;;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 执行查询语句，并把结果集返回给ResultSet</span><br><span class="line">            ResultSet rs &#x3D; s.executeQuery(sql);</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                int id &#x3D; rs.getInt(&quot;id&quot;);&#x2F;&#x2F; 可以使用字段名</span><br><span class="line">                String name &#x3D; rs.getString(2);&#x2F;&#x2F; 也可以使用字段的顺序</span><br><span class="line">                float hp &#x3D; rs.getFloat(&quot;hp&quot;);</span><br><span class="line">                int damage &#x3D; rs.getInt(4);</span><br><span class="line">                System.out.printf(&quot;%d\t%s\t%f\t%d%n&quot;, id, name, hp, damage);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 不一定要在这里关闭ReultSet，因为Statement关闭的时候，会自动关闭ResultSet</span><br><span class="line">            &#x2F;&#x2F; rs.close();</span><br><span class="line"> </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-SQL语句判断账号密码是否正确"><a class="header-anchor" href="#步骤-2-SQL语句判断账号密码是否正确">¶</a>步骤 2 : SQL语句判断账号密码是否正确</h3>
<ol>
<li>
<p>创建一个用户表，有字段name,password</p>
</li>
<li>
<p>插入一条数据</p>
</li>
</ol>
<p>insert into user values(null,‘dashen’,‘thisispassword’);</p>
<ol start="3">
<li>SQL语句判断账号密码是否正确</li>
</ol>
<p>判断账号密码的<strong>正确方式</strong>是根据账号和密码到表中去找数据，如果有数据，就表明密码正确了，如果没数据，就表明密码错误。</p>
<p><strong>不恰当的方式</strong> 是把uers表的数据全部查到内存中，挨个进行比较。 如果users表里有100万条数据呢？ 内存都不够用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">  id int(11) AUTO_INCREMENT,</span><br><span class="line">  name varchar(30) ,</span><br><span class="line">  password varchar(30),</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">) ;</span><br><span class="line">insert into user values(null,&#39;dashen&#39;,&#39;thisispassword&#39;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">                Statement s &#x3D; c.createStatement();</span><br><span class="line">                 </span><br><span class="line">                ) &#123;</span><br><span class="line">            String name &#x3D; &quot;dashen&quot;;</span><br><span class="line">            &#x2F;&#x2F;正确的密码是：thisispassword</span><br><span class="line">            String password &#x3D; &quot;thisispassword1&quot;;</span><br><span class="line">   </span><br><span class="line">            String sql &#x3D; &quot;select * from user where name &#x3D; &#39;&quot; + name +&quot;&#39; and password &#x3D; &#39;&quot; + password+&quot;&#39;&quot;;</span><br><span class="line">              </span><br><span class="line">            &#x2F;&#x2F; 执行查询语句，并把结果集返回给ResultSet</span><br><span class="line">            ResultSet rs &#x3D; s.executeQuery(sql);</span><br><span class="line">              </span><br><span class="line">            if(rs.next())</span><br><span class="line">                System.out.println(&quot;账号密码正确&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(&quot;账号密码错误&quot;);</span><br><span class="line">             </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;);</span><br><span class="line">                Statement s &#x3D; c.createStatement();</span><br><span class="line">                 </span><br><span class="line">                ) &#123;</span><br><span class="line">            String name &#x3D; &quot;dashen&quot;;</span><br><span class="line">            &#x2F;&#x2F;正确的密码是：thisispassword</span><br><span class="line">            String password &#x3D; &quot;thisispassword&quot;;</span><br><span class="line">   </span><br><span class="line">            String sql &#x3D; &quot;select * from user where name &#x3D; &#39;&quot; + name +&quot;&#39; and password &#x3D; &#39;&quot; + password+&quot;&#39;&quot;;</span><br><span class="line">              </span><br><span class="line">            &#x2F;&#x2F; 执行查询语句，并把结果集返回给ResultSet</span><br><span class="line">            ResultSet rs &#x3D; s.executeQuery(sql);</span><br><span class="line">              </span><br><span class="line">            if(rs.next())</span><br><span class="line">                System.out.println(&quot;账号密码正确&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(&quot;账号密码错误&quot;);</span><br><span class="line">             </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-获取总数"><a class="header-anchor" href="#步骤-3-获取总数">¶</a>步骤 3 : 获取总数</h3>
<p>执行的sql语句为</p>
<p>select count(*) from hero</p>
<p>然后通过ResultSet获取出来</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/1714.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">                &quot;root&quot;, &quot;admin&quot;); Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            String sql &#x3D; &quot;select count(*) from hero&quot;;</span><br><span class="line"> </span><br><span class="line">            ResultSet rs &#x3D; s.executeQuery(sql);</span><br><span class="line">            int total &#x3D; 0;</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                total &#x3D; rs.getInt(1);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            System.out.println(&quot;表Hero中总共有:&quot; + total+&quot; 条数据&quot;);</span><br><span class="line"> </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;); </span><br><span class="line">        	Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            String sql &#x3D; &quot;select count(*) from hero&quot;;</span><br><span class="line"> </span><br><span class="line">            ResultSet rs &#x3D; s.executeQuery(sql);</span><br><span class="line">            int total &#x3D; 0;</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                total &#x3D; rs.getInt(1);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            System.out.println(&quot;表Hero中总共有:&quot; + total+&quot; 条数据&quot;);</span><br><span class="line"> </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-练习-分页查询"><a class="header-anchor" href="#步骤-4-练习-分页查询">¶</a>步骤 4 : 练习-分页查询</h3>
<p>设计一个方法，进行分页查询</p>
<p>public static void list(int start, int count)</p>
<p>start 表示开始页数，count表示一页显示的总数<br>
<strong>list(0,5)</strong> 表示第一页，一共显示5条数据<br>
<strong>list(10,5)</strong> 表示第三页，一共显示5条数据<br>
进行分页查询用到的SQL语句参考 ： [查询数据]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void list(int start,int count)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;); </span><br><span class="line">        	Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">        	String sql &#x3D; &quot;select * from hero limit &quot;+start+&quot;,&quot;+count+&quot;&quot;;</span><br><span class="line">            ResultSet rs &#x3D; s.executeQuery(sql);</span><br><span class="line">            while(rs.next())&#123;</span><br><span class="line">                int id &#x3D; rs.getInt(&quot;id&quot;);&#x2F;&#x2F; 可以使用字段名</span><br><span class="line">                String name &#x3D; rs.getString(2);&#x2F;&#x2F; 也可以使用字段的顺序</span><br><span class="line">                float hp &#x3D; rs.getFloat(&quot;hp&quot;);</span><br><span class="line">                int damage &#x3D; rs.getInt(4);</span><br><span class="line">                System.out.printf(&quot;%d\t%s\t%f\t%d%n&quot;, id, name, hp, damage);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        list(0,5);</span><br><span class="line">        list(10,5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、在JDBC中使用预编译STATEMENT-以及它的优点"><a class="header-anchor" href="#5、在JDBC中使用预编译STATEMENT-以及它的优点">¶</a>5、在JDBC中使用预编译STATEMENT 以及它的优点</h2>
<h3 id="步骤-1-使用PreparedStatement"><a class="header-anchor" href="#步骤-1-使用PreparedStatement">¶</a>步骤 1 : 使用PreparedStatement</h3>
<p>和 Statement一样，PreparedStatement也是用来执行sql语句的<br>
与创建Statement不同的是，需要根据sql语句创建PreparedStatement<br>
除此之外，还能够通过设置参数，指定相应的值，而不是Statement那样使用字符串拼接</p>
<p>注： 这是JAVA里唯二的基1的地方，另一个是[查询语句]中的ResultSet也是基1的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">    </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">    </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        String sql &#x3D; &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            &#x2F;&#x2F; 根据sql语句创建PreparedStatement</span><br><span class="line">            PreparedStatement ps &#x3D; c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F; 设置参数</span><br><span class="line">            ps.setString(1, &quot;提莫&quot;);</span><br><span class="line">            ps.setFloat(2, 313.0f);</span><br><span class="line">            ps.setInt(3, 50);</span><br><span class="line">            &#x2F;&#x2F; 执行</span><br><span class="line">            ps.execute();</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">    </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">    </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        String sql &#x3D; &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;);</span><br><span class="line">            &#x2F;&#x2F; 根据sql语句创建PreparedStatement</span><br><span class="line">            PreparedStatement ps &#x3D; c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F; 设置参数</span><br><span class="line">            ps.setString(1, &quot;提莫&quot;);</span><br><span class="line">            ps.setFloat(2, 313.0f);</span><br><span class="line">            ps.setInt(3, 50);</span><br><span class="line">            &#x2F;&#x2F; 执行</span><br><span class="line">            ps.execute();</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-PreparedStatement的优点1-参数设置"><a class="header-anchor" href="#步骤-2-PreparedStatement的优点1-参数设置">¶</a>步骤 2 : PreparedStatement的优点1-参数设置</h3>
<p><strong>Statement</strong> 需要进行字符串拼接，可读性和维护性比较差</p>
<p>String sql = “insert into hero values(null,”+&quot;‘提莫’&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;;</p>
<p><strong>PreparedStatement</strong> 使用参数设置，可读性好，不易犯错</p>
<p>String sql = “insert into hero values(null,?,?,?)”;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        String sql &#x3D; &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();</span><br><span class="line">            PreparedStatement ps &#x3D; c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line">            &#x2F;&#x2F; Statement需要进行字符串拼接，可读性和维修性比较差</span><br><span class="line">            String sql0 &#x3D; &quot;insert into hero values(null,&quot; + &quot;&#39;提莫&#39;&quot; + &quot;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;</span><br><span class="line">            s.execute(sql0);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; PreparedStatement 使用参数设置，可读性好，不易犯错</span><br><span class="line">            &#x2F;&#x2F; &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">            ps.setString(1, &quot;提莫&quot;);</span><br><span class="line">            ps.setFloat(2, 313.0f);</span><br><span class="line">            ps.setInt(3, 50);</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-PreparedStatement的优点2-性能表现"><a class="header-anchor" href="#步骤-3-PreparedStatement的优点2-性能表现">¶</a>步骤 3 : PreparedStatement的优点2-性能表现</h3>
<p>PreparedStatement有预编译机制，性能比Statement更快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        String sql &#x3D; &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">                Statement s &#x3D; c.createStatement();</span><br><span class="line">                PreparedStatement ps &#x3D; c.prepareStatement(sql);</span><br><span class="line">            ) &#123;</span><br><span class="line">            &#x2F;&#x2F; Statement执行10次，需要10次把SQL语句传输到数据库端</span><br><span class="line">            &#x2F;&#x2F; 数据库要对每一次来的SQL语句进行编译处理</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                String sql0 &#x3D; &quot;insert into hero values(null,&quot; + &quot;&#39;提莫&#39;&quot; + &quot;,&quot;</span><br><span class="line">                        + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;</span><br><span class="line">                s.execute(sql0);</span><br><span class="line">            &#125;</span><br><span class="line">            s.close();</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; PreparedStatement 执行10次，只需要1次把SQL语句传输到数据库端</span><br><span class="line">            &#x2F;&#x2F; 数据库对带?的SQL进行预编译</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 每次执行，只需要传输参数到数据库端</span><br><span class="line">            &#x2F;&#x2F; 1. 网络传输量比Statement更小</span><br><span class="line">            &#x2F;&#x2F; 2. 数据库不需要再进行编译，响应更快</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                ps.setString(1, &quot;提莫&quot;);</span><br><span class="line">                ps.setFloat(2, 313.0f);</span><br><span class="line">                ps.setInt(3, 50);</span><br><span class="line">                ps.execute();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-4-PreparedStatement的优点3-防止SQL注入式攻击"><a class="header-anchor" href="#步骤-4-PreparedStatement的优点3-防止SQL注入式攻击">¶</a>步骤 4 : PreparedStatement的优点3-防止SQL注入式攻击</h3>
<p>假设name是用户提交来的数据</p>
<p>String name = “‘盖伦’ OR 1=1”;</p>
<p>使用Statement就需要进行字符串拼接<br>
拼接出来的语句是：</p>
<p>select * from hero where name = ‘盖伦’ OR 1=1</p>
<p>因为有OR 1=1，这是恒成立的<br>
那么就会把所有的英雄都查出来，而不只是盖伦<br>
如果Hero表里的数据是海量的，比如几百万条，<strong>把这个表里的数据全部查出来</strong><br>
会让数据库负载变高，CPU100%，内存消耗光，<strong>响应变得极其缓慢</strong></p>
<p>而PreparedStatement使用的是<strong>参数设置</strong>，就不会有这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        String sql &#x3D; &quot;select * from hero where name &#x3D; ?&quot;;</span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">                Statement s &#x3D; c.createStatement();</span><br><span class="line">            PreparedStatement ps &#x3D; c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line">            &#x2F;&#x2F; 假设name是用户提交来的数据</span><br><span class="line">            String name &#x3D; &quot;&#39;盖伦&#39; OR 1&#x3D;1&quot;;</span><br><span class="line">            String sql0 &#x3D; &quot;select * from hero where name &#x3D; &quot; + name;</span><br><span class="line">            &#x2F;&#x2F; 拼接出来的SQL语句就是</span><br><span class="line">            &#x2F;&#x2F; select * from hero where name &#x3D; &#39;盖伦&#39; OR 1&#x3D;1</span><br><span class="line">            &#x2F;&#x2F; 因为有OR 1&#x3D;1，所以恒成立</span><br><span class="line">            &#x2F;&#x2F; 那么就会把所有的英雄都查出来，而不只是盖伦</span><br><span class="line">            &#x2F;&#x2F; 如果Hero表里的数据是海量的，比如几百万条，把这个表里的数据全部查出来</span><br><span class="line">            &#x2F;&#x2F; 会让数据库负载变高，CPU100%，内存消耗光，响应变得极其缓慢</span><br><span class="line">            System.out.println(sql0);</span><br><span class="line">  </span><br><span class="line">            ResultSet rs0 &#x3D; s.executeQuery(sql0);</span><br><span class="line">            while (rs0.next()) &#123;</span><br><span class="line">                String heroName &#x3D; rs0.getString(&quot;name&quot;);</span><br><span class="line">                System.out.println(heroName);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            s.execute(sql0);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 使用预编译Statement就可以杜绝SQL注入</span><br><span class="line">  </span><br><span class="line">            ps.setString(1, name);</span><br><span class="line">  </span><br><span class="line">            ResultSet rs &#x3D; ps.executeQuery();</span><br><span class="line">            &#x2F;&#x2F; 查不出数据出来</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                String heroName &#x3D; rs.getString(&quot;name&quot;);</span><br><span class="line">                System.out.println(heroName);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-5-练习-性能比较"><a class="header-anchor" href="#步骤-5-练习-性能比较">¶</a>步骤 5 : 练习-性能比较</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">    </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">    </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		quiter();</span><br><span class="line">	&#125;</span><br><span class="line">	public static void quiter()&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		String sqll&#x3D;&quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">		try(Connection connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,</span><br><span class="line">				&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">				Statement statement&#x3D;connection.createStatement();</span><br><span class="line">				PreparedStatement ps&#x3D;connection.prepareStatement(sqll)</span><br><span class="line">				)&#123;</span><br><span class="line">			System.out.println(&quot;获取到statement对象&quot;+statement);</span><br><span class="line">			long dk&#x3D; System.currentTimeMillis();</span><br><span class="line">			for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">				String sql&#x3D;&quot;insert into hero values(null,name&#x3D;&#39;英雄&#39;,122,50)&quot;;</span><br><span class="line">				statement.execute(sql);</span><br><span class="line">			&#125;</span><br><span class="line">			long jk&#x3D; System.currentTimeMillis();</span><br><span class="line">			System.out.println(&quot;使用Statement插入数据的时间是：&quot;+(jk-dk));</span><br><span class="line">			long jkk&#x3D; System.currentTimeMillis();</span><br><span class="line">			for (int i &#x3D; 0; i &lt;10000; i++) &#123;</span><br><span class="line">				ps.setString(1,&quot;英雄&quot;);</span><br><span class="line">				ps.setLong(2,122);</span><br><span class="line">				ps.setInt(3,50);</span><br><span class="line">			&#125;</span><br><span class="line">			long dkk&#x3D; System.currentTimeMillis();</span><br><span class="line">			System.out.println(&quot;使用PreparedStatement插入数据的时间是：&quot;+(dkk-jkk));</span><br><span class="line">		&#125; catch (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">    </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">    </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		quiter();</span><br><span class="line">	&#125;</span><br><span class="line">	public static void quiter()&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		String sqll&#x3D;&quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">		try(Connection connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;);</span><br><span class="line">				Statement statement&#x3D;connection.createStatement();</span><br><span class="line">				PreparedStatement ps&#x3D;connection.prepareStatement(sqll)</span><br><span class="line">				)&#123;</span><br><span class="line">			System.out.println(&quot;获取到statement对象&quot;+statement);</span><br><span class="line">			long dk&#x3D; System.currentTimeMillis();</span><br><span class="line">			for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">				String sql&#x3D;&quot;insert into hero values(null,name&#x3D;&#39;英雄&#39;,122,50)&quot;;</span><br><span class="line">				statement.execute(sql);</span><br><span class="line">			&#125;</span><br><span class="line">			long jk&#x3D; System.currentTimeMillis();</span><br><span class="line">			System.out.println(&quot;使用Statement插入数据的时间是：&quot;+(jk-dk));</span><br><span class="line">			long jkk&#x3D; System.currentTimeMillis();</span><br><span class="line">			for (int i &#x3D; 0; i &lt;10000; i++) &#123;</span><br><span class="line">				ps.setString(1,&quot;英雄&quot;);</span><br><span class="line">				ps.setLong(2,122);</span><br><span class="line">				ps.setInt(3,50);</span><br><span class="line">			&#125;</span><br><span class="line">			long dkk&#x3D; System.currentTimeMillis();</span><br><span class="line">			System.out.println(&quot;使用PreparedStatement插入数据的时间是：&quot;+(dkk-jkk));</span><br><span class="line">		&#125; catch (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取到statement对象com.mysql.cj.jdbc.StatementImpl@2ef9b8bc</span><br><span class="line">使用Statement插入数据的时间是：1305025</span><br><span class="line">使用PreparedStatement插入数据的时间是：46</span><br></pre></td></tr></table></figure>
<h2 id="6、EXECUTE与EXECUTEUPDATE的区别"><a class="header-anchor" href="#6、EXECUTE与EXECUTEUPDATE的区别">¶</a>6、EXECUTE与EXECUTEUPDATE的区别</h2>
<h3 id="步骤-1-相同点"><a class="header-anchor" href="#步骤-1-相同点">¶</a>步骤 1 : 相同点</h3>
<p><strong>execute</strong>与<strong>executeUpdate</strong>的相同点：都可以执行增加，删除，修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            String sqlInsert &#x3D; &quot;insert into Hero values (null,&#39;盖伦&#39;,616,100)&quot;;</span><br><span class="line">            String sqlDelete &#x3D; &quot;delete from Hero where id &#x3D; 100&quot;;</span><br><span class="line">            String sqlUpdate &#x3D; &quot;update Hero set hp &#x3D; 300 where id &#x3D; 100&quot;;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 相同点：都可以执行增加，删除，修改</span><br><span class="line"> </span><br><span class="line">            s.execute(sqlInsert);</span><br><span class="line">            s.execute(sqlDelete);</span><br><span class="line">            s.execute(sqlUpdate);</span><br><span class="line">            s.executeUpdate(sqlInsert);</span><br><span class="line">            s.executeUpdate(sqlDelete);</span><br><span class="line">            s.executeUpdate(sqlUpdate);</span><br><span class="line"> </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            String sqlInsert &#x3D; &quot;insert into Hero values (null,&#39;盖伦&#39;,616,100)&quot;;</span><br><span class="line">            String sqlDelete &#x3D; &quot;delete from Hero where id &#x3D; 100&quot;;</span><br><span class="line">            String sqlUpdate &#x3D; &quot;update Hero set hp &#x3D; 300 where id &#x3D; 100&quot;;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 相同点：都可以执行增加，删除，修改</span><br><span class="line"> </span><br><span class="line">            s.execute(sqlInsert);</span><br><span class="line">            s.execute(sqlDelete);</span><br><span class="line">            s.execute(sqlUpdate);</span><br><span class="line">            s.executeUpdate(sqlInsert);</span><br><span class="line">            s.executeUpdate(sqlDelete);</span><br><span class="line">            s.executeUpdate(sqlUpdate);</span><br><span class="line"> </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-不同点"><a class="header-anchor" href="#步骤-2-不同点">¶</a>步骤 2 : 不同点</h3>
<p>不同1：<br>
execute<strong>可以执行查询语句</strong><br>
然后通过getResultSet，把结果集取出来<br>
executeUpdate<strong>不能执行查询语句</strong><br>
不同2:<br>
execute<strong>返回boolean类型</strong>，true表示执行的是查询语句，false表示执行的是insert,delete,update等等<br>
executeUpdate<strong>返回的是int</strong>，表示有多少条数据受到了影响</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 不同1：execute可以执行查询语句</span><br><span class="line">            &#x2F;&#x2F; 然后通过getResultSet，把结果集取出来</span><br><span class="line">            String sqlSelect &#x3D; &quot;select * from hero&quot;;</span><br><span class="line">  </span><br><span class="line">            s.execute(sqlSelect);</span><br><span class="line">            ResultSet rs &#x3D; s.getResultSet();</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getInt(&quot;id&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; executeUpdate不能执行查询语句</span><br><span class="line">            &#x2F;&#x2F; s.executeUpdate(sqlSelect);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 不同2:</span><br><span class="line">            &#x2F;&#x2F; execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等</span><br><span class="line">            boolean isSelect &#x3D; s.execute(sqlSelect);</span><br><span class="line">            System.out.println(isSelect);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; executeUpdate返回的是int，表示有多少条数据受到了影响</span><br><span class="line">            String sqlUpdate &#x3D; &quot;update Hero set hp &#x3D; 300 where id &lt; 100&quot;;</span><br><span class="line">            int number &#x3D; s.executeUpdate(sqlUpdate);</span><br><span class="line">            System.out.println(number);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 不同1：execute可以执行查询语句</span><br><span class="line">            &#x2F;&#x2F; 然后通过getResultSet，把结果集取出来</span><br><span class="line">            String sqlSelect &#x3D; &quot;select * from hero&quot;;</span><br><span class="line">  </span><br><span class="line">            s.execute(sqlSelect);</span><br><span class="line">            ResultSet rs &#x3D; s.getResultSet();</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getInt(&quot;id&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; executeUpdate不能执行查询语句</span><br><span class="line">            &#x2F;&#x2F; s.executeUpdate(sqlSelect);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 不同2:</span><br><span class="line">            &#x2F;&#x2F; execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等</span><br><span class="line">            boolean isSelect &#x3D; s.execute(sqlSelect);</span><br><span class="line">            System.out.println(isSelect);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; executeUpdate返回的是int，表示有多少条数据受到了影响</span><br><span class="line">            String sqlUpdate &#x3D; &quot;update Hero set hp &#x3D; 300 where id &lt; 100&quot;;</span><br><span class="line">            int number &#x3D; s.executeUpdate(sqlUpdate);</span><br><span class="line">            System.out.println(number);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-分页查询"><a class="header-anchor" href="#步骤-3-练习-分页查询">¶</a>步骤 3 : 练习-分页查询</h3>
<p>使用execute方式，而不是executeQuery方式完成练习 [练习-分页查询]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void search(int start,int count)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            System.out.println(&quot;载入驱动&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Connection c&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;);</span><br><span class="line">            System.out.println(&quot;建立连接&quot;);</span><br><span class="line">            Statement s&#x3D;c.createStatement();</span><br><span class="line">            String sql&#x3D;&quot;select *from hero limit &quot;+(start-1)*count+&#39;,&#39;+count+&quot;  &quot;;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">            ResultSet rs&#x3D;s.getResultSet();     </span><br><span class="line">            while(rs.next())&#123;</span><br><span class="line">                int id&#x3D;rs.getInt(1);</span><br><span class="line">                String name&#x3D;rs.getString(2);</span><br><span class="line">                float hp&#x3D;rs.getFloat(3);</span><br><span class="line">                int damage&#x3D;rs.getInt(4);</span><br><span class="line">                System.out.printf(&quot;%d,%s,%f,%d%n&quot;,id,name,hp,damage);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        search(4,5);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、获取自增长ID以及表的元数据"><a class="header-anchor" href="#7、获取自增长ID以及表的元数据">¶</a>7、获取自增长ID以及表的元数据</h2>
<h3 id="步骤-1-获取自增长id"><a class="header-anchor" href="#步骤-1-获取自增长id">¶</a>步骤 1 : 获取自增长id</h3>
<p>在Statement通过execute或者executeUpdate执行完插入语句后，MySQL会为新插入的数据分配一个自增长id，(前提是这个表的id设置为了自增长,在Mysql创建表的时候，AUTO_INCREMENT就表示自增长)</p>
<p>CREATE TABLE hero (</p>
<p>id int(11) AUTO_INCREMENT,</p>
<p>…</p>
<p>}</p>
<p>但是无论是execute还是executeUpdate都不会返回这个自增长id是多少。需要通过<strong>Statement</strong>的<strong>getGeneratedKeys</strong>获取该id<br>
<strong>注：</strong> 第20行的代码，后面加了个<strong>Statement.RETURN_GENERATED_KEYS</strong>参数，以确保会返回自增长ID。 通常情况下不需要加这个，有的时候需要加，所以先加上，保险一些</p>
<p>PreparedStatement ps = c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         String sql &#x3D; &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">                PreparedStatement ps &#x3D; c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);          </span><br><span class="line">                ) &#123;</span><br><span class="line">  </span><br><span class="line">            ps.setString(1, &quot;盖伦&quot;);</span><br><span class="line">            ps.setFloat(2, 616);</span><br><span class="line">            ps.setInt(3, 100);</span><br><span class="line">   </span><br><span class="line">            &#x2F;&#x2F; 执行插入语句</span><br><span class="line">            ps.execute();</span><br><span class="line">   </span><br><span class="line">            &#x2F;&#x2F; 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id</span><br><span class="line">            &#x2F;&#x2F; JDBC通过getGeneratedKeys获取该id</span><br><span class="line">            ResultSet rs &#x3D; ps.getGeneratedKeys();</span><br><span class="line">            if (rs.next()) &#123;</span><br><span class="line">                int id &#x3D; rs.getInt(1);</span><br><span class="line">                System.out.println(id);</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         String sql &#x3D; &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;);</span><br><span class="line">                PreparedStatement ps &#x3D; c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);          </span><br><span class="line">                ) &#123;</span><br><span class="line">  </span><br><span class="line">            ps.setString(1, &quot;盖伦&quot;);</span><br><span class="line">            ps.setFloat(2, 616);</span><br><span class="line">            ps.setInt(3, 100);</span><br><span class="line">   </span><br><span class="line">            &#x2F;&#x2F; 执行插入语句</span><br><span class="line">            ps.execute();</span><br><span class="line">   </span><br><span class="line">            &#x2F;&#x2F; 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id</span><br><span class="line">            &#x2F;&#x2F; JDBC通过getGeneratedKeys获取该id</span><br><span class="line">            ResultSet rs &#x3D; ps.getGeneratedKeys();</span><br><span class="line">            if (rs.next()) &#123;</span><br><span class="line">                int id &#x3D; rs.getInt(1);</span><br><span class="line">                System.out.println(id);</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-获取表的元数据"><a class="header-anchor" href="#步骤-2-获取表的元数据">¶</a>步骤 2 : 获取表的元数据</h3>
<p>元数据概念：<br>
和数据库服务器相关的数据，比如数据库版本，有哪些表，表有哪些字段，字段类型是什么等等。</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/878.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DatabaseMetaData;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);) &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 查看数据库层面的元数据</span><br><span class="line">            &#x2F;&#x2F; 即数据库服务器版本，驱动版本，都有哪些数据库等等</span><br><span class="line">  </span><br><span class="line">            DatabaseMetaData dbmd &#x3D; c.getMetaData();</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 获取数据库服务器产品名称</span><br><span class="line">            System.out.println(&quot;数据库产品名称:\t&quot;+dbmd.getDatabaseProductName());</span><br><span class="line">            &#x2F;&#x2F; 获取数据库服务器产品版本号</span><br><span class="line">            System.out.println(&quot;数据库产品版本:\t&quot;+dbmd.getDatabaseProductVersion());</span><br><span class="line">            &#x2F;&#x2F; 获取数据库服务器用作类别和表名之间的分隔符 如test.user</span><br><span class="line">            System.out.println(&quot;数据库和表分隔符:\t&quot;+dbmd.getCatalogSeparator());</span><br><span class="line">            &#x2F;&#x2F; 获取驱动版本</span><br><span class="line">            System.out.println(&quot;驱动版本:\t&quot;+dbmd.getDriverVersion());</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;可用的数据库列表：&quot;);</span><br><span class="line">            &#x2F;&#x2F; 获取数据库名称</span><br><span class="line">            ResultSet rs &#x3D; dbmd.getCatalogs();</span><br><span class="line">  </span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                System.out.println(&quot;数据库名称:\t&quot;+rs.getString(1));</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DatabaseMetaData;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;);) &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 查看数据库层面的元数据</span><br><span class="line">            &#x2F;&#x2F; 即数据库服务器版本，驱动版本，都有哪些数据库等等</span><br><span class="line">  </span><br><span class="line">            DatabaseMetaData dbmd &#x3D; c.getMetaData();</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 获取数据库服务器产品名称</span><br><span class="line">            System.out.println(&quot;数据库产品名称:\t&quot;+dbmd.getDatabaseProductName());</span><br><span class="line">            &#x2F;&#x2F; 获取数据库服务器产品版本号</span><br><span class="line">            System.out.println(&quot;数据库产品版本:\t&quot;+dbmd.getDatabaseProductVersion());</span><br><span class="line">            &#x2F;&#x2F; 获取数据库服务器用作类别和表名之间的分隔符 如test.user</span><br><span class="line">            System.out.println(&quot;数据库和表分隔符:\t&quot;+dbmd.getCatalogSeparator());</span><br><span class="line">            &#x2F;&#x2F; 获取驱动版本</span><br><span class="line">            System.out.println(&quot;驱动版本:\t&quot;+dbmd.getDriverVersion());</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;可用的数据库列表：&quot;);</span><br><span class="line">            &#x2F;&#x2F; 获取数据库名称</span><br><span class="line">            ResultSet rs &#x3D; dbmd.getCatalogs();</span><br><span class="line">  </span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                System.out.println(&quot;数据库名称:\t&quot;+rs.getString(1));</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-练习-自增长id"><a class="header-anchor" href="#步骤-3-练习-自增长id">¶</a>步骤 3 : 练习-自增长id</h3>
<p>当插入一条数据之后，通过获取自增长id，得到这条数据的id，比如说是55.</p>
<p>删除这条数据的前一条，54.</p>
<p>如果54不存在，则删除53，以此类推直到删除上一条数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         String sql &#x3D; &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;admin&quot;);</span><br><span class="line">                PreparedStatement ps &#x3D; c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);          </span><br><span class="line">        		Statement s&#x3D;c.createStatement();</span><br><span class="line">        		) &#123;</span><br><span class="line">  </span><br><span class="line">            ps.setString(1, &quot;盖伦&quot;);</span><br><span class="line">            ps.setFloat(2, 616);</span><br><span class="line">            ps.setInt(3, 100);</span><br><span class="line">   </span><br><span class="line">            &#x2F;&#x2F; 执行插入语句</span><br><span class="line">            ps.execute();</span><br><span class="line">   </span><br><span class="line">            &#x2F;&#x2F; 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id</span><br><span class="line">            &#x2F;&#x2F; JDBC通过getGeneratedKeys获取该id</span><br><span class="line">            ResultSet rs &#x3D; ps.getGeneratedKeys();</span><br><span class="line">            if (rs.next()) &#123;</span><br><span class="line">            	</span><br><span class="line">                int id &#x3D; rs.getInt(1);</span><br><span class="line">                System.out.println(id);</span><br><span class="line">                </span><br><span class="line">                for (int i &#x3D; 0; i &lt; id; i++) &#123;</span><br><span class="line">                    String sqlSelect&#x3D;&quot;select*from hero where id&#x3D;&quot;+(id-1-i)+&quot;&quot;;</span><br><span class="line">                    String sqlDelete&#x3D;&quot;delete from hero where id&#x3D;&quot;+(id-1-i)+&quot;&quot;;</span><br><span class="line">                    rs&#x3D;s.executeQuery(sqlSelect);</span><br><span class="line">                    if(rs.next())&#123;</span><br><span class="line">                        s.execute(sqlDelete);</span><br><span class="line">                        System.out.println(&quot;删除成功&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、如何在JDBC中使用事务"><a class="header-anchor" href="#8、如何在JDBC中使用事务">¶</a>8、如何在JDBC中使用事务</h2>
<h3 id="步骤-1-不使用事务的情况"><a class="header-anchor" href="#步骤-1-不使用事务的情况">¶</a>步骤 1 : 不使用事务的情况</h3>
<p><strong>没有事务的前提下</strong><br>
假设业务操作是：加血，减血各做一次<br>
结束后，英雄的血量不变<br>
而减血的SQL<br>
不小心写错写成了 updat<strong>a</strong>(而非update)<br>
那么最后结果是血量增加了，而非期望的不变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;没有事务的前提下</span><br><span class="line">            &#x2F;&#x2F;假设业务操作时，加血，减血各做一次</span><br><span class="line">            &#x2F;&#x2F;结束后，英雄的血量不变</span><br><span class="line">              </span><br><span class="line">            &#x2F;&#x2F;加血的SQL</span><br><span class="line">            String sql1 &#x3D; &quot;update hero set hp &#x3D; hp +1 where id &#x3D; 22&quot;;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">              </span><br><span class="line">            &#x2F;&#x2F;减血的SQL</span><br><span class="line">            &#x2F;&#x2F;不小心写错写成了 updata(而非update)</span><br><span class="line">              </span><br><span class="line">            String sql2 &#x3D; &quot;updata hero set hp &#x3D; hp -1 where id &#x3D; 22&quot;;</span><br><span class="line">            s.execute(sql2);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;885400&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;没有事务的前提下</span><br><span class="line">            &#x2F;&#x2F;假设业务操作时，加血，减血各做一次</span><br><span class="line">            &#x2F;&#x2F;结束后，英雄的血量不变</span><br><span class="line">              </span><br><span class="line">            &#x2F;&#x2F;加血的SQL</span><br><span class="line">            String sql1 &#x3D; &quot;update hero set hp &#x3D; hp +1 where id &#x3D; 22&quot;;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">              </span><br><span class="line">            &#x2F;&#x2F;减血的SQL</span><br><span class="line">            &#x2F;&#x2F;不小心写错写成了 updata(而非update)</span><br><span class="line">              </span><br><span class="line">            String sql2 &#x3D; &quot;updata hero set hp &#x3D; hp -1 where id &#x3D; 22&quot;;</span><br><span class="line">            s.execute(sql2);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-使用事务"><a class="header-anchor" href="#步骤-2-使用事务">¶</a>步骤 2 : 使用事务</h3>
<p>在事务中的多个操作，<strong>要么都成功，要么都失败</strong><br>
通过 c.setAutoCommit(false);<strong>关闭自动提交</strong><br>
使用 c.commit();进行<strong>手动提交</strong><br>
在22行-35行之间的数据库操作，就处于同一个事务当中，要么都成功，要么都失败<br>
所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句<strong>都没有被提交</strong>。 除非两条SQL语句都是正确的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?characterEncoding&#x3D;UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 有事务的前提下</span><br><span class="line">            &#x2F;&#x2F; 在事务中的多个操作，要么都成功，要么都失败</span><br><span class="line">  </span><br><span class="line">            c.setAutoCommit(false);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 加血的SQL</span><br><span class="line">            String sql1 &#x3D; &quot;update hero set hp &#x3D; hp +1 where id &#x3D; 22&quot;;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 减血的SQL</span><br><span class="line">            &#x2F;&#x2F; 不小心写错写成了 updata(而非update)</span><br><span class="line">  </span><br><span class="line">            String sql2 &#x3D; &quot;updata hero set hp &#x3D; hp -1 where id &#x3D; 22&quot;;</span><br><span class="line">            s.execute(sql2);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 手动提交</span><br><span class="line">            c.commit();</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;885400&quot;);</span><br><span class="line">            Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 有事务的前提下</span><br><span class="line">            &#x2F;&#x2F; 在事务中的多个操作，要么都成功，要么都失败</span><br><span class="line">  </span><br><span class="line">            c.setAutoCommit(false);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 加血的SQL</span><br><span class="line">            String sql1 &#x3D; &quot;update hero set hp &#x3D; hp +1 where id &#x3D; 22&quot;;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 减血的SQL</span><br><span class="line">            &#x2F;&#x2F; 不小心写错写成了 updata(而非update)</span><br><span class="line">  </span><br><span class="line">            String sql2 &#x3D; &quot;updata hero set hp &#x3D; hp -1 where id &#x3D; 22&quot;;</span><br><span class="line">            s.execute(sql2);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 手动提交</span><br><span class="line">            c.commit();</span><br><span class="line">  </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-3-MYSQL-表的类型必须是INNODB才支持事务"><a class="header-anchor" href="#步骤-3-MYSQL-表的类型必须是INNODB才支持事务">¶</a>步骤 3 : MYSQL 表的类型必须是INNODB才支持事务</h3>
<p>在Mysql中，只有当表的类型是INNODB的时候，才支持事务，所以需要把表的类型设置为INNODB,否则无法观察到事务.</p>
<p>修改表的类型为INNODB的SQL：</p>
<p>alter table hero ENGINE  = innodb;</p>
<p>查看表的类型的SQL</p>
<p>show table status from how2java;</p>
<p>不过有个前提，就是当前的MYSQL服务器本身要支持INNODB,如果不支持，请看 [开启MYSQL INNODB的办法]</p>
<h3 id="步骤-4-练习-事务"><a class="header-anchor" href="#步骤-4-练习-事务">¶</a>步骤 4 : 练习-事务</h3>
<p>当**c.setAutoCommit(false);**时，事务是不会提交的<br>
只有执行使用 <strong>c.commit();</strong> 才会提交进行</p>
<p>设计一个代码，删除表中<strong>前10条数据</strong>，但是删除前会在控制台弹出一个提示：<br>
是否要删除数据(<strong>Y/N</strong>)<br>
如果用户输入<strong>Y</strong>，则删除<br>
如果输入<strong>N</strong>则不删除。<br>
如果输入的既不是Y也不是N，则重复提示</p>
<p><img src="/2020/06/30/Java%E4%B8%AD%E7%BA%A7%E3%80%90HOW2J%E3%80%91/2650.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Connection c&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;how2java?&quot;+&quot;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;&quot;+&quot;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong&quot;,&quot;root&quot;,&quot;885400&quot;);</span><br><span class="line">            Statement s&#x3D;c.createStatement();</span><br><span class="line">            String sql&#x3D;&quot;select*from hero limit 0,10&quot;;</span><br><span class="line">            ResultSet rs&#x3D;s.executeQuery(sql);</span><br><span class="line">            int id&#x3D;0;</span><br><span class="line">            ArrayList&lt;Integer&gt; al&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">            while(rs.next())&#123;</span><br><span class="line">                id&#x3D;rs.getInt(1);</span><br><span class="line">                System.out.println(&quot;试图删除id&#x3D;&quot;+id+&quot;的数据&quot;);</span><br><span class="line">                al.add(id);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;是否删除前十个数据?(y&#x2F;n)&quot;);</span><br><span class="line">            Scanner scan&#x3D;new Scanner(System.in);</span><br><span class="line">            String yesORno&#x3D;scan.next();</span><br><span class="line">            if(yesORno.equals(&quot;y&quot;))&#123;</span><br><span class="line">                System.out.println(&quot;提交删除&quot;);</span><br><span class="line">                c.setAutoCommit(yesORno.equals(&quot;y&quot;));          </span><br><span class="line">                for (Integer integer : al) &#123;</span><br><span class="line">                    String sqlDelete&#x3D;&quot;delete from hero where id&#x3D;&quot;+integer+&quot;&quot;;</span><br><span class="line">                    s.execute(sqlDelete);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;删除成功&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;不进行删除操作&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            scan.close();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、图形界面"><a class="header-anchor" href="#八、图形界面">¶</a>八、图形界面</h1>
<h1 id="九、网络编程"><a class="header-anchor" href="#九、网络编程">¶</a>九、网络编程</h1>
<h1 id="十、实践项目"><a class="header-anchor" href="#十、实践项目">¶</a>十、实践项目</h1>
]]></content>
      <categories>
        <category>How2j</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Java</tag>
        <tag>中级</tag>
      </tags>
  </entry>
</search>
